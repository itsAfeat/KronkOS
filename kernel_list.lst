     1                                  ; ==================================================================
     2                                  ; The Kronk Operating System kernel
     3                                  ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                                  ;
     5                                  ; This is loaded from the drive by BOOTLOAD.BIN, as KERNEL.BIN
     6                                  ; ==================================================================
     7                                  
     8                                      ORG 0x0000
     9                                      BITS 16
    10                                      
    11                                      %define KRONKOS_VER '0.3.2'
    12                                      %define KRONKOS_API 4
    13                                      
    14                                      ; RAM locations
    15                                      disk_buffer     equ 24576
    16                                      prg_load_loc    equ 32768
    17                                      set_load_loc    equ 36864
    18                                  
    19                                      ; Screen mouse clamps
    20                                      screenmaxW      equ 0x004E
    21                                      screenminW      equ 0x0001
    22                                      screenmaxH      equ 0x0017
    23                                      screenminH      equ 0x0001
    24                                      
    25                                      ; Mouse buttons
    26                                      leftMButton     equ 0x09
    27                                      rightMButton    equ 0x0A
    28                                  
    29                                      ; Screen modes
    30                                      vidRes          equ 0x13
    31                                      cliRes          equ 0x03
    32                                  
    33                                  ; ******************************************************************
    34                                  ; Start the kernel
    35                                  kernel_start:
    36 00000000 E8A61A                      call seed_random
    37                                  
    38 00000003 FA                          cli                         ; Clear interrupts
    39 00000004 B80020                      mov ax, 0x2000              ; The bootloader loads us at 0x2000
    40 00000007 8ED8                        mov ds, ax                  ; Set DS and ES to 0x2000
    41 00000009 8EC0                        mov es, ax
    42                                  
    43                                      ; Stack just below 0x2000:0x0000 starting at 0x1000:0x0000.
    44                                      ; First push will set SS:SP to 0x1000:0xfffe because SP will wrap.
    45 0000000B B80010                      mov ax, 0x1000
    46 0000000E 8ED0                        mov ss, ax
    47 00000010 31E4                        xor sp, sp
    48                                  
    49 00000012 FC                          cld                         ; Clear Direction Flag (DF=0 is for forward string movement)
    50                                  ; ******************************************************************
    51                                  
    52                                  
    53                                  ; ==================================================================
    54                                  ; START OF KERNEL
    55                                  ; ==================================================================
    56                                  
    57                                  RESET:
    58 00000013 31C0                    	xor ax, ax
    59 00000015 31DB                    	xor bx, bx
    60 00000017 31C9                    	xor cx, cx
    61 00000019 31D2                    	xor dx, dx
    62 0000001B 31F6                    	xor si, si
    63 0000001D 31FF                    	xor di, di
    64                                  
    65                                      ; Change the cursor to a solid block
    66 0000001F B500                        mov ch, 0x00
    67 00000021 E88411                      call change_cursor
    68                                  
    69                                      ; Check if SETTINGS.KSF exists
    70 00000024 B8[0E03]                    mov ax, settings_filename
    71 00000027 E85221                      call os_file_exists
    72 0000002A 7311                        jnc .skip_setup     ; If it does... skip the setup
    73                                  
    74 0000002C E8A20A                      call setup_init
    75                                  
    76                                      ; Save the settings
    77 0000002F B8[0E03]                    mov ax, settings_filename
    78 00000032 BB0090                      mov bx, set_load_loc
    79 00000035 B9[6F01]                    mov cx, usrNam
    80 00000038 E8931E                      call os_write_file
    81                                  
    82 0000003B EBD6                        jmp RESET
    83                                  
    84                                  .skip_setup:
    85                                      ; Load the settings file
    86 0000003D B8[0E03]                    mov ax, settings_filename
    87 00000040 B90090                      mov cx, set_load_loc
    88 00000043 31DB                        xor bx, bx
    89 00000045 E8471D                      call os_load_file
    90                                  
    91 00000048 89DE                        mov si, bx
    92 0000004A BF[6F01]                    mov di, usrNam
    93 0000004D E8A70D                      call string_copy
    94                                  
    95 00000050 8A26[8401]                  mov ah, [vidMode]
    96 00000054 80FC00                      cmp ah, 0
    97 00000057 7405                        je .startCli
    98 00000059 80FC01                      cmp ah, 1
    99 0000005C 7404                        je .startVideo
   100                                  
   101                                  .startCli:
   102 0000005E E8D204                      call kronk_cli
   103 00000061 F4                          hlt
   104                                  
   105                                  .startVideo:
   106 00000062 E8490A                      call kronk_vid
   107 00000065 F4                          hlt
   108                                  
   109                                  
   110                                  ; ==================================================================
   111                                  ; JUMP VECTORS
   112                                  ; ==================================================================
   113                                  
   114                                  JUMP_VECTORS:
   115 00000066 EB98                        jmp kernel_start        ; 0x0066
   116 00000068 E9A81A                      jmp print               ; 0x0068
   117 0000006B E9EA0C                      jmp cls                 ; 0x006B
   118 0000006E E90B21                      jmp os_file_exists      ; 0x006E
   119 00000071 E91B1D                      jmp os_load_file        ; 0x0071
   120 00000074 E92421                      jmp os_create_file      ; 0x0074
   121 00000077 E9B021                      jmp os_remove_file      ; 0x0077
   122 0000007A E9511E                      jmp os_write_file       ; 0x007A
   123 0000007D E95A0D                      jmp string_lowercase    ; 0x007D
   124 00000080 E93A0D                      jmp string_uppercase    ; 0x0080
   125 00000083 E97A0D                      jmp string_truncate     ; 0x0083
   126 00000086 E9E50C                      jmp string_length       ; 0x0086
   127 00000089 E93011                      jmp move_cursor         ; 0x0089
   128 0000008C E93611                      jmp get_cursor_pos      ; 0x008C
   129 0000008F E94611                      jmp print_horiz_line    ; 0x008F
   130 00000092 E96011                      jmp input_dialog        ; 0x0092
   131 00000095 E9CA17                      jmp list_dialog         ; 0x0095
   132 00000098 E9B411                      jmp dialog_box          ; 0x0098
   133 0000009B E90A11                      jmp change_cursor       ; 0x009B
   134 0000009E E9EC10                      jmp string_clear        ; 0x009E
   135 000000A1 E9471C                      jmp os_get_file_list    ; 0x00A1
   136 000000A4 E93519                      jmp clear_regs          ; 0x00A4
   137 000000A7 E92D0E                      jmp int_to_string       ; 0x00A7
   138                                  
   139                                  
   140                                  ; ==================================================================
   141                                  ; KERNEL SUBROUTINES
   142                                  ; ==================================================================
   143                                  
   144                                      error_ext:
   145 000000AA 5E                              pop si
   146                                  
   147 000000AB B8[2103]                        mov ax, err1_ext
   148 000000AE BB[3303]                        mov bx, err2_ext
   149 000000B1 31C9                            xor cx, cx
   150 000000B3 31D2                            xor dx, dx
   151 000000B5 E89711                          call dialog_box
   152                                  
   153 000000B8 B70F                            mov bh, cli_color
   154 000000BA E89B0C                          call cls
   155                                  
   156 000000BD C3                              ret
   157                                  
   158                                      try_run_file:
   159 000000BE E8FC0C                          call string_uppercase
   160 000000C1 89C6                            mov si, ax
   161 000000C3 BF[0303]                        mov di, kern_filename
   162 000000C6 E8AF0D                          call string_compare
   163 000000C9 7230                            jc load_kern_err
   164                                  
   165 000000CB E8AE20                          call os_file_exists
   166 000000CE 7229                            jc .not_found
   167 000000D0 F8                              clc
   168                                  
   169 000000D1 89C6                            mov si, ax
   170 000000D3 56                              push si 
   171                                  
   172 000000D4 89F3                            mov bx, si
   173 000000D6 89F0                            mov ax, si
   174 000000D8 E8930C                          call string_length
   175                                  
   176 000000DB 89DE                            mov si, bx
   177 000000DD 01C6                            add si, ax
   178                                  
   179 000000DF 83EE03                          sub si, 3
   180                                  
   181 000000E2 BF[1B03]                        mov di, bin_ext
   182 000000E5 B90300                          mov cx, 3
   183 000000E8 F3A6                            rep cmpsb
   184 000000EA 7523                            jne execute_bas_program
   185 000000EC 5E                              pop si
   186                                  
   187 000000ED 89F0                            mov ax, si
   188 000000EF B90080                          mov cx, prg_load_loc
   189 000000F2 E89A1C                          call os_load_file
   190                                  
   191 000000F5 E85000                          call execute_bin_program
   192 000000F8 C3                              ret
   193                                  
   194                                          .not_found:
   195 000000F9 F9                                  stc
   196 000000FA C3                                  ret
   197                                  
   198                                          load_kern_err:
   199 000000FB 5E                                  pop si
   200                                  
   201 000000FC B8[5103]                            mov ax, err3_ext
   202 000000FF BB[6403]                            mov bx, err4_ext
   203 00000102 31C9                                xor cx, cx
   204 00000104 31D2                                xor dx, dx
   205 00000106 E84611                              call dialog_box
   206                                  
   207 00000109 B70F                                mov bh, cli_color
   208 0000010B E84A0C                              call cls
   209                                  
   210 0000010E C3                                  ret
   211                                  
   212                                      execute_bas_program:
   213 0000010F 5E                              pop si
   214 00000110 56                              push si
   215                                          
   216 00000111 89F3                            mov bx, si
   217 00000113 89F0                            mov ax, si
   218 00000115 E8560C                          call string_length
   219                                  
   220 00000118 89DE                            mov si, bx
   221 0000011A 01C6                            add si, ax
   222                                  
   223 0000011C 83EE03                          sub si, 3
   224                                  
   225 0000011F BF[1E03]                        mov di, bas_ext
   226 00000122 B90300                          mov cx, 3
   227 00000125 F3A6                            rep cmpsb
   228 00000127 7581                            jne error_ext
   229                                  
   230 00000129 5E                              pop si
   231                                          
   232 0000012A 89F0                            mov ax, si
   233 0000012C B90080                          mov cx, prg_load_loc
   234 0000012F E85D1C                          call os_load_file
   235                                  
   236 00000132 B70F                            mov bh, 0x0F
   237 00000134 E8210C                          call cls
   238                                  
   239 00000137 B80080                          mov ax, prg_load_loc
   240 0000013A 31F6                            xor si, si
   241                                          ;call os_run_basic
   242                                  
   243 0000013C BE[B103]                        mov si, new_line
   244 0000013F E8D119                          call print
   245                                  
   246 00000142 B70F                            mov bh, cli_color
   247 00000144 E8110C                          call cls
   248                                  
   249 00000147 C3                              ret
   250                                  
   251                                      execute_bin_program:
   252 00000148 BE[B103]                        mov si, new_line
   253 0000014B E8C519                          call print
   254                                  
   255 0000014E 31C0                    		xor ax, ax
   256 00000150 31DB                    		xor bx, bx
   257 00000152 31C9                    		xor cx, cx
   258 00000154 31D2                    		xor dx, dx
   259 00000156 31F6                    		xor si, si
   260 00000158 31FF                    		xor di, di
   261                                  
   262 0000015A E8(0080)                        call prg_load_loc
   263                                          
   264 0000015D B70F                            mov bh, 0x0F
   265 0000015F E8F60B                          call cls
   266                                  
   267 00000162 C3                              ret
   268                                  
   269                                  
   270                                  ; ------------------------------------------------------------------
   271                                  ; STRINGS AND OTHER VARIABLES
   272                                  
   273                                      ; DEBUG VARIABLES START
   274 00000163 4D653F20476F6E6761-         tmp:                db "Me? Gongaga", 0
   274 0000016C 676100             
   275                                      ; END
   276                                  
   277                                      ; USER RELATED VARIABLES START
   278 0000016F 00<rep 15h>                 usrNam:             times 21 db 0
   279                                  
   280 00000184 0000                        vidMode:            dw 0x00
   281                                      cli_color:          equ 0x0f
   282                                      vid_backcolor:      equ 0x01
   283                                      vid_forecolor:      equ 0x0f
   284                                      ; END
   285                                  
   286                                      ; TMP VARIABLES START
   287 00000186 4D4F555345204C4546-         mouse_left:         db "MOUSE LEFT", 0
   287 0000018F 5400               
   288 00000191 4D4F55534520524947-         mouse_right:        db "MOUSE RIGHT", 0
   288 0000019A 485400             
   289                                      ; END
   290                                  
   291                                      ; CLI SPECIFIC VARIABLES START
   292 0000019D 3A3E2000                	in_msg:				db ":> ", 0
   293 000001A1 00<rep 29h>             	in_buffer: 			times 41 db 0
   294 000001CA 206973206E6F74206B-         not_com:            db " is not known command", 0x0a, 0x0d, 0
   294 000001D3 6E6F776E20636F6D6D-
   294 000001DC 616E640A0D00       
   295                                      ; END
   296                                  
   297                                      ; CLI COMMANDS START
   298 000001E2 7265737461727400            restart_com:        db "restart", 0
   299 000001EA 73687574646F776E00          shutdown_com:       db "shutdown", 0
   300 000001F3 73657474696E677300          settings_com:       db "settings", 0
   301 000001FC 636C65617200                clear_com:          db "clear", 0
   302 00000202 64697200                    dir_com:            db "dir", 0
   303 00000206 68656C7000                  help_com:           db "help", 0
   304 0000020B 6564697400                  edit_com:           db "edit", 0
   305 00000210 6C6F616400                  load_com:           db "load", 0
   306 00000215 6D6B00                      mk_com:             db "mk", 0
   307 00000218 726D00                      rm_com:             db "rm", 0
   308                                      ; END
   309                                  
   310                                      ; MOUSE VARIABLES START
   311 0000021B 4D4F55534520495320-         mouse_yes:          db "MOUSE IS CONNECTED!", 0
   311 00000224 434F4E4E4543544544-
   311 0000022D 2100               
   312 0000022F 4D4F55534520495320-         mouse_no:           db "MOUSE IS NOT CONNECTED!", 0
   312 00000238 4E4F5420434F4E4E45-
   312 00000241 435445442100       
   313                                      ; END
   314                                  
   315                                      ; WELCOME SCREEN VARIABLES START
   316 00000247 0A0D204B726F6E6B4F-     	welcome_msg1:		db 0x0a, 0x0d, " KronkOS ver. ", KRONKOS_VER
   316 00000250 53207665722E20302E-
   316 00000259 332E32             
   317 0000025C 20<rep 1Ah>             						times 44-18 db " "
   318 00000276 0A0D2000                						db 0x0a, 0x0d, " ", 0
   319 0000027A 204B696C6F20427974-     	welcome_msg2:		db " Kilo Bytes of total memory available. ", 0x0a, 0x0d, 0
   319 00000283 6573206F6620746F74-
   319 0000028C 616C206D656D6F7279-
   319 00000295 20617661696C61626C-
   319 0000029E 652E200A0D00       
   320 000002A4 20<rep 2Dh>             	welcome_msg3:		times 45 db " "
   321 000002D1 0A0D20547970652027-     						db 0x0a, 0x0d, " Type 'help' and press enter to start off.   ", 0x0a, 0x0d, 0
   321 000002DA 68656C702720616E64-
   321 000002E3 20707265737320656E-
   321 000002EC 74657220746F207374-
   321 000002F5 617274206F66662E20-
   321 000002FE 20200A0D00         
   322                                  	; END
   323                                  
   324                                      ; FILE RELATED VARIABLES START
   325 00000303 4B45524E454C2E4249-     	kern_filename:		db 'KERNEL.BIN', 0
   325 0000030C 4E00               
   326 0000030E 53455454494E47532E-         settings_filename:  db 'SETTINGS.KSF', 0
   326 00000317 4B534600           
   327                                  
   328 0000031B 424B46                  	bin_ext:			db 'BKF'
   329 0000031E 424153                  	bas_ext:			db 'BAS'
   330 00000321 556E6B6E6F776E2065-     	err1_ext:			db "Unknown extension", 0
   330 0000032A 7874656E73696F6E00 
   331 00000333 4F6E6C79202E424B46-     	err2_ext:			db "Only .BKF and .BAS is allowed", 0
   331 0000033C 20616E64202E424153-
   331 00000345 20697320616C6C6F77-
   331 0000034E 656400             
   332 00000351 4572726F72206C6F61-     	err3_ext:			db "Error loading file", 0
   332 0000035A 64696E672066696C65-
   332 00000363 00                 
   333 00000364 596F752063616E2774-     	err4_ext:			db "You can't load KERNEL.BIN", 0
   333 0000036D 206C6F6164204B4552-
   333 00000376 4E454C2E42494E00   
   334 0000037E 596F752063616E2774-         err5_ext:           db "You can't load SETTINGS.KSF", 0
   334 00000387 206C6F616420534554-
   334 00000390 54494E47532E4B5346-
   334 00000399 00                 
   335 0000039A 0A0D46696C65206E6F-         notfound_msg:	    db 0x0a, 0x0d, "File not found", 0x0a, 0x0a, 0x0d, 0
   335 000003A3 7420666F756E640A0A-
   335 000003AC 0D00               
   336                                      ; END
   337                                  
   338                                      ; OTHER VARIABLES START
   339 000003AE 00                      	fmt_12_24:			db 0 		; (Non-zero = 24 hour format)
   340 000003AF 012F                    	fmt_date:			db 1, '/'	; 0, 1, 2 = M/D/Y, D/M/Y or Y/M/D
   341                                  									; Bit 7 = use name for months
   342                                  									; If bit 7 = 0, second byte = separator character
   343                                  
   344 000003B1 0A0D00                  	new_line:			db 0x0a, 0x0d, 0
   345 000003B4 202D2D2000              	file_size_sep:		db " -- ", 0
   346 000003B9 2042797465730A0D00      	file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   347                                      ; END
   348                                  
   349                                      ; MENUBAR VARIABLES START
   350                                      mb_color:           equ 0x30
   351 000003C2 20<rep 4Fh>                 mb_fill:            times 79 db " "
   352 00000411 00                                              db 0
   353                                      ; END
   354                                  
   355                                  ; ------------------------------------------------------------------
   356                                  ; INCLUDED FILES
   357                                  
   358                                      %include "./includes/settings_menu.asm"
   359                              <1> show_settings:
   360 00000412 60                  <1>     pusha
   361                              <1> 
   362                              <1> .main_menu:
   363 00000413 B8[8104]            <1>     mov ax, .main_options
   364 00000416 BB[9C04]            <1>     mov bx, .main_header
   365 00000419 B9[A504]            <1>     mov cx, .main_string
   366 0000041C E84314              <1>     call list_dialog
   367                              <1> 
   368 0000041F 83F801              <1>     cmp ax, 1
   369 00000422 7402                <1>     je .display_menu
   370                              <1> 
   371 00000424 EB54                <1>     jmp .end
   372                              <1> 
   373                              <1> .display_menu:
   374 00000426 B8[C404]            <1>     mov ax, .display_options
   375 00000429 BB[DD04]            <1>     mov bx, .display_header
   376 0000042C B9[EC04]            <1>     mov cx, .display_string
   377 0000042F E83014              <1>     call list_dialog
   378                              <1> 
   379 00000432 83F801              <1>     cmp ax, 1
   380 00000435 7407                <1>     je .change_cli
   381                              <1> 
   382 00000437 83F802              <1>     cmp ax, 2
   383 0000043A 7420                <1>     je .change_vid
   384                              <1> 
   385 0000043C EBD5                <1>     jmp .main_menu
   386                              <1> 
   387                              <1> .change_cli:
   388 0000043E B8[0205]            <1>     mov ax, .display_restart1
   389 00000441 BB[1C05]            <1>     mov bx, .display_restart2
   390 00000444 31C9                <1>     xor cx, cx
   391 00000446 BA0100              <1>     mov dx, 1
   392 00000449 E8030E              <1>     call dialog_box
   393                              <1> 
   394 0000044C 85C0                <1>     test ax, ax
   395 0000044E 75D6                <1>     jnz .display_menu
   396                              <1> 
   397                              <1> 
   398 00000450 C606[8401]00        <1>     mov byte [vidMode], 0
   399 00000455 31C0                <1>     xor ax, ax
   400 00000457 CD13                <1>     int 0x13
   401 00000459 E9B7FB              <1>     jmp RESET
   402                              <1> 
   403                              <1> .change_vid:
   404 0000045C B8[0205]            <1>     mov ax, .display_restart1
   405 0000045F BB[1C05]            <1>     mov bx, .display_restart2
   406 00000462 31C9                <1>     xor cx, cx
   407 00000464 BA0100              <1>     mov dx, 1
   408 00000467 E8E50D              <1>     call dialog_box
   409                              <1> 
   410 0000046A 85C0                <1>     test ax, ax
   411 0000046C 75B8                <1>     jnz .display_menu
   412                              <1> 
   413 0000046E C606[8401]01        <1>     mov byte [vidMode], 1
   414 00000473 31C0                <1>     xor ax, ax
   415 00000475 CD13                <1>     int 0x13
   416 00000477 E999FB              <1>     jmp RESET
   417                              <1> 
   418                              <1> .end:
   419 0000047A B70F                <1>     mov bh, cli_color
   420 0000047C E8D908              <1>     call cls
   421                              <1> 
   422 0000047F 61                  <1>     popa
   423 00000480 C3                  <1>     ret
   424                              <1> 
   425                              <1> 
   426 00000481 444953504C41592C    <1> .main_options:      db "DISPLAY,"
   427 00000489 555345522C          <1>                     db "USER,"
   428 0000048E 455849542053455454- <1>                     db "EXIT SETTINGS", 0
   428 00000497 494E475300          <1>
   429 0000049C 53455454494E475300  <1> .main_header:       db "SETTINGS", 0
   430 000004A5 4368616E6765207468- <1> .main_string:       db "Change the settings of KronkOS", 0
   430 000004AE 652073657474696E67- <1>
   430 000004B7 73206F66204B726F6E- <1>
   430 000004C0 6B4F5300            <1>
   431                              <1> 
   432 000004C4 434C49204D4F44452C  <1> .display_options:   db "CLI MODE,"
   433 000004CD 564944454F204D4F44- <1>                     db "VIDEO MODE,"
   433 000004D6 452C                <1>
   434 000004D8 4241434B00          <1>                     db "BACK", 0
   435 000004DD 564944454F20534554- <1> .display_header:    db "VIDEO SETTINGS", 0
   435 000004E6 54494E475300        <1>
   436 000004EC 4368616E6765207468- <1> .display_string:    db "Change the video mode", 0
   436 000004F5 6520766964656F206D- <1>
   436 000004FE 6F646500            <1>
   437 00000502 546869732077696C6C- <1> .display_restart1:  db "This will restart KronkOS", 0
   437 0000050B 207265737461727420- <1>
   437 00000514 4B726F6E6B4F5300    <1>
   438 0000051C 507265737320274F4B- <1> .display_restart2:  db "Press 'OK' to continue", 0
   438 00000525 2720746F20636F6E74- <1>
   438 0000052E 696E756500          <1>
   359                                      %include "./includes/cli.asm"
   360                              <1> kronk_cli:
   361 00000533 B80000              <1>     mov ax, 0
   362 00000536 B70F                <1>     mov bh, cli_color
   363 00000538 E8F10E              <1>     call switch_mode
   364                              <1>     
   365                              <1>     ; Disable color blinking
   366 0000053B B80310              <1>     mov ax, 0x1003
   367 0000053E BB0000              <1>     mov bx, 0x0000
   368 00000541 CD10                <1>     int 0x10
   369                              <1> 
   370                              <1> 	; Let's see if there's a file called AUTORUN.BIN and execute
   371                              <1> 	; it if so, before going to the terminal
   372                              <1> 
   373 00000543 B8[FB09]            <1>     mov ax, .autobin_filename
   374 00000546 E8331C              <1>     call os_file_exists
   375 00000549 7209                <1>     jc .no_autorun_bin
   376                              <1> 
   377 0000054B B90080              <1>     mov cx, prg_load_loc
   378 0000054E E83E18              <1>     call os_load_file
   379 00000551 E8F4FB              <1>     call execute_bin_program
   380                              <1> 
   381                              <1> .no_autorun_bin:
   382 00000554 B8[070A]            <1>     mov ax, .autobas_filename
   383 00000557 E8221C              <1>     call os_file_exists
   384 0000055A 7209                <1>     jc .no_autorun_bas
   385                              <1> 
   386 0000055C B90080              <1>     mov cx, prg_load_loc
   387 0000055F E82D18              <1>     call os_load_file
   388 00000562 E8AAFB              <1>     call execute_bas_program
   389                              <1> 
   390                              <1> .no_autorun_bas:
   391                              <1>     ; Draw welcome menu
   392 00000565 BE[4702]            <1>     mov si, welcome_msg1
   393 00000568 E8B615              <1>     call welcome_print
   394                              <1> 
   395 0000056B B488                <1>     mov ah, 0x88
   396 0000056D CD15                <1>     int 0x15
   397 0000056F E86509              <1>     call int_to_string
   398 00000572 89C6                <1>     mov si, ax
   399 00000574 E8AA15              <1>     call welcome_print
   400                              <1> 
   401 00000577 BE[7A02]            <1>     mov si, welcome_msg2
   402 0000057A E8A415              <1>     call welcome_print
   403 0000057D BE[A402]            <1>     mov si, welcome_msg3
   404 00000580 E89E15              <1>     call welcome_print
   405                              <1> 
   406 00000583 B80A0E              <1>     mov ax, 0x0e0a
   407 00000586 CD10                <1>     int 0x10
   408                              <1> 
   409                              <1> ; The loop that gets the input
   410                              <1> .input_loop:
   411                              <1>     ; Change the cursor to a solid block
   412 00000588 B500                <1>     mov ch, 0x00
   413 0000058A E81B0C              <1>     call change_cursor
   414                              <1> 
   415 0000058D E88304              <1>     call check_pos
   416 00000590 E8A604              <1>     call draw_menu_bar
   417                              <1> 
   418                              <1>     ; Print the username and the input msg
   419                              <1>     ;mov si, usrNam
   420                              <1>     ;call print
   421 00000593 BE[9D01]            <1>     mov si, in_msg
   422 00000596 E87A15              <1>     call print
   423                              <1> 
   424                              <1>     ; Get the input and save it in in_buffer 
   425 00000599 E89F14              <1>     call get_input
   426                              <1> 
   427                              <1>     ; Check the input
   428 0000059C B8[F301]            <1>     mov ax, settings_com
   429 0000059F E8D51E              <1>     call check_com
   430 000005A2 0F83C400            <1>     jnc .settings
   431                              <1> 
   432 000005A6 B8[FC01]            <1>     mov ax, clear_com
   433 000005A9 E8CB1E              <1>     call check_com
   434 000005AC 0F83C000            <1>     jnc .clear
   435                              <1> 
   436 000005B0 B8[0202]            <1>     mov ax, dir_com
   437 000005B3 E8C11E              <1>     call check_com
   438 000005B6 0F83BE00            <1>     jnc .dir
   439                              <1> 
   440 000005BA B8[0602]            <1>     mov ax, help_com
   441 000005BD E8B71E              <1>     call check_com
   442 000005C0 0F836301            <1>     jnc .show_help
   443                              <1>     
   444                              <1>     ; ----------------------------------
   445                              <1>     ; MK AND RM
   446                              <1> 
   447 000005C4 60                  <1>     pusha
   448                              <1> 
   449 000005C5 BE[A401]            <1>     mov si, in_buffer+3
   450 000005C8 BF[8C09]            <1>     mov di, .tmp_filename
   451 000005CB E82908              <1>     call string_copy
   452                              <1> 
   453 000005CE BE[A101]            <1>     mov si, in_buffer
   454 000005D1 BF[A009]            <1>     mov di, .tmp_inbuffer
   455 000005D4 E82008              <1>     call string_copy
   456                              <1> 
   457 000005D7 BE[A101]            <1>     mov si, in_buffer
   458 000005DA B80200              <1>     mov ax, 2
   459 000005DD E82008              <1>     call string_truncate
   460                              <1>     
   461 000005E0 B8[1502]            <1>     mov ax, mk_com
   462 000005E3 E8911E              <1>     call check_com
   463 000005E6 0F831003            <1>     jnc .make_file
   464                              <1> 
   465 000005EA B8[1802]            <1>     mov ax, rm_com
   466 000005ED E8871E              <1>     call check_com
   467 000005F0 0F833103            <1>     jnc .remove_file
   468                              <1> 
   469 000005F4 BE[A009]            <1>     mov si, .tmp_inbuffer
   470 000005F7 BF[A101]            <1>     mov di, in_buffer
   471 000005FA E8FA07              <1>     call string_copy
   472                              <1> 
   473 000005FD 61                  <1>     popa
   474                              <1> 
   475                              <1>     ; ----------------------------------
   476                              <1>     ; LOAD AND EDIT
   477                              <1> 
   478 000005FE 60                  <1>     pusha
   479                              <1> 
   480 000005FF BE[A601]            <1>     mov si, in_buffer+5
   481 00000602 BF[8C09]            <1>     mov di, .tmp_filename
   482 00000605 E8EF07              <1>     call string_copy
   483                              <1> 
   484 00000608 BE[A101]            <1>     mov si, in_buffer
   485 0000060B BF[A009]            <1>     mov di, .tmp_inbuffer
   486 0000060E E8E607              <1>     call string_copy
   487                              <1> 
   488 00000611 BE[A101]            <1>     mov si, in_buffer
   489 00000614 B80400              <1>     mov ax, 4
   490 00000617 E8E607              <1>     call string_truncate
   491                              <1> 
   492 0000061A B8[1002]            <1>     mov ax, load_com
   493 0000061D E8571E              <1>     call check_com
   494 00000620 0F832C03            <1>     jnc .load_file
   495                              <1> 
   496 00000624 BE[A009]            <1>     mov si, .tmp_inbuffer
   497 00000627 BF[A101]            <1>     mov di, in_buffer
   498 0000062A E8CA07              <1>     call string_copy
   499                              <1> 
   500 0000062D 61                  <1>     popa
   501                              <1> 
   502 0000062E B8[E201]            <1>     mov ax, restart_com
   503 00000631 E8431E              <1>     call check_com
   504 00000634 0F833403            <1>     jnc .restart
   505                              <1> 
   506 00000638 B8[EA01]            <1>     mov ax, shutdown_com
   507 0000063B E8391E              <1>     call check_com
   508 0000063E 0F833203            <1>     jnc .shutdown
   509 00000642 7200                <1>     jc .not_equal
   510                              <1> 
   511                              <1> .not_equal:
   512 00000644 B40E                <1>     mov ah, 0x0e
   513 00000646 B00A                <1>     mov al, 0x0a
   514 00000648 CD10                <1>     int 0x10
   515                              <1> 
   516 0000064A B40E                <1>     mov ah, 0x0e
   517 0000064C B022                <1>     mov al, '"'
   518 0000064E CD10                <1>     int 0x10
   519                              <1> 
   520 00000650 BE[A101]            <1>     mov si, in_buffer
   521 00000653 E8BD14              <1>     call print
   522                              <1> 
   523 00000656 B40E                <1>     mov ah, 0x0e
   524 00000658 B022                <1>     mov al, '"'
   525 0000065A CD10                <1>     int 0x10
   526                              <1>     
   527 0000065C BE[CA01]            <1>     mov si, not_com
   528 0000065F E8B114              <1>     call print
   529                              <1>     
   530                              <1>     ; Create a new line
   531 00000662 B80A0E              <1>     mov ax, 0x0e0a
   532 00000665 CD10                <1>     int 0x10
   533                              <1> 
   534 00000667 E91EFF              <1>     jmp .input_loop
   535                              <1> 
   536                              <1> ; ----------------------------------
   537                              <1> ; SETTINGS
   538                              <1> 
   539                              <1> .settings:
   540 0000066A E8A5FD              <1>     call show_settings
   541 0000066D E918FF              <1>     jmp .input_loop
   542                              <1> 
   543                              <1> ; ----------------------------------
   544                              <1> ; CLEAR
   545                              <1> 
   546                              <1> .clear:
   547 00000670 B70F                <1>     mov bh, cli_color
   548 00000672 E8E306              <1>     call cls
   549 00000675 E910FF              <1>     jmp .input_loop
   550                              <1> 
   551                              <1> ; ----------------------------------
   552                              <1> ; DIR
   553                              <1> 
   554                              <1> .dir:
   555 00000678 31C0                <1>     xor ax, ax
   556 0000067A E86E16              <1>     call os_get_file_list
   557                              <1> 
   558 0000067D 50                  <1>     push ax
   559 0000067E B80A0E              <1>     mov ax, 0x0e0a
   560 00000681 CD10                <1>     int 0x10
   561 00000683 CD10                <1>     int 0x10
   562 00000685 B00D                <1>     mov al, 0x0d
   563 00000687 CD10                <1>     int 0x10
   564 00000689 58                  <1>     pop ax
   565                              <1> 
   566 0000068A 89C6                <1>     mov si, ax
   567 0000068C BF[8C09]            <1>     mov di, .tmp_filename
   568 0000068F BA0000              <1>     mov dx, 0
   569                              <1> 
   570 00000692 B40E                <1>     mov ah, 0x0e
   571 00000694 B020                <1>     mov al, ' '
   572 00000696 CD10                <1>     int 0x10
   573                              <1> 
   574                              <1>     .loop:
   575 00000698 AC                  <1>         lodsb
   576 00000699 3C2C                <1>         cmp al, ','
   577 0000069B 740C                <1>         je .add_size
   578 0000069D 3C00                <1>         cmp al, 0
   579 0000069F 744C                <1>         je .done
   580                              <1> 
   581 000006A1 AA                  <1>         stosb
   582 000006A2 42                  <1>         inc dx
   583                              <1> 
   584 000006A3 B40E                <1>         mov ah, 0x0e
   585 000006A5 CD10                <1>         int 0x10
   586                              <1> 
   587 000006A7 EBEF                <1>         jmp .loop
   588                              <1> 
   589                              <1>     .add_size:
   590 000006A9 60                  <1>         pusha
   591 000006AA 83FA0C              <1>         cmp dx, 12
   592 000006AD 7D03                <1>         jge .continue
   593                              <1> 
   594 000006AF E82F00              <1>         call .add_spaces
   595                              <1> 
   596                              <1>         .continue:
   597 000006B2 BE[C909]            <1>         mov si, .file_size_sep
   598 000006B5 E85B14              <1>         call print
   599                              <1> 
   600 000006B8 89D0                <1>         mov ax, dx
   601 000006BA E84307              <1>         call string_truncate
   602                              <1> 
   603 000006BD B8[8C09]            <1>         mov ax, .tmp_filename
   604 000006C0 E81B1C              <1>         call os_get_file_size
   605                              <1> 
   606 000006C3 89D8                <1>         mov ax, bx
   607 000006C5 E80F08              <1>         call int_to_string
   608 000006C8 89C6                <1>         mov si, ax
   609 000006CA E84614              <1>         call print
   610                              <1> 
   611 000006CD BE[B903]            <1>         mov si, file_size_typ
   612 000006D0 E84014              <1>         call print
   613                              <1> 
   614 000006D3 B8200E              <1>         mov ax, 0x0e20
   615 000006D6 CD10                <1>         int 0x10
   616                              <1> 
   617 000006D8 61                  <1>         popa
   618                              <1> 
   619 000006D9 BF[8C09]            <1>         mov di, .tmp_filename
   620 000006DC BA0000              <1>         mov dx, 0
   621 000006DF EBB7                <1>         jmp .loop
   622                              <1> 
   623                              <1>     .add_spaces:
   624 000006E1 B8200E              <1>         mov ax, 0x0e20
   625 000006E4 CD10                <1>         int 0x10
   626 000006E6 42                  <1>         inc dx
   627 000006E7 83FA0C              <1>         cmp dx, 12
   628 000006EA 75F5                <1>         jne .add_spaces
   629 000006EC C3                  <1>         ret
   630                              <1> 
   631                              <1>     .done:
   632 000006ED 83FA0C              <1>         cmp dx, 12
   633 000006F0 7D03                <1>         jge .done_c
   634                              <1> 
   635 000006F2 E8ECFF              <1>         call .add_spaces
   636                              <1> 
   637                              <1>         .done_c:
   638 000006F5 BE[C909]            <1>         mov si, .file_size_sep
   639 000006F8 E81814              <1>         call print
   640                              <1> 
   641 000006FB BE[8C09]            <1>         mov si, .tmp_filename
   642 000006FE 89D0                <1>         mov ax, dx
   643 00000700 E8FD06              <1>         call string_truncate
   644                              <1> 
   645 00000703 B8[8C09]            <1>         mov ax, .tmp_filename
   646 00000706 E8D51B              <1>         call os_get_file_size
   647                              <1> 
   648 00000709 89D8                <1>         mov ax, bx
   649 0000070B E8C907              <1>         call int_to_string
   650 0000070E 89C6                <1>         mov si, ax
   651 00000710 E80014              <1>         call print
   652                              <1> 
   653 00000713 BE[CE09]            <1>         mov si, .file_size_typ
   654 00000716 E8FA13              <1>         call print
   655                              <1> 
   656 00000719 50                  <1>     push ax
   657                              <1> 
   658 0000071A B80A0E              <1>     mov ax, 0x0e0a
   659 0000071D CD10                <1>     int 0x10
   660 0000071F B00D                <1>     mov al, 0x0d
   661 00000721 CD10                <1>     int 0x10
   662                              <1> 
   663 00000723 58                  <1>     pop ax
   664                              <1> 
   665 00000724 E961FE              <1>     jmp .input_loop
   666                              <1> 
   667                              <1> ; ----------------------------------
   668                              <1> ; HELP
   669                              <1> 
   670                              <1> .show_help:
   671 00000727 B8[5707]            <1>     mov ax, .help_commands
   672 0000072A BB[C908]            <1>     mov bx, .help_header
   673 0000072D B9[D308]            <1>     mov cx, .help_string
   674 00000730 E82F11              <1>     call list_dialog
   675                              <1> 
   676 00000733 83F804              <1>     cmp ax, 4
   677 00000736 0F8430FF            <1>     je .settings
   678                              <1>     
   679 0000073A B70F                <1>     mov bh, cli_color
   680 0000073C E81906              <1>     call cls
   681                              <1> 
   682 0000073F 83F802              <1>     cmp ax, 2
   683 00000742 0F8432FF            <1>     je .dir
   684 00000746 83F809              <1>     cmp ax, 9
   685 00000749 0F841F02            <1>     je .restart
   686 0000074D 83F80A              <1>     cmp ax, 10
   687 00000750 0F842002            <1>     je .shutdown
   688                              <1> 
   689 00000754 E931FE              <1>     jmp .input_loop
   690                              <1> 
   691 00000757 48454C502020202020- <1>     .help_commands:     db "HELP       --  What you're looking at,"
   691 00000760 20202D2D2020576861- <1>
   691 00000769 7420796F7527726520- <1>
   691 00000772 6C6F6F6B696E672061- <1>
   691 0000077B 742C                <1>
   692 0000077D 444952202020202020- <1>                         db "DIR        --  Show a list of all files,"
   692 00000786 20202D2D202053686F- <1>
   692 0000078F 772061206C69737420- <1>
   692 00000798 6F6620616C6C206669- <1>
   692 000007A1 6C65732C            <1>
   693 000007A5 434C45415220202020- <1>                         db "CLEAR      --  Clear the terminal,"
   693 000007AE 20202D2D2020436C65- <1>
   693 000007B7 617220746865207465- <1>
   693 000007C0 726D696E616C2C      <1>
   694 000007C7 53455454494E475320- <1>                         db "SETTINGS   --  Show the settings menu,"
   694 000007D0 20202D2D202053686F- <1>
   694 000007D9 772074686520736574- <1>
   694 000007E2 74696E6773206D656E- <1>
   694 000007EB 752C                <1>
   695 000007ED 4D4B2046494C452020- <1>                         db "MK FILE    --  Create a file,"
   695 000007F6 20202D2D2020437265- <1>
   695 000007FF 61746520612066696C- <1>
   695 00000808 652C                <1>
   696 0000080A 524D2046494C452020- <1>                         db "RM FILE    --  Delete a file,"
   696 00000813 20202D2D202044656C- <1>
   696 0000081C 65746520612066696C- <1>
   696 00000825 652C                <1>
   697 00000827 4C4F41442046494C45- <1>                         db "LOAD FILE  --  Load/run a file,"
   697 00000830 20202D2D20204C6F61- <1>
   697 00000839 642F72756E20612066- <1>
   697 00000842 696C652C            <1>
   698 00000846 454449542046494C45- <1>                         db "EDIT FILE  --  Load and edit a file,"
   698 0000084F 20202D2D20204C6F61- <1>
   698 00000858 6420616E6420656469- <1>
   698 00000861 7420612066696C652C  <1>
   699 0000086A 524553544152542020- <1>                         db "RESTART    --  Restart KronkOS,"
   699 00000873 20202D2D2020526573- <1>
   699 0000087C 74617274204B726F6E- <1>
   699 00000885 6B4F532C            <1>
   700 00000889 53485554444F574E20- <1>                         db "SHUTDOWN   --  Shutdown KronkOS,,"
   700 00000892 20202D2D2020536875- <1>
   700 0000089B 74646F776E204B726F- <1>
   700 000008A4 6E6B4F532C2C        <1>
   701 000008AA 43414E43454C202020- <1>                         db "CANCEL     --  Leave this menu", 0
   701 000008B3 20202D2D20204C6561- <1>
   701 000008BC 76652074686973206D- <1>
   701 000008C5 656E7500            <1>
   702 000008C9 48454C50204D454E55- <1>     .help_header:       db "HELP MENU", 0
   702 000008D2 00                  <1>
   703 000008D3 507265737320454E54- <1>     .help_string:       db "Press ENTER to run any of the commands", 0
   703 000008DC 455220746F2072756E- <1>
   703 000008E5 20616E79206F662074- <1>
   703 000008EE 686520636F6D6D616E- <1>
   703 000008F7 647300              <1>
   704                              <1> 
   705                              <1> ; ----------------------------------
   706                              <1> ; MAKE FILE
   707                              <1> 
   708                              <1> .make_file:
   709 000008FA 60                  <1>     pusha
   710 000008FB B8[8C09]            <1>     mov ax, .tmp_filename
   711 000008FE E89A18              <1>     call os_create_file
   712                              <1>     
   713 00000901 B80A0E              <1>     mov ax, 0x0e0a
   714 00000904 CD10                <1>     int 0x10
   715 00000906 B00D                <1>     mov al, 0x0d
   716 00000908 CD10                <1>     int 0x10
   717                              <1> 
   718 0000090A BE[8C09]            <1>     mov si, .tmp_filename
   719 0000090D E80312              <1>     call print
   720 00000910 BE[E909]            <1>     mov si, .tmp_filemk
   721 00000913 E8FD11              <1>     call print
   722                              <1> 
   723 00000916 B80A0E              <1>     mov ax, 0x0e0a
   724 00000919 CD10                <1>     int 0x10
   725 0000091B CD10                <1>     int 0x10
   726 0000091D B00D                <1>     mov al, 0x0d
   727 0000091F CD10                <1>     int 0x10
   728                              <1> 
   729 00000921 61                  <1>     popa
   730                              <1> 
   731 00000922 E963FC              <1>     jmp .input_loop
   732                              <1> 
   733                              <1> ; ----------------------------------
   734                              <1> ; REMOVE FILE
   735                              <1> 
   736                              <1> .remove_file:
   737 00000925 60                  <1>     pusha
   738 00000926 B8[8C09]            <1>     mov ax, .tmp_filename
   739 00000929 E8FE18              <1>     call os_remove_file
   740                              <1>     
   741 0000092C B80A0E              <1>     mov ax, 0x0e0a
   742 0000092F CD10                <1>     int 0x10
   743 00000931 B00D                <1>     mov al, 0x0d
   744 00000933 CD10                <1>     int 0x10
   745                              <1> 
   746 00000935 BE[8C09]            <1>     mov si, .tmp_filename
   747 00000938 E8D811              <1>     call print
   748 0000093B BE[D709]            <1>     mov si, .tmp_filerm
   749 0000093E E8D211              <1>     call print
   750                              <1> 
   751 00000941 B80A0E              <1>     mov ax, 0x0e0a
   752 00000944 CD10                <1>     int 0x10
   753 00000946 CD10                <1>     int 0x10
   754 00000948 B00D                <1>     mov al, 0x0d
   755 0000094A CD10                <1>     int 0x10
   756                              <1> 
   757 0000094C 61                  <1>     popa
   758                              <1> 
   759 0000094D E938FC              <1>     jmp .input_loop
   760                              <1> 
   761                              <1> ; ----------------------------------
   762                              <1> ; LOAD FILE
   763                              <1> 
   764                              <1> .load_file:
   765 00000950 60                  <1>     pusha
   766 00000951 31C0                <1>     xor ax, ax
   767                              <1> 
   768 00000953 B8[8C09]            <1>     mov ax, .tmp_filename
   769 00000956 E865F7              <1>     call try_run_file
   770 00000959 7204                <1>     jc .not_found
   771                              <1> 
   772 0000095B 61                  <1>     popa
   773 0000095C E929FC              <1>     jmp .input_loop
   774                              <1> 
   775                              <1>     .not_found:
   776 0000095F BE[9A03]            <1>         mov si, notfound_msg
   777 00000962 E8AE11              <1>         call print
   778                              <1> 
   779 00000965 61                  <1>         popa
   780 00000966 E91FFC              <1>         jmp .input_loop
   781                              <1> 
   782                              <1> ; ----------------------------------
   783                              <1> ; EDIT FILE
   784                              <1> 
   785                              <1> .edit_file:
   786 00000969 E91CFC              <1>     jmp .input_loop
   787                              <1> 
   788                              <1> ; ----------------------------------
   789                              <1> ; RESTART
   790                              <1> 
   791                              <1> .restart:
   792 0000096C B80000              <1>     mov ax, 0x00
   793 0000096F CD13                <1>     int 0x13
   794 00000971 CD19                <1>     int 0x19
   795                              <1> 
   796                              <1>     ; Halt cpu if restart fails
   797 00000973 F4                  <1>     hlt
   798                              <1> 
   799                              <1> ; ----------------------------------
   800                              <1> ; SHUTDOWN
   801                              <1> 
   802                              <1> .shutdown:
   803 00000974 31C0                <1>     xor ax, ax
   804 00000976 CD13                <1>     int 0x13
   805                              <1> 
   806 00000978 B80010              <1>     mov ax, 0x1000
   807 0000097B 8CD0                <1>     mov ax, ss
   808 0000097D BC00F0              <1>     mov sp, 0xf000
   809 00000980 B80753              <1>     mov ax, 0x5307
   810 00000983 BB0100              <1>     mov bx, 0x0001
   811 00000986 B90300              <1>     mov cx, 0x0003
   812 00000989 CD15                <1>     int 0x15
   813                              <1> 
   814                              <1>     ; Halt cpu if shutdown fails
   815 0000098B F4                  <1>     hlt
   816                              <1> 
   817                              <1> 
   818 0000098C 00<rep 14h>         <1> .tmp_filename:      times 20 db 0
   819 000009A0 00<rep 29h>         <1> .tmp_inbuffer:      times 41 db 0
   820 000009C9 202D2D2000          <1> .file_size_sep:		db " -- ", 0
   821 000009CE 2042797465730A0D00  <1> .file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   822 000009D7 20686173206265656E- <1> .tmp_filerm:        db " has been deleted", 0
   822 000009E0 2064656C6574656400  <1>
   823 000009E9 20686173206265656E- <1> .tmp_filemk:        db " has been created", 0
   823 000009F2 206372656174656400  <1>
   824 000009FB 4155544F52554E2E42- <1> .autobin_filename:  db "AUTORUN.BKF", 0
   824 00000A04 4B4600              <1>
   825 00000A07 4155544F52554E2E42- <1> .autobas_filename:  db "AUTORUN.BAS", 0
   825 00000A10 415300              <1>
   360                                      %include "./includes/menubar.asm"
   361                              <1> check_pos:
   362 00000A13 60                  <1>     pusha
   363                              <1> 
   364 00000A14 B403                <1>     mov ah, 0x03
   365 00000A16 30FF                <1>     xor bh, bh
   366 00000A18 CD10                <1>     int 0x10
   367                              <1> 
   368 00000A1A 80FE18              <1>     cmp dh, 24
   369 00000A1D 7402                <1>     je .at_end
   370                              <1> 
   371 00000A1F 61                  <1>     popa
   372 00000A20 C3                  <1>     ret
   373                              <1> 
   374                              <1> .at_end:
   375 00000A21 B80306              <1>     mov ax, 0x0603
   376 00000A24 B70F                <1>     mov bh, cli_color
   377 00000A26 BA4F18              <1> 	mov dx, 0x184f
   378 00000A29 31C9                <1> 	xor cx, cx
   379 00000A2B CD10                <1>     int 0x10
   380                              <1> 
   381 00000A2D B402                <1>     mov ah, 0x02
   382 00000A2F 30FF                <1>     xor bh, bh
   383 00000A31 30D2                <1>     xor dl, dl
   384 00000A33 B615                <1>     mov dh, 21
   385 00000A35 CD10                <1>     int 0x10
   386                              <1> 
   387 00000A37 61                  <1>     popa
   388 00000A38 C3                  <1>     ret
   389                              <1> 
   390                              <1> draw_menu_bar:
   391 00000A39 60                  <1>     pusha
   392                              <1> 
   393 00000A3A B403                <1>     mov ah, 0x03
   394 00000A3C 30FF                <1>     xor bh, bh
   395 00000A3E CD10                <1>     int 0x10
   396                              <1> 
   397 00000A40 52                  <1>     push dx
   398                              <1> 
   399 00000A41 B80407              <1>     mov ax, 0x0704
   400 00000A44 B70F                <1>     mov bh, cli_color
   401 00000A46 BA4F18              <1> 	mov dx, 0x184f
   402 00000A49 31C9                <1> 	xor cx, cx
   403 00000A4B CD10                <1>     int 0x10
   404 00000A4D B80406              <1>     mov ax, 0x0604
   405 00000A50 CD10                <1>     int 0x10
   406                              <1>     
   407 00000A52 B402                <1>     mov ah, 0x02
   408 00000A54 B618                <1>     mov dh, 24
   409 00000A56 30FF                <1>     xor bh, bh
   410 00000A58 30D2                <1>     xor dl, dl
   411 00000A5A CD10                <1>     int 0x10
   412                              <1> 
   413 00000A5C BE[C203]            <1>     mov si, mb_fill
   414 00000A5F B330                <1>     mov bl, mb_color
   415 00000A61 E8E810              <1>     call print_atr
   416                              <1> 
   417 00000A64 B402                <1>     mov ah, 0x02
   418 00000A66 B618                <1>     mov dh, 24
   419 00000A68 B201                <1>     mov dl, 1
   420 00000A6A 30FF                <1>     xor bh, bh
   421 00000A6C CD10                <1>     int 0x10
   422                              <1> 
   423 00000A6E E82505              <1>     call get_time_string
   424 00000A71 89DE                <1>     mov si, bx
   425 00000A73 B330                <1>     mov bl, mb_color
   426 00000A75 E8D410              <1>     call print_atr
   427                              <1> 
   428 00000A78 B402                <1>     mov ah, 0x02
   429 00000A7A B618                <1>     mov dh, 24
   430 00000A7C B21C                <1>     mov dl, 28
   431 00000A7E 30FF                <1>     xor bh, bh
   432 00000A80 CD10                <1>     int 0x10
   433                              <1> 
   434 00000A82 B8[6F01]            <1>     mov ax, usrNam
   435 00000A85 E83503              <1>     call string_uppercase
   436 00000A88 89C6                <1>     mov si, ax
   437 00000A8A B330                <1>     mov bl, mb_color
   438 00000A8C E8BD10              <1>     call print_atr
   439                              <1> 
   440 00000A8F B402                <1>     mov ah, 0x02
   441 00000A91 B618                <1>     mov dh, 24
   442 00000A93 B245                <1>     mov dl, 69
   443 00000A95 30FF                <1>     xor bh, bh
   444 00000A97 CD10                <1>     int 0x10
   445                              <1> 
   446 00000A99 E8B105              <1>     call get_date_string
   447 00000A9C 89DE                <1>     mov si, bx
   448 00000A9E B330                <1>     mov bl, mb_color
   449 00000AA0 E8A910              <1>     call print_atr
   450                              <1> 
   451 00000AA3 B402                <1>     mov ah, 0x02
   452 00000AA5 30FF                <1>     xor bh, bh
   453 00000AA7 30D2                <1>     xor dl, dl
   454 00000AA9 5A                  <1>     pop dx
   455 00000AAA CD10                <1>     int 0x10
   456                              <1> 
   457 00000AAC 61                  <1>     popa
   458 00000AAD C3                  <1>     ret
   361                                      %include "./includes/video.asm"
   362                              <1> kronk_vid:
   363 00000AAE B80100              <1>     mov ax, 1
   364 00000AB1 B701                <1>     mov bh, vid_backcolor
   365 00000AB3 E87609              <1>     call switch_mode
   366                              <1>     
   367                              <1>     ; Disable color blinking
   368 00000AB6 B80310              <1>     mov ax, 0x1003
   369 00000AB9 BB0000              <1>     mov bx, 0x0000
   370 00000ABC CD10                <1>     int 0x10
   371                              <1> 
   372                              <1>     ; Initalize and enable the mouse if possible
   373 00000ABE E8B410              <1>     call mouse_initialize
   374 00000AC1 720A                <1>     jc vid_input
   375 00000AC3 B001                <1>     mov al, 1
   376 00000AC5 A2[CE0A]            <1>     mov [mouse_working], al
   377 00000AC8 E8D810              <1>     call mouse_enable
   378 00000ACB EB00                <1>     jmp vid_input
   379                              <1> 
   380                              <1> vid_input:
   381                              <1>     ;mov si, mb_string
   382                              <1>     ;xor bh, bh
   383                              <1>     ;mov bl, vid_forecolor
   384                              <1>     ;call print_atr
   385                              <1> 
   386                              <1>     ;mov bh, vid_backcolor
   387                              <1>     ;call cls
   388                              <1> 
   389                              <1>     ;mov al, [mouse_working]
   390                              <1>     ;cmp al, 0
   391                              <1>     ;call mouse_loop
   392                              <1>     ;call move_cursor
   393                              <1> 
   394                              <1>     ;mov si, sejt
   395                              <1>     ;xor bh, bh
   396                              <1>     ;mov bl, vid_forecolor
   397                              <1>     ;call print_atr
   398                              <1> 
   399 00000ACD F4                  <1>     hlt
   400                              <1> 
   401                              <1> ; ------------------------------------------------------------------
   402                              <1> ; STRINGS AND OTHER VARIABLES
   403                              <1> 
   404 00000ACE 00                  <1>     mouse_working:      db 0
   405 00000ACF 2000                <1>     sejt:               db " ", 0
   362                                      %include "./includes/setup.asm"
   363                              <1> ; ==================================================================
   364                              <1> ; The Kronk Operating System setup file
   365                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   366                              <1> ;
   367                              <1> ; This is loaded from the drive by KERNEL.BIN, at first boot
   368                              <1> ; ==================================================================
   369                              <1> setup_init:
   370                              <1> 
   371                              <1>     ; Color variables
   372                              <1>     basic_colors    equ 0x1F
   373                              <1>     marked_colors   equ 0x1E
   374                              <1> 
   375                              <1>     ; Setup text box variables
   376                              <1>     edge_width      equ 14
   377                              <1>     border_length   equ 50
   378                              <1>     
   379                              <1>     ; Disable color blinking
   380 00000AD1 B80310              <1>     mov ax, 0x1003
   381 00000AD4 BB0000              <1>     mov bx, 0x0000
   382 00000AD7 CD10                <1>     int 0x10
   383                              <1> 
   384 00000AD9 EB00                <1>     jmp setup_start
   385                              <1> 
   386                              <1> ; ******************************************************************
   387                              <1> ; Start the setup
   388                              <1> setup_start:
   389 00000ADB 60                  <1>     pusha
   390 00000ADC B71F                <1>     mov bh, basic_colors
   391 00000ADE E87702              <1>     call cls
   392                              <1> 
   393 00000AE1 BE[430D]            <1>     mov si, setup_string
   394 00000AE4 E86C09              <1>     call setup_bottom_string
   395                              <1> 
   396 00000AE7 BE[680B]            <1>     mov si, usr_set
   397 00000AEA E8290C              <1>     call draw_setup_box
   398                              <1> 
   399 00000AED B8[540B]            <1>     mov ax, usr_save
   400 00000AF0 E87809              <1>     call setup_input
   401                              <1> 
   402 00000AF3 B71F                <1>     mov bh, basic_colors
   403 00000AF5 E86002              <1>     call cls
   404                              <1> 
   405 00000AF8 BE[970B]            <1>     mov si, vid_set
   406 00000AFB E8180C              <1>     call draw_setup_box
   407                              <1> 
   408 00000AFE B8[0E0D]            <1>     mov ax, vid_opt1
   409 00000B01 BB[170D]            <1>     mov bx, vid_opt2
   410 00000B04 B9[220D]            <1>     mov cx, vid_opt3
   411 00000B07 BAE11F              <1>     mov dx, 0x1fe1
   412 00000B0A E8560A              <1>     call setup_choose
   413                              <1> 
   414 00000B0D 83F802              <1>     cmp ax, 2
   415 00000B10 7517                <1>     jne .setup_done
   416                              <1> 
   417                              <1>     ; User has choosen "cancel" and KronkOS will therefore shutdown
   418 00000B12 31C0                <1>     xor ax, ax
   419 00000B14 CD13                <1>     int 0x13
   420                              <1> 
   421 00000B16 B80010              <1>     mov ax, 0x1000
   422 00000B19 8CD0                <1>     mov ax, ss
   423 00000B1B BC00F0              <1>     mov sp, 0xf000
   424 00000B1E B80753              <1>     mov ax, 0x5307
   425 00000B21 BB0100              <1>     mov bx, 0x0001
   426 00000B24 B90300              <1>     mov cx, 0x0003
   427 00000B27 CD15                <1>     int 0x15
   428                              <1> 
   429                              <1> .setup_done:
   430 00000B29 A3[8401]            <1>     mov [vidMode], ax
   431                              <1> 
   432 00000B2C BE[540B]            <1>     mov si, usr_save
   433 00000B2F BF[6F01]            <1>     mov di, usrNam
   434 00000B32 E8C202              <1>     call string_copy
   435                              <1> 
   436 00000B35 61                  <1>     popa
   437 00000B36 C3                  <1>     ret
   438                              <1> 
   439                              <1> ; ******************************************************************
   440                              <1> 
   441                              <1> ; ------------------------------------------------------------------
   442                              <1> ; VARIABLES
   443 00000B37 766964656F6D6F6465- <1>     vidmode_save:   db "videomode,", 0
   443 00000B40 2C00                <1>
   444 00000B42 300A0D00            <1>     cli_save:       db "0", 0x0a, 0x0d, 0
   445 00000B46 310A0D00            <1>     vid_save:       db "1", 0x0a, 0x0d, 0
   446 00000B4A 757365726E616D652C- <1>     usrname_save:   db "username,", 0
   446 00000B53 00                  <1>
   447 00000B54 00<rep 14h>         <1>     usr_save:       times 20 db 0
   448                              <1> 
   449 00000B68 506C6561736520656E- <1>     usr_set:    db "Please enter your username, and press enter...", 0
   449 00000B71 74657220796F757220- <1>
   449 00000B7A 757365726E616D652C- <1>
   449 00000B83 20616E642070726573- <1>
   449 00000B8C 7320656E7465722E2E- <1>
   449 00000B95 2E00                <1>
   450                              <1> 
   451 00000B97 506C65617365206368- <1>     vid_set:    db "Please choose a standard view mode...", 0x0a, 0x0a
   451 00000BA0 6F6F73652061207374- <1>
   451 00000BA9 616E64617264207669- <1>
   451 00000BB2 6577206D6F64652E2E- <1>
   451 00000BBB 2E0A0A              <1>
   452 00000BBE 564944454F204D4F44- <1>                 db "VIDEO MODE is for the more casual user, that", 0x0a, "just want to be able to use KronkOS with ease by using a nice graphical interface.", 0x0a, 0x0a
   452 00000BC7 4520697320666F7220- <1>
   452 00000BD0 746865206D6F726520- <1>
   452 00000BD9 63617375616C207573- <1>
   452 00000BE2 65722C20746861740A- <1>
   452 00000BEB 6A7573742077616E74- <1>
   452 00000BF4 20746F206265206162- <1>
   452 00000BFD 6C6520746F20757365- <1>
   452 00000C06 204B726F6E6B4F5320- <1>
   452 00000C0F 776974682065617365- <1>
   452 00000C18 206279207573696E67- <1>
   452 00000C21 2061206E6963652067- <1>
   452 00000C2A 726170686963616C20- <1>
   452 00000C33 696E74657266616365- <1>
   452 00000C3C 2E0A0A              <1>
   453 00000C3F 434C49204D4F444520- <1>                 db "CLI MODE is for the more advanced user, where", 0x0a, "instead of pressing buttons, you use commands to", 0x0a, "execute the various actions you desire.", 0x0a, 0x0a
   453 00000C48 697320666F72207468- <1>
   453 00000C51 65206D6F7265206164- <1>
   453 00000C5A 76616E636564207573- <1>
   453 00000C63 65722C207768657265- <1>
   453 00000C6C 0A696E737465616420- <1>
   453 00000C75 6F6620707265737369- <1>
   453 00000C7E 6E6720627574746F6E- <1>
   453 00000C87 732C20796F75207573- <1>
   453 00000C90 6520636F6D6D616E64- <1>
   453 00000C99 7320746F0A65786563- <1>
   453 00000CA2 757465207468652076- <1>
   453 00000CAB 6172696F7573206163- <1>
   453 00000CB4 74696F6E7320796F75- <1>
   453 00000CBD 206465736972652E0A- <1>
   453 00000CC6 0A                  <1>
   454 00000CC7 557365207468652061- <1>                 db "Use the arrow keys and 'ENTER' to select between the different options", 0
   454 00000CD0 72726F77206B657973- <1>
   454 00000CD9 20616E642027454E54- <1>
   454 00000CE2 45522720746F207365- <1>
   454 00000CEB 6C6563742062657477- <1>
   454 00000CF4 65656E207468652064- <1>
   454 00000CFD 6966666572656E7420- <1>
   454 00000D06 6F7074696F6E7300    <1>
   455                              <1> 
   456 00000D0E 434C49204D4F444500  <1>     vid_opt1:   db "CLI MODE", 0
   457 00000D17 564944454F204D4F44- <1>     vid_opt2:   db "VIDEO MODE", 0
   457 00000D20 4500                <1>
   458 00000D22 43616E63656C202857- <1>     vid_opt3:   db "Cancel (Will shutdown KronkOS)", 0
   458 00000D2B 696C6C207368757464- <1>
   458 00000D34 6F776E204B726F6E6B- <1>
   458 00000D3D 4F532900            <1>
   459                              <1> 
   460 00000D41 0000                <1>     vid_chosen: dw 0
   461                              <1> 
   462 00000D43 204B726F6E6B4F5320- <1>     setup_string: db " KronkOS ", KRONKOS_VER, " setup", 0
   462 00000D4C 302E332E3220736574- <1>
   462 00000D55 757000              <1>
   363                                      %include "./includes/cls.asm"
   364                              <1> cls:
   365 00000D58 60                  <1>     pusha
   366                              <1>     
   367 00000D59 B406                <1>     mov ah, 0x06
   368 00000D5B BA4F18              <1>     mov dx, 0x184f
   369                              <1> 
   370 00000D5E 30C0                <1>     xor al, al
   371 00000D60 31C9                <1>     xor cx, cx
   372                              <1> 
   373 00000D62 CD10                <1>     int 0x10
   374                              <1>     
   375 00000D64 B402                <1>     mov ah, 0x2
   376 00000D66 31D2                <1>     xor dx, dx
   377 00000D68 30FF                <1>     xor bh, bh
   378                              <1> 
   379 00000D6A CD10                <1>     int 0x10
   380                              <1>     
   381 00000D6C 61                  <1>     popa
   382 00000D6D C3                  <1>     ret
   364                                      %include "./includes/string.asm"
   365                              <1> ; ==================================================================
   366                              <1> ; KronkOS -- The Kronk Operating System kernel
   367                              <1> ; Copyright (C) 2019-2020 Alexander Wiencken
   368                              <1> ;
   369                              <1> ; STRING MANIPULATION ROUTINES
   370                              <1> ; ==================================================================
   371                              <1> 
   372                              <1> ; ------------------------------------------------------------------
   373                              <1> ; string_length -- Return length of a string
   374                              <1> ; IN: AX = string location
   375                              <1> ; OUT AX = length (other regs preserved)
   376                              <1> 
   377                              <1> string_length:
   378 00000D6E 60                  <1>     pusha
   379 00000D6F 89C3                <1>     mov bx, ax
   380 00000D71 B90000              <1>     mov cx, 0
   381                              <1> 
   382                              <1>     .more:
   383 00000D74 803F00              <1>         cmp byte [bx], 0
   384 00000D77 7404                <1>         je .done
   385 00000D79 43                  <1>         inc bx
   386 00000D7A 41                  <1>         inc cx
   387 00000D7B EBF7                <1>         jmp .more
   388                              <1> 
   389                              <1>     .done:
   390 00000D7D 890E[860D]          <1>         mov word [.tmp_counter], cx
   391 00000D81 61                  <1>         popa
   392                              <1> 
   393 00000D82 A1[860D]            <1>         mov ax, [.tmp_counter]
   394 00000D85 C3                  <1>         ret
   395                              <1> 
   396 00000D86 0000                <1>         .tmp_counter dw 0
   397                              <1> 
   398                              <1> ; ------------------------------------------------------------------
   399                              <1> ; find_char_in_string -- Find location of character in a string
   400                              <1> ; IN: SI = string location, AL = character to find
   401                              <1> ; OUT AX = location in string, or 0 if not present
   402                              <1> 
   403                              <1> find_char_in_string:
   404 00000D88 60                  <1>     pusha
   405 00000D89 B90100              <1>     mov cx, 1
   406                              <1> 
   407                              <1>     .more:
   408 00000D8C 3804                <1>         cmp byte [si], al
   409 00000D8E 7409                <1>         je .done
   410 00000D90 803C00              <1>         cmp byte [si], 0
   411 00000D93 740D                <1>         je .notfound
   412                              <1>         
   413 00000D95 46                  <1>         inc si
   414 00000D96 41                  <1>         inc cx
   415                              <1> 
   416 00000D97 EBF3                <1>         jmp .more
   417                              <1>     
   418                              <1>     .done:
   419 00000D99 890E[A70D]          <1>         mov [.tmp], cx
   420 00000D9D 61                  <1>         popa
   421 00000D9E A1[A70D]            <1>         mov ax, [.tmp]
   422                              <1> 
   423 00000DA1 C3                  <1>         ret
   424                              <1>     
   425                              <1>     .notfound:
   426 00000DA2 61                  <1>         popa
   427 00000DA3 B80000              <1>         mov ax, 0
   428                              <1> 
   429 00000DA6 C3                  <1>         ret
   430                              <1> 
   431 00000DA7 0000                <1>     .tmp dw 0
   432                              <1> 
   433                              <1> ; ------------------------------------------------------------------
   434                              <1> ; string_charchange -- Change a character in a string
   435                              <1> ; IN: SI = string location, AL = char to find, BL = char to replace with
   436                              <1> 
   437                              <1> string_charchange:
   438 00000DA9 60                  <1>     pusha
   439 00000DAA 88C1                <1>     mov cl, al
   440                              <1> 
   441                              <1>     .loop:
   442 00000DAC 8A04                <1>         mov byte al, [si]
   443 00000DAE 3C00                <1>         cmp al, 0
   444 00000DB0 7409                <1>         je .finish
   445 00000DB2 38C8                <1>         cmp al, cl
   446 00000DB4 7502                <1>         jne .nochange
   447                              <1> 
   448 00000DB6 881C                <1>         mov byte [si], bl
   449                              <1> 
   450                              <1>     .nochange:
   451 00000DB8 46                  <1>         inc si
   452 00000DB9 EBF1                <1>         jmp .loop
   453                              <1>     
   454                              <1>     .finish:
   455 00000DBB 61                  <1>         popa
   456 00000DBC C3                  <1>         ret
   457                              <1> 
   458                              <1> ; ------------------------------------------------------------------
   459                              <1> ; string_uppercase -- Convert string to upper case
   460                              <1> ; IN/OUT: AX = string location
   461                              <1> 
   462                              <1> string_uppercase:
   463 00000DBD 60                  <1>     pusha
   464 00000DBE 89C6                <1>     mov si, ax
   465                              <1> 
   466                              <1>     .more:
   467 00000DC0 803C00              <1>         cmp byte [si], 0
   468 00000DC3 7413                <1>         je .done
   469                              <1> 
   470 00000DC5 803C61              <1>         cmp byte [si], 'a'
   471 00000DC8 720B                <1>         jb .noatoz
   472 00000DCA 803C7A              <1>         cmp byte [si], 'z'
   473 00000DCD 7706                <1>         ja .noatoz
   474                              <1> 
   475 00000DCF 802C20              <1>         sub byte [si], 0x20
   476                              <1> 
   477 00000DD2 46                  <1>         inc si
   478 00000DD3 EBEB                <1>         jmp .more
   479                              <1> 
   480                              <1>     .noatoz:
   481 00000DD5 46                  <1>         inc si
   482 00000DD6 EBE8                <1>         jmp .more
   483                              <1> 
   484                              <1>     .done:
   485 00000DD8 61                  <1>         popa
   486 00000DD9 C3                  <1>         ret
   487                              <1> 
   488                              <1> ; ------------------------------------------------------------------
   489                              <1> ; string_lowercase -- Convert string to lower case
   490                              <1> ; IN/OUT: AX = string location
   491                              <1> 
   492                              <1> string_lowercase:
   493 00000DDA 60                  <1>     pusha
   494 00000DDB 89C6                <1>     mov si, ax
   495                              <1> 
   496                              <1>     .more:
   497 00000DDD 803C00              <1>         cmp byte [si], 0
   498 00000DE0 7413                <1>         je .done
   499                              <1> 
   500 00000DE2 803C41              <1>         cmp byte [si], 'A'
   501 00000DE5 720B                <1>         jb .noatoz
   502 00000DE7 803C5A              <1>         cmp byte [si], 'Z'
   503 00000DEA 7706                <1>         ja .noatoz
   504                              <1> 
   505 00000DEC 800420              <1>         add byte [si], 0x20
   506                              <1> 
   507 00000DEF 46                  <1>         inc si
   508 00000DF0 EBEB                <1>         jmp .more
   509                              <1>     
   510                              <1>     .noatoz:
   511 00000DF2 46                  <1>         inc si
   512 00000DF3 EBE8                <1>         jmp .more
   513                              <1> 
   514                              <1>     .done:
   515 00000DF5 61                  <1>         popa
   516 00000DF6 C3                  <1>         ret
   517                              <1>         
   518                              <1> ; ------------------------------------------------------------------
   519                              <1> ; string_copy -- Copy one string on to another
   520                              <1> ; IN: SI = source
   521                              <1> ; OUT: DI = destination
   522                              <1> 
   523                              <1> string_copy:
   524 00000DF7 60                  <1>     pusha
   525                              <1> 
   526                              <1>     .more:
   527 00000DF8 AC                  <1>         lodsb
   528 00000DF9 AA                  <1>         stosb
   529                              <1> 
   530 00000DFA 84C0                <1>         test al, al
   531 00000DFC 75FA                <1>         jnz .more
   532                              <1> 
   533                              <1>     .done:
   534 00000DFE 61                  <1>         popa
   535 00000DFF C3                  <1>         ret
   536                              <1> 
   537                              <1> ; ------------------------------------------------------------------
   538                              <1> ; string_truncate -- Chop string down to specified number of characters
   539                              <1> ; IN: SI = string location, AX = number of characters
   540                              <1> ; OUT: Modified string
   541                              <1> 
   542                              <1> string_truncate:
   543 00000E00 60                  <1>     pusha
   544                              <1> 
   545 00000E01 01C6                <1>     add si, ax
   546 00000E03 C60400              <1>     mov byte [si], 0
   547                              <1> 
   548 00000E06 61                  <1>     popa
   549 00000E07 C3                  <1>     ret
   550                              <1> 
   551                              <1> ; ------------------------------------------------------------------
   552                              <1> ; string_add
   553                              <1> ; IN: AX = string one; BX = string two
   554                              <1> ; OUT AX = product
   555                              <1> 
   556                              <1> string_add:
   557                              <1>     .add_loop:
   558 00000E08 AC                  <1>         lodsb
   559 00000E09 AA                  <1>         stosb
   560                              <1> 
   561 00000E0A 3C00                <1>         cmp al, 0
   562 00000E0C 75FA                <1>         jne .add_loop
   563                              <1> 
   564 00000E0E C3                  <1>         ret
   565                              <1> 
   566                              <1> ; ------------------------------------------------------------------
   567                              <1> ; string_join -- Join two strings into a third seperate string
   568                              <1> ; IN/OUT: AX = string one, BX = string two, CX = product destination
   569                              <1> 
   570                              <1> string_join:
   571 00000E0F 60                  <1>     pusha
   572                              <1>     
   573 00000E10 89C6                <1>     mov si, ax
   574 00000E12 89CF                <1>     mov di, cx
   575                              <1> 
   576 00000E14 E8E0FF              <1>     call string_copy
   577 00000E17 E854FF              <1>     call string_length
   578                              <1> 
   579 00000E1A 01C1                <1>     add cx, ax
   580                              <1> 
   581 00000E1C 89DE                <1>     mov si, bx
   582 00000E1E 89CF                <1>     mov di, cx
   583 00000E20 E8D4FF              <1>     call string_copy
   584                              <1> 
   585 00000E23 61                  <1>     popa
   586 00000E24 C3                  <1>     ret
   587                              <1> 
   588                              <1> ; ------------------------------------------------------------------
   589                              <1> ; string_chomp -- Strip away extra spaces from a string
   590                              <1> ; IN: AX = string location
   591                              <1> 
   592                              <1> string_chomp:
   593 00000E25 60                  <1>     pusha
   594                              <1> 
   595 00000E26 89C2                <1>     mov dx, ax
   596                              <1> 
   597 00000E28 89C7                <1>     mov di, ax
   598 00000E2A B90000              <1>     mov cx, 0
   599                              <1> 
   600                              <1>     .keepcounting:
   601 00000E2D 803D20              <1>         cmp byte [di], ' '
   602 00000E30 7504                <1>         jne .counted
   603 00000E32 41                  <1>         inc cx
   604 00000E33 47                  <1>         inc di
   605 00000E34 EBF7                <1>         jmp .keepcounting
   606                              <1> 
   607                              <1>     .counted:
   608 00000E36 83F900              <1>         cmp cx, 0
   609 00000E39 740E                <1>         je .finished_copy
   610                              <1> 
   611 00000E3B 89FE                <1>         mov si, di
   612 00000E3D 89D7                <1>         mov di, dx
   613                              <1>     
   614                              <1>     .keep_copying:
   615 00000E3F AC                  <1>         lodsb
   616 00000E40 8805                <1>         mov [di], al
   617 00000E42 3C00                <1>         cmp al, 0
   618 00000E44 7403                <1>         je .finished_copy
   619 00000E46 47                  <1>         inc di
   620                              <1> 
   621 00000E47 EBF6                <1>         jmp .keep_copying
   622                              <1> 
   623                              <1>     .finished_copy:
   624 00000E49 89D0                <1>         mov ax, dx
   625                              <1> 
   626 00000E4B E820FF              <1>         call string_length
   627 00000E4E 83F800              <1>         cmp ax, 0
   628 00000E51 740F                <1>         je .done
   629                              <1> 
   630 00000E53 89D6                <1>         mov si, dx
   631 00000E55 01C6                <1>         add si, ax
   632                              <1>     
   633                              <1>     .more:
   634 00000E57 4E                  <1>         dec si
   635 00000E58 803C20              <1>         cmp byte [si], ' '
   636 00000E5B 7505                <1>         jne .done
   637 00000E5D C60400              <1>         mov byte [si], 0
   638 00000E60 EBF5                <1>         jmp .more
   639                              <1>     
   640                              <1>     .done:
   641 00000E62 61                  <1>         popa
   642 00000E63 C3                  <1>         ret
   643                              <1> 
   644                              <1> ; ------------------------------------------------------------------
   645                              <1> ; string_strip -- Remove a character from a string (max 255 chars)
   646                              <1> ; IN: SI = string location, AL = character to remove
   647                              <1> ; OUT: SI = modified string
   648                              <1> 
   649                              <1> string_strip:
   650 00000E64 60                  <1>     pusha
   651                              <1> 
   652 00000E65 89F7                <1>     mov di, si
   653 00000E67 88C3                <1>     mov bl, al
   654                              <1> 
   655                              <1>     .nextchar:
   656 00000E69 AC                  <1>         lodsb
   657 00000E6A AA                  <1>         stosb
   658 00000E6B 3C00                <1>         cmp al, 0
   659 00000E6D 7407                <1>         je .finish
   660 00000E6F 38D8                <1>         cmp al, bl
   661 00000E71 75F6                <1>         jne .nextchar
   662                              <1> 
   663                              <1>     .skip:
   664 00000E73 4F                  <1>         dec di
   665 00000E74 EBF3                <1>         jmp .nextchar
   666                              <1> 
   667                              <1>     .finish:
   668 00000E76 61                  <1>         popa
   669 00000E77 C3                  <1>         ret
   670                              <1> 
   671                              <1> ; ------------------------------------------------------------------
   672                              <1> ; string_compare -- Check if two strings match
   673                              <1> ; IN: SI = string one, DI = string two
   674                              <1> ; OUT: carry set if same, clear if different
   675                              <1> 
   676                              <1> string_compare:
   677 00000E78 60                  <1>     pusha
   678                              <1> 
   679                              <1>     .more:
   680 00000E79 8A04                <1>         mov al, [si]
   681 00000E7B 8A1D                <1>         mov bl, [di]
   682                              <1> 
   683 00000E7D 80FB00              <1>         cmp bl, 0
   684 00000E80 740B                <1>         je .terminated
   685                              <1> 
   686 00000E82 38D8                <1>         cmp al, bl
   687 00000E84 7504                <1>         jne .not_same
   688                              <1> 
   689 00000E86 46                  <1>         inc si
   690 00000E87 47                  <1>         inc di
   691 00000E88 EBEF                <1>         jmp .more
   692                              <1>     
   693                              <1>     .not_same:
   694 00000E8A 61                  <1>         popa
   695 00000E8B F8                  <1>         clc
   696 00000E8C C3                  <1>         ret
   697                              <1>     
   698                              <1>     .terminated:
   699 00000E8D 61                  <1>         popa
   700 00000E8E F9                  <1>         stc
   701 00000E8F C3                  <1>         ret
   702                              <1> 
   703                              <1> ; ------------------------------------------------------------------
   704                              <1> ; string_to_int -- Convert string to an integer
   705                              <1> ; IN: SI = string (max 5 chars, up to '65536')
   706                              <1> ; OUT: AX = number
   707                              <1> 
   708                              <1> string_to_int:
   709 00000E90 60                  <1>     pusha
   710                              <1> 
   711 00000E91 89F0                <1>     mov ax, si
   712 00000E93 E8D8FE              <1>     call string_length
   713                              <1> 
   714 00000E96 01C6                <1>     add si, ax
   715 00000E98 4E                  <1>     dec si
   716                              <1> 
   717 00000E99 89C1                <1>     mov cx, ax
   718                              <1> 
   719 00000E9B BB0000              <1>     mov bx, 0
   720 00000E9E B80000              <1>     mov ax, 0
   721                              <1> 
   722 00000EA1 C706[D30E]0100      <1>     mov word [.multiplier], 1
   723                              <1> 
   724                              <1>     .loop:
   725 00000EA7 B80000              <1>         mov ax, 0
   726 00000EAA 8A04                <1>         mov byte al, [si]
   727 00000EAC 2C30                <1>         sub al, 48
   728                              <1> 
   729 00000EAE F726[D30E]          <1>         mul word [.multiplier]
   730 00000EB2 01C3                <1>         add bx, ax
   731                              <1> 
   732 00000EB4 50                  <1>         push ax
   733 00000EB5 A1[D30E]            <1>         mov word ax, [.multiplier]
   734 00000EB8 BA0A00              <1>         mov dx, 10
   735 00000EBB F7E2                <1>         mul dx
   736 00000EBD A3[D30E]            <1>         mov word [.multiplier], ax
   737 00000EC0 58                  <1>         pop ax
   738                              <1> 
   739 00000EC1 49                  <1>         dec cx
   740 00000EC2 83F900              <1>         cmp cx, 0
   741 00000EC5 7403                <1>         je .finish
   742 00000EC7 4E                  <1>         dec si
   743 00000EC8 EBDD                <1>         jmp .loop
   744                              <1>     
   745                              <1>     .finish:
   746 00000ECA 891E[D50E]          <1>         mov word [.tmp], bx
   747 00000ECE 61                  <1>         popa
   748 00000ECF A1[D50E]            <1>         mov word ax, [.tmp]
   749                              <1> 
   750 00000ED2 C3                  <1>         ret
   751                              <1> 
   752 00000ED3 0000                <1>     .multiplier dw 0
   753 00000ED5 0000                <1>     .tmp        dw 0
   754                              <1> 
   755                              <1> ; ------------------------------------------------------------------
   756                              <1> ; int_to_string -- Convert unsigned integer to a string
   757                              <1> ; IN: AX = unsigned int
   758                              <1> ; OUT: AX = string
   759                              <1> 
   760                              <1> int_to_string:
   761 00000ED7 60                  <1>     pusha
   762                              <1> 
   763 00000ED8 B90000              <1>     mov cx, 0
   764 00000EDB BB0A00              <1>     mov bx, 10
   765 00000EDE BF[FE0E]            <1>     mov di, .t
   766                              <1> 
   767                              <1>     .push:
   768 00000EE1 BA0000              <1>         mov dx, 0
   769 00000EE4 F7F3                <1>         div bx
   770 00000EE6 41                  <1>         inc cx
   771 00000EE7 52                  <1>         push dx
   772 00000EE8 85C0                <1>         test ax, ax
   773 00000EEA 75F5                <1>         jnz .push
   774                              <1> 
   775                              <1>     .pop:
   776 00000EEC 5A                  <1>         pop dx
   777 00000EED 80C230              <1>         add dl, '0'
   778 00000EF0 8815                <1>         mov [di], dl
   779 00000EF2 47                  <1>         inc di
   780 00000EF3 49                  <1>         dec cx
   781 00000EF4 75F6                <1>         jnz .pop
   782                              <1> 
   783 00000EF6 C60500              <1>         mov byte [di], 0
   784                              <1> 
   785 00000EF9 61                  <1>         popa
   786 00000EFA B8[FE0E]            <1>         mov ax, .t
   787 00000EFD C3                  <1>         ret
   788                              <1> 
   789 00000EFE 00<rep 7h>          <1>         .t times 7 db 0
   790                              <1> 
   791                              <1> ; ------------------------------------------------------------------
   792                              <1> ; sint_to_string -- Convert signed integer to string
   793                              <1> ; IN: AX = signed int
   794                              <1> ; OUT: AX = string location
   795                              <1> 
   796                              <1> sint_to_string:
   797 00000F05 60                  <1>     pusha
   798                              <1> 
   799 00000F06 B90000              <1>     mov cx, 0
   800 00000F09 BB0A00              <1>     mov bx, 10
   801 00000F0C BF[3A0F]            <1>     mov di, .t
   802                              <1> 
   803 00000F0F 85C0                <1>     test ax, ax
   804 00000F11 7802                <1>     js .neg
   805 00000F13 EB08                <1>     jmp .push
   806                              <1> 
   807                              <1>     .neg:
   808 00000F15 F7D8                <1>         neg ax
   809 00000F17 C606[3A0F]2D        <1>         mov byte [.t], '-'
   810 00000F1C 47                  <1>         inc di
   811                              <1>     
   812                              <1>     .push:
   813 00000F1D BA0000              <1>         mov dx, 0
   814 00000F20 F7F3                <1>         div bx
   815 00000F22 41                  <1>         inc cx
   816 00000F23 52                  <1>         push dx
   817 00000F24 85C0                <1>         test ax, ax
   818 00000F26 75F5                <1>         jnz .push
   819                              <1> 
   820                              <1>     .pop:
   821 00000F28 5A                  <1>         pop dx
   822 00000F29 80C230              <1>         add dl, '0'
   823 00000F2C 8815                <1>         mov [di], dl
   824 00000F2E 47                  <1>         inc di
   825 00000F2F 49                  <1>         dec cx
   826 00000F30 75F6                <1>         jnz .pop
   827                              <1> 
   828 00000F32 C60500              <1>         mov byte [di], 0
   829                              <1> 
   830 00000F35 61                  <1>         popa
   831 00000F36 B8[3A0F]            <1>         mov ax, .t
   832 00000F39 C3                  <1>         ret
   833                              <1> 
   834 00000F3A 00<rep 7h>          <1>         .t times 7 db 0
   835                              <1>         
   836                              <1> ; ------------------------------------------------------------------
   837                              <1> ; lint_to_string -- Convert long integer to string
   838                              <1> ; IN: DX:AX = long unsigned int, BX = number base, DI = string location
   839                              <1> ; OUT: DI = location of converted string
   840                              <1> 
   841                              <1> lint_to_string:
   842 00000F41 60                  <1>     pusha
   843                              <1> 
   844 00000F42 89FE                <1>     mov si, di
   845 00000F44 C7050000            <1>     mov word [di], 0
   846                              <1> 
   847 00000F48 83FB25              <1>     cmp bx, 37
   848 00000F4B 773B                <1>     ja .done
   849                              <1> 
   850 00000F4D 83FB00              <1>     cmp bx, 0
   851 00000F50 7436                <1>     je .done
   852                              <1> 
   853                              <1>     .conversion_loop:
   854 00000F52 B90000              <1>         mov cx, 0
   855                              <1> 
   856 00000F55 91                  <1>         xchg ax, cx
   857 00000F56 92                  <1>         xchg ax, dx
   858 00000F57 F7F3                <1>         div bx
   859                              <1> 
   860 00000F59 91                  <1>         xchg ax, cx
   861 00000F5A F7F3                <1>         div bx
   862 00000F5C 87CA                <1>         xchg cx, dx
   863                              <1>     
   864                              <1>     .save_digit:
   865 00000F5E 83F909              <1>         cmp cx, 9
   866 00000F61 7E03                <1>         jle .convert_digit
   867                              <1> 
   868 00000F63 83C107              <1>         add cx, 'A'-'9'-1
   869                              <1> 
   870                              <1>     .convert_digit:
   871 00000F66 83C130              <1>         add cx, '0'
   872                              <1> 
   873 00000F69 50                  <1>         push ax
   874 00000F6A 53                  <1>         push bx
   875 00000F6B 89F0                <1>         mov ax, si
   876 00000F6D E8FEFD              <1>         call string_length
   877                              <1> 
   878 00000F70 89F7                <1>         mov di, si
   879 00000F72 01C7                <1>         add di, ax
   880 00000F74 40                  <1>         inc ax
   881                              <1>     
   882                              <1>     .move_string_up:
   883 00000F75 8A1D                <1>         mov bl, [di]
   884 00000F77 885D01              <1>         mov [di+1], bl
   885 00000F7A 4F                  <1>         dec di
   886 00000F7B 48                  <1>         dec ax
   887 00000F7C 75F7                <1>         jnz .move_string_up
   888                              <1> 
   889 00000F7E 5B                  <1>         pop bx
   890 00000F7F 58                  <1>         pop ax
   891 00000F80 880C                <1>         mov [si], cl
   892                              <1>     
   893                              <1>     .test_end:
   894 00000F82 89D1                <1>         mov cx, dx
   895 00000F84 09C1                <1>         or cx, ax
   896 00000F86 75CA                <1>         jnz .conversion_loop
   897                              <1>     
   898                              <1>     .done:
   899 00000F88 61                  <1>         popa
   900 00000F89 C3                  <1>         ret
   901                              <1>         
   902                              <1> ; ------------------------------------------------------------------
   903                              <1> ; set_time_fmt -- Set time reporting format (eg '10:25 AM' or '2300 hours')
   904                              <1> ; IN: AL = format flag, 0 = 12-hr format
   905                              <1> 
   906                              <1> set_time_fmt:
   907 00000F8A 60                  <1> 	pusha
   908 00000F8B 3C00                <1> 	cmp al, 0
   909 00000F8D 7402                <1> 	je .store
   910 00000F8F B0FF                <1> 	mov al, 0x0FF
   911                              <1> .store:
   912 00000F91 A2[AE03]            <1> 	mov [fmt_12_24], al
   913 00000F94 61                  <1> 	popa
   914 00000F95 C3                  <1> 	ret
   915                              <1> 
   916                              <1> 
   917                              <1> ; ------------------------------------------------------------------
   918                              <1> ; get_time_string -- Get current time in a string (eg '10:25')
   919                              <1> ; OUT: BX = string location
   920                              <1> 
   921                              <1> get_time_string:
   922 00000F96 60                  <1> 	pusha
   923                              <1> 
   924 00000F97 89DF                <1> 	mov di, bx
   925                              <1> 
   926 00000F99 F8                  <1> 	clc
   927 00000F9A B402                <1> 	mov ah, 2
   928 00000F9C CD1A                <1> 	int 0x1A
   929 00000F9E 7305                <1> 	jnc .read
   930                              <1> 
   931 00000FA0 F8                  <1> 	clc
   932 00000FA1 B402                <1> 	mov ah, 2
   933 00000FA3 CD1A                <1> 	int 0x1A
   934                              <1> 
   935                              <1> .read:
   936 00000FA5 88E8                <1> 	mov al, ch
   937 00000FA7 E8450B              <1> 	call bcd_to_int
   938 00000FAA 89C2                <1> 	mov dx, ax
   939                              <1> 
   940 00000FAC 88E8                <1> 	mov al,	ch
   941 00000FAE C0E804              <1> 	shr al, 4
   942 00000FB1 80E50F              <1> 	and ch, 0x0F
   943 00000FB4 F606[AE03]FF        <1> 	test byte [fmt_12_24], 0x0FF
   944 00000FB9 740A                <1> 	jz .twelve_hr
   945                              <1> 
   946 00000FBB E86900              <1> 	call .add_digit
   947 00000FBE 88E8                <1> 	mov al, ch
   948 00000FC0 E86400              <1> 	call .add_digit
   949 00000FC3 EB2F                <1> 	jmp short .minutes
   950                              <1> 
   951                              <1> .twelve_hr:
   952 00000FC5 83FA00              <1> 	cmp dx, 0
   953 00000FC8 741B                <1> 	je .midnight
   954                              <1> 
   955 00000FCA 83FA0A              <1> 	cmp dx, 10
   956 00000FCD 7C1D                <1> 	jl .twelve_st1
   957                              <1> 
   958 00000FCF 83FA0C              <1> 	cmp dx, 12
   959 00000FD2 7E15                <1> 	jle .twelve_st2
   960                              <1> 
   961 00000FD4 89D0                <1> 	mov ax, dx
   962 00000FD6 83E80C              <1> 	sub ax, 12
   963 00000FD9 B30A                <1> 	mov bl, 10
   964 00000FDB F6F3                <1> 	div bl
   965 00000FDD 88E5                <1> 	mov ch, ah
   966                              <1> 
   967 00000FDF 3C00                <1> 	cmp al, 0
   968 00000FE1 7409                <1> 	je .twelve_st1
   969                              <1> 
   970 00000FE3 EB04                <1> 	jmp short .twelve_st2
   971                              <1> 
   972                              <1> .midnight:
   973 00000FE5 B001                <1> 	mov al, 1
   974 00000FE7 B502                <1> 	mov ch, 2
   975                              <1> 
   976                              <1> .twelve_st2:
   977 00000FE9 E83B00              <1> 	call .add_digit
   978                              <1> .twelve_st1:
   979 00000FEC 88E8                <1> 	mov al, ch
   980 00000FEE E83600              <1> 	call .add_digit
   981                              <1> 
   982 00000FF1 B03A                <1> 	mov al, ':'
   983 00000FF3 AA                  <1> 	stosb
   984                              <1> 
   985                              <1> .minutes:
   986 00000FF4 88C8                <1> 	mov al, cl
   987 00000FF6 C0E804              <1> 	shr al, 4
   988 00000FF9 80E10F              <1> 	and cl, 0x0F
   989 00000FFC E82800              <1> 	call .add_digit
   990 00000FFF 88C8                <1> 	mov al, cl
   991 00001001 E82300              <1> 	call .add_digit
   992                              <1> 
   993 00001004 B020                <1> 	mov al, ' '
   994 00001006 AA                  <1> 	stosb
   995                              <1> 
   996 00001007 BE[2B10]            <1> 	mov si, .hours_string
   997 0000100A F606[AE03]FF        <1> 	test byte [fmt_12_24], 0x0FF
   998 0000100F 750B                <1> 	jnz .copy
   999                              <1> 
  1000 00001011 BE[3410]            <1> 	mov si, .pm_string
  1001 00001014 83FA0C              <1> 	cmp dx, 12
  1002 00001017 7F03                <1> 	jg .copy
  1003                              <1> 
  1004 00001019 BE[3110]            <1> 	mov si, .am_string
  1005                              <1> 
  1006                              <1> .copy:
  1007 0000101C 80C301              <1>     add bl, 1
  1008 0000101F AC                  <1> 	lodsb
  1009 00001020 AA                  <1> 	stosb
  1010 00001021 3C00                <1> 	cmp al, 0
  1011 00001023 75F7                <1> 	jne .copy
  1012                              <1> 
  1013 00001025 61                  <1> 	popa
  1014 00001026 C3                  <1> 	ret
  1015                              <1> 
  1016                              <1> .add_digit:
  1017 00001027 0430                <1> 	add al, '0'
  1018 00001029 AA                  <1> 	stosb
  1019 0000102A C3                  <1> 	ret
  1020                              <1> 
  1021                              <1> 
  1022 0000102B 686F75727300        <1> 	.hours_string	db 'hours', 0
  1023 00001031 414D00              <1> 	.am_string 	db 'AM', 0
  1024 00001034 504D00              <1> 	.pm_string 	db 'PM', 0
  1025                              <1> 
  1026                              <1> 
  1027                              <1> ; ------------------------------------------------------------------
  1028                              <1> ; set_date_fmt -- Set date reporting format (M/D/Y, D/M/Y or Y/M/D - 0, 1, 2)
  1029                              <1> ; IN: AX = format flag, 0-2
  1030                              <1> ; If AX bit 7 = 1 = use name for months
  1031                              <1> ; If AX bit 7 = 0, high byte = separator character
  1032                              <1> 
  1033                              <1> set_date_fmt:
  1034 00001037 60                  <1> 	pusha
  1035 00001038 A880                <1> 	test al, 0x80
  1036 0000103A 7505                <1> 	jnz .fmt_clear
  1037                              <1> 
  1038 0000103C 25037F              <1> 	and ax, 0x7F03
  1039 0000103F EB03                <1> 	jmp short .fmt_test
  1040                              <1> 
  1041                              <1> .fmt_clear:
  1042 00001041 83E003              <1> 	and ax, 0003
  1043                              <1> 
  1044                              <1> .fmt_test:
  1045 00001044 3C03                <1> 	cmp al, 3
  1046 00001046 7303                <1> 	jae .leave
  1047 00001048 A3[AF03]            <1> 	mov [fmt_date], ax
  1048                              <1> 
  1049                              <1> .leave:
  1050 0000104B 61                  <1> 	popa
  1051 0000104C C3                  <1> 	ret
  1052                              <1> 
  1053                              <1> 
  1054                              <1> ; ------------------------------------------------------------------
  1055                              <1> ; get_date_string -- Get current date in a string (eg '12/31/2007')
  1056                              <1> ; OUT: BX = string location
  1057                              <1> 
  1058                              <1> get_date_string:
  1059 0000104D 60                  <1> 	pusha
  1060                              <1> 
  1061 0000104E 89DF                <1> 	mov di, bx
  1062 00001050 8B1E[AF03]          <1> 	mov bx, [fmt_date]
  1063 00001054 81E3037F            <1> 	and bx, 0x7F03
  1064                              <1> 
  1065 00001058 F8                  <1> 	clc
  1066 00001059 B404                <1> 	mov ah, 4
  1067 0000105B CD1A                <1> 	int 0x1A
  1068 0000105D 7305                <1> 	jnc .read
  1069                              <1> 
  1070 0000105F F8                  <1> 	clc
  1071 00001060 B404                <1> 	mov ah, 4
  1072 00001062 CD1A                <1> 	int 0x1A
  1073                              <1> 
  1074                              <1> .read:
  1075 00001064 80FB02              <1> 	cmp bl, 2
  1076 00001067 751C                <1> 	jne .try_fmt1
  1077                              <1> 
  1078 00001069 88EC                <1> 	mov ah, ch
  1079 0000106B E8A000              <1> 	call .add_2digits
  1080 0000106E 88CC                <1> 	mov ah, cl
  1081 00001070 E89B00              <1> 	call .add_2digits
  1082 00001073 B02F                <1> 	mov al, '/'
  1083 00001075 AA                  <1> 	stosb
  1084                              <1> 
  1085 00001076 88F4                <1> 	mov ah, dh
  1086 00001078 E89300              <1> 	call .add_2digits
  1087 0000107B B02F                <1> 	mov al, '/'
  1088 0000107D AA                  <1> 	stosb
  1089                              <1> 
  1090 0000107E 88D4                <1> 	mov ah, dl
  1091 00001080 E88B00              <1> 	call .add_2digits
  1092 00001083 EB71                <1> 	jmp .done
  1093                              <1> 
  1094                              <1> .try_fmt1:
  1095 00001085 80FB01              <1> 	cmp bl, 1
  1096 00001088 7536                <1> 	jne .do_fmt0
  1097                              <1> 
  1098 0000108A 88D4                <1> 	mov ah, dl
  1099 0000108C E86D00              <1> 	call .add_1or2digits
  1100                              <1> 
  1101 0000108F 88F8                <1> 	mov al, bh
  1102 00001091 80FF00              <1> 	cmp bh, 0
  1103 00001094 7502                <1> 	jne .fmt1_day
  1104                              <1> 
  1105 00001096 B020                <1> 	mov al, ' '
  1106                              <1> 
  1107                              <1> .fmt1_day:
  1108 00001098 AA                  <1> 	stosb
  1109                              <1> 
  1110 00001099 88F4                <1> 	mov ah,	dh
  1111 0000109B 80FF00              <1> 	cmp bh, 0
  1112 0000109E 7509                <1> 	jne .fmt1_month
  1113                              <1> 
  1114 000010A0 E87F00              <1> 	call .add_month
  1115 000010A3 B82C20              <1> 	mov ax, ', '
  1116 000010A6 AB                  <1> 	stosw
  1117 000010A7 EB06                <1> 	jmp short .fmt1_century
  1118                              <1> 
  1119                              <1> .fmt1_month:
  1120 000010A9 E85000              <1> 	call .add_1or2digits
  1121 000010AC 88F8                <1> 	mov al, bh
  1122 000010AE AA                  <1> 	stosb
  1123                              <1> 
  1124                              <1> .fmt1_century:
  1125 000010AF 88EC                <1> 	mov ah,	ch
  1126 000010B1 80FC00              <1> 	cmp ah, 0
  1127 000010B4 7403                <1> 	je .fmt1_year
  1128                              <1> 
  1129 000010B6 E84300              <1> 	call .add_1or2digits
  1130                              <1> 
  1131                              <1> .fmt1_year:
  1132 000010B9 88CC                <1> 	mov ah, cl
  1133 000010BB E85000              <1> 	call .add_2digits
  1134                              <1> 
  1135 000010BE EB36                <1> 	jmp .done
  1136                              <1> 
  1137                              <1> .do_fmt0:
  1138 000010C0 88F4                <1> 	mov ah,	dh
  1139 000010C2 80FF00              <1> 	cmp bh, 0
  1140 000010C5 7508                <1> 	jne .fmt0_month
  1141                              <1> 
  1142 000010C7 E85800              <1> 	call .add_month
  1143 000010CA B020                <1> 	mov al, ' '
  1144 000010CC AA                  <1> 	stosb
  1145 000010CD EB06                <1> 	jmp short .fmt0_day
  1146                              <1> 
  1147                              <1> .fmt0_month:
  1148 000010CF E82A00              <1> 	call .add_1or2digits
  1149 000010D2 88F8                <1> 	mov al, bh
  1150 000010D4 AA                  <1> 	stosb
  1151                              <1> 
  1152                              <1> .fmt0_day:
  1153 000010D5 88D4                <1> 	mov ah, dl
  1154 000010D7 E82200              <1> 	call .add_1or2digits
  1155                              <1> 
  1156 000010DA 88F8                <1> 	mov al, bh
  1157 000010DC 80FF00              <1> 	cmp bh, 0
  1158 000010DF 7505                <1> 	jne .fmt0_day2
  1159                              <1> 
  1160 000010E1 B02C                <1> 	mov al, ','
  1161 000010E3 AA                  <1> 	stosb
  1162 000010E4 B020                <1> 	mov al, ' '
  1163                              <1> 
  1164                              <1> .fmt0_day2:
  1165 000010E6 AA                  <1> 	stosb
  1166                              <1> 
  1167                              <1> .fmt0_century:
  1168 000010E7 88EC                <1> 	mov ah,	ch
  1169 000010E9 80FC00              <1> 	cmp ah, 0
  1170 000010EC 7403                <1> 	je .fmt0_year
  1171                              <1> 
  1172 000010EE E80B00              <1> 	call .add_1or2digits
  1173                              <1> 
  1174                              <1> .fmt0_year:
  1175 000010F1 88CC                <1> 	mov ah, cl
  1176 000010F3 E81800              <1> 	call .add_2digits
  1177                              <1> 
  1178                              <1> 
  1179                              <1> .done:
  1180 000010F6 B80000              <1> 	mov ax, 0
  1181 000010F9 AB                  <1> 	stosw
  1182                              <1> 
  1183 000010FA 61                  <1> 	popa
  1184 000010FB C3                  <1> 	ret
  1185                              <1> 
  1186                              <1> 
  1187                              <1> .add_1or2digits:
  1188 000010FC F6C4F0              <1> 	test ah, 0x0F0
  1189 000010FF 7405                <1> 	jz .only_one
  1190 00001101 E80A00              <1> 	call .add_2digits
  1191 00001104 EB07                <1> 	jmp short .two_done
  1192                              <1> .only_one:
  1193 00001106 88E0                <1> 	mov al, ah
  1194 00001108 240F                <1> 	and al, 0x0F
  1195 0000110A E81100              <1> 	call .add_digit
  1196                              <1> .two_done:
  1197 0000110D C3                  <1> 	ret
  1198                              <1> 
  1199                              <1> .add_2digits:
  1200 0000110E 88E0                <1> 	mov al, ah
  1201 00001110 C0E804              <1> 	shr al, 4
  1202 00001113 E80800              <1> 	call .add_digit
  1203 00001116 88E0                <1> 	mov al, ah
  1204 00001118 240F                <1> 	and al, 0x0F
  1205 0000111A E80100              <1> 	call .add_digit
  1206 0000111D C3                  <1> 	ret
  1207                              <1> 
  1208                              <1> .add_digit:
  1209 0000111E 0430                <1> 	add al, '0'
  1210 00001120 AA                  <1> 	stosb
  1211 00001121 C3                  <1> 	ret
  1212                              <1> 
  1213                              <1> .add_month:
  1214 00001122 53                  <1> 	push bx
  1215 00001123 51                  <1> 	push cx
  1216 00001124 88E0                <1> 	mov al, ah
  1217 00001126 E8C609              <1> 	call bcd_to_int
  1218 00001129 FEC8                <1> 	dec al
  1219 0000112B B304                <1> 	mov bl, 4
  1220 0000112D F6E3                <1> 	mul bl
  1221 0000112F BE[4311]            <1> 	mov si, .months
  1222 00001132 01C6                <1> 	add si, ax
  1223 00001134 B90400              <1> 	mov cx, 4
  1224 00001137 F3A4                <1> 	rep movsb
  1225 00001139 807DFF20            <1> 	cmp byte [di-1], ' '
  1226 0000113D 7501                <1> 	jne .done_month
  1227 0000113F 4F                  <1> 	dec di
  1228                              <1> .done_month:
  1229 00001140 59                  <1> 	pop cx
  1230 00001141 5B                  <1> 	pop bx
  1231 00001142 C3                  <1> 	ret
  1232                              <1> 
  1233 00001143 4A616E2E4665622E4D- <1> 	.months db 'Jan.Feb.Mar.Apr.May JuneJulyAug.SeptOct.Nov.Dec.'
  1233 0000114C 61722E4170722E4D61- <1>
  1233 00001155 79204A756E654A756C- <1>
  1233 0000115E 794175672E53657074- <1>
  1233 00001167 4F63742E4E6F762E44- <1>
  1233 00001170 65632E              <1>
  1234                              <1> 
  1235                              <1> ; ------------------------------------------------------------------
  1236                              <1> ; string_tokenize -- Reads tokens separated by specified char from
  1237                              <1> ; a string. Returns pointer to next token, or 0 if none left
  1238                              <1> ; IN: AL = separator char, SI = beginning
  1239                              <1> ; OUT: DI = next token or 0 if none
  1240                              <1> 
  1241                              <1> string_tokenize:
  1242 00001173 56                  <1> 	push si
  1243                              <1> 
  1244                              <1>     .next_char:
  1245 00001174 3804                <1> 	    cmp byte [si], al
  1246 00001176 7408                <1> 	    je .return_token
  1247 00001178 803C00              <1> 	    cmp byte [si], 0
  1248 0000117B 740B                <1> 	    jz .no_more
  1249 0000117D 46                  <1> 	    inc si
  1250 0000117E EBF4                <1> 	    jmp .next_char
  1251                              <1> 
  1252                              <1>     .return_token:
  1253 00001180 C60400              <1> 	    mov byte [si], 0
  1254 00001183 46                  <1> 	    inc si
  1255 00001184 89F7                <1> 	    mov di, si
  1256 00001186 5E                  <1> 	    pop si
  1257 00001187 C3                  <1> 	    ret
  1258                              <1> 
  1259                              <1>     .no_more:
  1260 00001188 BF0000              <1> 	    mov di, 0
  1261 0000118B 5E                  <1> 	    pop si
  1262 0000118C C3                  <1> 	    ret
  1263                              <1> 
  1264                              <1> ; ------------------------------------------------------------------
  1265                              <1> ; string_clear -- Clears a variable
  1266                              <1> ; IN: DI  = variable, AX = length
  1267                              <1> ; OUT: empty variable
  1268                              <1> 
  1269                              <1> string_clear:
  1270 0000118D 60                  <1>     pusha
  1271 0000118E BBFFFF              <1>     mov bx, -1
  1272                              <1>     
  1273                              <1>     .loop:
  1274 00001191 30C0                <1>         xor al, al
  1275 00001193 AA                  <1>         stosb
  1276                              <1>         
  1277 00001194 43                  <1>         inc bx
  1278                              <1> 
  1279 00001195 39D8                <1>         cmp ax, bx
  1280 00001197 75F8                <1>         jne .loop
  1281 00001199 61                  <1>         popa
  1282 0000119A C3                  <1>         ret
  1283                              <1> 
  1284                              <1> ; ==================================================================
   365                                      %include "./includes/screen.asm"
   366                              <1> ; ------------------------------------------------------------------
   367                              <1> ; show_cursor -- Turns on cursor in text mode
   368                              <1> ; IN/OUT: Nothing
   369                              <1> 
   370                              <1> show_cursor:
   371 0000119B 60                  <1> 	pusha
   372                              <1> 
   373 0000119C B506                <1> 	mov ch, 6
   374 0000119E B107                <1> 	mov cl, 7
   375 000011A0 B401                <1> 	mov ah, 1
   376 000011A2 B003                <1> 	mov al, 3
   377 000011A4 CD10                <1> 	int 10h
   378                              <1> 
   379 000011A6 61                  <1> 	popa
   380 000011A7 C3                  <1> 	ret
   381                              <1> 
   382                              <1> ; ------------------------------------------------------------------
   383                              <1> ; change_cursor -- Change the cursors look
   384                              <1> ; IN: CH = 0x00/0x06
   385                              <1> 
   386                              <1> change_cursor:
   387 000011A8 60                  <1> 	pusha
   388                              <1> 
   389 000011A9 B401                <1> 	mov ah, 0x01
   390 000011AB B107                <1> 	mov cl, 0x07
   391 000011AD CD10                <1> 	int 10h
   392                              <1> 
   393 000011AF 61                  <1> 	popa
   394 000011B0 C3                  <1> 	ret
   395                              <1> 
   396                              <1> ; ------------------------------------------------------------------
   397                              <1> ; hide_cursor -- Turns off cursor in text mode
   398                              <1> ; IN/OUT: Nothing
   399                              <1> 
   400                              <1> hide_cursor:
   401 000011B1 60                  <1> 	pusha
   402                              <1> 
   403 000011B2 B520                <1> 	mov ch, 32
   404 000011B4 B401                <1> 	mov ah, 1
   405 000011B6 B003                <1> 	mov al, 3
   406 000011B8 CD10                <1> 	int 10h
   407                              <1> 
   408 000011BA 61                  <1> 	popa
   409 000011BB C3                  <1> 	ret
   410                              <1> 
   411                              <1> ; ------------------------------------------------------------------
   412                              <1> ; move_cursor -- Moves cursor in text mode
   413                              <1> ; IN: DH, DL = row, column
   414                              <1> 
   415                              <1> move_cursor:
   416 000011BC 60                  <1> 	pusha
   417                              <1> 
   418 000011BD B700                <1> 	mov bh, 0
   419 000011BF B402                <1> 	mov ah, 2
   420 000011C1 CD10                <1> 	int 0x10
   421                              <1> 
   422 000011C3 61                  <1> 	popa
   423 000011C4 C3                  <1> 	ret
   424                              <1> 
   425                              <1> ; ------------------------------------------------------------------
   426                              <1> ; get_cursor_pos -- Return position of text cursor
   427                              <1> ; OUT: DH, DL = row, column
   428                              <1> 
   429                              <1> get_cursor_pos:
   430 000011C5 60                  <1> 	pusha
   431                              <1> 
   432 000011C6 B700                <1> 	mov bh, 0
   433 000011C8 B403                <1> 	mov ah, 3
   434 000011CA CD10                <1> 	int 0x10
   435                              <1> 
   436 000011CC 8916[D611]          <1> 	mov [.tmp], dx
   437 000011D0 61                  <1> 	popa
   438 000011D1 8B16[D611]          <1> 	mov dx, [.tmp]
   439 000011D5 C3                  <1> 	ret
   440                              <1> 
   441 000011D6 0000                <1> 	.tmp dw 0
   442                              <1> 
   443                              <1> ; ------------------------------------------------------------------
   444                              <1> ; print_horiz_line -- Draw a horizontal line on the screen
   445                              <1> ; IN: AX = line type (1 for double (=), otherwise single (-))
   446                              <1> 
   447                              <1> print_horiz_line:
   448 000011D8 60                  <1> 	pusha
   449                              <1> 
   450 000011D9 89C1                <1> 	mov cx, ax
   451 000011DB B0C4                <1> 	mov al, 196
   452                              <1> 
   453 000011DD 83F901              <1> 	cmp cx, 1
   454 000011E0 7502                <1> 	jne .ready
   455 000011E2 B0CD                <1> 	mov al, 205
   456                              <1> 
   457                              <1> 	.ready:
   458 000011E4 B90000              <1> 		mov cx, 0
   459 000011E7 B40E                <1> 		mov ah, 0Eh
   460                              <1> 
   461                              <1> 	.restart:
   462 000011E9 CD10                <1> 		int 0x10
   463 000011EB 41                  <1> 		inc cx
   464 000011EC 83F950              <1> 		cmp cx, 80
   465 000011EF 7402                <1> 		je .done
   466 000011F1 EBF6                <1> 		jmp .restart
   467                              <1> 
   468                              <1> 	.done:
   469 000011F3 61                  <1> 		popa
   470 000011F4 C3                  <1> 		ret
   471                              <1> 
   472                              <1> ; ------------------------------------------------------------------
   473                              <1> ; input_dialog -- Get text string from user via a dialog box
   474                              <1> ; IN: AX = string location, BX = message to show
   475                              <1> ; OUT: AX = string location
   476                              <1> 
   477                              <1> input_dialog:
   478 000011F5 60                  <1> 	pusha
   479                              <1> 
   480 000011F6 50                  <1> 	push ax
   481 000011F7 53                  <1> 	push bx
   482                              <1> 
   483                              <1> 
   484 000011F8 B60A                <1> 	mov dh, 10
   485 000011FA B20C                <1> 	mov dl, 12
   486                              <1> 
   487                              <1> .redbox:
   488 000011FC E8BDFF              <1> 	call move_cursor
   489                              <1> 
   490 000011FF 60                  <1> 	pusha
   491 00001200 B409                <1> 	mov ah, 09h
   492 00001202 B700                <1> 	mov bh, 0
   493 00001204 B93700              <1> 	mov cx, 55
   494 00001207 B31F                <1> 	mov bl, 0x1F
   495 00001209 B020                <1> 	mov al, ' '
   496 0000120B CD10                <1> 	int 0x10
   497 0000120D 61                  <1> 	popa
   498                              <1> 
   499 0000120E FEC6                <1> 	inc dh
   500 00001210 80FE10              <1> 	cmp dh, 16
   501 00001213 7402                <1> 	je .boxdone
   502 00001215 EBE5                <1> 	jmp .redbox
   503                              <1> 
   504                              <1> 
   505                              <1> .boxdone:
   506 00001217 B20E                <1> 	mov dl, 14
   507 00001219 B60B                <1> 	mov dh, 11
   508 0000121B E89EFF              <1> 	call move_cursor
   509                              <1> 
   510                              <1> 
   511 0000121E 5B                  <1> 	pop bx
   512 0000121F 89DE                <1> 	mov si, bx
   513 00001221 E8EF08              <1> 	call print
   514                              <1> 
   515 00001224 B20E                <1> 	mov dl, 14
   516 00001226 B60D                <1> 	mov dh, 13
   517 00001228 E891FF              <1> 	call move_cursor
   518                              <1> 
   519                              <1> 
   520 0000122B 58                  <1> 	pop ax
   521 0000122C BB3200              <1> 	mov bx, 50
   522 0000122F E89B01              <1> 	call input_string
   523                              <1> 
   524 00001232 61                  <1> 	popa
   525 00001233 C3                  <1> 	ret
   526                              <1> 
   527                              <1> ; ------------------------------------------------------------------
   528                              <1> ; draw_block -- Render block of specified colour
   529                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   530                              <1> 
   531                              <1> draw_block:
   532 00001234 60                  <1> 	pusha
   533                              <1> 
   534                              <1> .more:
   535 00001235 E884FF              <1> 	call move_cursor		; Move to block starting position
   536                              <1> 
   537 00001238 B409                <1> 	mov ah, 09h			; Draw colour section
   538 0000123A B700                <1> 	mov bh, 0
   539 0000123C 89F1                <1> 	mov cx, si
   540 0000123E B020                <1> 	mov al, ' '
   541 00001240 CD10                <1> 	int 10h
   542                              <1> 
   543 00001242 FEC6                <1> 	inc dh				; Get ready for next line
   544                              <1> 
   545 00001244 B80000              <1> 	mov ax, 0
   546 00001247 88F0                <1> 	mov al, dh			; Get current Y position into DL
   547 00001249 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
   548 0000124B 75E8                <1> 	jne .more			; If not, keep drawing
   549                              <1> 
   550 0000124D 61                  <1> 	popa
   551 0000124E C3                  <1> 	ret
   552                              <1> 
   553                              <1> ; ------------------------------------------------------------------
   554                              <1> ; dialog_box -- Print dialog box in middle of screen, with button(s)
   555                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display)
   556                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
   557                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   558                              <1> ; NOTE: Each string is limited to 40 characters
   559                              <1> 
   560                              <1> dialog_box:
   561 0000124F 60                  <1> 	pusha
   562                              <1> 
   563 00001250 8916[CB13]          <1> 	mov [.tmp], dx
   564                              <1> 
   565 00001254 E85AFF              <1> 	call hide_cursor
   566                              <1> 
   567 00001257 B609                <1> 	mov dh, 9			; First, draw blue background box
   568 00001259 B213                <1> 	mov dl, 19
   569                              <1> 
   570                              <1> .redbox:				; Loop to draw all lines of box
   571 0000125B E85EFF              <1> 	call move_cursor
   572                              <1> 
   573 0000125E 60                  <1> 	pusha
   574 0000125F B409                <1> 	mov ah, 0x09
   575 00001261 B700                <1> 	mov bh, 0
   576 00001263 B92A00              <1> 	mov cx, 42
   577 00001266 B31F                <1> 	mov bl, 0x1F		; White on blue
   578 00001268 B020                <1> 	mov al, ' '
   579 0000126A CD10                <1> 	int 10h
   580 0000126C 61                  <1> 	popa
   581                              <1> 
   582 0000126D FEC6                <1> 	inc dh
   583 0000126F 80FE10              <1> 	cmp dh, 16
   584 00001272 7402                <1> 	je .boxdone
   585 00001274 EBE5                <1> 	jmp .redbox
   586                              <1> 
   587                              <1> 
   588                              <1> .boxdone:
   589 00001276 83F800              <1> 	cmp ax, 0			; Skip string params if zero
   590 00001279 740C                <1> 	je .no_first_string
   591 0000127B B214                <1> 	mov dl, 20
   592 0000127D B60A                <1> 	mov dh, 10
   593 0000127F E83AFF              <1> 	call move_cursor
   594                              <1> 
   595 00001282 89C6                <1> 	mov si, ax			; First string
   596 00001284 E88C08              <1> 	call print
   597                              <1> 
   598                              <1> .no_first_string:
   599 00001287 83FB00              <1> 	cmp bx, 0
   600 0000128A 740C                <1> 	je .no_second_string
   601 0000128C B214                <1> 	mov dl, 20
   602 0000128E B60B                <1> 	mov dh, 11
   603 00001290 E829FF              <1> 	call move_cursor
   604                              <1> 
   605 00001293 89DE                <1> 	mov si, bx			; Second string
   606 00001295 E87B08              <1> 	call print
   607                              <1> 
   608                              <1> .no_second_string:
   609 00001298 83F900              <1> 	cmp cx, 0
   610 0000129B 740C                <1> 	je .no_third_string
   611 0000129D B214                <1> 	mov dl, 20
   612 0000129F B60C                <1> 	mov dh, 12
   613 000012A1 E818FF              <1> 	call move_cursor
   614                              <1> 
   615 000012A4 89CE                <1> 	mov si, cx			; Third string
   616 000012A6 E86A08              <1> 	call print
   617                              <1> 
   618                              <1> .no_third_string:
   619 000012A9 8B16[CB13]          <1> 	mov dx, [.tmp]
   620 000012AD 83FA00              <1> 	cmp dx, 0
   621 000012B0 7405                <1> 	je .one_button
   622 000012B2 83FA01              <1> 	cmp dx, 1
   623 000012B5 741E                <1> 	je .two_button
   624                              <1> 
   625                              <1> 
   626                              <1> .one_button:
   627 000012B7 B3F0                <1> 	mov bl, 11110000b		; Black on white
   628 000012B9 B60E                <1> 	mov dh, 14
   629 000012BB B223                <1> 	mov dl, 35
   630 000012BD BE0800              <1> 	mov si, 8
   631 000012C0 BF0F00              <1> 	mov di, 15
   632 000012C3 E86EFF              <1> 	call draw_block
   633                              <1> 
   634 000012C6 B226                <1> 	mov dl, 38			; OK button, centred at bottom of box
   635 000012C8 B60E                <1> 	mov dh, 14
   636 000012CA E8EFFE              <1> 	call move_cursor
   637 000012CD BE[AB13]            <1> 	mov si, .ok_button_string
   638 000012D0 E84008              <1> 	call print
   639                              <1> 
   640 000012D3 EB2E                <1> 	jmp .one_button_wait
   641                              <1> 
   642                              <1> 
   643                              <1> .two_button:
   644 000012D5 B3F0                <1> 	mov bl, 11110000b		; Black on white
   645 000012D7 B60E                <1> 	mov dh, 14
   646 000012D9 B21B                <1> 	mov dl, 27
   647 000012DB BE0800              <1> 	mov si, 8
   648 000012DE BF0F00              <1> 	mov di, 15
   649 000012E1 E850FF              <1> 	call draw_block
   650                              <1> 
   651 000012E4 B21E                <1> 	mov dl, 30			; OK button
   652 000012E6 B60E                <1> 	mov dh, 14
   653 000012E8 E8D1FE              <1> 	call move_cursor
   654 000012EB BE[AB13]            <1> 	mov si, .ok_button_string
   655 000012EE E82208              <1> 	call print
   656                              <1> 
   657 000012F1 B22C                <1> 	mov dl, 44			; Cancel button
   658 000012F3 B60E                <1> 	mov dh, 14
   659 000012F5 E8C4FE              <1> 	call move_cursor
   660 000012F8 BE[AE13]            <1> 	mov si, .cancel_button_string
   661 000012FB E81508              <1> 	call print
   662                              <1> 
   663 000012FE B90000              <1> 	mov cx, 0			; Default button = 0
   664 00001301 EB0D                <1> 	jmp .two_button_wait
   665                              <1> 
   666                              <1> 
   667                              <1> 
   668                              <1> .one_button_wait:
   669 00001303 B400                <1> 	mov ah, 0x00
   670 00001305 CD16                <1> 	int 0x16
   671                              <1> 
   672 00001307 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
   673 00001309 75F8                <1> 	jne .one_button_wait
   674                              <1> 
   675 0000130B E88DFE              <1> 	call show_cursor
   676                              <1> 
   677 0000130E 61                  <1> 	popa
   678 0000130F C3                  <1> 	ret
   679                              <1> 
   680                              <1> 
   681                              <1> .two_button_wait:
   682 00001310 B400                <1> 	mov ah, 0x00
   683 00001312 CD16                <1> 	int 0x16
   684                              <1> 	
   685 00001314 80FC4B              <1> 	cmp ah, 0x4B			; Left cursor key pressed?
   686 00001317 753D                <1> 	jne .noleft
   687                              <1> 
   688 00001319 B3F0                <1> 	mov bl, 11110000b		; Black on white
   689 0000131B B60E                <1> 	mov dh, 14
   690 0000131D B21B                <1> 	mov dl, 27
   691 0000131F BE0800              <1> 	mov si, 8
   692 00001322 BF0F00              <1> 	mov di, 15
   693 00001325 E80CFF              <1> 	call draw_block
   694                              <1> 
   695 00001328 B21E                <1> 	mov dl, 30				; OK button
   696 0000132A B60E                <1> 	mov dh, 14
   697 0000132C E88DFE              <1> 	call move_cursor
   698 0000132F BE[AB13]            <1> 	mov si, .ok_button_string
   699 00001332 E8DE07              <1> 	call print
   700                              <1> 
   701 00001335 B31F                <1> 	mov bl, 0x1F		; White on blue for cancel button
   702 00001337 B60E                <1> 	mov dh, 14
   703 00001339 B22A                <1> 	mov dl, 42
   704 0000133B BE0900              <1> 	mov si, 9
   705 0000133E BF0F00              <1> 	mov di, 15
   706 00001341 E8F0FE              <1> 	call draw_block
   707                              <1> 
   708 00001344 B22C                <1> 	mov dl, 44				; Cancel button
   709 00001346 B60E                <1> 	mov dh, 14
   710 00001348 E871FE              <1> 	call move_cursor
   711 0000134B BE[AE13]            <1> 	mov si, .cancel_button_string
   712 0000134E E8C207              <1> 	call print
   713                              <1> 
   714 00001351 B90000              <1> 	mov cx, 0				; And update result we'll return
   715 00001354 EBBA                <1> 	jmp .two_button_wait
   716                              <1> 
   717                              <1> 
   718                              <1> .noleft:
   719 00001356 80FC4D              <1> 	cmp ah, 0x4D			; Right cursor key pressed?
   720 00001359 753E                <1> 	jne .noright
   721                              <1> 
   722                              <1> 
   723 0000135B B31F                <1> 	mov bl, 0x1F		; Black on white
   724 0000135D B60E                <1> 	mov dh, 14
   725 0000135F B21B                <1> 	mov dl, 27
   726 00001361 BE0800              <1> 	mov si, 8
   727 00001364 BF0F00              <1> 	mov di, 15
   728 00001367 E8CAFE              <1> 	call draw_block
   729                              <1> 
   730 0000136A B21E                <1> 	mov dl, 30				; OK button
   731 0000136C B60E                <1> 	mov dh, 14
   732 0000136E E84BFE              <1> 	call move_cursor
   733 00001371 BE[AB13]            <1> 	mov si, .ok_button_string
   734 00001374 E89C07              <1> 	call print
   735                              <1> 
   736 00001377 B3F0                <1> 	mov bl, 11110000b		; White on blue for cancel button
   737 00001379 B60E                <1> 	mov dh, 14
   738 0000137B B22B                <1> 	mov dl, 43
   739 0000137D BE0800              <1> 	mov si, 8
   740 00001380 BF0F00              <1> 	mov di, 15
   741 00001383 E8AEFE              <1> 	call draw_block
   742                              <1> 
   743 00001386 B22C                <1> 	mov dl, 44				; Cancel button
   744 00001388 B60E                <1> 	mov dh, 14
   745 0000138A E82FFE              <1> 	call move_cursor
   746 0000138D BE[AE13]            <1> 	mov si, .cancel_button_string
   747 00001390 E88007              <1> 	call print
   748                              <1> 
   749 00001393 B90100              <1> 	mov cx, 1				; And update result we'll return
   750 00001396 E977FF              <1> 	jmp .two_button_wait
   751                              <1> 
   752                              <1> 
   753                              <1> .noright:
   754 00001399 3C0D                <1> 	cmp al, 13				; Wait for enter key (13) to be pressed
   755 0000139B 0F8571FF            <1> 	jne .two_button_wait
   756                              <1> 
   757 0000139F E8F9FD              <1> 	call show_cursor
   758                              <1> 
   759 000013A2 890E[CB13]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
   760 000013A6 61                  <1> 	popa
   761 000013A7 A1[CB13]            <1> 	mov ax, [.tmp]
   762                              <1> 
   763 000013AA C3                  <1> 	ret
   764                              <1> 
   765                              <1> 
   766 000013AB 4F4B00              <1> 	.ok_button_string	db 'OK', 0
   767 000013AE 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
   768 000013B5 2020204F4B20202000  <1> 	.ok_button_noselect	db '   OK   ', 0
   769 000013BE 20202043616E63656C- <1> 	.cancel_button_noselect	db '   Cancel   ', 0
   769 000013C7 20202000            <1>
   770                              <1> 
   771 000013CB 0000                <1> 	.tmp dw 0
   772                              <1> 
   773                              <1> ; ------------------------------------------------------------------
   774                              <1> ; input_string --- Get a string from keyboard input
   775                              <1> ; IN: AX = output address, BX = maximum bytes of output string
   776                              <1> ; OUT: nothing
   777                              <1> 
   778                              <1> input_string:
   779 000013CD 60                  <1> 	pusha
   780                              <1> 
   781                              <1> 	; If the character count is zero, don't do anything.
   782 000013CE 83FB00              <1> 	cmp bx, 0
   783 000013D1 7424                <1> 	je .done
   784                              <1> 
   785 000013D3 89C7                <1> 	mov di, ax			; DI = Current position in buffer
   786                              <1> 	
   787 000013D5 4B                  <1> 	dec bx				; BX = Maximum characters in string
   788 000013D6 89D9                <1> 	mov cx, bx			; CX = Remaining character count
   789                              <1> 
   790                              <1> .get_char:
   791 000013D8 B400                <1> 	mov ah, 0x00
   792 000013DA CD16                <1> 	int 0x16
   793                              <1> 
   794 000013DC 3C08                <1> 	cmp al, 8
   795 000013DE 7419                <1> 	je .backspace
   796                              <1> 
   797 000013E0 3C0D                <1> 	cmp al, 13			; The ENTER key ends the prompt
   798 000013E2 7410                <1> 	je .end_string
   799                              <1> 
   800                              <1> 	; Do not add any characters if the maximum size has been reached.
   801 000013E4 E3F2                <1> 	jcxz .get_char
   802                              <1> 
   803                              <1> 	; Only add printable characters (ASCII Values 32-126)
   804 000013E6 3C20                <1> 	cmp al, ' '
   805 000013E8 72EE                <1> 	jb .get_char
   806                              <1> 
   807 000013EA 3C7E                <1> 	cmp al, 126
   808 000013EC 77EA                <1> 	ja .get_char
   809                              <1> 
   810 000013EE E83100              <1> 	call .add_char
   811                              <1> 
   812 000013F1 49                  <1> 	dec cx
   813 000013F2 EBE4                <1> 	jmp .get_char
   814                              <1> 
   815                              <1> .end_string:
   816 000013F4 B000                <1> 	mov al, 0
   817 000013F6 AA                  <1> 	stosb
   818                              <1> 
   819                              <1> .done:
   820 000013F7 61                  <1> 	popa
   821 000013F8 C3                  <1> 	ret
   822                              <1> 
   823                              <1> .backspace:
   824                              <1> 	; Check if there are any characters to backspace
   825 000013F9 39D9                <1> 	cmp cx, bx 
   826 000013FB 73DB                <1> 	jae .get_char
   827                              <1> 
   828 000013FD 41                  <1> 	inc cx				; Increase characters remaining
   829                              <1> 
   830 000013FE E80A00              <1> 	call .reverse_cursor		; Move back to the previous character
   831 00001401 B020                <1> 	mov al, ' '			; Print a space on the character
   832 00001403 E81C00              <1> 	call .add_char
   833 00001406 E80200              <1> 	call .reverse_cursor		; Now move the cursor back again
   834                              <1> 
   835 00001409 EBCD                <1> 	jmp .get_char
   836                              <1> 
   837                              <1> .reverse_cursor:
   838 0000140B 4F                  <1> 	dec di				; Move the output pointer backwards
   839                              <1> 	
   840 0000140C E8B6FD              <1> 	call get_cursor_pos
   841 0000140F 80FA00              <1> 	cmp dl, 0			; Is the cursor at the start of line?
   842 00001412 7406                <1> 	je .back_line
   843                              <1> 
   844 00001414 FECA                <1> 	dec dl				; If not, just decrease the column
   845 00001416 E8A3FD              <1> 	call move_cursor
   846 00001419 C3                  <1> 	ret
   847                              <1> 
   848                              <1> .back_line:
   849 0000141A FECE                <1> 	dec dh				; Otherwise, move the cursor to the end
   850 0000141C B24F                <1> 	mov dl, 79			; of the previous line.
   851 0000141E E89BFD              <1> 	call move_cursor
   852 00001421 C3                  <1> 	ret
   853                              <1> 
   854                              <1> 
   855                              <1> .add_char:
   856 00001422 AA                  <1> 	stosb
   857 00001423 B40E                <1> 	mov ah, 0x0E			; Teletype Function
   858 00001425 B700                <1> 	mov bh, 0			; Video Page 0
   859 00001427 55                  <1> 	push bp				; Some BIOS's may mess up BP
   860 00001428 CD10                <1> 	int 0x10
   861 0000142A 5D                  <1> 	pop bp
   862 0000142B C3                  <1> 	ret
   863                              <1> 
   864                              <1> ; ------------------------------------------------------------------
   865                              <1> ; switch_mode -- Switch between VIDEO and CLI mode
   866                              <1> ; IN: AX = mode (0 for CLI and 1 for video)
   867                              <1> ;	  BH = color scheme (only background for video)
   868                              <1> ; OUT: Switches mode
   869                              <1> 
   870                              <1> switch_mode:
   871 0000142C 60                  <1> 	pusha
   872 0000142D 30DB                <1> 	xor bl, bl
   873                              <1> 
   874 0000142F 85C0                <1> 	test ax, ax
   875 00001431 7405                <1> 	je .switch_cli
   876                              <1> 
   877 00001433 83F801              <1> 	cmp ax, 1
   878 00001436 740F                <1> 	je .switch_vid
   879                              <1> 
   880                              <1> .switch_cli:
   881                              <1> 	; Switch to text mode
   882 00001438 B80300              <1> 	mov ax, cliRes
   883 0000143B CD10                <1> 	int 0x10
   884                              <1> 
   885                              <1> 	; Change the cursor
   886 0000143D 31C9                <1> 	xor cx, cx
   887 0000143F E866FD              <1> 	call change_cursor
   888                              <1> 
   889                              <1> 	; Clear the screen and change color scheme
   890 00001442 E813F9              <1> 	call cls
   891                              <1> 
   892 00001445 EB0A                <1> 	jmp .done
   893                              <1> 
   894                              <1> .switch_vid:
   895                              <1> 	; Switch to video mode
   896 00001447 B81300              <1> 	mov ax, vidRes
   897 0000144A CD10                <1> 	int 0x10
   898                              <1> 
   899                              <1> 	; Clear the screen and change the background color
   900 0000144C E809F9              <1> 	call cls
   901                              <1> 
   902 0000144F EB00                <1> 	jmp .done
   903                              <1> 
   904                              <1> .done:
   905 00001451 61                  <1> 	popa
   906 00001452 C3                  <1> 	ret
   907                              <1> 
   908                              <1> ; ------------------------------------------------------------------
   909                              <1> ; setup_bottom_string -- Draw a string in the bottom of the setup screen
   910                              <1> ; IN: SI = String location
   911                              <1> 
   912                              <1> setup_bottom_string:
   913 00001453 56                  <1> 	push si
   914 00001454 B617                <1>     mov dh, 23
   915 00001456 30D2                <1>     xor dl, dl
   916 00001458 E861FD              <1>     call move_cursor
   917                              <1> 
   918 0000145B B80100              <1>     mov ax, 1
   919 0000145E E877FD              <1>     call print_horiz_line
   920                              <1> 	
   921 00001461 5E                  <1> 	pop si
   922 00001462 E8AE06              <1>     call print
   923                              <1> 
   924 00001465 31D2                <1>     xor dx, dx
   925 00001467 E852FD              <1>     call move_cursor
   926                              <1> 
   927 0000146A C3                  <1> 	ret
   928                              <1> 
   929                              <1> ; ------------------------------------------------------------------
   930                              <1> ; setup_input -- Get keyboard input for the setup
   931                              <1> ; IN: AX = string location
   932                              <1> ; OUT: AX = string location
   933                              <1> 
   934                              <1> setup_input:
   935 0000146B 60                  <1> 	pusha
   936 0000146C 89C7                <1> 	mov di, ax
   937 0000146E 50                  <1> 	push ax
   938                              <1> 
   939                              <1> 	; Position the mouse
   940 0000146F B403                <1> 	mov ah, 0x03
   941 00001471 B700                <1> 	mov bh, 0
   942 00001473 CD10                <1> 	int 0x10
   943                              <1> 
   944 00001475 B402                <1> 	mov ah, 0x02
   945 00001477 B21B                <1> 	mov dl, 27
   946 00001479 FEC6                <1> 	inc dh
   947 0000147B CD10                <1> 	int 0x10
   948                              <1> 
   949                              <1> 	; And draw the top/sides
   950 0000147D BE[2815]            <1> 	mov si, .top_bar
   951 00001480 E89006              <1> 	call print
   952                              <1> 
   953 00001483 B402                <1> 	mov ah, 0x02
   954 00001485 B21B                <1> 	mov dl, 27
   955 00001487 FEC6                <1> 	inc dh
   956 00001489 CD10                <1> 	int 0x10
   957                              <1> 	
   958 0000148B 8836[6215]          <1> 	mov [.mouse_pos], dh
   959 0000148F BE[4115]            <1> 	mov si, .sidl_bar
   960 00001492 E87E06              <1> 	call print
   961                              <1> 	
   962 00001495 B402                <1> 	mov ah, 0x02
   963 00001497 B21B                <1> 	mov dl, 27
   964 00001499 FEC6                <1> 	inc dh
   965 0000149B CD10                <1> 	int 0x10
   966                              <1> 
   967 0000149D BE[4815]            <1> 	mov si, .bot_bar
   968 000014A0 E87006              <1> 	call print
   969                              <1> 
   970 000014A3 B402                <1> 	mov ah, 0x02
   971 000014A5 B21B                <1> 	mov dl, 27
   972 000014A7 8A36[6215]          <1> 	mov dh, [.mouse_pos]
   973 000014AB CD10                <1> 	int 0x10
   974                              <1> 
   975 000014AD 30DB                <1> 	xor bl, bl
   976                              <1> 
   977                              <1> 	; Clear the string location
   978                              <1> .clear_loop:
   979 000014AF B000                <1> 	mov al, 0
   980 000014B1 AA                  <1> 	stosb
   981 000014B2 FEC3                <1> 	inc bl
   982                              <1> 
   983 000014B4 80FB14              <1> 	cmp bl, 20
   984 000014B7 75F6                <1> 	jne .clear_loop
   985                              <1> 
   986 000014B9 B403                <1> 	mov ah, 0x03
   987 000014BB B700                <1> 	mov bh, 0
   988 000014BD CD10                <1> 	int 0x10
   989                              <1> 
   990 000014BF B402                <1> 	mov ah, 0x02
   991 000014C1 B21D                <1> 	mov dl, 29
   992 000014C3 CD10                <1> 	int 0x10
   993                              <1> 
   994 000014C5 58                  <1> 	pop ax
   995 000014C6 89C7                <1> 	mov di, ax
   996 000014C8 30DB                <1> 	xor bl, bl
   997                              <1> 
   998                              <1> .input_loop:
   999 000014CA B403                <1> 	mov ah, 0x03
  1000 000014CC B700                <1> 	mov bh, 0
  1001 000014CE CD10                <1> 	int 0x10
  1002                              <1> 
  1003 000014D0 8816[6215]          <1> 	mov [.mouse_pos], dl
  1004                              <1> 
  1005 000014D4 B402                <1> 	mov ah, 0x02
  1006 000014D6 B230                <1> 	mov dl, 48
  1007 000014D8 CD10                <1> 	int 0x10
  1008                              <1> 
  1009 000014DA BE[4415]            <1> 	mov si, .sidr_bar
  1010 000014DD E83306              <1> 	call print
  1011                              <1> 
  1012 000014E0 B402                <1> 	mov ah, 0x02
  1013 000014E2 8A16[6215]          <1> 	mov dl, [.mouse_pos]
  1014 000014E6 CD10                <1> 	int 0x10
  1015                              <1> 
  1016 000014E8 B400                <1> 	mov ah, 0x00
  1017 000014EA CD16                <1> 	int 0x16
  1018                              <1> 
  1019 000014EC 3C0D                <1> 	cmp al, 0x0d
  1020 000014EE 7436                <1> 	je .input_done
  1021                              <1> 
  1022 000014F0 3C08                <1> 	cmp al, 0x08
  1023 000014F2 7524                <1> 	jne .not_back
  1024                              <1> 
  1025                              <1> 	; Pressed backspace
  1026 000014F4 B403                <1> 	mov ah, 0x03
  1027 000014F6 B700                <1> 	mov bh, 0
  1028 000014F8 CD10                <1> 	int 0x10
  1029                              <1> 
  1030 000014FA 80FA1D              <1> 	cmp dl, 29
  1031 000014FD 74CB                <1> 	je .input_loop
  1032                              <1> 
  1033 000014FF FECA                <1> 	dec dl
  1034 00001501 FECB                <1> 	dec bl
  1035                              <1> 
  1036 00001503 B402                <1> 	mov ah, 0x02
  1037 00001505 CD10                <1> 	int 0x10
  1038                              <1> 
  1039 00001507 B40E                <1> 	mov ah, 0x0e
  1040 00001509 B000                <1> 	mov al, 0
  1041 0000150B CD10                <1> 	int 0x10
  1042                              <1> 	
  1043 0000150D B402                <1> 	mov ah, 0x02
  1044 0000150F CD10                <1> 	int 0x10
  1045                              <1> 
  1046 00001511 4F                  <1> 	dec di
  1047 00001512 B000                <1> 	mov al, 0
  1048 00001514 AA                  <1> 	stosb
  1049 00001515 4F                  <1> 	dec di
  1050                              <1> 
  1051 00001516 EBB2                <1> 	jmp .input_loop
  1052                              <1> 
  1053                              <1> .not_back:
  1054 00001518 80FB13              <1> 	cmp bl, 19
  1055 0000151B 74AD                <1> 	je .input_loop
  1056 0000151D FEC3                <1> 	inc bl
  1057                              <1> 
  1058 0000151F AA                  <1> 	stosb
  1059                              <1> 
  1060 00001520 B40E                <1> 	mov ah, 0x0e
  1061 00001522 CD10                <1> 	int 0x10
  1062                              <1> 
  1063 00001524 EBA4                <1> 	jmp .input_loop 
  1064                              <1> 
  1065                              <1> .input_done:
  1066 00001526 61                  <1> 	popa
  1067 00001527 C3                  <1> 	ret
  1068                              <1> 
  1069 00001528 DA                  <1> .top_bar:	db 0xda
  1070 00001529 C4<rep 15h>         <1> 			times 21 db 0xc4
  1071 0000153E BF0A00              <1> 			db 0xbf, 0x0a, 0
  1072 00001541 B32000              <1> .sidl_bar:	db 0xb3, 0x20, 0
  1073 00001544 20B30A00            <1> .sidr_bar:	db 0x20, 0xb3, 0x0a, 0
  1074 00001548 C0                  <1> .bot_bar:	db 0xc0
  1075 00001549 C4<rep 15h>         <1> 			times 21 db 0xc4
  1076 0000155E D90A0D00            <1> 			db 0xd9, 0x0a, 0x0d, 0
  1077                              <1> 
  1078 00001562 1D                  <1> .mouse_pos:	db 29
  1079                              <1> 
  1080                              <1> ; ------------------------------------------------------------------
  1081                              <1> ; setup_choose -- Draw text and use the cursors to choose between them
  1082                              <1> ; IN: AX, BX, CX = options
  1083                              <1> ;	  DH = not focused color
  1084                              <1> ;	  DL = focused color
  1085                              <1> ; OUT: AX = options choosen (starting at 0)
  1086                              <1> 
  1087                              <1> setup_choose:
  1088 00001563 E84BFC              <1> 	call hide_cursor
  1089 00001566 60                  <1> 	pusha
  1090 00001567 52                  <1> 	push dx
  1091                              <1> 
  1092 00001568 8A16[9B16]          <1> 	mov dl, [.start_x]
  1093 0000156C 8A36[9C16]          <1> 	mov dh, [.start_y]
  1094 00001570 E849FC              <1> 	call move_cursor
  1095 00001573 5A                  <1> 	pop dx
  1096                              <1> 	
  1097 00001574 89C6                <1> 	mov si, ax
  1098 00001576 BF[9D16]            <1> 	mov di, .option1
  1099 00001579 E87BF8              <1> 	call string_copy
  1100                              <1> 	
  1101 0000157C 89DE                <1> 	mov si, bx
  1102 0000157E BF[C516]            <1> 	mov di, .option2
  1103 00001581 E873F8              <1> 	call string_copy
  1104                              <1> 
  1105 00001584 89CE                <1> 	mov si, cx
  1106 00001586 BF[ED16]            <1> 	mov di, .option3
  1107 00001589 E86BF8              <1> 	call string_copy
  1108                              <1> 
  1109 0000158C 31C9                <1> 	xor cx, cx
  1110 0000158E EB03                <1> 	jmp .choose_loop
  1111                              <1> 
  1112 00001590 E9F700              <1> 	jmp .done
  1113                              <1> 
  1114                              <1> .choose_loop:
  1115 00001593 E84100              <1> 	call .print_options
  1116 00001596 E80B00              <1> 	call .check_arrows
  1117 00001599 E8C800              <1> 	call .clear_bottom
  1118                              <1> 
  1119 0000159C 83F803              <1> 	cmp ax, 3
  1120 0000159F 75F2                <1> 	jne .choose_loop
  1121 000015A1 E9E600              <1> 	jmp .done
  1122                              <1> 
  1123                              <1> .check_arrows:
  1124 000015A4 60                  <1> 	pusha
  1125 000015A5 BE[430D]            <1>     mov si, setup_string
  1126 000015A8 E8A8FE              <1>     call setup_bottom_string
  1127 000015AB 61                  <1> 	popa
  1128                              <1> 
  1129 000015AC 31C0                <1> 	xor ax, ax
  1130 000015AE CD16                <1> 	int 0x16
  1131                              <1> 
  1132 000015B0 80FC48              <1> 	cmp ah, 0x48	; UP
  1133 000015B3 740A                <1> 	je .up
  1134 000015B5 80FC50              <1> 	cmp ah, 0x50	; DOWN
  1135 000015B8 740F                <1> 	je .down
  1136                              <1> 
  1137 000015BA 3C0D                <1> 	cmp al, 0x0D	; ENTER
  1138 000015BC 7415                <1> 	je .enter
  1139                              <1> 
  1140 000015BE C3                  <1> 	ret				; Failsafe return
  1141                              <1> 
  1142                              <1> 	.up:
  1143 000015BF 85C9                <1> 		test cx, cx
  1144 000015C1 7402                <1> 		jz .at_top
  1145                              <1> 
  1146 000015C3 49                  <1> 		dec cx
  1147 000015C4 C3                  <1> 		ret
  1148                              <1> 	
  1149                              <1> 		.at_top:
  1150 000015C5 B90200              <1> 			mov cx, 2
  1151 000015C8 C3                  <1> 			ret
  1152                              <1> 	
  1153                              <1> 	.down:
  1154 000015C9 83F902              <1> 		cmp cx, 2
  1155 000015CC 7402                <1> 		je .at_bottom
  1156                              <1> 
  1157 000015CE 41                  <1> 		inc cx
  1158 000015CF C3                  <1> 		ret
  1159                              <1> 
  1160                              <1> 		.at_bottom:
  1161 000015D0 31C9                <1> 			xor cx, cx
  1162 000015D2 C3                  <1> 			ret
  1163                              <1> 
  1164                              <1> 	.enter:
  1165 000015D3 B80300              <1> 		mov ax, 3
  1166 000015D6 C3                  <1> 		ret
  1167                              <1> 
  1168                              <1> .print_options:
  1169 000015D7 83F900              <1> 	cmp cx, 0
  1170 000015DA 740A                <1> 	je .mark_1
  1171                              <1> 
  1172 000015DC 83F901              <1> 	cmp cx, 1
  1173 000015DF 7419                <1> 	je .mark_2
  1174                              <1> 
  1175 000015E1 83F902              <1> 	cmp cx, 2
  1176 000015E4 7428                <1> 	je .mark_3
  1177                              <1> 
  1178                              <1> 	.mark_1:
  1179 000015E6 BE[9D16]            <1> 		mov si, .option1
  1180 000015E9 E83F00              <1> 		call .print_marked
  1181                              <1> 
  1182 000015EC BE[C516]            <1> 		mov si, .option2
  1183 000015EF E82F00              <1> 		call .print_normal
  1184                              <1> 
  1185 000015F2 BE[ED16]            <1> 		mov si, .option3
  1186 000015F5 E82900              <1> 		call .print_normal
  1187                              <1> 
  1188 000015F8 EB26                <1> 		jmp .mark_done
  1189                              <1> 	
  1190                              <1> 	.mark_2:
  1191 000015FA BE[9D16]            <1> 		mov si, .option1
  1192 000015FD E82100              <1> 		call .print_normal
  1193                              <1> 
  1194 00001600 BE[C516]            <1> 		mov si, .option2
  1195 00001603 E82500              <1> 		call .print_marked
  1196                              <1> 
  1197 00001606 BE[ED16]            <1> 		mov si, .option3
  1198 00001609 E81500              <1> 		call .print_normal
  1199                              <1> 
  1200 0000160C EB12                <1> 		jmp .mark_done
  1201                              <1> 	
  1202                              <1> 	.mark_3:
  1203 0000160E BE[9D16]            <1> 		mov si, .option1
  1204 00001611 E80D00              <1> 		call .print_normal
  1205                              <1> 
  1206 00001614 BE[C516]            <1> 		mov si, .option2
  1207 00001617 E80700              <1> 		call .print_normal
  1208                              <1> 
  1209 0000161A BE[ED16]            <1> 		mov si, .option3
  1210 0000161D E80B00              <1> 		call .print_marked
  1211                              <1> 
  1212                              <1> 	.mark_done:
  1213 00001620 C3                  <1> 		ret
  1214                              <1> 
  1215                              <1> .print_normal:
  1216 00001621 E81700              <1> 	call .print_space
  1217 00001624 E8EC04              <1> 	call print
  1218 00001627 E82D00              <1> 	call .new_line
  1219                              <1> 
  1220 0000162A C3                  <1> 	ret
  1221                              <1> 
  1222                              <1> .print_marked:
  1223 0000162B 53                  <1> 	push bx
  1224                              <1> 
  1225 0000162C E80C00              <1> 	call .print_space
  1226 0000162F 31DB                <1> 	xor bx, bx
  1227 00001631 88D3                <1> 	mov bl, dl
  1228 00001633 E81605              <1> 	call print_atr
  1229 00001636 E81E00              <1> 	call .new_line
  1230                              <1> 
  1231 00001639 5B                  <1> 	pop bx
  1232 0000163A C3                  <1> 	ret
  1233                              <1> 
  1234                              <1> .print_space:
  1235 0000163B 53                  <1> 	push bx
  1236                              <1> 
  1237 0000163C 31DB                <1> 	xor bx, bx
  1238 0000163E BB2800              <1> 	mov bx, .screen_mid
  1239                              <1> 	
  1240 00001641 89F0                <1> 	mov ax, si
  1241 00001643 E828F7              <1> 	call string_length
  1242 00001646 D1F8                <1> 	sar ax, 1
  1243                              <1> 
  1244 00001648 29C3                <1> 	sub bx, ax
  1245                              <1> 
  1246                              <1> 	.space_loop:
  1247 0000164A B40E                <1> 		mov ah, 0x0e
  1248 0000164C B020                <1> 		mov al, ' '
  1249 0000164E CD10                <1> 		int 0x10
  1250                              <1> 
  1251 00001650 4B                  <1> 		dec bx
  1252 00001651 85DB                <1> 		test bx, bx
  1253 00001653 75F5                <1> 		jnz .space_loop
  1254                              <1> 
  1255 00001655 5B                  <1> 	pop bx
  1256 00001656 C3                  <1> 	ret
  1257                              <1> 
  1258                              <1> .new_line:
  1259 00001657 50                  <1> 	push ax
  1260                              <1> 
  1261 00001658 B80A0E              <1> 	mov ax, 0x0E0A
  1262 0000165B CD10                <1> 	int 0x10
  1263 0000165D B80D0E              <1> 	mov ax, 0x0E0D
  1264 00001660 CD10                <1> 	int 0x10
  1265                              <1> 
  1266 00001662 58                  <1> 	pop ax
  1267 00001663 C3                  <1> 	ret
  1268                              <1> 
  1269                              <1> .clear_bottom:
  1270 00001664 60                  <1> 	pusha
  1271                              <1> 
  1272 00001665 8A36[9C16]          <1> 	mov dh, [.start_y]
  1273 00001669 8A16[9B16]          <1> 	mov dl, [.start_x]
  1274 0000166D E84CFB              <1> 	call move_cursor
  1275                              <1> 
  1276 00001670 B80A07              <1> 	mov ax, 0x070A
  1277 00001673 B71F                <1> 	mov bh, 0x1F
  1278 00001675 31C9                <1> 	xor cx, cx
  1279 00001677 BA4F18              <1> 	mov dx, 0x184f
  1280 0000167A CD10                <1> 	int 0x10
  1281                              <1> 	
  1282 0000167C B80A06              <1> 	mov ax, 0x060A
  1283 0000167F B71F                <1> 	mov bh, 0x1F
  1284 00001681 31C9                <1> 	xor cx, cx
  1285 00001683 BA4F18              <1> 	mov dx, 0x184f
  1286 00001686 CD10                <1> 	int 0x10
  1287                              <1> 
  1288 00001688 61                  <1> 	popa
  1289 00001689 C3                  <1> 	ret
  1290                              <1> 
  1291                              <1> .done:
  1292 0000168A E8D7FF              <1> 	call .clear_bottom
  1293 0000168D 890E[1517]          <1> 	mov [.option_picked], cx
  1294                              <1> 
  1295 00001691 61                  <1> 	popa
  1296 00001692 E806FB              <1> 	call show_cursor
  1297                              <1> 
  1298 00001695 0FB606[1517]        <1> 	movzx ax, [.option_picked]
  1299 0000169A C3                  <1> 	ret
  1300                              <1> 
  1301                              <1> .screen_mid		equ 40
  1302 0000169B 00                  <1> .start_x:		db 0
  1303 0000169C 12                  <1> .start_y:		db 18
  1304                              <1> 
  1305 0000169D 00<rep 28h>         <1> .option1:		times 40 db 0
  1306 000016C5 00<rep 28h>         <1> .option2:		times 40 db 0
  1307 000016ED 00<rep 28h>         <1> .option3:		times 40 db 0
  1308                              <1> 
  1309 00001715 00                  <1> .option_picked:	db 0
  1310                              <1> 
  1311                              <1> ; ------------------------------------------------------------------
  1312                              <1> ; draw_setup_box -- Draw a text box for the setup
  1313                              <1> ; IN: SI = location of the string
  1314                              <1> ; OUT: prints a box that's meant for the setup
  1315                              <1> 
  1316                              <1> draw_setup_box:
  1317 00001716 60                  <1> 	pusha
  1318 00001717 30DB                <1> 	xor bl, bl
  1319                              <1> 
  1320 00001719 31D2                <1> 	xor dx, dx
  1321 0000171B E89EFA              <1> 	call move_cursor
  1322                              <1> 
  1323 0000171E 56                  <1> 	push si
  1324 0000171F BE[8217]            <1> 	mov si, .setbox_top
  1325 00001722 E8EE03              <1> 	call print
  1326                              <1> 
  1327 00001725 BE[0D18]            <1> 	mov si, .setbox_nwl
  1328 00001728 E8E803              <1> 	call print
  1329                              <1> 
  1330 0000172B 5E                  <1> 	pop si
  1331                              <1> 
  1332                              <1> .print_loop:
  1333 0000172C AC                  <1> 	lodsb
  1334 0000172D 84C0                <1> 	test al, al
  1335 0000172F 7446                <1> 	je .done
  1336                              <1> 
  1337 00001731 3C0A                <1> 	cmp al, 0x0a
  1338 00001733 740D                <1> 	je .new_line
  1339                              <1> 
  1340 00001735 80FB30              <1> 	cmp bl, 48
  1341 00001738 7408                <1> 	je .new_line
  1342                              <1> 
  1343 0000173A B40E                <1> 	mov ah, 0x0e
  1344 0000173C CD10                <1> 	int 0x10
  1345                              <1> 	
  1346 0000173E FEC3                <1> 	inc bl
  1347                              <1> 
  1348 00001740 EBEA                <1> 	jmp .print_loop
  1349                              <1> 
  1350                              <1> .new_line:
  1351 00001742 E80A00              <1> 	call .finish_line
  1352                              <1> 
  1353 00001745 56                  <1> 	push si
  1354 00001746 BE[0D18]            <1> 	mov si, .setbox_nwl
  1355 00001749 E8C703              <1> 	call print
  1356 0000174C 5E                  <1> 	pop si
  1357                              <1> 
  1358 0000174D EBDD                <1> 	jmp .print_loop
  1359                              <1> 
  1360                              <1> .finish_line:
  1361 0000174F B730                <1> 	mov bh, border_length-2
  1362 00001751 28DF                <1> 	sub bh, bl
  1363                              <1> 
  1364                              <1> .finish_loop:
  1365 00001753 80FF00              <1> 	cmp bh, 0
  1366 00001756 760A                <1> 	jbe .loop_done
  1367                              <1> 
  1368 00001758 B40E                <1> 	mov ah, 0x0e
  1369 0000175A B020                <1> 	mov al, " "
  1370 0000175C CD10                <1> 	int 0x10
  1371 0000175E FECF                <1> 	dec bh
  1372                              <1> 
  1373 00001760 EBF1                <1> 	jmp .finish_loop
  1374                              <1> 
  1375                              <1> .loop_done:
  1376 00001762 56                  <1> 	push si
  1377 00001763 BE[1E18]            <1> 	mov si, .setbox_fnl
  1378 00001766 E8AA03              <1> 	call print
  1379 00001769 5E                  <1> 	pop si
  1380 0000176A 31DB                <1> 	xor bx, bx
  1381                              <1> 
  1382 0000176C B80A0E              <1> 	mov ax, 0x0e0a
  1383 0000176F CD10                <1> 	int 0x10
  1384                              <1> 
  1385 00001771 B80D0E              <1> 	mov ax, 0x0e0d
  1386 00001774 CD10                <1> 	int 0x10
  1387                              <1> 	
  1388 00001776 C3                  <1> 	ret
  1389                              <1> 
  1390                              <1> .done:
  1391 00001777 E8D5FF              <1> 	call .finish_line
  1392                              <1> 
  1393 0000177A BE[C817]            <1> 	mov si, .setbox_bot
  1394 0000177D E89303              <1> 	call print
  1395                              <1> 
  1396 00001780 61                  <1> 	popa
  1397 00001781 C3                  <1> 	ret
  1398                              <1> 	
  1399                              <1> 
  1400 00001782 0A                  <1> .setbox_top:	db 0x0a
  1401 00001783 20<rep Eh>          <1>         		times edge_width db " "
  1402 00001791 DA                  <1>                 db 0xDA
  1403 00001792 C4<rep 32h>         <1>                 times border_length db 0xC4
  1404 000017C4 BF0A0D00            <1>                 db 0xBF, 0x0a, 0x0d, 0
  1405                              <1> 
  1406 000017C8 20<rep Eh>          <1> .setbox_bot:	times edge_width db " "
  1407 000017D6 C0                  <1>                 db 0xC0
  1408 000017D7 C4<rep 32h>         <1>                 times border_length db 0xC4
  1409 00001809 D90A0D00            <1>                 db 0xD9, 0x0a, 0x0d, 0
  1410                              <1> 
  1411 0000180D 20<rep Eh>          <1> .setbox_nwl:	times edge_width db " "
  1412 0000181B B32000              <1> 				db 0xB3, " ", 0
  1413                              <1> 
  1414 0000181E 20B300              <1> .setbox_fnl:	db " ", 0xB3, 0
  1415                              <1> 
  1416                              <1> ; ------------------------------------------------------------------
  1417                              <1> ; draw_box -- Draw a box
  1418                              <1> ; IN: AL = color
  1419                              <1> ;	  BX = end x position
  1420                              <1> ;	  CX = end y position
  1421                              <1> ;	  DH = start x position
  1422                              <1> ;	  DL = start y position
  1423                              <1> ; OUT: Draws box
  1424                              <1> 
  1425                              <1> draw_box:
  1426 00001821 60                  <1> 	pusha
  1427                              <1> 
  1428 00001822 8836[5A18]          <1> 	mov [.startx], dh
  1429 00001826 8816[5C18]          <1> 	mov [.starty], dl
  1430 0000182A 891E[5E18]          <1> 	mov [.endx], bx
  1431 0000182E 890E[6018]          <1> 	mov [.endy], cx
  1432                              <1> 
  1433 00001832 8B0E[5A18]          <1> 	mov cx, [.startx]
  1434 00001836 8B16[5C18]          <1> 	mov dx, [.starty]
  1435 0000183A B40C                <1> 	mov ah, 0x0C
  1436                              <1> 
  1437                              <1> 	.x_loop:
  1438 0000183C 3B0E[5E18]          <1> 		cmp cx, [.endx]
  1439 00001840 7405                <1> 		je .y_loop
  1440                              <1> 
  1441 00001842 CD10                <1> 		int 0x10
  1442                              <1> 
  1443 00001844 41                  <1> 		inc cx
  1444 00001845 EBF5                <1> 		jmp .x_loop
  1445                              <1> 
  1446                              <1> 	.y_loop:
  1447 00001847 CD10                <1> 		int 0x10
  1448                              <1> 
  1449 00001849 3B16[6018]          <1> 		cmp dx, [.endy]
  1450 0000184D 7407                <1> 		je .done
  1451                              <1> 
  1452 0000184F 8B0E[5A18]          <1> 		mov cx, [.startx]
  1453 00001853 42                  <1> 		inc dx
  1454 00001854 EBE6                <1> 		jmp .x_loop
  1455                              <1> 	
  1456                              <1> 	.done:
  1457 00001856 61                  <1> 		popa
  1458 00001857 C3                  <1> 		ret
  1459                              <1> 
  1460 00001858 0000                <1> 	.tmp:    dw 0
  1461 0000185A 0000                <1> 	.startx: dw 0
  1462 0000185C 0000                <1> 	.starty: dw 0
  1463 0000185E 0000                <1> 	.endx:   dw 0
  1464 00001860 0000                <1> 	.endy:	 dw 0
  1465                              <1> 
  1466                              <1> ; ------------------------------------------------------------------
  1467                              <1> ; list_dialog -- Show a dialog with a list of options
  1468                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1469                              <1> ;     BX = first help string, CX = second help string
  1470                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1471                              <1> 
  1472                              <1> list_dialog:
  1473 00001862 60                  <1> 	pusha
  1474                              <1> 
  1475 00001863 50                  <1> 	push ax				; Store string list for now
  1476                              <1> 
  1477 00001864 51                  <1> 	push cx				; And help strings
  1478 00001865 53                  <1> 	push bx
  1479                              <1> 
  1480 00001866 E848F9              <1> 	call hide_cursor
  1481                              <1> 
  1482                              <1> 
  1483 00001869 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1484 0000186B 89C6                <1> 	mov si, ax
  1485                              <1> .count_loop:
  1486 0000186D AC                  <1> 	lodsb
  1487 0000186E 3C00                <1> 	cmp al, 0
  1488 00001870 7408                <1> 	je .done_count
  1489 00001872 3C2C                <1> 	cmp al, ','
  1490 00001874 75F7                <1> 	jne .count_loop
  1491 00001876 FEC1                <1> 	inc cl
  1492 00001878 EBF3                <1> 	jmp .count_loop
  1493                              <1> 
  1494                              <1> .done_count:
  1495 0000187A FEC1                <1> 	inc cl
  1496 0000187C 880E[D519]          <1> 	mov byte [.num_of_entries], cl
  1497                              <1> 
  1498 00001880 B39F                <1> 	mov bl, 0x9F		; White on light blue
  1499 00001882 B20F                <1> 	mov dl, 15			; Start X position
  1500 00001884 B602                <1> 	mov dh, 2			; Start Y position
  1501 00001886 BE3200              <1> 	mov si, 50			; Width
  1502 00001889 BF1700              <1> 	mov di, 23			; Finish Y position
  1503 0000188C E8A5F9              <1> 	call draw_block		; Draw option selector window
  1504                              <1> 
  1505 0000188F B210                <1> 	mov dl, 16			; Show first line of help text...
  1506 00001891 B603                <1> 	mov dh, 3
  1507 00001893 E826F9              <1> 	call move_cursor
  1508                              <1> 
  1509 00001896 5E                  <1> 	pop si				; Get back first string
  1510 00001897 E87902              <1> 	call print
  1511                              <1> 
  1512 0000189A FEC6                <1> 	inc dh				; ...and the second
  1513 0000189C E81DF9              <1> 	call move_cursor
  1514                              <1> 
  1515 0000189F 5E                  <1> 	pop si
  1516 000018A0 E87002              <1> 	call print
  1517                              <1> 
  1518                              <1> 
  1519 000018A3 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1520 000018A4 8936[D719]          <1> 	mov word [.list_string], si
  1521                              <1> 
  1522                              <1> 
  1523                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1524                              <1> 	; entry and let the user move up and down using the cursor keys
  1525                              <1> 
  1526 000018A8 C606[D619]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1527                              <1> 
  1528 000018AD B214                <1> 	mov dl, 20			; Set up starting position for selector
  1529 000018AF B607                <1> 	mov dh, 7
  1530                              <1> 
  1531 000018B1 E808F9              <1> 	call move_cursor
  1532                              <1> 
  1533                              <1> .more_select:
  1534 000018B4 60                  <1> 	pusha
  1535 000018B5 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1536 000018B7 B210                <1> 	mov dl, 16
  1537 000018B9 B606                <1> 	mov dh, 6
  1538 000018BB BE3000              <1> 	mov si, 48
  1539 000018BE BF1600              <1> 	mov di, 22
  1540 000018C1 E870F9              <1> 	call draw_block
  1541 000018C4 61                  <1> 	popa
  1542                              <1> 
  1543 000018C5 E8E100              <1> 	call .draw_black_bar
  1544                              <1> 
  1545 000018C8 8B36[D719]          <1> 	mov word si, [.list_string]
  1546 000018CC E89A00              <1> 	call .draw_list
  1547                              <1> 
  1548                              <1> .another_key:
  1549 000018CF B400                <1> 	mov ah, 0x00
  1550 000018D1 CD16                <1> 	int 0x16
  1551                              <1> 
  1552 000018D3 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1553 000018D6 740F                <1> 	je .go_up
  1554 000018D8 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1555 000018DB 741B                <1> 	je .go_down
  1556 000018DD 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1557 000018DF 7468                <1> 	je .option_selected
  1558 000018E1 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1559 000018E3 747E                <1> 	je .esc_pressed
  1560 000018E5 EBCD                <1> 	jmp .more_select		; If not, wait for another key
  1561                              <1> 
  1562                              <1> 
  1563                              <1> .go_up:
  1564 000018E7 80FE07              <1> 	cmp dh, 7			; Already at top?
  1565 000018EA 7E32                <1> 	jle .hit_top
  1566                              <1> 
  1567 000018EC E8CF00              <1> 	call .draw_white_bar
  1568                              <1> 
  1569 000018EF B219                <1> 	mov dl, 25
  1570 000018F1 E8C8F8              <1> 	call move_cursor
  1571                              <1> 
  1572 000018F4 FECE                <1> 	dec dh				; Row to select (increasing down)
  1573 000018F6 EBBC                <1> 	jmp .more_select
  1574                              <1> 
  1575                              <1> 
  1576                              <1> .go_down:				; Already at bottom of list?
  1577 000018F8 80FE14              <1> 	cmp dh, 20
  1578 000018FB 7430                <1> 	je .hit_bottom
  1579                              <1> 
  1580 000018FD B90000              <1> 	mov cx, 0
  1581 00001900 88F1                <1> 	mov byte cl, dh
  1582                              <1> 
  1583 00001902 80E907              <1> 	sub cl, 7
  1584 00001905 FEC1                <1> 	inc cl
  1585 00001907 020E[D619]          <1> 	add byte cl, [.skip_num]
  1586                              <1> 
  1587 0000190B A0[D519]            <1> 	mov byte al, [.num_of_entries]
  1588 0000190E 38C1                <1> 	cmp cl, al
  1589 00001910 74BD                <1> 	je .another_key
  1590                              <1> 
  1591 00001912 E8A900              <1> 	call .draw_white_bar
  1592                              <1> 
  1593 00001915 B219                <1> 	mov dl, 25
  1594 00001917 E8A2F8              <1> 	call move_cursor
  1595                              <1> 
  1596 0000191A FEC6                <1> 	inc dh
  1597 0000191C EB96                <1> 	jmp .more_select
  1598                              <1> 
  1599                              <1> 
  1600                              <1> .hit_top:
  1601 0000191E 8A0E[D619]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1602 00001922 80F900              <1> 	cmp cl, 0
  1603 00001925 74A8                <1> 	je .another_key			; If not, wait for another key
  1604                              <1> 
  1605 00001927 FE0E[D619]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1606 0000192B EB87                <1> 	jmp .more_select
  1607                              <1> 
  1608                              <1> 
  1609                              <1> .hit_bottom:				; See if there's more to scroll
  1610 0000192D B90000              <1> 	mov cx, 0
  1611 00001930 88F1                <1> 	mov byte cl, dh
  1612                              <1> 
  1613 00001932 80E907              <1> 	sub cl, 7
  1614 00001935 FEC1                <1> 	inc cl
  1615 00001937 020E[D619]          <1> 	add byte cl, [.skip_num]
  1616                              <1> 
  1617 0000193B A0[D519]            <1> 	mov byte al, [.num_of_entries]
  1618 0000193E 38C1                <1> 	cmp cl, al
  1619 00001940 748D                <1> 	je .another_key
  1620                              <1> 
  1621 00001942 FE06[D619]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1622 00001946 E96BFF              <1> 	jmp .more_select
  1623                              <1> 
  1624                              <1> 
  1625                              <1> 
  1626                              <1> .option_selected:
  1627 00001949 E84FF8              <1> 	call show_cursor
  1628                              <1> 
  1629 0000194C 80EE07              <1> 	sub dh, 7
  1630                              <1> 
  1631 0000194F B80000              <1> 	mov ax, 0
  1632 00001952 88F0                <1> 	mov al, dh
  1633                              <1> 
  1634 00001954 FEC0                <1> 	inc al				; Options start from 1
  1635 00001956 0206[D619]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1636                              <1> 
  1637 0000195A A3[D319]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1638                              <1> 
  1639 0000195D 61                  <1> 	popa
  1640                              <1> 
  1641 0000195E A1[D319]            <1> 	mov word ax, [.tmp]
  1642 00001961 F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1643 00001962 C3                  <1> 	ret
  1644                              <1> 
  1645                              <1> 
  1646                              <1> 
  1647                              <1> .esc_pressed:
  1648 00001963 E835F8              <1> 	call show_cursor
  1649 00001966 61                  <1> 	popa
  1650 00001967 F9                  <1> 	stc				; Set carry for Esc
  1651 00001968 C3                  <1> 	ret
  1652                              <1> 
  1653                              <1> 
  1654                              <1> 
  1655                              <1> .draw_list:
  1656 00001969 60                  <1> 	pusha
  1657                              <1> 
  1658 0000196A B212                <1> 	mov dl, 18			; Get into position for option list text
  1659 0000196C B607                <1> 	mov dh, 7
  1660 0000196E E84BF8              <1> 	call move_cursor
  1661                              <1> 
  1662                              <1> 
  1663 00001971 B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  1664 00001974 8A0E[D619]          <1> 	mov byte cl, [.skip_num]
  1665                              <1> 
  1666                              <1> .skip_loop:
  1667 00001978 83F900              <1> 	cmp cx, 0
  1668 0000197B 7408                <1> 	je .skip_loop_finished
  1669                              <1> .more_lodsb:
  1670 0000197D AC                  <1> 	lodsb
  1671 0000197E 3C2C                <1> 	cmp al, ','
  1672 00001980 75FB                <1> 	jne .more_lodsb
  1673 00001982 49                  <1> 	dec cx
  1674 00001983 EBF3                <1> 	jmp .skip_loop
  1675                              <1> 
  1676                              <1> 
  1677                              <1> .skip_loop_finished:
  1678 00001985 BB0000              <1> 	mov bx, 0			; Counter for total number of options
  1679                              <1> 
  1680                              <1> 
  1681                              <1> .more:
  1682 00001988 AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  1683                              <1> 
  1684 00001989 3C00                <1> 	cmp al, 0			; End of string?
  1685 0000198B 7417                <1> 	je .done_list
  1686                              <1> 
  1687 0000198D 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1688 0000198F 7406                <1> 	je .newline
  1689                              <1> 
  1690 00001991 B40E                <1> 	mov ah, 0Eh
  1691 00001993 CD10                <1> 	int 10h
  1692 00001995 EBF1                <1> 	jmp .more
  1693                              <1> 
  1694                              <1> .newline:
  1695 00001997 B212                <1> 	mov dl, 18			; Go back to starting X position
  1696 00001999 FEC6                <1> 	inc dh				; But jump down a line
  1697 0000199B E81EF8              <1> 	call move_cursor
  1698                              <1> 
  1699 0000199E 43                  <1> 	inc bx				; Update the number-of-options counter
  1700 0000199F 83FB0E              <1> 	cmp bx, 14			; Limit to one screen of options
  1701 000019A2 7CE4                <1> 	jl .more
  1702                              <1> 
  1703                              <1> .done_list:
  1704 000019A4 61                  <1> 	popa
  1705 000019A5 E814F8              <1> 	call move_cursor
  1706                              <1> 
  1707 000019A8 C3                  <1> 	ret
  1708                              <1> 
  1709                              <1> 
  1710                              <1> 
  1711                              <1> .draw_black_bar:
  1712 000019A9 60                  <1> 	pusha
  1713                              <1> 
  1714 000019AA B211                <1> 	mov dl, 17
  1715 000019AC E80DF8              <1> 	call move_cursor
  1716                              <1> 
  1717 000019AF B409                <1> 	mov ah, 09h			; Draw white bar at top
  1718 000019B1 B700                <1> 	mov bh, 0
  1719 000019B3 B92E00              <1> 	mov cx, 46
  1720 000019B6 B30F                <1> 	mov bl, 00001111b		; White text on black background
  1721 000019B8 B020                <1> 	mov al, ' '
  1722 000019BA CD10                <1> 	int 10h
  1723                              <1> 
  1724 000019BC 61                  <1> 	popa
  1725 000019BD C3                  <1> 	ret
  1726                              <1> 
  1727                              <1> 
  1728                              <1> 
  1729                              <1> .draw_white_bar:
  1730 000019BE 60                  <1> 	pusha
  1731                              <1> 
  1732 000019BF B211                <1> 	mov dl, 17
  1733 000019C1 E8F8F7              <1> 	call move_cursor
  1734                              <1> 
  1735 000019C4 B409                <1> 	mov ah, 09h			; Draw white bar at top
  1736 000019C6 B700                <1> 	mov bh, 0
  1737 000019C8 B92E00              <1> 	mov cx, 46
  1738 000019CB B3F0                <1> 	mov bl, 11110000b		; Black text on white background
  1739 000019CD B020                <1> 	mov al, ' '
  1740 000019CF CD10                <1> 	int 10h
  1741                              <1> 
  1742 000019D1 61                  <1> 	popa
  1743 000019D2 C3                  <1> 	ret
  1744                              <1> 
  1745                              <1> 
  1746 000019D3 0000                <1> 	.tmp			dw 0
  1747 000019D5 00                  <1> 	.num_of_entries		db 0
  1748 000019D6 00                  <1> 	.skip_num		db 0
  1749 000019D7 0000                <1> 	.list_string		dw 0
   366                                      %include "./includes/misc.asm"
   367                              <1> ; get_api_version -- Return current version of KronkOS API
   368                              <1> ; OUT: AL = API version number
   369                              <1> 
   370                              <1> get_api_version:
   371 000019D9 B004                <1> 	mov al, KRONKOS_API
   372 000019DB C3                  <1> 	ret
   373                              <1> 
   374                              <1> ; ------------------------------------------------------------------
   375                              <1> ; clear_regs -- Clear all the registers
   376                              <1> 
   377                              <1> clear_regs:
   378 000019DC 31C0                <1> 	xor ax, ax
   379 000019DE 31DB                <1> 	xor bx, bx
   380 000019E0 31C9                <1> 	xor cx, cx
   381 000019E2 31D2                <1> 	xor dx, dx
   382 000019E4 31F6                <1> 	xor si, si
   383 000019E6 31FF                <1> 	xor di, di
   384                              <1> 	
   385 000019E8 C3                  <1> 	ret
   386                              <1> 
   387                              <1> ; ------------------------------------------------------------------
   388                              <1> ; fatal_error -- Display error message and halt execution
   389                              <1> ; IN: AX = error message string location
   390                              <1> 
   391                              <1> fatal_error:
   392 000019E9 89C3                <1> 	mov bx, ax			; Store string location for now
   393                              <1> 
   394 000019EB B600                <1> 	mov dh, 0
   395 000019ED B200                <1> 	mov dl, 0
   396 000019EF E8CAF7              <1> 	call move_cursor
   397                              <1> 
   398 000019F2 60                  <1> 	pusha
   399 000019F3 B409                <1> 	mov ah, 0x09		; Draw red bar at top
   400 000019F5 B700                <1> 	mov bh, 0
   401 000019F7 B9F000              <1> 	mov cx, 240
   402 000019FA B34F                <1> 	mov bl, 01001111b
   403 000019FC B020                <1> 	mov al, ' '
   404 000019FE CD10                <1> 	int 10h
   405 00001A00 61                  <1> 	popa
   406                              <1> 
   407 00001A01 B600                <1> 	mov dh, 0
   408 00001A03 B200                <1> 	mov dl, 0
   409 00001A05 E8B4F7              <1> 	call move_cursor
   410                              <1> 
   411 00001A08 BE[151A]            <1> 	mov si, .msg_inform		; Inform of fatal error
   412 00001A0B E80501              <1> 	call print
   413                              <1> 
   414 00001A0E 89DE                <1> 	mov si, bx			; Program-supplied error message
   415 00001A10 E80001              <1> 	call print
   416                              <1> 
   417 00001A13 EBFE                <1> 	jmp $				; Halt execution
   418                              <1> 
   419                              <1> 	
   420 00001A15 464154414C204F5045- <1> 	.msg_inform		db 'FATAL OPERATING SYSTEM ERROR!', 0x0d, 0x0a, 0
   420 00001A1E 524154494E47205359- <1>
   420 00001A27 5354454D204552524F- <1>
   420 00001A30 52210D0A00          <1>
   421                              <1> 
   422                              <1> ; ------------------------------------------------------------------
   423                              <1> ; bios_wait -- Wait
   424                              <1> ; IN: CX:DX time
   425                              <1> 
   426                              <1> bios_wait:
   427 00001A35 B80086              <1> 	mov ax, 0x8600
   428 00001A38 CD15                <1>     int 0x15
   429 00001A3A C3                  <1>     ret
   367                                      %include "./includes/input.asm"
   368                              <1> get_input:
   369 00001A3B 60                  <1>     pusha
   370 00001A3C B200                <1>     mov dl, 0
   371 00001A3E BE[A101]            <1>     mov si, in_buffer
   372                              <1> 
   373                              <1>     ; Clear the input buffer for use
   374                              <1>     .clear_loop:
   375 00001A41 C60400              <1>         mov byte [si], 0
   376                              <1> 
   377 00001A44 46                  <1>         inc si
   378 00001A45 FEC2                <1>         inc dl
   379                              <1> 
   380 00001A47 80FA1E              <1>         cmp dl, 30
   381 00001A4A 75F5                <1>         jne .clear_loop
   382                              <1> 
   383 00001A4C BE[A101]            <1>     mov si, in_buffer
   384 00001A4F 30DB                <1>     xor bl, bl ; Used for checking the length of the buffer
   385                              <1> 
   386                              <1> ; The actual loop
   387                              <1> .input_loop:
   388 00001A51 B400                <1>     mov ah, 0x00
   389 00001A53 CD16                <1>     int 0x16
   390                              <1> 
   391                              <1>     ; Check if the user pressed enter
   392 00001A55 3C0D                <1>     cmp al, 0x0d
   393 00001A57 7442                <1>     je .input_done
   394                              <1> 
   395                              <1>     ; Check if the user pressed backspace
   396 00001A59 3C08                <1>     cmp al, 0x08
   397 00001A5B 7524                <1>     jne .not_back
   398                              <1> 
   399                              <1>     ; ******************************
   400                              <1>     ; The user pressed backspace!
   401                              <1> 
   402                              <1>     ; Get current cursor position
   403 00001A5D B403                <1>     mov ah, 0x03
   404 00001A5F B700                <1>     mov bh, 0
   405 00001A61 CD10                <1>     int 0x10
   406                              <1> 
   407 00001A63 80FA03              <1>     cmp dl, 3 ; 3 = backspace limit
   408 00001A66 74E9                <1>     je .input_loop
   409                              <1> 
   410 00001A68 FECA                <1>     dec dl
   411 00001A6A FECB                <1>     dec bl
   412                              <1> 
   413                              <1>     ; Move one back
   414 00001A6C B402                <1>     mov ah, 0x02
   415 00001A6E CD10                <1>     int 0x10
   416                              <1> 
   417 00001A70 B40E                <1>     mov ah, 0x0e
   418 00001A72 B000                <1>     mov al, 0
   419 00001A74 CD10                <1>     int 0x10
   420                              <1> 
   421 00001A76 B402                <1>     mov ah, 0x02
   422 00001A78 CD10                <1>     int 0x10
   423                              <1> 
   424                              <1>     ; Remove the last character from the input buffer
   425 00001A7A 4E                  <1>     dec si
   426 00001A7B B000                <1>     mov al, 0
   427 00001A7D 8804                <1>     mov [si], al
   428                              <1> 
   429 00001A7F EBD0                <1>     jmp .input_loop
   430                              <1>     
   431                              <1>     ; ******************************
   432                              <1> 
   433                              <1>     ; Show the pressed character and save it to the input buffer
   434                              <1>     .not_back:
   435 00001A81 80FB28              <1>         cmp bl, 40
   436 00001A84 74CB                <1>         je .input_loop
   437 00001A86 FEC3                <1>         inc bl
   438                              <1> 
   439 00001A88 8804                <1>         mov [si], al
   440 00001A8A 46                  <1>         inc si
   441                              <1> 
   442 00001A8B B40E                <1>         mov ah, 0x0e
   443 00001A8D 3C61                <1>         cmp al, 'a'
   444 00001A8F 7206                <1>         jb .noatoz
   445 00001A91 3C7A                <1>         cmp al, 'z'
   446 00001A93 7702                <1>         ja .noatoz
   447                              <1>         
   448 00001A95 24DF                <1>         and al, 0xdf
   449                              <1>         .noatoz:
   450 00001A97 CD10                <1>         int 0x10
   451                              <1> 
   452 00001A99 EBB6                <1>         jmp .input_loop
   453                              <1> 
   454                              <1>     ; Return the cursor to the start and return
   455                              <1>     .input_done:
   456 00001A9B B8[A101]            <1>         mov ax, in_buffer
   457 00001A9E E839F3              <1>         call string_lowercase
   458                              <1> 
   459 00001AA1 B40E                <1>         mov ah, 0x0e
   460 00001AA3 B00D                <1>         mov al, 0x0d
   461 00001AA5 CD10                <1>         int 0x10
   462                              <1> 
   463 00001AA7 61                  <1>         popa
   464 00001AA8 C3                  <1>         ret
   368                                      %include "./includes/math.asm"
   369                              <1> ; ==================================================================
   370                              <1> ; KronkOS -- The Kronk Operating System kernel
   371                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   372                              <1> ;
   373                              <1> ; MATH ROUTINES
   374                              <1> ; ==================================================================
   375                              <1> 
   376                              <1> ; ------------------------------------------------------------------
   377                              <1> ; seed_random -- Seed the random number generator based on clock
   378                              <1> 
   379                              <1> seed_random:
   380 00001AA9 53                  <1> 	push bx
   381 00001AAA 50                  <1> 	push ax
   382                              <1> 
   383 00001AAB BB0000              <1> 	mov bx, 0
   384 00001AAE B002                <1> 	mov al, 0x02
   385 00001AB0 E670                <1> 	out 0x70, al
   386 00001AB2 E471                <1> 	in al, 0x71
   387                              <1> 
   388 00001AB4 88C3                <1> 	mov bl, al
   389 00001AB6 C1E308              <1> 	shl bx, 8
   390 00001AB9 B000                <1> 	mov al, 0
   391 00001ABB E670                <1> 	out 0x70, al
   392 00001ABD E471                <1> 	in al, 0x71
   393                              <1> 
   394 00001ABF 891E[C61A]          <1> 	mov word [random_seed], bx
   395                              <1> 
   396 00001AC3 58                  <1> 	pop ax
   397 00001AC4 5B                  <1> 	pop bx
   398 00001AC5 C3                  <1> 	ret
   399                              <1> 
   400 00001AC6 0000                <1> 	random_seed dw 0
   401                              <1> 
   402                              <1> ; ------------------------------------------------------------------
   403                              <1> ; get_random -- Return a random integer between low and high (inclusive)
   404                              <1> ; IN: AX = low integer, BX = high integer
   405                              <1> ; OUT: CX = random integer
   406                              <1> 
   407                              <1> get_random:
   408 00001AC8 52                  <1> 	push dx
   409 00001AC9 53                  <1> 	push bx
   410 00001ACA 50                  <1> 	push ax
   411                              <1> 
   412 00001ACB 29C3                <1> 	sub bx, ax
   413 00001ACD E80F00              <1> 	call .generate_random
   414 00001AD0 89DA                <1> 	mov dx, bx
   415 00001AD2 83C201              <1> 	add dx, 1
   416 00001AD5 F7E2                <1> 	mul dx
   417 00001AD7 89D1                <1> 	mov cx, dx
   418                              <1> 
   419 00001AD9 58                  <1> 	pop ax
   420 00001ADA 5B                  <1> 	pop bx
   421 00001ADB 5A                  <1> 	pop dx
   422 00001ADC 01C1                <1> 	add cx, ax
   423 00001ADE C3                  <1> 	ret
   424                              <1> 
   425                              <1> 	.generate_random:
   426 00001ADF 52                  <1> 		push dx
   427 00001AE0 53                  <1> 		push bx
   428                              <1> 
   429 00001AE1 A1[C61A]            <1> 		mov ax, [random_seed]
   430 00001AE4 BA8373              <1> 		mov dx, 0x7383
   431 00001AE7 F7E2                <1> 		mul dx
   432 00001AE9 A3[C61A]            <1> 		mov [random_seed], ax
   433                              <1> 
   434 00001AEC 5B                  <1> 		pop bx
   435 00001AED 5A                  <1> 		pop dx
   436                              <1> 		
   437 00001AEE C3                  <1> 		ret
   438                              <1> 
   439                              <1> ; ------------------------------------------------------------------
   440                              <1> ; bcd_to_int -- Converts binary coded decimal number to an integer
   441                              <1> ; IN: AL = BCD number
   442                              <1> ; OUT: AX = integer value
   443                              <1> 
   444                              <1> bcd_to_int:
   445 00001AEF 60                  <1> 	pusha
   446                              <1> 
   447 00001AF0 88C3                <1> 	mov bl, al
   448                              <1> 
   449 00001AF2 83E00F              <1> 	and ax, 0x0F
   450 00001AF5 89C1                <1> 	mov cx, ax
   451                              <1> 
   452 00001AF7 C0EB04              <1> 	shr bl, 4
   453 00001AFA B00A                <1> 	mov al, 10
   454 00001AFC F6E3                <1> 	mul bl
   455                              <1> 
   456 00001AFE 01C8                <1> 	add ax, cx
   457 00001B00 A3[081B]            <1> 	mov [.tmp], ax
   458                              <1> 
   459 00001B03 61                  <1> 	popa
   460 00001B04 A1[081B]            <1> 	mov ax, [.tmp]
   461 00001B07 C3                  <1> 	ret
   462                              <1> 
   463 00001B08 0000                <1> 	.tmp	dw 0
   464                              <1> 	
   465                              <1> ; ------------------------------------------------------------------
   466                              <1> ; long_int_negate -- Multiply value in DX:AX by -1
   467                              <1> ; IN: DX:AX = long integer
   468                              <1> ; OUT: DX:AX = -(initial DX:AX)
   469                              <1> 
   470                              <1> long_int_negate:
   471 00001B0A F7D8                <1> 	neg ax
   472 00001B0C 83D200              <1> 	adc dx, 0
   473 00001B0F F7DA                <1> 	neg dx
   474 00001B11 C3                  <1> 	ret
   475                              <1> 
   476                              <1> ; ------------------------------------------------------------------
   477                              <1> ; hex_to_int -- Convert a hexadecimal to decimal
   478                              <1> ; IN: AX = number to be converted, BX = base
   479                              <1> 
   480                              <1> hex_to_int:
   481 00001B12 C3                  <1> 	ret
   482                              <1> 
   483                              <1> ; ==================================================================
   369                                      %include "./includes/print.asm"
   370                              <1> ; ------------------------------------------------------------------
   371                              <1> ; print -- Print a string to the screen
   372                              <1> ; IN: SI = The location of the string
   373                              <1> 
   374                              <1> print:
   375 00001B13 60                  <1>     pusha
   376 00001B14 B40E                <1>     mov ah, 0x0e
   377                              <1> 
   378                              <1> .repeat:
   379 00001B16 AC                  <1>     lodsb
   380 00001B17 84C0                <1>     test al, al
   381 00001B19 7404                <1>     jz .done
   382                              <1> 
   383 00001B1B CD10                <1>     int 0x10
   384 00001B1D EBF7                <1>     jmp short .repeat
   385                              <1> 
   386                              <1> .done:
   387 00001B1F 61                  <1>     popa
   388 00001B20 C3                  <1>     ret
   389                              <1> 
   390                              <1> ; ------------------------------------------------------------------
   391                              <1> ; welcome_print -- Print the welcome message
   392                              <1> ; IN: SI = The location of the string
   393                              <1> 
   394                              <1> welcome_print:
   395 00001B21 B409                <1>     mov ah, 0x09
   396 00001B23 B90100              <1>     mov cx, 1
   397 00001B26 31DB                <1>     xor bx, bx
   398 00001B28 B330                <1>     mov bl, mb_color
   399                              <1> 
   400                              <1>     .repeat:
   401 00001B2A AC                  <1>         lodsb
   402 00001B2B 3C00                <1>         cmp al, 0
   403 00001B2D 741C                <1>         je .done
   404                              <1> 
   405 00001B2F 3C0A                <1>         cmp al, 0x0a
   406 00001B31 7410                <1>         je .other_char
   407 00001B33 3C0D                <1>         cmp al, 0x0d
   408 00001B35 740C                <1>         je .other_char
   409                              <1> 
   410 00001B37 E88BF6              <1>         call get_cursor_pos
   411 00001B3A FEC2                <1>         inc dl
   412 00001B3C E87DF6              <1>         call move_cursor
   413                              <1> 
   414 00001B3F CD10                <1>         int 0x10
   415 00001B41 EBE7                <1>         jmp short .repeat
   416                              <1> 
   417                              <1>     .other_char:
   418 00001B43 B40E                <1>         mov ah, 0x0e
   419 00001B45 CD10                <1>         int 0x10
   420                              <1> 
   421 00001B47 B409                <1>         mov ah, 0x09
   422 00001B49 EBDF                <1>         jmp .repeat
   423                              <1> 
   424                              <1>     .done:
   425 00001B4B C3                  <1>         ret
   426                              <1> 
   427                              <1> ; ------------------------------------------------------------------
   428                              <1> ; print_atr -- Print a string with attribute to the screen
   429                              <1> ; IN: SI = The location of the string
   430                              <1> ;     BH = Page number
   431                              <1> ;     BL = Attribute
   432                              <1> 
   433                              <1> print_atr:
   434 00001B4C 60                  <1>     pusha
   435 00001B4D B90100              <1>     mov cx, 1
   436 00001B50 B409                <1>     mov ah, 0x09
   437                              <1> 
   438                              <1> .repeat:
   439 00001B52 AC                  <1>     lodsb
   440 00001B53 84C0                <1>     test al, al
   441 00001B55 741C                <1>     jz .done
   442                              <1> 
   443 00001B57 3C0A                <1>     cmp al, 0x0a
   444 00001B59 7410                <1>     je .special_char
   445                              <1> 
   446 00001B5B 3C0D                <1>     cmp al, 0x0d
   447 00001B5D 740C                <1>     je .special_char
   448                              <1> 
   449 00001B5F CD10                <1>     int 0x10
   450                              <1> 
   451 00001B61 E861F6              <1>     call get_cursor_pos
   452 00001B64 FEC2                <1>     inc dl
   453 00001B66 E853F6              <1>     call move_cursor
   454                              <1> 
   455 00001B69 EBE7                <1>     jmp short .repeat
   456                              <1> 
   457                              <1> .special_char:
   458 00001B6B B40E                <1>     mov ah, 0x0e
   459 00001B6D CD10                <1>     int 0x10
   460 00001B6F B409                <1>     mov ah, 0x09
   461                              <1> 
   462 00001B71 EBDF                <1>     jmp short .repeat
   463                              <1> 
   464                              <1> .done:
   465 00001B73 61                  <1>     popa
   466 00001B74 C3                  <1>     ret
   370                                      %include "./includes/mouse.asm"
   371                              <1> HW_EQUIP_PS2     equ 4          ; PS2 mouse installed?
   372                              <1> MOUSE_PKT_BYTES  equ 3          ; Number of bytes in mouse packet
   373                              <1> MOUSE_RESOLUTION equ 3          ; Mouse resolution 8 counts/mm
   374                              <1> ARG_OFFSETS      equ 6          ; Offset of args from BP
   375                              <1> 
   376                              <1> mouse_initialize:
   377 00001B75 06                  <1>     push es
   378 00001B76 53                  <1>     push bx
   379                              <1> 
   380 00001B77 CD11                <1>     int 0x11
   381 00001B79 A90400              <1>     test ax, HW_EQUIP_PS2
   382 00001B7C 7421                <1>     jz .no_mouse
   383                              <1> 
   384 00001B7E B805C2              <1>     mov ax, 0xC205
   385 00001B81 B703                <1>     mov bh, MOUSE_PKT_BYTES
   386 00001B83 CD15                <1>     int 0x15
   387 00001B85 7218                <1>     jc .no_mouse
   388                              <1> 
   389 00001B87 B803C2              <1>     mov ax, 0xC203
   390 00001B8A B703                <1>     mov bh, MOUSE_RESOLUTION
   391 00001B8C CD15                <1>     int 0x15
   392 00001B8E 720F                <1>     jc .no_mouse
   393                              <1> 
   394 00001B90 0E                  <1>     push cs
   395 00001B91 07                  <1>     pop es
   396                              <1> 
   397 00001B92 BB[0A1C]            <1>     mov bx, mouse_callback_dummy
   398 00001B95 B807C2              <1>     mov ax, 0xC207
   399 00001B98 CD15                <1>     int 0x15
   400 00001B9A 7203                <1>     jc .no_mouse
   401                              <1> 
   402 00001B9C F8                  <1>     clc
   403 00001B9D EB01                <1>     jmp .finished
   404                              <1>     
   405                              <1>     .no_mouse:
   406 00001B9F F9                  <1>         stc
   407                              <1>     
   408                              <1>     .finished:
   409 00001BA0 5B                  <1>         pop bx
   410 00001BA1 07                  <1>         pop es
   411 00001BA2 C3                  <1>         ret
   412                              <1> 
   413                              <1> 
   414                              <1> mouse_enable:
   415 00001BA3 06                  <1>     push es
   416 00001BA4 53                  <1>     push bx
   417                              <1> 
   418 00001BA5 E81400              <1>     call mouse_disable
   419                              <1> 
   420 00001BA8 0E                  <1>     push cs
   421 00001BA9 07                  <1>     pop es
   422 00001BAA BB[CF1B]            <1>     mov bx, mouse_callback
   423 00001BAD B807C2              <1>     mov ax, 0xC207
   424 00001BB0 CD15                <1>     int 0x15
   425                              <1> 
   426 00001BB2 B800C2              <1>     mov ax, 0xC200
   427 00001BB5 B701                <1>     mov bh, 1
   428 00001BB7 CD15                <1>     int 0x15
   429                              <1> 
   430 00001BB9 5B                  <1>     pop bx
   431 00001BBA 07                  <1>     pop es
   432 00001BBB C3                  <1>     ret
   433                              <1> 
   434                              <1> 
   435                              <1> mouse_disable:
   436 00001BBC 06                  <1>     push es
   437 00001BBD 53                  <1>     push bx
   438                              <1> 
   439 00001BBE B800C2              <1>     mov ax, 0xC200
   440 00001BC1 31DB                <1>     xor bx, bx
   441 00001BC3 CD15                <1>     int 0x15
   442                              <1> 
   443 00001BC5 8EC3                <1>     mov es, bx
   444 00001BC7 B807C2              <1>     mov ax, 0xC207
   445 00001BCA CD15                <1>     int 0x15
   446                              <1> 
   447 00001BCC 5B                  <1>     pop bx
   448 00001BCD 07                  <1>     pop es
   449 00001BCE C3                  <1>     ret
   450                              <1> 
   451                              <1> 
   452                              <1> mouse_callback:
   453 00001BCF 55                  <1>     push bp
   454 00001BD0 89E5                <1>     mov bp, sp
   455                              <1> 
   456 00001BD2 1E                  <1>     push ds
   457 00001BD3 50                  <1>     push ax
   458 00001BD4 53                  <1>     push bx
   459 00001BD5 51                  <1>     push cx
   460 00001BD6 52                  <1>     push dx
   461                              <1> 
   462 00001BD7 0E                  <1>     push cs
   463 00001BD8 1F                  <1>     pop ds
   464                              <1> 
   465 00001BD9 8A460C              <1>     mov al, [bp+ARG_OFFSETS+6]
   466 00001BDC 88C3                <1>     mov bl, al
   467 00001BDE B103                <1>     mov cl, 3
   468 00001BE0 D2E0                <1>     shl al, cl
   469                              <1> 
   470 00001BE2 18F6                <1>     sbb dh, dh
   471 00001BE4 98                  <1>     cbw
   472 00001BE5 8A5608              <1>     mov dl, [bp+ARG_OFFSETS+2]
   473 00001BE8 8A460A              <1>     mov al, [bp+ARG_OFFSETS+4]
   474                              <1> 
   475 00001BEB F7DA                <1>     neg dx
   476 00001BED 8B0E[BD1C]          <1>     mov cx, [mouseY]
   477 00001BF1 01CA                <1>     add dx, cx
   478 00001BF3 8B0E[BB1C]          <1>     mov cx, [mouseX]
   479 00001BF7 01C8                <1>     add ax, cx
   480                              <1> 
   481 00001BF9 881E[BF1C]          <1>     mov [curStatus], bl
   482 00001BFD A3[BB1C]            <1>     mov [mouseX], ax
   483 00001C00 8916[BD1C]          <1>     mov [mouseY], dx
   484                              <1> 
   485 00001C04 5A                  <1>     pop dx
   486 00001C05 59                  <1>     pop cx
   487 00001C06 5B                  <1>     pop bx
   488 00001C07 58                  <1>     pop ax
   489 00001C08 1F                  <1>     pop ds
   490 00001C09 5D                  <1>     pop bp
   491                              <1> 
   492                              <1> mouse_callback_dummy:
   493 00001C0A CB                  <1>     retf
   494                              <1> 
   495                              <1> poll_mouse:
   496 00001C0B 50                  <1>     push ax
   497 00001C0C 53                  <1>     push bx
   498 00001C0D 52                  <1>     push dx
   499                              <1>     
   500 00001C0E BB0200              <1>     mov bx, 0x0002
   501                              <1> 
   502 00001C11 FA                  <1>     cli
   503 00001C12 A1[BB1C]            <1>     mov ax, [mouseX]
   504 00001C15 8B16[BD1C]          <1>     mov dx, [mouseY]
   505 00001C19 FB                  <1>     sti
   506                              <1> 
   507 00001C1A 5A                  <1>     pop dx
   508 00001C1B 5B                  <1>     pop bx
   509 00001C1C 58                  <1>     pop ax
   510 00001C1D C3                  <1>     ret
   511                              <1> 
   512                              <1> clamp_mouse:
   513 00001C1E A1[BB1C]            <1>     mov ax, [mouseX]
   514                              <1> 
   515 00001C21 83F84E              <1>     cmp ax, screenmaxW
   516 00001C24 7D17                <1>     jge .r_edge
   517                              <1> 
   518 00001C26 BA0100              <1>     mov dx, screenminW
   519 00001C29 39D0                <1>     cmp ax, dx
   520 00001C2B 7E22                <1>     jle .l_edge
   521                              <1> 
   522 00001C2D BA0100              <1>     mov dx, screenminH
   523 00001C30 A1[BD1C]            <1>     mov ax, [mouseY]
   524 00001C33 39D0                <1>     cmp ax, dx
   525 00001C35 7E2A                <1>     jle .t_edge
   526                              <1> 
   527 00001C37 83F817              <1>     cmp ax, screenmaxH
   528 00001C3A 7D37                <1>     jge .b_edge
   529                              <1> 
   530 00001C3C C3                  <1>     ret
   531                              <1> 
   532                              <1> .r_edge:
   533 00001C3D C706[BB1C]4E00      <1>     mov word [mouseX], screenmaxW
   534 00001C43 8A16[BB1C]          <1>     mov dl, [mouseX]
   535 00001C47 8A36[BD1C]          <1>     mov dh, [mouseY]
   536 00001C4B E86EF5              <1>     call move_cursor
   537 00001C4E C3                  <1>     ret
   538                              <1> 
   539                              <1> .l_edge:
   540 00001C4F C706[BB1C]0100      <1>     mov word [mouseX], screenminW
   541 00001C55 8A16[BB1C]          <1>     mov dl, [mouseX]
   542 00001C59 8A36[BD1C]          <1>     mov dh, [mouseY]
   543 00001C5D E85CF5              <1>     call move_cursor
   544 00001C60 C3                  <1>     ret
   545                              <1> 
   546                              <1> .t_edge:
   547 00001C61 C706[BD1C]0100      <1>     mov word [mouseY], screenminH
   548 00001C67 8A16[BB1C]          <1>     mov dl, [mouseX]
   549 00001C6B 8A36[BD1C]          <1>     mov dh, [mouseY]
   550 00001C6F E84AF5              <1>     call move_cursor
   551 00001C72 C3                  <1>     ret
   552                              <1> 
   553                              <1> .b_edge:
   554 00001C73 C706[BD1C]1700      <1>     mov word [mouseY], screenmaxH
   555 00001C79 8A16[BB1C]          <1>     mov dl, [mouseX]
   556 00001C7D 8A36[BD1C]          <1>     mov dh, [mouseY]
   557 00001C81 E838F5              <1>     call move_cursor
   558 00001C84 C3                  <1>     ret
   559                              <1> 
   560                              <1> no_mouse:
   561 00001C85 B8[1B02]            <1>     mov ax, mouse_yes
   562 00001C88 31DB                <1>     xor bx, bx
   563 00001C8A 31C9                <1>     xor cx, cx
   564 00001C8C BA0000              <1>     mov dx, 0
   565 00001C8F E8BDF5              <1>     call dialog_box
   566                              <1> 
   567 00001C92 31C0                <1>     xor ax, ax
   568 00001C94 CD13                <1>     int 0x13
   569                              <1> 
   570 00001C96 B80010              <1>     mov ax, 0x1000
   571 00001C99 8CD0                <1>     mov ax, ss
   572 00001C9B BC00F0              <1>     mov sp, 0xf000
   573 00001C9E B80753              <1>     mov ax, 0x5307
   574 00001CA1 BB0100              <1>     mov bx, 0x0001
   575 00001CA4 B90300              <1>     mov cx, 0x0003
   576 00001CA7 CD15                <1>     int 0x15
   577                              <1> 
   578                              <1> mouse_loop:
   579 00001CA9 E85FFF              <1>     call poll_mouse
   580 00001CAC 8A16[BB1C]          <1>     mov dl, [mouseX]
   581 00001CB0 8A36[BD1C]          <1>     mov dh, [mouseY]
   582                              <1>     
   583 00001CB4 E805F5              <1>     call move_cursor
   584 00001CB7 E864FF              <1>     call clamp_mouse
   585                              <1> 
   586 00001CBA C3                  <1>     ret
   587                              <1> 
   588 00001CBB 0000                <1> mouseX:         dw 0
   589 00001CBD 0000                <1> mouseY:         dw 0
   590 00001CBF 00                  <1> curStatus:      db 0
   591 00001CC0 0D4572726F72207365- <1> noMouseMsg:     db 0x0d, "Error setting up and initializing mouse", 0x0a, 0x0d, 0
   591 00001CC9 7474696E6720757020- <1>
   591 00001CD2 616E6420696E697469- <1>
   591 00001CDB 616C697A696E67206D- <1>
   591 00001CE4 6F7573650A0D00      <1>
   371                                      %include "./includes/disk.asm"
   372                              <1> ; ==================================================================
   373                              <1> ; The Kronk Operating System kernel
   374                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   375                              <1> ;
   376                              <1> ; FAT12 FLOPPY DISK ROUTINES
   377                              <1> ; ==================================================================
   378                              <1> 
   379                              <1> ; ------------------------------------------------------------------
   380                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
   381                              <1> ; IN/OUT: AX = location to store zero-terminated filename string
   382                              <1> 
   383                              <1> os_get_file_list:
   384 00001CEB 60                  <1> 	pusha
   385                              <1> 
   386 00001CEC A3[8D1D]            <1> 	mov word [.file_list_tmp], ax
   387                              <1> 
   388 00001CEF 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   389                              <1> 
   390 00001CF5 E84007              <1> 	call disk_reset_floppy		; Just in case disk was changed
   391                              <1> 
   392 00001CF8 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   393 00001CFB E84907              <1> 	call disk_convert_l2hts
   394                              <1> 
   395 00001CFE BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   396 00001D01 89F3                <1> 	mov bx, si
   397                              <1> 
   398 00001D03 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   399 00001D05 B00E                <1> 	mov al, 14			; And read 14 of them
   400                              <1> 
   401 00001D07 60                  <1> 	pusha				; Prepare to enter loop
   402                              <1> 
   403                              <1> 
   404                              <1> .read_root_dir:
   405 00001D08 61                  <1> 	popa
   406 00001D09 60                  <1> 	pusha
   407                              <1> 
   408 00001D0A F9                  <1> 	stc
   409 00001D0B CD13                <1> 	int 13h				; Read sectors
   410 00001D0D E82807              <1> 	call disk_reset_floppy		; Check we've read them OK
   411 00001D10 7307                <1> 	jnc .show_dir_init		; No errors, continue
   412                              <1> 
   413 00001D12 E82307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
   414 00001D15 73F1                <1> 	jnc .read_root_dir
   415 00001D17 EB6E                <1> 	jmp .done			; Double error, exit 'dir' routine
   416                              <1> 
   417                              <1> .show_dir_init:
   418 00001D19 61                  <1> 	popa
   419                              <1> 
   420 00001D1A B80000              <1> 	mov ax, 0
   421 00001D1D BE0060              <1> 	mov si, disk_buffer		; Data reader from start of filenames
   422                              <1> 
   423 00001D20 8B3E[8D1D]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
   424                              <1> 
   425                              <1> 
   426                              <1> .start_entry:
   427 00001D24 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   428 00001D27 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   429 00001D29 7457                <1> 	je .skip
   430                              <1> 
   431 00001D2B A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   432 00001D2D 7553                <1> 	jnz .skip			; Yes, ignore it
   433                              <1> 
   434 00001D2F 8A04                <1> 	mov al, [si]
   435 00001D31 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   436 00001D33 744D                <1> 	je .skip
   437                              <1> 
   438 00001D35 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
   439 00001D37 744E                <1> 	je .done
   440                              <1> 
   441                              <1> 
   442 00001D39 B90100              <1> 	mov cx, 1			; Set char counter
   443 00001D3C 89F2                <1> 	mov dx, si			; Beginning of possible entry
   444                              <1> 
   445                              <1> .testdirentry:
   446 00001D3E 46                  <1> 	inc si
   447 00001D3F 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   448 00001D41 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   449 00001D43 7C3B                <1> 	jl .nxtdirentry
   450 00001D45 3C7E                <1> 	cmp al, '~'
   451 00001D47 7737                <1> 	ja .nxtdirentry
   452                              <1> 
   453 00001D49 41                  <1> 	inc cx
   454 00001D4A 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
   455 00001D4D 7402                <1> 	je .gotfilename
   456 00001D4F EBED                <1> 	jmp .testdirentry
   457                              <1> 
   458                              <1> 
   459                              <1> .gotfilename:				; Got a filename that passes testing
   460 00001D51 89D6                <1> 	mov si, dx			; DX = where getting string
   461                              <1> 
   462 00001D53 B90000              <1> 	mov cx, 0
   463                              <1> .loopy:
   464 00001D56 8A04                <1> 	mov byte al, [si]
   465 00001D58 3C20                <1> 	cmp al, ' '
   466 00001D5A 7411                <1> 	je .ignore_space
   467 00001D5C 8805                <1> 	mov byte [di], al
   468 00001D5E 46                  <1> 	inc si
   469 00001D5F 47                  <1> 	inc di
   470 00001D60 41                  <1> 	inc cx
   471 00001D61 83F908              <1> 	cmp cx, 8
   472 00001D64 7410                <1> 	je .add_dot
   473 00001D66 83F90B              <1> 	cmp cx, 11
   474 00001D69 7411                <1> 	je .done_copy
   475 00001D6B EBE9                <1> 	jmp .loopy
   476                              <1> 
   477                              <1> .ignore_space:
   478 00001D6D 46                  <1> 	inc si
   479 00001D6E 41                  <1> 	inc cx
   480 00001D6F 83F908              <1> 	cmp cx, 8
   481 00001D72 7402                <1> 	je .add_dot
   482 00001D74 EBE0                <1> 	jmp .loopy
   483                              <1> 
   484                              <1> .add_dot:
   485 00001D76 C6052E              <1> 	mov byte [di], '.'
   486 00001D79 47                  <1> 	inc di
   487 00001D7A EBDA                <1> 	jmp .loopy
   488                              <1> 
   489                              <1> .done_copy:
   490 00001D7C C6052C              <1> 	mov byte [di], ','
   491 00001D7F 47                  <1> 	inc di
   492                              <1> 
   493                              <1> .nxtdirentry:
   494 00001D80 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
   495                              <1> 
   496                              <1> .skip:
   497 00001D82 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
   498 00001D85 EB9D                <1> 	jmp .start_entry
   499                              <1> 
   500                              <1> 
   501                              <1> .done:
   502 00001D87 4F                  <1> 	dec di
   503 00001D88 C60500              <1> 	mov byte [di], 0		; Zero-terminate string (gets rid of final comma)
   504                              <1> 
   505 00001D8B 61                  <1> 	popa
   506 00001D8C C3                  <1> 	ret
   507                              <1> 
   508 00001D8D 0000                <1> 	.file_list_tmp		dw 0
   509                              <1> 
   510                              <1> ; ------------------------------------------------------------------
   511                              <1> ; os_load_file -- Load file into RAM
   512                              <1> ; IN: AX = location of filename, CX = location in RAM to load file
   513                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
   514                              <1> 
   515                              <1> os_load_file:
   516 00001D8F E82BF0              <1> 	call string_uppercase
   517 00001D92 E87205              <1> 	call int_filename_convert
   518                              <1> 
   519 00001D95 A3[971E]            <1> 	mov [.filename_loc], ax		; Store filename location
   520 00001D98 890E[991E]          <1> 	mov [.load_position], cx	; And where to load the file!
   521                              <1> 
   522 00001D9C 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   523                              <1> 
   524 00001DA2 E89306              <1> 	call disk_reset_floppy		; In case floppy has been changed
   525 00001DA5 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
   526                              <1> 
   527 00001DA7 B8[A91E]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
   528 00001DAA E93CFC              <1> 	jmp fatal_error
   529                              <1> 
   530                              <1> 
   531                              <1> .floppy_ok:				; Ready to read first block of data
   532 00001DAD B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   533 00001DB0 E89406              <1> 	call disk_convert_l2hts
   534                              <1> 
   535 00001DB3 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   536 00001DB6 89F3                <1> 	mov bx, si
   537                              <1> 
   538 00001DB8 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   539 00001DBA B00E                <1> 	mov al, 14			; 14 root directory sectors
   540                              <1> 
   541 00001DBC 60                  <1> 	pusha				; Prepare to enter loop
   542                              <1> 
   543                              <1> 
   544                              <1> .read_root_dir:
   545 00001DBD 61                  <1> 	popa
   546 00001DBE 60                  <1> 	pusha
   547                              <1> 
   548 00001DBF F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
   549 00001DC0 CD13                <1> 	int 13h				; Read sectors
   550 00001DC2 7308                <1> 	jnc .search_root_dir		; No errors = continue
   551                              <1> 
   552 00001DC4 E87106              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
   553 00001DC7 73F4                <1> 	jnc .read_root_dir
   554                              <1> 
   555 00001DC9 61                  <1> 	popa
   556 00001DCA EB38                <1> 	jmp .root_problem		; Double error = exit
   557                              <1> 
   558                              <1> .search_root_dir:
   559 00001DCC 61                  <1> 	popa
   560                              <1> 
   561 00001DCD B9E000              <1> 	mov cx, word 224		; Search all entries in root dir
   562 00001DD0 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
   563                              <1> 
   564                              <1> .next_root_entry:
   565 00001DD3 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
   566 00001DD6 BF0060              <1> 	mov di, disk_buffer		; Point root dir at next entry
   567 00001DD9 01DF                <1> 	add di, bx
   568                              <1> 
   569 00001DDB 8A05                <1> 	mov al, [di]			; First character of name
   570                              <1> 
   571 00001DDD 3C00                <1> 	cmp al, 0			; Last file name already checked?
   572 00001DDF 7423                <1> 	je .root_problem
   573                              <1> 
   574 00001DE1 3CE5                <1> 	cmp al, 229			; Was this file deleted?
   575 00001DE3 74EE                <1> 	je .next_root_entry		; If yes, skip it
   576                              <1> 
   577 00001DE5 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
   578                              <1> 
   579 00001DE8 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
   580 00001DEA 74E7                <1> 	je .next_root_entry
   581                              <1> 
   582 00001DEC A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   583 00001DEE 75E3                <1> 	jnz .next_root_entry
   584                              <1> 
   585 00001DF0 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
   586                              <1> 
   587 00001DF4 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
   588 00001DF6 E8C4EF              <1> 	call string_uppercase
   589                              <1> 
   590 00001DF9 8B36[971E]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
   591                              <1> 
   592 00001DFD E878F0              <1> 	call string_compare		; Current entry same as requested?
   593 00001E00 7207                <1> 	jc .found_file_to_load
   594                              <1> 
   595 00001E02 E2CF                <1> 	loop .next_root_entry
   596                              <1> 
   597                              <1> .root_problem:
   598 00001E04 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
   599 00001E07 F9                  <1> 	stc				; return with size = 0 and carry set
   600 00001E08 C3                  <1> 	ret
   601                              <1> 
   602                              <1> 
   603                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
   604 00001E09 8B451C              <1> 	mov ax, [di+28]			; Store file size to return to calling routine
   605 00001E0C A3[9B1E]            <1> 	mov word [.file_size], ax
   606                              <1> 
   607 00001E0F 83F800              <1> 	cmp ax, 0			; If the file size is zero, don't bother trying
   608 00001E12 7478                <1> 	je .end				; to read more clusters
   609                              <1> 
   610 00001E14 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
   611 00001E17 A3[931E]            <1> 	mov word [.cluster], ax
   612                              <1> 
   613 00001E1A B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
   614 00001E1D E82706              <1> 	call disk_convert_l2hts
   615                              <1> 
   616 00001E20 BF0060              <1> 	mov di, disk_buffer		; ES:BX points to our buffer
   617 00001E23 89FB                <1> 	mov bx, di
   618                              <1> 
   619 00001E25 B402                <1> 	mov ah, 2			; int 13h params: read sectors
   620 00001E27 B009                <1> 	mov al, 9			; And read 9 of them
   621                              <1> 
   622 00001E29 60                  <1> 	pusha
   623                              <1> 
   624                              <1> .read_fat:
   625 00001E2A 61                  <1> 	popa				; In case registers altered by int 13h
   626 00001E2B 60                  <1> 	pusha
   627                              <1> 
   628 00001E2C F9                  <1> 	stc
   629 00001E2D CD13                <1> 	int 13h
   630 00001E2F 7308                <1> 	jnc .read_fat_ok
   631                              <1> 
   632 00001E31 E80406              <1> 	call disk_reset_floppy
   633 00001E34 73F4                <1> 	jnc .read_fat
   634                              <1> 
   635 00001E36 61                  <1> 	popa
   636 00001E37 EBCB                <1> 	jmp .root_problem
   637                              <1> 
   638                              <1> 
   639                              <1> .read_fat_ok:
   640 00001E39 61                  <1> 	popa
   641                              <1> 
   642                              <1> 
   643                              <1> .load_file_sector:
   644 00001E3A A1[931E]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
   645 00001E3D 83C01F              <1> 	add ax, 31
   646                              <1> 
   647 00001E40 E80406              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
   648                              <1> 
   649 00001E43 8B1E[991E]          <1> 	mov bx, [.load_position]
   650                              <1> 
   651                              <1> 
   652 00001E47 B402                <1> 	mov ah, 02			; AH = read sectors, AL = just read 1
   653 00001E49 B001                <1> 	mov al, 01
   654                              <1> 
   655 00001E4B F9                  <1> 	stc
   656 00001E4C CD13                <1> 	int 13h
   657 00001E4E 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
   658                              <1> 
   659 00001E50 E8E505              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
   660 00001E53 73E5                <1> 	jnc .load_file_sector
   661                              <1> 
   662 00001E55 B8[A91E]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
   663 00001E58 E98EFB              <1> 	jmp fatal_error
   664                              <1> 
   665                              <1> 
   666                              <1> .calculate_next_cluster:
   667 00001E5B A1[931E]            <1> 	mov ax, [.cluster]
   668 00001E5E BB0300              <1> 	mov bx, 3
   669 00001E61 F7E3                <1> 	mul bx
   670 00001E63 BB0200              <1> 	mov bx, 2
   671 00001E66 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
   672 00001E68 BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   673 00001E6B 01C6                <1> 	add si, ax
   674 00001E6D 3E8B04              <1> 	mov ax, word [ds:si]
   675                              <1> 
   676 00001E70 09D2                <1> 	or dx, dx			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
   677                              <1> 
   678 00001E72 7405                <1> 	jz .even			; If [CLUSTER] = even, drop last 4 bits of word
   679                              <1> 					; with next cluster; if odd, drop first 4 bits
   680                              <1> 
   681                              <1> .odd:
   682 00001E74 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
   683 00001E77 EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   684                              <1> 
   685                              <1> .even:
   686 00001E79 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
   687                              <1> 
   688                              <1> .calculate_cluster_cont:
   689 00001E7C A3[931E]            <1> 	mov word [.cluster], ax		; Store cluster
   690                              <1> 
   691 00001E7F 3DF80F              <1> 	cmp ax, 0FF8h
   692 00001E82 7308                <1> 	jae .end
   693                              <1> 
   694 00001E84 8106[991E]0002      <1> 	add word [.load_position], 512
   695 00001E8A EBAE                <1> 	jmp .load_file_sector		; Onto next sector!
   696                              <1> 
   697                              <1> 
   698                              <1> .end:
   699 00001E8C 8B1E[9B1E]          <1> 	mov bx, [.file_size]		; Get file size to pass back in BX
   700 00001E90 F8                  <1> 	clc				; Carry clear = good load
   701 00001E91 C3                  <1> 	ret
   702                              <1> 
   703                              <1> 
   704 00001E92 00                  <1> 	.bootd		db 0 		; Boot device number
   705 00001E93 0000                <1> 	.cluster	dw 0 		; Cluster of the file we want to load
   706 00001E95 0000                <1> 	.pointer	dw 0 		; Pointer into disk_buffer, for loading 'file2load'
   707                              <1> 
   708 00001E97 0000                <1> 	.filename_loc	dw 0		; Temporary store of filename location
   709 00001E99 0000                <1> 	.load_position	dw 0		; Where we'll load the file
   710 00001E9B 0000                <1> 	.file_size	dw 0		; Size of the file
   711                              <1> 
   712 00001E9D 00<rep Ch>          <1> 	.string_buff	times 12 db 0	; For size (integer) printing
   713                              <1> 
   714 00001EA9 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy failed to reset', 0
   714 00001EB2 696C653A20466C6F70- <1>
   714 00001EBB 7079206661696C6564- <1>
   714 00001EC4 20746F207265736574- <1>
   714 00001ECD 00                  <1>
   715                              <1> 
   716                              <1> 
   717                              <1> ; --------------------------------------------------------------------------
   718                              <1> ; os_write_file -- Save (max 64K) file to disk
   719                              <1> ; IN: AX = filename, BX = data location, CX = bytes to write
   720                              <1> ; OUT: Carry clear if OK, set if failure
   721                              <1> 
   722                              <1> os_write_file:
   723 00001ECE 60                  <1> 	pusha
   724                              <1> 
   725 00001ECF 89C6                <1> 	mov si, ax
   726 00001ED1 E89AEE              <1> 	call string_length
   727 00001ED4 83F800              <1> 	cmp ax, 0
   728 00001ED7 0F849201            <1> 	je near .failure
   729 00001EDB 89F0                <1> 	mov ax, si
   730                              <1> 
   731 00001EDD E8DDEE              <1> 	call string_uppercase
   732 00001EE0 E82404              <1> 	call int_filename_convert	; Make filename FAT12-style
   733 00001EE3 0F828601            <1> 	jc near .failure
   734                              <1> 
   735 00001EE7 890E[7020]          <1> 	mov word [.filesize], cx
   736 00001EEB 891E[7620]          <1> 	mov word [.location], bx
   737 00001EEF A3[7A20]            <1> 	mov word [.filename], ax
   738                              <1> 
   739 00001EF2 E88702              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
   740 00001EF5 0F837401            <1> 	jnc near .failure
   741                              <1> 
   742                              <1> 
   743                              <1> 	; First, zero out the .free_clusters list from any previous execution
   744 00001EF9 60                  <1> 	pusha
   745                              <1> 
   746 00001EFA BF[7C20]            <1> 	mov di, .free_clusters
   747 00001EFD B98000              <1> 	mov cx, 128
   748                              <1> .clean_free_loop:
   749 00001F00 C7050000            <1> 	mov word [di], 0
   750 00001F04 47                  <1> 	inc di
   751 00001F05 47                  <1> 	inc di
   752 00001F06 E2F8                <1> 	loop .clean_free_loop
   753                              <1> 
   754 00001F08 61                  <1> 	popa
   755                              <1> 
   756                              <1> 
   757                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
   758                              <1> 
   759 00001F09 89C8                <1> 	mov ax, cx
   760 00001F0B BA0000              <1> 	mov dx, 0
   761 00001F0E BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
   762 00001F11 F7F3                <1> 	div bx
   763 00001F13 83FA00              <1> 	cmp dx, 0
   764 00001F16 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
   765 00001F18 EB03                <1> 	jmp .carry_on
   766                              <1> 
   767                              <1> .add_a_bit:
   768 00001F1A 83C001              <1> 	add ax, 1
   769                              <1> .carry_on:
   770                              <1> 
   771 00001F1D A3[7820]            <1> 	mov word [.clusters_needed], ax
   772                              <1> 
   773 00001F20 A1[7A20]            <1> 	mov word ax, [.filename]	; Get filename back
   774                              <1> 
   775 00001F23 E87502              <1> 	call os_create_file		; Create empty root dir entry for this file
   776 00001F26 0F824301            <1> 	jc near .failure		; If we can't write to the media, jump out
   777                              <1> 
   778 00001F2A 8B1E[7020]          <1> 	mov word bx, [.filesize]
   779 00001F2E 83FB00              <1> 	cmp bx, 0
   780 00001F31 0F843501            <1> 	je near .finished
   781                              <1> 
   782 00001F35 E86B04              <1> 	call disk_read_fat		; Get FAT copy into RAM
   783 00001F38 BE0360              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
   784                              <1> 
   785 00001F3B BB0200              <1> 	mov bx, 2			; Current cluster counter
   786 00001F3E 8B0E[7820]          <1> 	mov word cx, [.clusters_needed]
   787 00001F42 BA0000              <1> 	mov dx, 0			; Offset in .free_clusters list
   788                              <1> 
   789                              <1> .find_free_cluster:
   790 00001F45 AD                  <1> 	lodsw				; Get a word
   791 00001F46 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
   792 00001F49 740D                <1> 	jz .found_free_even		; Free entry?
   793                              <1> 
   794                              <1> .more_odd:
   795 00001F4B 43                  <1> 	inc bx				; If not, bump our counter
   796 00001F4C 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
   797                              <1> 
   798 00001F4D AD                  <1> 	lodsw				; Get word
   799 00001F4E C1E804              <1> 	shr ax, 4			; Shift for odd
   800 00001F51 09C0                <1> 	or ax, ax			; Free entry?
   801 00001F53 7416                <1> 	jz .found_free_odd
   802                              <1> 
   803                              <1> .more_even:
   804 00001F55 43                  <1> 	inc bx				; If not, keep going
   805 00001F56 EBED                <1> 	jmp .find_free_cluster
   806                              <1> 
   807                              <1> 
   808                              <1> .found_free_even:
   809 00001F58 56                  <1> 	push si
   810 00001F59 BE[7C20]            <1> 	mov si, .free_clusters		; Store cluster
   811 00001F5C 01D6                <1> 	add si, dx
   812 00001F5E 891C                <1> 	mov word [si], bx
   813 00001F60 5E                  <1> 	pop si
   814                              <1> 
   815 00001F61 49                  <1> 	dec cx				; Got all the clusters we need?
   816 00001F62 83F900              <1> 	cmp cx, 0
   817 00001F65 7417                <1> 	je .finished_list
   818                              <1> 
   819 00001F67 42                  <1> 	inc dx				; Next word in our list
   820 00001F68 42                  <1> 	inc dx
   821 00001F69 EBE0                <1> 	jmp .more_odd
   822                              <1> 
   823                              <1> .found_free_odd:
   824 00001F6B 56                  <1> 	push si
   825 00001F6C BE[7C20]            <1> 	mov si, .free_clusters		; Store cluster
   826 00001F6F 01D6                <1> 	add si, dx
   827 00001F71 891C                <1> 	mov word [si], bx
   828 00001F73 5E                  <1> 	pop si
   829                              <1> 
   830 00001F74 49                  <1> 	dec cx
   831 00001F75 83F900              <1> 	cmp cx, 0
   832 00001F78 7404                <1> 	je .finished_list
   833                              <1> 
   834 00001F7A 42                  <1> 	inc dx				; Next word in our list
   835 00001F7B 42                  <1> 	inc dx
   836 00001F7C EBD7                <1> 	jmp .more_even
   837                              <1> 
   838                              <1> 
   839                              <1> 
   840                              <1> .finished_list:
   841                              <1> 
   842                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
   843                              <1> 	; that correspond to free clusters on the disk; the next job is to
   844                              <1> 	; create a cluster chain in the FAT for our file
   845                              <1> 
   846 00001F7E B90000              <1> 	mov cx, 0			; .free_clusters offset counter
   847 00001F81 C706[7420]0100      <1> 	mov word [.count], 1		; General cluster counter
   848                              <1> 
   849                              <1> .chain_loop:
   850 00001F87 A1[7420]            <1> 	mov word ax, [.count]		; Is this the last cluster?
   851 00001F8A 3B06[7820]          <1> 	cmp word ax, [.clusters_needed]
   852 00001F8E 7455                <1> 	je .last_cluster
   853                              <1> 
   854 00001F90 BF[7C20]            <1> 	mov di, .free_clusters
   855                              <1> 
   856 00001F93 01CF                <1> 	add di, cx
   857 00001F95 8B1D                <1> 	mov word bx, [di]		; Get cluster
   858                              <1> 
   859 00001F97 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
   860 00001F99 BA0000              <1> 	mov dx, 0
   861 00001F9C BB0300              <1> 	mov bx, 3
   862 00001F9F F7E3                <1> 	mul bx
   863 00001FA1 BB0200              <1> 	mov bx, 2
   864 00001FA4 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   865 00001FA6 BE0060              <1> 	mov si, disk_buffer
   866 00001FA9 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   867 00001FAB 3E8B04              <1> 	mov ax, word [ds:si]
   868                              <1> 
   869 00001FAE 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   870 00001FB0 741B                <1> 	jz .even
   871                              <1> 
   872                              <1> .odd:
   873 00001FB2 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
   874 00001FB5 BF[7C20]            <1> 	mov di, .free_clusters
   875 00001FB8 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   876 00001FBA 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
   877 00001FBD C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
   878 00001FC0 01D8                <1> 	add ax, bx
   879                              <1> 
   880 00001FC2 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   881                              <1> 
   882 00001FC5 FF06[7420]          <1> 	inc word [.count]
   883 00001FC9 41                  <1> 	inc cx				; Move on a word in .free_clusters
   884 00001FCA 41                  <1> 	inc cx
   885                              <1> 
   886 00001FCB EBBA                <1> 	jmp .chain_loop
   887                              <1> 
   888                              <1> .even:
   889 00001FCD 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
   890 00001FD0 BF[7C20]            <1> 	mov di, .free_clusters
   891 00001FD3 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   892 00001FD5 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
   893                              <1> 
   894 00001FD8 01D8                <1> 	add ax, bx
   895                              <1> 
   896 00001FDA 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   897                              <1> 
   898 00001FDD FF06[7420]          <1> 	inc word [.count]
   899 00001FE1 41                  <1> 	inc cx				; Move on a word in .free_clusters
   900 00001FE2 41                  <1> 	inc cx
   901                              <1> 
   902 00001FE3 EBA2                <1> 	jmp .chain_loop
   903                              <1> 
   904                              <1> 
   905                              <1> 
   906                              <1> .last_cluster:
   907 00001FE5 BF[7C20]            <1> 	mov di, .free_clusters
   908 00001FE8 01CF                <1> 	add di, cx
   909 00001FEA 8B1D                <1> 	mov word bx, [di]		; Get cluster
   910                              <1> 
   911 00001FEC 89D8                <1> 	mov ax, bx
   912                              <1> 
   913 00001FEE BA0000              <1> 	mov dx, 0
   914 00001FF1 BB0300              <1> 	mov bx, 3
   915 00001FF4 F7E3                <1> 	mul bx
   916 00001FF6 BB0200              <1> 	mov bx, 2
   917 00001FF9 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   918 00001FFB BE0060              <1> 	mov si, disk_buffer
   919 00001FFE 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   920 00002000 3E8B04              <1> 	mov ax, word [ds:si]
   921                              <1> 
   922 00002003 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   923 00002005 7408                <1> 	jz .even_last
   924                              <1> 
   925                              <1> .odd_last:
   926 00002007 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
   927 0000200A 83C080              <1> 	add ax, 0FF80h
   928 0000200D EB06                <1> 	jmp .finito
   929                              <1> 
   930                              <1> .even_last:
   931 0000200F 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
   932 00002012 05F80F              <1> 	add ax, 0FF8h
   933                              <1> 
   934                              <1> 
   935                              <1> .finito:
   936 00002015 3E8904              <1> 	mov word [ds:si], ax
   937                              <1> 
   938 00002018 E8B403              <1> 	call disk_write_fat		; Save our FAT back to disk
   939                              <1> 
   940                              <1> 
   941                              <1> 	; Now it's time to save the sectors to disk!
   942                              <1> 
   943 0000201B B90000              <1> 	mov cx, 0
   944                              <1> 
   945                              <1> .save_loop:
   946 0000201E BF[7C20]            <1> 	mov di, .free_clusters
   947 00002021 01CF                <1> 	add di, cx
   948 00002023 8B05                <1> 	mov word ax, [di]
   949                              <1> 
   950 00002025 83F800              <1> 	cmp ax, 0
   951 00002028 0F841D00            <1> 	je near .write_root_entry
   952                              <1> 
   953 0000202C 60                  <1> 	pusha
   954                              <1> 
   955 0000202D 83C01F              <1> 	add ax, 31
   956                              <1> 
   957 00002030 E81404              <1> 	call disk_convert_l2hts
   958                              <1> 
   959 00002033 8B1E[7620]          <1> 	mov word bx, [.location]
   960                              <1> 
   961 00002037 B403                <1> 	mov ah, 3
   962 00002039 B001                <1> 	mov al, 1
   963 0000203B F9                  <1> 	stc
   964 0000203C CD13                <1> 	int 13h
   965                              <1> 
   966 0000203E 61                  <1> 	popa
   967                              <1> 
   968 0000203F 8106[7620]0002      <1> 	add word [.location], 512
   969 00002045 41                  <1> 	inc cx
   970 00002046 41                  <1> 	inc cx
   971 00002047 EBD5                <1> 	jmp .save_loop
   972                              <1> 
   973                              <1> 
   974                              <1> .write_root_entry:
   975                              <1> 
   976                              <1> 	; Now it's time to head back to the root directory, find our
   977                              <1> 	; entry and update it with the cluster in use and file size
   978                              <1> 
   979 00002049 E8A203              <1> 	call disk_read_root_dir
   980                              <1> 
   981 0000204C A1[7A20]            <1> 	mov word ax, [.filename]
   982 0000204F E81903              <1> 	call disk_get_root_entry
   983                              <1> 
   984 00002052 A1[7C20]            <1> 	mov word ax, [.free_clusters]	; Get first free cluster
   985                              <1> 
   986 00002055 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
   987                              <1> 
   988 00002058 8B0E[7020]          <1> 	mov word cx, [.filesize]
   989 0000205C 894D1C              <1> 	mov word [di+28], cx
   990                              <1> 
   991 0000205F C6451E00            <1> 	mov byte [di+30], 0		; File size
   992 00002063 C6451F00            <1> 	mov byte [di+31], 0
   993                              <1> 
   994 00002067 E8AF03              <1> 	call disk_write_root_dir
   995                              <1> 
   996                              <1> .finished:
   997 0000206A 61                  <1> 	popa
   998 0000206B F8                  <1> 	clc
   999 0000206C C3                  <1> 	ret
  1000                              <1> 
  1001                              <1> .failure:
  1002 0000206D 61                  <1> 	popa
  1003 0000206E F9                  <1> 	stc				; Couldn't write!
  1004 0000206F C3                  <1> 	ret
  1005                              <1> 
  1006                              <1> 
  1007 00002070 0000                <1> 	.filesize	dw 0
  1008 00002072 0000                <1> 	.cluster	dw 0
  1009 00002074 0000                <1> 	.count		dw 0
  1010 00002076 0000                <1> 	.location	dw 0
  1011                              <1> 
  1012 00002078 0000                <1> 	.clusters_needed	dw 0
  1013                              <1> 
  1014 0000207A 0000                <1> 	.filename	dw 0
  1015                              <1> 
  1016 0000207C 0000<rep 80h>       <1> 	.free_clusters	times 128 dw 0
  1017                              <1> 
  1018                              <1> 
  1019                              <1> ; --------------------------------------------------------------------------
  1020                              <1> ; os_file_exists -- Check for presence of file on the floppy
  1021                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
  1022                              <1> 
  1023                              <1> os_file_exists:
  1024 0000217C E83EEC              <1> 	call string_uppercase
  1025 0000217F E88501              <1> 	call int_filename_convert	; Make FAT12-style filename
  1026                              <1> 
  1027 00002182 50                  <1> 	push ax
  1028 00002183 E8E8EB              <1> 	call string_length
  1029 00002186 83F800              <1> 	cmp ax, 0
  1030 00002189 740D                <1> 	je .failure
  1031 0000218B 58                  <1> 	pop ax
  1032                              <1> 
  1033 0000218C 50                  <1> 	push ax
  1034 0000218D E85E02              <1> 	call disk_read_root_dir
  1035                              <1> 
  1036 00002190 58                  <1> 	pop ax				; Restore filename
  1037 00002191 BF0060              <1> 	mov di, disk_buffer
  1038 00002194 E8D401              <1> 	call disk_get_root_entry	; Set or clear carry flag
  1039                              <1> 	
  1040 00002197 C3                  <1> 	ret
  1041                              <1> 
  1042                              <1> .failure:
  1043 00002198 58                  <1> 	pop ax
  1044 00002199 F9                  <1> 	stc
  1045 0000219A C3                  <1> 	ret
  1046                              <1> 
  1047                              <1> 
  1048                              <1> ; --------------------------------------------------------------------------
  1049                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
  1050                              <1> ; IN: AX = location of filename
  1051                              <1> 
  1052                              <1> os_create_file:
  1053 0000219B F8                  <1> 	clc
  1054                              <1> 
  1055 0000219C E81EEC              <1> 	call string_uppercase
  1056 0000219F E86501              <1> 	call int_filename_convert	; Make FAT12-style filename
  1057 000021A2 60                  <1> 	pusha
  1058                              <1> 
  1059 000021A3 50                  <1> 	push ax				; Save filename for now
  1060                              <1> 
  1061 000021A4 E8D5FF              <1> 	call os_file_exists		; Does the file already exist?
  1062 000021A7 7315                <1> 	jnc .exists_error
  1063                              <1> 
  1064                              <1> 
  1065                              <1> 	; Root dir already read into disk_buffer by os_file_exists
  1066                              <1> 
  1067 000021A9 BF0060              <1> 	mov di, disk_buffer		; So point DI at it!
  1068                              <1> 
  1069                              <1> 
  1070 000021AC B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
  1071                              <1> .next_entry:
  1072 000021AF 8A05                <1> 	mov byte al, [di]
  1073 000021B1 3C00                <1> 	cmp al, 0			; Is this a free entry?
  1074 000021B3 740D                <1> 	je .found_free_entry
  1075 000021B5 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
  1076 000021B7 7409                <1> 	je .found_free_entry
  1077 000021B9 83C720              <1> 	add di, 32			; If not, go onto next entry
  1078 000021BC E2F1                <1> 	loop .next_entry
  1079                              <1> 
  1080                              <1> .exists_error:				; We also get here if above loop finds nothing
  1081 000021BE 58                  <1> 	pop ax				; Get filename back
  1082                              <1> 
  1083 000021BF 61                  <1> 	popa
  1084 000021C0 F9                  <1> 	stc				; Set carry for failure
  1085 000021C1 C3                  <1> 	ret
  1086                              <1> 
  1087                              <1> 
  1088                              <1> .found_free_entry:
  1089 000021C2 5E                  <1> 	pop si				; Get filename back
  1090 000021C3 B90B00              <1> 	mov cx, 11
  1091 000021C6 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
  1092                              <1> 
  1093                              <1> 
  1094 000021C8 83EF0B              <1> 	sub di, 11			; Back to start of root dir entry, for clarity
  1095                              <1> 
  1096                              <1> 
  1097 000021CB C6450B00            <1> 	mov byte [di+11], 0		; Attributes
  1098 000021CF C6450C00            <1> 	mov byte [di+12], 0		; Reserved
  1099 000021D3 C6450D00            <1> 	mov byte [di+13], 0		; Reserved
  1100 000021D7 C6450EC6            <1> 	mov byte [di+14], 0C6h		; Creation time
  1101 000021DB C6450F7E            <1> 	mov byte [di+15], 07Eh		; Creation time
  1102 000021DF C6451000            <1> 	mov byte [di+16], 0		; Creation date
  1103 000021E3 C6451100            <1> 	mov byte [di+17], 0		; Creation date
  1104 000021E7 C6451200            <1> 	mov byte [di+18], 0		; Last access date
  1105 000021EB C6451300            <1> 	mov byte [di+19], 0		; Last access date
  1106 000021EF C6451400            <1> 	mov byte [di+20], 0		; Ignore in FAT12
  1107 000021F3 C6451500            <1> 	mov byte [di+21], 0		; Ignore in FAT12
  1108 000021F7 C64516C6            <1> 	mov byte [di+22], 0C6h		; Last write time
  1109 000021FB C645177E            <1> 	mov byte [di+23], 07Eh		; Last write time
  1110 000021FF C6451800            <1> 	mov byte [di+24], 0		; Last write date
  1111 00002203 C6451900            <1> 	mov byte [di+25], 0		; Last write date
  1112 00002207 C6451A00            <1> 	mov byte [di+26], 0		; First logical cluster
  1113 0000220B C6451B00            <1> 	mov byte [di+27], 0		; First logical cluster
  1114 0000220F C6451C00            <1> 	mov byte [di+28], 0		; File size
  1115 00002213 C6451D00            <1> 	mov byte [di+29], 0		; File size
  1116 00002217 C6451E00            <1> 	mov byte [di+30], 0		; File size
  1117 0000221B C6451F00            <1> 	mov byte [di+31], 0		; File size
  1118                              <1> 
  1119 0000221F E8F701              <1> 	call disk_write_root_dir
  1120 00002222 7203                <1> 	jc .failure
  1121                              <1> 
  1122 00002224 61                  <1> 	popa
  1123 00002225 F8                  <1> 	clc				; Clear carry for success
  1124 00002226 C3                  <1> 	ret
  1125                              <1> 
  1126                              <1> .failure:
  1127 00002227 61                  <1> 	popa
  1128 00002228 F9                  <1> 	stc
  1129 00002229 C3                  <1> 	ret
  1130                              <1> 
  1131                              <1> 
  1132                              <1> ; --------------------------------------------------------------------------
  1133                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
  1134                              <1> ; IN: AX = location of filename to remove
  1135                              <1> 
  1136                              <1> os_remove_file:
  1137 0000222A 60                  <1> 	pusha
  1138 0000222B E88FEB              <1> 	call string_uppercase
  1139 0000222E E8D600              <1> 	call int_filename_convert	; Make filename FAT12-style
  1140 00002231 50                  <1> 	push ax				; Save filename
  1141                              <1> 
  1142 00002232 F8                  <1> 	clc
  1143                              <1> 
  1144 00002233 E8B801              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1145                              <1> 
  1146 00002236 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
  1147                              <1> 
  1148 00002239 58                  <1> 	pop ax				; Get chosen filename back
  1149                              <1> 
  1150 0000223A E82E01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1151 0000223D 7269                <1> 	jc .failure			; If entry can't be found
  1152                              <1> 
  1153                              <1> 
  1154 0000223F 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
  1155 00002243 A3[AB22]            <1> 	mov word [.cluster], ax		; And save it
  1156                              <1> 
  1157 00002246 C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
  1158                              <1> 
  1159 00002249 47                  <1> 	inc di
  1160                              <1> 
  1161 0000224A B90000              <1> 	mov cx, 0			; Set rest of data in root dir entry to zeros
  1162                              <1> .clean_loop:
  1163 0000224D C60500              <1> 	mov byte [di], 0
  1164 00002250 47                  <1> 	inc di
  1165 00002251 41                  <1> 	inc cx
  1166 00002252 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
  1167 00002255 7CF6                <1> 	jl .clean_loop
  1168                              <1> 
  1169 00002257 E8BF01              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
  1170                              <1> 
  1171                              <1> 
  1172 0000225A E84601              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
  1173 0000225D BF0060              <1> 	mov di, disk_buffer		; And DI points to it
  1174                              <1> 
  1175                              <1> 
  1176                              <1> .more_clusters:
  1177 00002260 A1[AB22]            <1> 	mov word ax, [.cluster]		; Get cluster contents
  1178                              <1> 
  1179 00002263 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
  1180 00002266 743D                <1> 	je .nothing_to_do
  1181                              <1> 
  1182 00002268 BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
  1183 0000226B F7E3                <1> 	mul bx
  1184 0000226D BB0200              <1> 	mov bx, 2
  1185 00002270 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
  1186 00002272 BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1187 00002275 01C6                <1> 	add si, ax
  1188 00002277 3E8B04              <1> 	mov ax, word [ds:si]
  1189                              <1> 
  1190 0000227A 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
  1191                              <1> 
  1192 0000227C 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
  1193                              <1> 					; with next cluster; if odd, drop first 4 bits
  1194                              <1> .odd:
  1195 0000227E 50                  <1> 	push ax
  1196 0000227F 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
  1197 00002282 3E8904              <1> 	mov word [ds:si], ax
  1198 00002285 58                  <1> 	pop ax
  1199                              <1> 
  1200 00002286 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
  1201 00002289 EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1202                              <1> 
  1203                              <1> .even:
  1204 0000228B 50                  <1> 	push ax
  1205 0000228C 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
  1206 0000228F 3E8904              <1> 	mov word [ds:si], ax
  1207 00002292 58                  <1> 	pop ax
  1208                              <1> 
  1209 00002293 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
  1210                              <1> 
  1211                              <1> .calculate_cluster_cont:
  1212 00002296 A3[AB22]            <1> 	mov word [.cluster], ax		; Store cluster
  1213                              <1> 
  1214 00002299 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
  1215 0000229C 7302                <1> 	jae .end
  1216                              <1> 
  1217 0000229E EBC0                <1> 	jmp .more_clusters		; If not, grab more
  1218                              <1> 
  1219                              <1> .end:
  1220 000022A0 E82C01              <1> 	call disk_write_fat
  1221 000022A3 7203                <1> 	jc .failure
  1222                              <1> 
  1223                              <1> .nothing_to_do:
  1224 000022A5 61                  <1> 	popa
  1225 000022A6 F8                  <1> 	clc
  1226 000022A7 C3                  <1> 	ret
  1227                              <1> 
  1228                              <1> .failure:
  1229 000022A8 61                  <1> 	popa
  1230 000022A9 F9                  <1> 	stc
  1231 000022AA C3                  <1> 	ret
  1232                              <1> 
  1233                              <1> 
  1234 000022AB 0000                <1> 	.cluster dw 0
  1235                              <1> 
  1236                              <1> 
  1237                              <1> ; --------------------------------------------------------------------------
  1238                              <1> ; os_rename_file -- Change the name of a file on the disk
  1239                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
  1240                              <1> ; OUT: carry set on error
  1241                              <1> 
  1242                              <1> os_rename_file:
  1243 000022AD 53                  <1> 	push bx
  1244 000022AE 50                  <1> 	push ax
  1245                              <1> 
  1246 000022AF F8                  <1> 	clc
  1247                              <1> 
  1248 000022B0 E83B01              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1249                              <1> 
  1250 000022B3 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
  1251                              <1> 
  1252 000022B6 58                  <1> 	pop ax				; Get chosen filename back
  1253                              <1> 
  1254 000022B7 E803EB              <1> 	call string_uppercase
  1255 000022BA E84A00              <1> 	call int_filename_convert
  1256                              <1> 
  1257 000022BD E8AB00              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1258 000022C0 7217                <1> 	jc .fail_read			; Quit out if file not found
  1259                              <1> 
  1260 000022C2 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
  1261                              <1> 
  1262 000022C3 89D8                <1> 	mov ax, bx
  1263                              <1> 
  1264 000022C5 E8F5EA              <1> 	call string_uppercase
  1265 000022C8 E83C00              <1> 	call int_filename_convert
  1266                              <1> 
  1267 000022CB 89C6                <1> 	mov si, ax
  1268                              <1> 
  1269 000022CD B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
  1270 000022D0 F3A4                <1> 	rep movsb
  1271                              <1> 
  1272 000022D2 E84401              <1> 	call disk_write_root_dir	; Save root dir to disk
  1273 000022D5 7205                <1> 	jc .fail_write
  1274                              <1> 
  1275 000022D7 F8                  <1> 	clc
  1276 000022D8 C3                  <1> 	ret
  1277                              <1> 
  1278                              <1> .fail_read:
  1279 000022D9 58                  <1> 	pop ax
  1280 000022DA F9                  <1> 	stc
  1281 000022DB C3                  <1> 	ret
  1282                              <1> 
  1283                              <1> .fail_write:
  1284 000022DC F9                  <1> 	stc
  1285 000022DD C3                  <1> 	ret
  1286                              <1> 
  1287                              <1> 
  1288                              <1> ; --------------------------------------------------------------------------
  1289                              <1> ; os_get_file_size -- Get file size information for specified file
  1290                              <1> ; IN: AX = filename; OUT: BX = file size in bytes (up to 64K)
  1291                              <1> ; or carry set if file not found
  1292                              <1> 
  1293                              <1> os_get_file_size:
  1294 000022DE 60                  <1> 	pusha
  1295                              <1> 
  1296 000022DF E8DBEA              <1> 	call string_uppercase
  1297 000022E2 E82200              <1> 	call int_filename_convert
  1298                              <1> 
  1299 000022E5 F8                  <1> 	clc
  1300                              <1> 
  1301 000022E6 50                  <1> 	push ax
  1302                              <1> 
  1303 000022E7 E80401              <1> 	call disk_read_root_dir
  1304 000022EA 7216                <1> 	jc .failure
  1305                              <1> 
  1306 000022EC 58                  <1> 	pop ax
  1307                              <1> 
  1308 000022ED BF0060              <1> 	mov di, disk_buffer
  1309                              <1> 
  1310 000022F0 E87800              <1> 	call disk_get_root_entry
  1311 000022F3 720D                <1> 	jc .failure
  1312                              <1> 
  1313 000022F5 8B5D1C              <1> 	mov word bx, [di+28]
  1314                              <1> 
  1315 000022F8 891E[0523]          <1> 	mov word [.tmp], bx
  1316                              <1> 
  1317 000022FC 61                  <1> 	popa
  1318                              <1> 
  1319 000022FD 8B1E[0523]          <1> 	mov word bx, [.tmp]
  1320                              <1> 
  1321 00002301 C3                  <1> 	ret
  1322                              <1> 
  1323                              <1> .failure:
  1324 00002302 61                  <1> 	popa
  1325 00002303 F9                  <1> 	stc
  1326 00002304 C3                  <1> 	ret
  1327                              <1> 
  1328                              <1> 
  1329 00002305 0000                <1> 	.tmp	dw 0
  1330                              <1> 
  1331                              <1> 
  1332                              <1> ; ==================================================================
  1333                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  1334                              <1> 
  1335                              <1> ; ------------------------------------------------------------------
  1336                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  1337                              <1> ; IN: AX = filename string
  1338                              <1> ; OUT: AX = location of converted string (carry set if invalid)
  1339                              <1> 
  1340                              <1> int_filename_convert:
  1341 00002307 60                  <1> 	pusha
  1342                              <1> 
  1343 00002308 89C6                <1> 	mov si, ax
  1344                              <1> 
  1345 0000230A E861EA              <1> 	call string_length
  1346 0000230D 83F80E              <1> 	cmp ax, 14			; Filename too long?
  1347 00002310 7F49                <1> 	jg .failure			; Fail if so
  1348                              <1> 
  1349 00002312 83F800              <1> 	cmp ax, 0
  1350 00002315 7444                <1> 	je .failure			; Similarly, fail if zero-char string
  1351                              <1> 
  1352 00002317 89C2                <1> 	mov dx, ax			; Store string length for now
  1353                              <1> 
  1354 00002319 BF[5E23]            <1> 	mov di, .dest_string
  1355                              <1> 
  1356 0000231C B90000              <1> 	mov cx, 0
  1357                              <1> .copy_loop:
  1358 0000231F AC                  <1> 	lodsb
  1359 00002320 3C2E                <1> 	cmp al, '.'
  1360 00002322 7408                <1> 	je .extension_found
  1361 00002324 AA                  <1> 	stosb
  1362 00002325 41                  <1> 	inc cx
  1363 00002326 39D1                <1> 	cmp cx, dx
  1364 00002328 7F31                <1> 	jg .failure			; No extension found = wrong
  1365 0000232A EBF3                <1> 	jmp .copy_loop
  1366                              <1> 
  1367                              <1> .extension_found:
  1368 0000232C 83F900              <1> 	cmp cx, 0
  1369 0000232F 742A                <1> 	je .failure			; Fail if extension dot is first char
  1370                              <1> 
  1371 00002331 83F908              <1> 	cmp cx, 8
  1372 00002334 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  1373                              <1> 
  1374                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  1375                              <1> 	; with spaces, if necessary
  1376                              <1> 
  1377                              <1> .add_spaces:
  1378 00002336 C60520              <1> 	mov byte [di], ' '
  1379 00002339 47                  <1> 	inc di
  1380 0000233A 41                  <1> 	inc cx
  1381 0000233B 83F908              <1> 	cmp cx, 8
  1382 0000233E 7CF6                <1> 	jl .add_spaces
  1383                              <1> 
  1384                              <1> 	; Finally, copy over the extension
  1385                              <1> .do_extension:
  1386 00002340 AC                  <1> 	lodsb				; 3 characters
  1387 00002341 3C00                <1> 	cmp al, 0
  1388 00002343 7416                <1> 	je .failure
  1389 00002345 AA                  <1> 	stosb
  1390 00002346 AC                  <1> 	lodsb
  1391 00002347 3C00                <1> 	cmp al, 0
  1392 00002349 7410                <1> 	je .failure
  1393 0000234B AA                  <1> 	stosb
  1394 0000234C AC                  <1> 	lodsb
  1395 0000234D 3C00                <1> 	cmp al, 0
  1396 0000234F 740A                <1> 	je .failure
  1397 00002351 AA                  <1> 	stosb
  1398                              <1> 
  1399 00002352 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  1400                              <1> 
  1401 00002355 61                  <1> 	popa
  1402 00002356 B8[5E23]            <1> 	mov ax, .dest_string
  1403 00002359 F8                  <1> 	clc				; Clear carry for success
  1404 0000235A C3                  <1> 	ret
  1405                              <1> 
  1406                              <1> 
  1407                              <1> .failure:
  1408 0000235B 61                  <1> 	popa
  1409 0000235C F9                  <1> 	stc				; Set carry for failure
  1410 0000235D C3                  <1> 	ret
  1411                              <1> 
  1412                              <1> 
  1413 0000235E 00<rep Dh>          <1> 	.dest_string	times 13 db 0
  1414                              <1> 
  1415                              <1> 
  1416                              <1> ; --------------------------------------------------------------------------
  1417                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  1418                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  1419                              <1> ; or carry set if file not found
  1420                              <1> 
  1421                              <1> disk_get_root_entry:
  1422 0000236B 60                  <1> 	pusha
  1423                              <1> 
  1424 0000236C A3[9F23]            <1> 	mov word [.filename], ax
  1425                              <1> 
  1426 0000236F B9E000              <1> 	mov cx, 224			; Search all (224) entries
  1427 00002372 B80000              <1> 	mov ax, 0			; Searching at offset 0
  1428                              <1> 
  1429                              <1> .to_next_root_entry:
  1430 00002375 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  1431                              <1> 
  1432 00002377 8B36[9F23]          <1> 	mov word si, [.filename]	; Start searching for filename
  1433 0000237B B90B00              <1> 	mov cx, 11
  1434 0000237E F3A6                <1> 	rep cmpsb
  1435 00002380 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  1436                              <1> 
  1437 00002382 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  1438                              <1> 
  1439 00002385 BF0060              <1> 	mov di, disk_buffer		; Point to next root dir entry
  1440 00002388 01C7                <1> 	add di, ax
  1441                              <1> 
  1442 0000238A 87D1                <1> 	xchg dx, cx			; Get the original CX back
  1443 0000238C E2E7                <1> 	loop .to_next_root_entry
  1444                              <1> 
  1445 0000238E 61                  <1> 	popa
  1446                              <1> 
  1447 0000238F F9                  <1> 	stc				; Set carry if entry not found
  1448 00002390 C3                  <1> 	ret
  1449                              <1> 
  1450                              <1> 
  1451                              <1> .found_file:
  1452 00002391 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  1453                              <1> 
  1454 00002394 893E[A123]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  1455                              <1> 
  1456 00002398 61                  <1> 	popa
  1457                              <1> 
  1458 00002399 8B3E[A123]          <1> 	mov word di, [.tmp]
  1459                              <1> 
  1460 0000239D F8                  <1> 	clc
  1461 0000239E C3                  <1> 	ret
  1462                              <1> 
  1463                              <1> 
  1464 0000239F 0000                <1> 	.filename	dw 0
  1465 000023A1 0000                <1> 	.tmp		dw 0
  1466                              <1> 
  1467                              <1> 
  1468                              <1> ; --------------------------------------------------------------------------
  1469                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  1470                              <1> ; IN: Nothing; OUT: carry set if failure
  1471                              <1> 
  1472                              <1> disk_read_fat:
  1473 000023A3 60                  <1> 	pusha
  1474                              <1> 
  1475 000023A4 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1476 000023A7 E89D00              <1> 	call disk_convert_l2hts
  1477                              <1> 
  1478 000023AA BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1479 000023AD BB0020              <1> 	mov bx, 2000h
  1480 000023B0 8EC3                <1> 	mov es, bx
  1481 000023B2 89F3                <1> 	mov bx, si
  1482                              <1> 
  1483 000023B4 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1484 000023B6 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  1485                              <1> 
  1486 000023B8 60                  <1> 	pusha				; Prepare to enter loop
  1487                              <1> 
  1488                              <1> 
  1489                              <1> .read_fat_loop:
  1490 000023B9 61                  <1> 	popa
  1491 000023BA 60                  <1> 	pusha
  1492                              <1> 
  1493 000023BB F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1494 000023BC CD13                <1> 	int 13h				; Read sectors
  1495                              <1> 
  1496 000023BE 7308                <1> 	jnc .fat_done
  1497 000023C0 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  1498 000023C3 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  1499                              <1> 
  1500 000023C5 61                  <1> 	popa
  1501 000023C6 EB04                <1> 	jmp .read_failure		; Fatal double error
  1502                              <1> 
  1503                              <1> .fat_done:
  1504 000023C8 61                  <1> 	popa				; Restore registers from main loop
  1505                              <1> 
  1506 000023C9 61                  <1> 	popa				; And restore registers from start of system call
  1507 000023CA F8                  <1> 	clc
  1508 000023CB C3                  <1> 	ret
  1509                              <1> 
  1510                              <1> .read_failure:
  1511 000023CC 61                  <1> 	popa
  1512 000023CD F9                  <1> 	stc				; Set carry flag (for failure)
  1513 000023CE C3                  <1> 	ret
  1514                              <1> 
  1515                              <1> 
  1516                              <1> ; --------------------------------------------------------------------------
  1517                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  1518                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  1519                              <1> 
  1520                              <1> disk_write_fat:
  1521 000023CF 60                  <1> 	pusha
  1522                              <1> 
  1523 000023D0 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1524 000023D3 E87100              <1> 	call disk_convert_l2hts
  1525                              <1> 
  1526 000023D6 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1527 000023D9 8CDB                <1> 	mov bx, ds
  1528 000023DB 8EC3                <1> 	mov es, bx
  1529 000023DD 89F3                <1> 	mov bx, si
  1530                              <1> 
  1531 000023DF B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1532 000023E1 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  1533                              <1> 
  1534 000023E3 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1535 000023E4 CD13                <1> 	int 13h				; Write sectors
  1536                              <1> 
  1537 000023E6 7203                <1> 	jc .write_failure		; Fatal double error
  1538                              <1> 
  1539 000023E8 61                  <1> 	popa				; And restore from start of system call
  1540 000023E9 F8                  <1> 	clc
  1541 000023EA C3                  <1> 	ret
  1542                              <1> 
  1543                              <1> .write_failure:
  1544 000023EB 61                  <1> 	popa
  1545 000023EC F9                  <1> 	stc				; Set carry flag (for failure)
  1546 000023ED C3                  <1> 	ret
  1547                              <1> 
  1548                              <1> 
  1549                              <1> ; --------------------------------------------------------------------------
  1550                              <1> ; disk_read_root_dir -- Get the root directory contents
  1551                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  1552                              <1> 
  1553                              <1> disk_read_root_dir:
  1554 000023EE 60                  <1> 	pusha
  1555                              <1> 
  1556 000023EF B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1557 000023F2 E85200              <1> 	call disk_convert_l2hts
  1558                              <1> 
  1559 000023F5 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1560 000023F8 8CDB                <1> 	mov bx, ds
  1561 000023FA 8EC3                <1> 	mov es, bx
  1562 000023FC 89F3                <1> 	mov bx, si
  1563                              <1> 
  1564 000023FE B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1565 00002400 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  1566                              <1> 
  1567 00002402 60                  <1> 	pusha				; Prepare to enter loop
  1568                              <1> 
  1569                              <1> 
  1570                              <1> .read_root_dir_loop:
  1571 00002403 61                  <1> 	popa
  1572 00002404 60                  <1> 	pusha
  1573                              <1> 
  1574 00002405 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1575 00002406 CD13                <1> 	int 13h				; Read sectors
  1576                              <1> 
  1577 00002408 7308                <1> 	jnc .root_dir_finished
  1578 0000240A E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  1579 0000240D 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  1580                              <1> 
  1581 0000240F 61                  <1> 	popa
  1582 00002410 EB04                <1> 	jmp .read_failure		; Fatal double error
  1583                              <1> 
  1584                              <1> 
  1585                              <1> .root_dir_finished:
  1586 00002412 61                  <1> 	popa				; Restore registers from main loop
  1587                              <1> 
  1588 00002413 61                  <1> 	popa				; And restore from start of this system call
  1589 00002414 F8                  <1> 	clc				; Clear carry (for success)
  1590 00002415 C3                  <1> 	ret
  1591                              <1> 
  1592                              <1> .read_failure:
  1593 00002416 61                  <1> 	popa
  1594 00002417 F9                  <1> 	stc				; Set carry flag (for failure)
  1595 00002418 C3                  <1> 	ret
  1596                              <1> 
  1597                              <1> 
  1598                              <1> ; --------------------------------------------------------------------------
  1599                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  1600                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  1601                              <1> 
  1602                              <1> disk_write_root_dir:
  1603 00002419 60                  <1> 	pusha
  1604                              <1> 
  1605 0000241A B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1606 0000241D E82700              <1> 	call disk_convert_l2hts
  1607                              <1> 
  1608 00002420 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1609 00002423 8CDB                <1> 	mov bx, ds
  1610 00002425 8EC3                <1> 	mov es, bx
  1611 00002427 89F3                <1> 	mov bx, si
  1612                              <1> 
  1613 00002429 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1614 0000242B B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  1615                              <1> 
  1616 0000242D F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1617 0000242E CD13                <1> 	int 13h				; Write sectors
  1618 00002430 7203                <1> 	jc .write_failure
  1619                              <1> 
  1620 00002432 61                  <1> 	popa				; And restore from start of this system call
  1621 00002433 F8                  <1> 	clc
  1622 00002434 C3                  <1> 	ret
  1623                              <1> 
  1624                              <1> .write_failure:
  1625 00002435 61                  <1> 	popa
  1626 00002436 F9                  <1> 	stc				; Set carry flag (for failure)
  1627 00002437 C3                  <1> 	ret
  1628                              <1> 
  1629                              <1> 
  1630                              <1> ; --------------------------------------------------------------------------
  1631                              <1> ; Reset floppy disk
  1632                              <1> 
  1633                              <1> disk_reset_floppy:
  1634 00002438 50                  <1> 	push ax
  1635 00002439 52                  <1> 	push dx
  1636 0000243A B80000              <1> 	mov ax, 0
  1637                              <1> ; ******************************************************************
  1638 0000243D 8A16[7624]          <1> 	mov dl, [bootdev]
  1639                              <1> ; ******************************************************************
  1640 00002441 F9                  <1> 	stc
  1641 00002442 CD13                <1> 	int 13h
  1642 00002444 5A                  <1> 	pop dx
  1643 00002445 58                  <1> 	pop ax
  1644 00002446 C3                  <1> 	ret
  1645                              <1> 
  1646                              <1> 
  1647                              <1> ; --------------------------------------------------------------------------
  1648                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  1649                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  1650                              <1> 
  1651                              <1> disk_convert_l2hts:
  1652 00002447 53                  <1> 	push bx
  1653 00002448 50                  <1> 	push ax
  1654                              <1> 
  1655 00002449 89C3                <1> 	mov bx, ax			; Save logical sector
  1656                              <1> 
  1657 0000244B BA0000              <1> 	mov dx, 0			; First the sector
  1658 0000244E F736[7424]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1659 00002452 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  1660 00002455 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  1661 00002457 89D8                <1> 	mov ax, bx
  1662                              <1> 
  1663 00002459 BA0000              <1> 	mov dx, 0			; Now calculate the head
  1664 0000245C F736[7424]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1665 00002460 BA0000              <1> 	mov dx, 0
  1666 00002463 F736[7224]          <1> 	div word [Sides]		; Floppy sides
  1667 00002467 88D6                <1> 	mov dh, dl			; Head/side
  1668 00002469 88C5                <1> 	mov ch, al			; Track
  1669                              <1> 
  1670 0000246B 58                  <1> 	pop ax
  1671 0000246C 5B                  <1> 	pop bx
  1672                              <1> 
  1673                              <1> ; ******************************************************************
  1674 0000246D 8A16[7624]          <1> 	mov dl, [bootdev]		; Set correct device
  1675                              <1> ; ******************************************************************
  1676                              <1> 
  1677 00002471 C3                  <1> 	ret
  1678                              <1> 
  1679                              <1> 
  1680 00002472 0200                <1> 	Sides dw 2
  1681 00002474 1200                <1> 	SecsPerTrack dw 18
  1682                              <1> ; ******************************************************************
  1683 00002476 00                  <1> 	bootdev db 0			; Boot device number
  1684                              <1> ; ******************************************************************
  1685                              <1> ; ==================================================================
   372                                      %include "./includes/checkin.asm"
   373                              <1> check_com:      ; AX = command
   374 00002477 BE[A101]            <1>     mov si, in_buffer
   375 0000247A 89C7                <1>     mov di, ax
   376                              <1> 
   377                              <1> .check_loop:
   378 0000247C AC                  <1>     lodsb
   379 0000247D 3A05                <1>     cmp al, [di]
   380 0000247F 7509                <1>     jne .not_equal
   381                              <1>     
   382 00002481 B000                <1>     mov al, 0
   383 00002483 3805                <1>     cmp [di], al
   384 00002485 7405                <1>     je .done
   385                              <1> 
   386 00002487 47                  <1>     inc di
   387 00002488 EBF2                <1>     jmp .check_loop
   388                              <1> 
   389                              <1> .not_equal:
   390 0000248A F9                  <1>     stc
   391 0000248B C3                  <1>     ret
   392                              <1> 
   393                              <1> .done:
   394 0000248C F8                  <1>     clc
   395 0000248D C3                  <1>     ret
   373                                  
   374                                  ; ==================================================================
   375                                  ; END OF KERNEL
   376                                  ; ==================================================================
