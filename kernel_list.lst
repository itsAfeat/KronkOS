     1                                  ; ==================================================================
     2                                  ; The Kronk Operating System kernel
     3                                  ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                                  ;
     5                                  ; This is loaded from the drive by BOOTLOAD.BIN, as KERNEL.BIN
     6                                  ; ==================================================================
     7                                  
     8                                      ORG 0x0000
     9                                      BITS 16
    10                                  
    11                                      %define KRONKOS_VER '0.3.2'
    12                                      %define KRONKOS_API 4
    13                                  
    14 00000000 EB00                        jmp kernel_start
    15                                  
    16                                      ; Screen mouse clamps
    17                                      screenmaxW      equ 0x004E
    18                                      screenminW      equ 0x0001
    19                                      screenmaxH      equ 0x0017
    20                                      screenminH      equ 0x0001
    21                                      
    22                                      ; Mouse buttons
    23                                      leftMButton     equ 0x09
    24                                      rightMButton    equ 0x0A
    25                                  
    26                                      ; Screen modes
    27                                      vidRes          equ 0x13
    28                                      cliRes          equ 0x03
    29                                      
    30                                      ; RAM location for kernel disk operations
    31                                      disk_buffer     equ 24576
    32                                  
    33                                  ; ******************************************************************
    34                                  ; Start the kernel
    35                                  kernel_start:
    36 00000002 E80219                      call seed_random
    37                                  
    38 00000005 FA                          cli                         ; Clear interrupts
    39 00000006 B80020                      mov ax, 0x2000              ; The bootloader loads us at 0x2000
    40 00000009 8ED8                        mov ds, ax                  ; Set DS and ES to 0x2000
    41 0000000B 8EC0                        mov es, ax
    42                                  
    43                                      ; Stack just below 0x2000:0x0000 starting at 0x1000:0x0000.
    44                                      ; First push will set SS:SP to 0x1000:0xfffe because SP will wrap.
    45 0000000D B80010                      mov ax, 0x1000
    46 00000010 8ED0                        mov ss, ax
    47 00000012 31E4                        xor sp, sp
    48                                  
    49 00000014 FC                          cld                         ; Clear Direction Flag (DF=0 is for forward string movement)
    50                                  ; ******************************************************************
    51                                  
    52                                  ; ------------------------------------------------------------------
    53                                  ; KERNEL CODE START
    54                                  RESET:
    55 00000015 31C0                    	xor ax, ax
    56 00000017 31DB                    	xor bx, bx
    57 00000019 31C9                    	xor cx, cx
    58 0000001B 31D2                    	xor dx, dx
    59 0000001D 31F6                    	xor si, si
    60 0000001F 31FF                    	xor di, di
    61                                  
    62                                      ; Change the cursor to a solid block
    63 00000021 B500                        mov ch, 0x00
    64 00000023 E8ED0F                      call change_cursor
    65                                  
    66                                      ; Check if SETTINGS.KSF exists
    67 00000026 B8[1502]                    mov ax, settings_filename
    68 00000029 E8AE1F                      call os_file_exists
    69 0000002C 7311                        jnc .skip_setup     ; If it does... skip the setup
    70                                  
    71 0000002E E80B09                      call setup_init
    72                                  
    73                                      ; Save the settings
    74 00000031 B8[1502]                    mov ax, settings_filename
    75 00000034 BB0080                      mov bx, 32768
    76 00000037 B9[7600]                    mov cx, usrNam
    77 0000003A E8EF1C                      call os_write_file
    78                                  
    79 0000003D EBD6                        jmp RESET
    80                                  
    81                                  .skip_setup:
    82                                      ; Load the settings file
    83 0000003F B8[1502]                    mov ax, settings_filename
    84 00000042 B90080                      mov cx, 32768
    85 00000045 31DB                        xor bx, bx
    86 00000047 E8A31B                      call os_load_file
    87                                  
    88 0000004A 89DE                        mov si, bx
    89 0000004C BF[7600]                    mov di, usrNam
    90 0000004F E8100C                      call string_copy
    91                                  
    92 00000052 8A26[8B00]                  mov ah, [vidMode]
    93 00000056 80FC00                      cmp ah, 0
    94 00000059 7405                        je .startCli
    95 0000005B 80FC01                      cmp ah, 1
    96 0000005E 7405                        je .startVideo
    97                                  
    98                                  .startCli:
    99 00000060 E8C303                      call kronk_cli
   100 00000063 EBFE                        jmp $
   101                                  
   102                                  .startVideo:
   103 00000065 E8B108                      call kronk_vid
   104 00000068 EBFE                        jmp $
   105                                  
   106                                  ; ------------------------------------------------------------------
   107                                  ; STRINGS AND OTHER VARIABLES
   108                                  
   109                                      ; DEBUG VARIABLES START
   110 0000006A 4D653F20476F6E6761-         tmp:                db "Me? Gongaga", 0
   110 00000073 676100             
   111                                      ; END
   112                                  
   113                                      ; USER RELATED VARIABLES START
   114 00000076 00<rept>                    usrNam:             times 21 db 0
   115                                  
   116 0000008B 0000                        vidMode:            dw 0x00
   117                                      cli_color:          equ 0x0f
   118                                      vid_backcolor:      equ 0x01
   119                                      vid_forecolor:      equ 0x0f
   120                                      ; END
   121                                  
   122                                      ; TMP VARIABLES START
   123 0000008D 4D4F555345204C4546-         mouse_left:         db "MOUSE LEFT", 0
   123 00000096 5400               
   124 00000098 4D4F55534520524947-         mouse_right:        db "MOUSE RIGHT", 0
   124 000000A1 485400             
   125                                      ; END
   126                                  
   127                                      ; CLI SPECIFIC VARIABLES START
   128 000000A4 3A3E2000                	in_msg:				db ":> ", 0
   129 000000A8 00<rept>                	in_buffer: 			times 41 db 0
   130 000000D1 206973206E6F74206B-         not_com:            db " is not known command", 0x0a, 0x0d, 0
   130 000000DA 6E6F776E20636F6D6D-
   130 000000E3 616E640A0D00       
   131                                      ; END
   132                                  
   133                                      ; CLI COMMANDS START
   134 000000E9 7265737461727400            restart_com:        db "restart", 0
   135 000000F1 73687574646F776E00          shutdown_com:       db "shutdown", 0
   136 000000FA 73657474696E677300          settings_com:       db "settings", 0
   137 00000103 636C65617200                clear_com:          db "clear", 0
   138 00000109 64697200                    dir_com:            db "dir", 0
   139 0000010D 68656C7000                  help_com:           db "help", 0
   140 00000112 6564697400                  edit_com:           db "edit", 0
   141 00000117 6C6F616400                  load_com:           db "load", 0
   142 0000011C 6D6B00                      mk_com:             db "mk", 0
   143 0000011F 726D00                      rm_com:             db "rm", 0
   144                                      ; END
   145                                  
   146                                      ; MOUSE VARIABLES START
   147 00000122 4D4F55534520495320-         mouse_yes:          db "MOUSE IS CONNECTED!", 0
   147 0000012B 434F4E4E4543544544-
   147 00000134 2100               
   148 00000136 4D4F55534520495320-         mouse_no:           db "MOUSE IS NOT CONNECTED!", 0
   148 0000013F 4E4F5420434F4E4E45-
   148 00000148 435445442100       
   149                                      ; END
   150                                  
   151                                      ; WELCOME SCREEN VARIABLES START
   152 0000014E 0A0D204B726F6E6B4F-     	welcome_msg1:		db 0x0a, 0x0d, " KronkOS ver. ", KRONKOS_VER
   152 00000157 53207665722E20302E-
   152 00000160 332E32             
   153 00000163 20<rept>                						times 44-18 db " "
   154 0000017D 0A0D2000                						db 0x0a, 0x0d, " ", 0
   155 00000181 204B696C6F20427974-     	welcome_msg2:		db " Kilo Bytes of total memory available. ", 0x0a, 0x0d, 0
   155 0000018A 6573206F6620746F74-
   155 00000193 616C206D656D6F7279-
   155 0000019C 20617661696C61626C-
   155 000001A5 652E200A0D00       
   156 000001AB 20<rept>                	welcome_msg3:		times 45 db " "
   157 000001D8 0A0D20547970652027-     						db 0x0a, 0x0d, " Type 'help' and press enter to start off.   ", 0x0a, 0x0d, 0
   157 000001E1 68656C702720616E64-
   157 000001EA 20707265737320656E-
   157 000001F3 74657220746F207374-
   157 000001FC 617274206F66662E20-
   157 00000205 20200A0D00         
   158                                  	; END
   159                                  
   160                                      ; FILE RELATED VARIABLES START
   161 0000020A 4B45524E454C2E4249-     	kern_filename:		db 'KERNEL.BIN', 0
   161 00000213 4E00               
   162 00000215 53455454494E47532E-         settings_filename:  db 'SETTINGS.KSF', 0
   162 0000021E 4B534600           
   163                                  
   164 00000222 424B46                  	bin_ext:			db 'BKF'
   165 00000225 424153                  	bas_ext:			db 'BAS'
   166 00000228 556E6B6E6F776E2065-     	err1_ext:			db "Unknown extension", 0
   166 00000231 7874656E73696F6E00 
   167 0000023A 4F6E6C79202E424B46-     	err2_ext:			db "Only .BKF and .BAS is allowed", 0
   167 00000243 20616E64202E424153-
   167 0000024C 20697320616C6C6F77-
   167 00000255 656400             
   168 00000258 4572726F72206C6F61-     	err3_ext:			db "Error loading file", 0
   168 00000261 64696E672066696C65-
   168 0000026A 00                 
   169 0000026B 596F752063616E2774-     	err4_ext:			db "You can't load KERNEL.BIN", 0
   169 00000274 206C6F6164204B4552-
   169 0000027D 4E454C2E42494E00   
   170 00000285 596F752063616E2774-         err5_ext:           db "You can't load SETTINGS.KSF", 0
   170 0000028E 206C6F616420534554-
   170 00000297 54494E47532E4B5346-
   170 000002A0 00                 
   171                                      ; END
   172                                  
   173                                      ; OTHER VARIABLES START
   174 000002A1 00                      	fmt_12_24:			db 0 		; (Non-zero = 24 hour format)
   175 000002A2 012F                    	fmt_date:			db 1, '/'	; 0, 1, 2 = M/D/Y, D/M/Y or Y/M/D
   176                                  									; Bit 7 = use name for months
   177                                  									; If bit 7 = 0, second byte = separator character
   178                                  
   179 000002A4 0A0D00                  	new_line:			db 0x0a, 0x0d, 0
   180 000002A7 202D2D2000              	file_size_sep:		db " -- ", 0
   181 000002AC 2042797465730A0D00      	file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   182                                      ; END
   183                                  
   184                                      ; MENUBAR VARIABLES START
   185                                      mb_color:           equ 0x30
   186 000002B5 20<rept>                    mb_fill:            times 79 db " "
   187 00000304 00                                              db 0
   188                                      ; END
   189                                  
   190                                  ; ------------------------------------------------------------------
   191                                  ; INCLUDED FILES
   192                                  
   193                                      %include "./includes/settings_menu.asm"
     1                              <1> show_settings:
     2 00000305 60                  <1>     pusha
     3                              <1> 
     4                              <1> .main_menu:
     5 00000306 B8[7403]            <1>     mov ax, .main_options
     6 00000309 BB[8F03]            <1>     mov bx, .main_header
     7 0000030C B9[9803]            <1>     mov cx, .main_string
     8 0000030F E8BB13              <1>     call list_dialog
     9                              <1> 
    10 00000312 83F801              <1>     cmp ax, 1
    11 00000315 7402                <1>     je .display_menu
    12                              <1> 
    13 00000317 EB54                <1>     jmp .end
    14                              <1> 
    15                              <1> .display_menu:
    16 00000319 B8[B703]            <1>     mov ax, .display_options
    17 0000031C BB[D003]            <1>     mov bx, .display_header
    18 0000031F B9[DF03]            <1>     mov cx, .display_string
    19 00000322 E8A813              <1>     call list_dialog
    20                              <1> 
    21 00000325 83F801              <1>     cmp ax, 1
    22 00000328 7407                <1>     je .change_cli
    23                              <1> 
    24 0000032A 83F802              <1>     cmp ax, 2
    25 0000032D 7420                <1>     je .change_vid
    26                              <1> 
    27 0000032F EBD5                <1>     jmp .main_menu
    28                              <1> 
    29                              <1> .change_cli:
    30 00000331 B8[F503]            <1>     mov ax, .display_restart1
    31 00000334 BB[0F04]            <1>     mov bx, .display_restart2
    32 00000337 31C9                <1>     xor cx, cx
    33 00000339 BA0100              <1>     mov dx, 1
    34 0000033C E87B0D              <1>     call dialog_box
    35                              <1> 
    36 0000033F 85C0                <1>     test ax, ax
    37 00000341 75D6                <1>     jnz .display_menu
    38                              <1> 
    39                              <1> 
    40 00000343 C606[8B00]00        <1>     mov byte [vidMode], 0
    41 00000348 31C0                <1>     xor ax, ax
    42 0000034A CD13                <1>     int 0x13
    43 0000034C E9C6FC              <1>     jmp RESET
    44                              <1> 
    45                              <1> .change_vid:
    46 0000034F B8[F503]            <1>     mov ax, .display_restart1
    47 00000352 BB[0F04]            <1>     mov bx, .display_restart2
    48 00000355 31C9                <1>     xor cx, cx
    49 00000357 BA0100              <1>     mov dx, 1
    50 0000035A E85D0D              <1>     call dialog_box
    51                              <1> 
    52 0000035D 85C0                <1>     test ax, ax
    53 0000035F 75B8                <1>     jnz .display_menu
    54                              <1> 
    55 00000361 C606[8B00]01        <1>     mov byte [vidMode], 1
    56 00000366 31C0                <1>     xor ax, ax
    57 00000368 CD13                <1>     int 0x13
    58 0000036A E9A8FC              <1>     jmp RESET
    59                              <1> 
    60                              <1> .end:
    61 0000036D B70F                <1>     mov bh, cli_color
    62 0000036F E85108              <1>     call cls
    63                              <1> 
    64 00000372 61                  <1>     popa
    65 00000373 C3                  <1>     ret
    66                              <1> 
    67                              <1> 
    68 00000374 444953504C41592C    <1> .main_options:      db "DISPLAY,"
    69 0000037C 555345522C          <1>                     db "USER,"
    70 00000381 455849542053455454- <1>                     db "EXIT SETTINGS", 0
    70 0000038A 494E475300          <1>
    71 0000038F 53455454494E475300  <1> .main_header:       db "SETTINGS", 0
    72 00000398 4368616E6765207468- <1> .main_string:       db "Change the settings of KronkOS", 0
    72 000003A1 652073657474696E67- <1>
    72 000003AA 73206F66204B726F6E- <1>
    72 000003B3 6B4F5300            <1>
    73                              <1> 
    74 000003B7 434C49204D4F44452C  <1> .display_options:   db "CLI MODE,"
    75 000003C0 564944454F204D4F44- <1>                     db "VIDEO MODE,"
    75 000003C9 452C                <1>
    76 000003CB 4241434B00          <1>                     db "BACK", 0
    77 000003D0 564944454F20534554- <1> .display_header:    db "VIDEO SETTINGS", 0
    77 000003D9 54494E475300        <1>
    78 000003DF 4368616E6765207468- <1> .display_string:    db "Change the video mode", 0
    78 000003E8 6520766964656F206D- <1>
    78 000003F1 6F646500            <1>
    79 000003F5 546869732077696C6C- <1> .display_restart1:  db "This will restart KronkOS", 0
    79 000003FE 207265737461727420- <1>
    79 00000407 4B726F6E6B4F5300    <1>
    80 0000040F 507265737320274F4B- <1> .display_restart2:  db "Press 'OK' to continue", 0
    80 00000418 2720746F20636F6E74- <1>
    80 00000421 696E756500          <1>
   194                                      %include "./includes/cli.asm"
     1                              <1> kronk_cli:
     2 00000426 B80000              <1>     mov ax, 0
     3 00000429 B70F                <1>     mov bh, cli_color
     4 0000042B E8690E              <1>     call switch_mode
     5                              <1>     
     6                              <1>     ; Disable color blinking
     7 0000042E B80310              <1>     mov ax, 0x1003
     8 00000431 BB0000              <1>     mov bx, 0x0000
     9 00000434 CD10                <1>     int 0x10
    10                              <1> 
    11                              <1>     ; Draw welcome menu
    12 00000436 BE[4E01]            <1>     mov si, welcome_msg1
    13 00000439 E84315              <1>     call welcome_print
    14                              <1> 
    15 0000043C B488                <1>     mov ah, 0x88
    16 0000043E CD15                <1>     int 0x15
    17 00000440 E8FF08              <1>     call int_to_string
    18 00000443 89C6                <1>     mov si, ax
    19 00000445 E83715              <1>     call welcome_print
    20                              <1> 
    21 00000448 BE[8101]            <1>     mov si, welcome_msg2
    22 0000044B E83115              <1>     call welcome_print
    23 0000044E BE[AB01]            <1>     mov si, welcome_msg3
    24 00000451 E82B15              <1>     call welcome_print
    25                              <1> 
    26 00000454 B80A0E              <1>     mov ax, 0x0e0a
    27 00000457 CD10                <1>     int 0x10
    28                              <1> 
    29                              <1> ; The loop that gets the input
    30                              <1> .input_loop:
    31                              <1>     ; Change the cursor to a solid block
    32 00000459 B500                <1>     mov ch, 0x00
    33 0000045B E8B50B              <1>     call change_cursor
    34                              <1> 
    35 0000045E E81D04              <1>     call check_pos
    36 00000461 E84004              <1>     call draw_menu_bar
    37                              <1> 
    38                              <1>     ; Print the username and the input msg
    39                              <1>     ;mov si, usrNam
    40                              <1>     ;call print
    41 00000464 BE[A400]            <1>     mov si, in_msg
    42 00000467 E80715              <1>     call print
    43                              <1> 
    44                              <1>     ; Get the input and save it in in_buffer 
    45 0000046A E82C14              <1>     call get_input
    46                              <1> 
    47                              <1>     ; Check the input
    48 0000046D B8[FA00]            <1>     mov ax, settings_com
    49 00000470 E8621E              <1>     call check_com
    50 00000473 0F839200            <1>     jnc .settings
    51                              <1> 
    52 00000477 B8[0301]            <1>     mov ax, clear_com
    53 0000047A E8581E              <1>     call check_com
    54 0000047D 0F838E00            <1>     jnc .clear
    55                              <1> 
    56 00000481 B8[0901]            <1>     mov ax, dir_com
    57 00000484 E84E1E              <1>     call check_com
    58 00000487 0F838C00            <1>     jnc .dir
    59                              <1> 
    60 0000048B B8[0D01]            <1>     mov ax, help_com
    61 0000048E E8441E              <1>     call check_com
    62 00000491 0F833101            <1>     jnc .show_help
    63                              <1> 
    64 00000495 BE[AB00]            <1>     mov si, in_buffer+3
    65 00000498 BF[0F08]            <1>     mov di, .tmp_filename
    66 0000049B E8C407              <1>     call string_copy
    67                              <1> 
    68 0000049E BE[A800]            <1>     mov si, in_buffer
    69 000004A1 BF[2308]            <1>     mov di, .tmp_inbuffer
    70 000004A4 E8BB07              <1>     call string_copy
    71                              <1> 
    72 000004A7 BE[A800]            <1>     mov si, in_buffer
    73 000004AA B80200              <1>     mov ax, 2
    74 000004AD E8BB07              <1>     call string_truncate
    75                              <1>     
    76 000004B0 B8[1C01]            <1>     mov ax, mk_com
    77 000004B3 E81F1E              <1>     call check_com
    78 000004B6 0F83DF02            <1>     jnc .make_file
    79                              <1> 
    80 000004BA B8[1F01]            <1>     mov ax, rm_com
    81 000004BD E8151E              <1>     call check_com
    82 000004C0 0F830003            <1>     jnc .remove_file
    83                              <1> 
    84 000004C4 BE[2308]            <1>     mov si, .tmp_inbuffer
    85 000004C7 BF[A800]            <1>     mov di, in_buffer
    86 000004CA E89507              <1>     call string_copy
    87                              <1> 
    88 000004CD B8[E900]            <1>     mov ax, restart_com
    89 000004D0 E8021E              <1>     call check_com
    90 000004D3 0F831803            <1>     jnc .restart
    91                              <1> 
    92 000004D7 B8[F100]            <1>     mov ax, shutdown_com
    93 000004DA E8F81D              <1>     call check_com
    94 000004DD 0F831603            <1>     jnc .shutdown
    95 000004E1 7200                <1>     jc .not_equal
    96                              <1> 
    97                              <1> .not_equal:
    98 000004E3 B40E                <1>     mov ah, 0x0e
    99 000004E5 B00A                <1>     mov al, 0x0a
   100 000004E7 CD10                <1>     int 0x10
   101                              <1> 
   102 000004E9 B40E                <1>     mov ah, 0x0e
   103 000004EB B022                <1>     mov al, '"'
   104 000004ED CD10                <1>     int 0x10
   105                              <1> 
   106 000004EF BE[A800]            <1>     mov si, in_buffer
   107 000004F2 E87C14              <1>     call print
   108                              <1> 
   109 000004F5 B40E                <1>     mov ah, 0x0e
   110 000004F7 B022                <1>     mov al, '"'
   111 000004F9 CD10                <1>     int 0x10
   112                              <1>     
   113 000004FB BE[D100]            <1>     mov si, not_com
   114 000004FE E87014              <1>     call print
   115                              <1>     
   116                              <1>     ; Create a new line
   117 00000501 B80A0E              <1>     mov ax, 0x0e0a
   118 00000504 CD10                <1>     int 0x10
   119                              <1> 
   120 00000506 E950FF              <1>     jmp .input_loop
   121                              <1> 
   122                              <1> .settings:
   123 00000509 E8F9FD              <1>     call show_settings
   124 0000050C E94AFF              <1>     jmp .input_loop
   125                              <1> 
   126                              <1> .clear:
   127 0000050F B70F                <1>     mov bh, cli_color
   128 00000511 E8AF06              <1>     call cls
   129 00000514 E942FF              <1>     jmp .input_loop
   130                              <1> 
   131                              <1> .dir:
   132 00000517 31C0                <1>     xor ax, ax
   133 00000519 E82D16              <1>     call os_get_file_list
   134                              <1> 
   135 0000051C 50                  <1>     push ax
   136 0000051D B80A0E              <1>     mov ax, 0x0e0a
   137 00000520 CD10                <1>     int 0x10
   138 00000522 CD10                <1>     int 0x10
   139 00000524 B00D                <1>     mov al, 0x0d
   140 00000526 CD10                <1>     int 0x10
   141 00000528 58                  <1>     pop ax
   142                              <1> 
   143 00000529 89C6                <1>     mov si, ax
   144 0000052B BF[0F08]            <1>     mov di, .tmp_filename
   145 0000052E BA0000              <1>     mov dx, 0
   146                              <1> 
   147 00000531 B40E                <1>     mov ah, 0x0e
   148 00000533 B020                <1>     mov al, ' '
   149 00000535 CD10                <1>     int 0x10
   150                              <1> 
   151                              <1>     .loop:
   152 00000537 AC                  <1>         lodsb
   153 00000538 3C2C                <1>         cmp al, ','
   154 0000053A 740C                <1>         je .add_size
   155 0000053C 3C00                <1>         cmp al, 0
   156 0000053E 744C                <1>         je .done
   157                              <1> 
   158 00000540 AA                  <1>         stosb
   159 00000541 42                  <1>         inc dx
   160                              <1> 
   161 00000542 B40E                <1>         mov ah, 0x0e
   162 00000544 CD10                <1>         int 0x10
   163                              <1> 
   164 00000546 EBEF                <1>         jmp .loop
   165                              <1> 
   166                              <1>     .add_size:
   167 00000548 60                  <1>         pusha
   168 00000549 83FA0C              <1>         cmp dx, 12
   169 0000054C 7D03                <1>         jge .continue
   170                              <1> 
   171 0000054E E82F00              <1>         call .add_spaces
   172                              <1> 
   173                              <1>         .continue:
   174 00000551 BE[4C08]            <1>         mov si, .file_size_sep
   175 00000554 E81A14              <1>         call print
   176                              <1> 
   177 00000557 89D0                <1>         mov ax, dx
   178 00000559 E80F07              <1>         call string_truncate
   179                              <1> 
   180 0000055C B8[0F08]            <1>         mov ax, .tmp_filename
   181 0000055F E8DA1B              <1>         call os_get_file_size
   182                              <1> 
   183 00000562 89D8                <1>         mov ax, bx
   184 00000564 E8DB07              <1>         call int_to_string
   185 00000567 89C6                <1>         mov si, ax
   186 00000569 E80514              <1>         call print
   187                              <1> 
   188 0000056C BE[AC02]            <1>         mov si, file_size_typ
   189 0000056F E8FF13              <1>         call print
   190                              <1> 
   191 00000572 B8200E              <1>         mov ax, 0x0e20
   192 00000575 CD10                <1>         int 0x10
   193                              <1> 
   194 00000577 61                  <1>         popa
   195                              <1> 
   196 00000578 BF[0F08]            <1>         mov di, .tmp_filename
   197 0000057B BA0000              <1>         mov dx, 0
   198 0000057E EBB7                <1>         jmp .loop
   199                              <1> 
   200                              <1>     .add_spaces:
   201 00000580 B8200E              <1>         mov ax, 0x0e20
   202 00000583 CD10                <1>         int 0x10
   203 00000585 42                  <1>         inc dx
   204 00000586 83FA0C              <1>         cmp dx, 12
   205 00000589 75F5                <1>         jne .add_spaces
   206 0000058B C3                  <1>         ret
   207                              <1> 
   208                              <1>     .done:
   209 0000058C 83FA0C              <1>         cmp dx, 12
   210 0000058F 7D03                <1>         jge .done_c
   211                              <1> 
   212 00000591 E8ECFF              <1>         call .add_spaces
   213                              <1> 
   214                              <1>         .done_c:
   215 00000594 BE[4C08]            <1>         mov si, .file_size_sep
   216 00000597 E8D713              <1>         call print
   217                              <1> 
   218 0000059A BE[0F08]            <1>         mov si, .tmp_filename
   219 0000059D 89D0                <1>         mov ax, dx
   220 0000059F E8C906              <1>         call string_truncate
   221                              <1> 
   222 000005A2 B8[0F08]            <1>         mov ax, .tmp_filename
   223 000005A5 E8941B              <1>         call os_get_file_size
   224                              <1> 
   225 000005A8 89D8                <1>         mov ax, bx
   226 000005AA E89507              <1>         call int_to_string
   227 000005AD 89C6                <1>         mov si, ax
   228 000005AF E8BF13              <1>         call print
   229                              <1> 
   230 000005B2 BE[5108]            <1>         mov si, .file_size_typ
   231 000005B5 E8B913              <1>         call print
   232                              <1> 
   233 000005B8 50                  <1>     push ax
   234                              <1> 
   235 000005B9 B80A0E              <1>     mov ax, 0x0e0a
   236 000005BC CD10                <1>     int 0x10
   237 000005BE B00D                <1>     mov al, 0x0d
   238 000005C0 CD10                <1>     int 0x10
   239                              <1> 
   240 000005C2 58                  <1>     pop ax
   241                              <1> 
   242 000005C3 E993FE              <1>     jmp .input_loop
   243                              <1> 
   244                              <1> 
   245                              <1> .show_help:
   246 000005C6 B8[F605]            <1>     mov ax, .help_commands
   247 000005C9 BB[6807]            <1>     mov bx, .help_header
   248 000005CC B9[7207]            <1>     mov cx, .help_string
   249 000005CF E8FB10              <1>     call list_dialog
   250                              <1> 
   251 000005D2 83F804              <1>     cmp ax, 4
   252 000005D5 0F8430FF            <1>     je .settings
   253                              <1>     
   254 000005D9 B70F                <1>     mov bh, cli_color
   255 000005DB E8E505              <1>     call cls
   256                              <1> 
   257 000005DE 83F802              <1>     cmp ax, 2
   258 000005E1 0F8432FF            <1>     je .dir
   259 000005E5 83F809              <1>     cmp ax, 9
   260 000005E8 0F840302            <1>     je .restart
   261 000005EC 83F80A              <1>     cmp ax, 10
   262 000005EF 0F840402            <1>     je .shutdown
   263                              <1> 
   264 000005F3 E963FE              <1>     jmp .input_loop
   265                              <1> 
   266 000005F6 48454C502020202020- <1>     .help_commands:     db "HELP       --  What you're looking at,"
   266 000005FF 20202D2D2020576861- <1>
   266 00000608 7420796F7527726520- <1>
   266 00000611 6C6F6F6B696E672061- <1>
   266 0000061A 742C                <1>
   267 0000061C 444952202020202020- <1>                         db "DIR        --  Show a list of all files,"
   267 00000625 20202D2D202053686F- <1>
   267 0000062E 772061206C69737420- <1>
   267 00000637 6F6620616C6C206669- <1>
   267 00000640 6C65732C            <1>
   268 00000644 434C45415220202020- <1>                         db "CLEAR      --  Clear the terminal,"
   268 0000064D 20202D2D2020436C65- <1>
   268 00000656 617220746865207465- <1>
   268 0000065F 726D696E616C2C      <1>
   269 00000666 53455454494E475320- <1>                         db "SETTINGS   --  Show the settings menu,"
   269 0000066F 20202D2D202053686F- <1>
   269 00000678 772074686520736574- <1>
   269 00000681 74696E6773206D656E- <1>
   269 0000068A 752C                <1>
   270 0000068C 4D4B2046494C452020- <1>                         db "MK FILE    --  Create a file,"
   270 00000695 20202D2D2020437265- <1>
   270 0000069E 61746520612066696C- <1>
   270 000006A7 652C                <1>
   271 000006A9 524D2046494C452020- <1>                         db "RM FILE    --  Delete a file,"
   271 000006B2 20202D2D202044656C- <1>
   271 000006BB 65746520612066696C- <1>
   271 000006C4 652C                <1>
   272 000006C6 4C4F41442046494C45- <1>                         db "LOAD FILE  --  Load/run a file,"
   272 000006CF 20202D2D20204C6F61- <1>
   272 000006D8 642F72756E20612066- <1>
   272 000006E1 696C652C            <1>
   273 000006E5 454449542046494C45- <1>                         db "EDIT FILE  --  Load and edit a file,"
   273 000006EE 20202D2D20204C6F61- <1>
   273 000006F7 6420616E6420656469- <1>
   273 00000700 7420612066696C652C  <1>
   274 00000709 524553544152542020- <1>                         db "RESTART    --  Restart KronkOS,"
   274 00000712 20202D2D2020526573- <1>
   274 0000071B 74617274204B726F6E- <1>
   274 00000724 6B4F532C            <1>
   275 00000728 53485554444F574E20- <1>                         db "SHUTDOWN   --  Shutdown KronkOS,,"
   275 00000731 20202D2D2020536875- <1>
   275 0000073A 74646F776E204B726F- <1>
   275 00000743 6E6B4F532C2C        <1>
   276 00000749 43414E43454C202020- <1>                         db "CANCEL     --  Leave this menu", 0
   276 00000752 20202D2D20204C6561- <1>
   276 0000075B 76652074686973206D- <1>
   276 00000764 656E7500            <1>
   277 00000768 48454C50204D454E55- <1>     .help_header:       db "HELP MENU", 0
   277 00000771 00                  <1>
   278 00000772 507265737320454E54- <1>     .help_string:       db "Press ENTER to run any of the commands", 0
   278 0000077B 455220746F2072756E- <1>
   278 00000784 20616E79206F662074- <1>
   278 0000078D 686520636F6D6D616E- <1>
   278 00000796 647300              <1>
   279                              <1> 
   280                              <1> 
   281                              <1> .make_file:
   282 00000799 60                  <1>     pusha
   283 0000079A B8[0F08]            <1>     mov ax, .tmp_filename
   284 0000079D E85918              <1>     call os_create_file
   285                              <1>     
   286 000007A0 B80A0E              <1>     mov ax, 0x0e0a
   287 000007A3 CD10                <1>     int 0x10
   288 000007A5 B00D                <1>     mov al, 0x0d
   289 000007A7 CD10                <1>     int 0x10
   290                              <1> 
   291 000007A9 BE[0F08]            <1>     mov si, .tmp_filename
   292 000007AC E8C211              <1>     call print
   293 000007AF BE[6C08]            <1>     mov si, .tmp_filemk
   294 000007B2 E8BC11              <1>     call print
   295                              <1> 
   296 000007B5 B80A0E              <1>     mov ax, 0x0e0a
   297 000007B8 CD10                <1>     int 0x10
   298 000007BA CD10                <1>     int 0x10
   299 000007BC B00D                <1>     mov al, 0x0d
   300 000007BE CD10                <1>     int 0x10
   301                              <1> 
   302 000007C0 61                  <1>     popa
   303                              <1> 
   304 000007C1 E995FC              <1>     jmp .input_loop
   305                              <1> 
   306                              <1> 
   307                              <1> .remove_file:
   308 000007C4 60                  <1>     pusha
   309 000007C5 B8[0F08]            <1>     mov ax, .tmp_filename
   310 000007C8 E8BD18              <1>     call os_remove_file
   311                              <1>     
   312 000007CB B80A0E              <1>     mov ax, 0x0e0a
   313 000007CE CD10                <1>     int 0x10
   314 000007D0 B00D                <1>     mov al, 0x0d
   315 000007D2 CD10                <1>     int 0x10
   316                              <1> 
   317 000007D4 BE[0F08]            <1>     mov si, .tmp_filename
   318 000007D7 E89711              <1>     call print
   319 000007DA BE[5A08]            <1>     mov si, .tmp_filerm
   320 000007DD E89111              <1>     call print
   321                              <1> 
   322 000007E0 B80A0E              <1>     mov ax, 0x0e0a
   323 000007E3 CD10                <1>     int 0x10
   324 000007E5 CD10                <1>     int 0x10
   325 000007E7 B00D                <1>     mov al, 0x0d
   326 000007E9 CD10                <1>     int 0x10
   327                              <1> 
   328 000007EB 61                  <1>     popa
   329                              <1> 
   330 000007EC E96AFC              <1>     jmp .input_loop
   331                              <1> 
   332                              <1> 
   333                              <1> .restart:
   334 000007EF B80000              <1>     mov ax, 0x00
   335 000007F2 CD13                <1>     int 0x13
   336 000007F4 CD19                <1>     int 0x19
   337                              <1> 
   338                              <1>     ; Halt cpu if restart fails
   339 000007F6 F4                  <1>     hlt
   340                              <1> 
   341                              <1> 
   342                              <1> .shutdown:
   343 000007F7 31C0                <1>     xor ax, ax
   344 000007F9 CD13                <1>     int 0x13
   345                              <1> 
   346 000007FB B80010              <1>     mov ax, 0x1000
   347 000007FE 8CD0                <1>     mov ax, ss
   348 00000800 BC00F0              <1>     mov sp, 0xf000
   349 00000803 B80753              <1>     mov ax, 0x5307
   350 00000806 BB0100              <1>     mov bx, 0x0001
   351 00000809 B90300              <1>     mov cx, 0x0003
   352 0000080C CD15                <1>     int 0x15
   353                              <1> 
   354                              <1>     ; Halt cpu if shutdown fails
   355 0000080E F4                  <1>     hlt
   356                              <1> 
   357                              <1> 
   358 0000080F 00<rept>            <1> .tmp_filename:      times 20 db 0
   359 00000823 00<rept>            <1> .tmp_inbuffer:      times 41 db 0
   360 0000084C 202D2D2000          <1> .file_size_sep:		db " -- ", 0
   361 00000851 2042797465730A0D00  <1> .file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   362 0000085A 20686173206265656E- <1> .tmp_filerm:        db " has been deleted", 0
   362 00000863 2064656C6574656400  <1>
   363 0000086C 20686173206265656E- <1> .tmp_filemk:        db " has been created", 0
   363 00000875 206372656174656400  <1>
   195                                      %include "./includes/menubar.asm"
     1                              <1> check_pos:
     2 0000087E 60                  <1>     pusha
     3                              <1> 
     4 0000087F B403                <1>     mov ah, 0x03
     5 00000881 30FF                <1>     xor bh, bh
     6 00000883 CD10                <1>     int 0x10
     7                              <1> 
     8 00000885 80FE18              <1>     cmp dh, 24
     9 00000888 7402                <1>     je .at_end
    10                              <1> 
    11 0000088A 61                  <1>     popa
    12 0000088B C3                  <1>     ret
    13                              <1> 
    14                              <1> .at_end:
    15 0000088C B80306              <1>     mov ax, 0x0603
    16 0000088F B70F                <1>     mov bh, cli_color
    17 00000891 BA4F18              <1> 	mov dx, 0x184f
    18 00000894 31C9                <1> 	xor cx, cx
    19 00000896 CD10                <1>     int 0x10
    20                              <1> 
    21 00000898 B402                <1>     mov ah, 0x02
    22 0000089A 30FF                <1>     xor bh, bh
    23 0000089C 30D2                <1>     xor dl, dl
    24 0000089E B615                <1>     mov dh, 21
    25 000008A0 CD10                <1>     int 0x10
    26                              <1> 
    27 000008A2 61                  <1>     popa
    28 000008A3 C3                  <1>     ret
    29                              <1> 
    30                              <1> draw_menu_bar:
    31 000008A4 60                  <1>     pusha
    32                              <1> 
    33 000008A5 B403                <1>     mov ah, 0x03
    34 000008A7 30FF                <1>     xor bh, bh
    35 000008A9 CD10                <1>     int 0x10
    36                              <1> 
    37 000008AB 52                  <1>     push dx
    38                              <1> 
    39 000008AC B80407              <1>     mov ax, 0x0704
    40 000008AF B70F                <1>     mov bh, cli_color
    41 000008B1 BA4F18              <1> 	mov dx, 0x184f
    42 000008B4 31C9                <1> 	xor cx, cx
    43 000008B6 CD10                <1>     int 0x10
    44 000008B8 B80406              <1>     mov ax, 0x0604
    45 000008BB CD10                <1>     int 0x10
    46                              <1>     
    47 000008BD B402                <1>     mov ah, 0x02
    48 000008BF B618                <1>     mov dh, 24
    49 000008C1 30FF                <1>     xor bh, bh
    50 000008C3 30D2                <1>     xor dl, dl
    51 000008C5 CD10                <1>     int 0x10
    52                              <1> 
    53 000008C7 BE[B502]            <1>     mov si, mb_fill
    54 000008CA B330                <1>     mov bl, mb_color
    55 000008CC E8DB10              <1>     call print_atr
    56                              <1> 
    57 000008CF B402                <1>     mov ah, 0x02
    58 000008D1 B618                <1>     mov dh, 24
    59 000008D3 B201                <1>     mov dl, 1
    60 000008D5 30FF                <1>     xor bh, bh
    61 000008D7 CD10                <1>     int 0x10
    62                              <1> 
    63 000008D9 E82505              <1>     call get_time_string
    64 000008DC 89DE                <1>     mov si, bx
    65 000008DE B330                <1>     mov bl, mb_color
    66 000008E0 E8C710              <1>     call print_atr
    67                              <1> 
    68 000008E3 B402                <1>     mov ah, 0x02
    69 000008E5 B618                <1>     mov dh, 24
    70 000008E7 B21C                <1>     mov dl, 28
    71 000008E9 30FF                <1>     xor bh, bh
    72 000008EB CD10                <1>     int 0x10
    73                              <1> 
    74 000008ED B8[7600]            <1>     mov ax, usrNam
    75 000008F0 E83503              <1>     call string_uppercase
    76 000008F3 89C6                <1>     mov si, ax
    77 000008F5 B330                <1>     mov bl, mb_color
    78 000008F7 E8B010              <1>     call print_atr
    79                              <1> 
    80 000008FA B402                <1>     mov ah, 0x02
    81 000008FC B618                <1>     mov dh, 24
    82 000008FE B245                <1>     mov dl, 69
    83 00000900 30FF                <1>     xor bh, bh
    84 00000902 CD10                <1>     int 0x10
    85                              <1> 
    86 00000904 E8B105              <1>     call get_date_string
    87 00000907 89DE                <1>     mov si, bx
    88 00000909 B330                <1>     mov bl, mb_color
    89 0000090B E89C10              <1>     call print_atr
    90                              <1> 
    91 0000090E B402                <1>     mov ah, 0x02
    92 00000910 30FF                <1>     xor bh, bh
    93 00000912 30D2                <1>     xor dl, dl
    94 00000914 5A                  <1>     pop dx
    95 00000915 CD10                <1>     int 0x10
    96                              <1> 
    97 00000917 61                  <1>     popa
    98 00000918 C3                  <1>     ret
   196                                      %include "./includes/video.asm"
     1                              <1> kronk_vid:
     2 00000919 B80100              <1>     mov ax, 1
     3 0000091C B701                <1>     mov bh, vid_backcolor
     4 0000091E E87609              <1>     call switch_mode
     5                              <1>     
     6                              <1>     ; Disable color blinking
     7 00000921 B80310              <1>     mov ax, 0x1003
     8 00000924 BB0000              <1>     mov bx, 0x0000
     9 00000927 CD10                <1>     int 0x10
    10                              <1> 
    11                              <1>     ; Initalize and enable the mouse if possible
    12 00000929 E8A710              <1>     call mouse_initialize
    13 0000092C 720A                <1>     jc vid_input
    14 0000092E B001                <1>     mov al, 1
    15 00000930 A2[3909]            <1>     mov [mouse_working], al
    16 00000933 E8CB10              <1>     call mouse_enable
    17 00000936 EB00                <1>     jmp vid_input
    18                              <1> 
    19                              <1> vid_input:
    20                              <1>     ;mov si, mb_string
    21                              <1>     ;xor bh, bh
    22                              <1>     ;mov bl, vid_forecolor
    23                              <1>     ;call print_atr
    24                              <1> 
    25                              <1>     ;mov bh, vid_backcolor
    26                              <1>     ;call cls
    27                              <1> 
    28                              <1>     ;mov al, [mouse_working]
    29                              <1>     ;cmp al, 0
    30                              <1>     ;call mouse_loop
    31                              <1>     ;call move_cursor
    32                              <1> 
    33                              <1>     ;mov si, sejt
    34                              <1>     ;xor bh, bh
    35                              <1>     ;mov bl, vid_forecolor
    36                              <1>     ;call print_atr
    37                              <1> 
    38 00000938 F4                  <1>     hlt
    39                              <1> 
    40                              <1> ; ------------------------------------------------------------------
    41                              <1> ; STRINGS AND OTHER VARIABLES
    42                              <1> 
    43 00000939 00                  <1>     mouse_working:      db 0
    44 0000093A 2000                <1>     sejt:               db " ", 0
   197                                      %include "./includes/setup.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; The Kronk Operating System setup file
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; This is loaded from the drive by KERNEL.BIN, at first boot
     6                              <1> ; ==================================================================
     7                              <1> setup_init:
     8                              <1> 
     9                              <1>     ; Color variables
    10                              <1>     basic_colors    equ 0x1F
    11                              <1>     marked_colors   equ 0x1E
    12                              <1> 
    13                              <1>     ; Setup text box variables
    14                              <1>     edge_width      equ 14
    15                              <1>     border_length   equ 50
    16                              <1>     
    17                              <1>     ; Disable color blinking
    18 0000093C B80310              <1>     mov ax, 0x1003
    19 0000093F BB0000              <1>     mov bx, 0x0000
    20 00000942 CD10                <1>     int 0x10
    21                              <1> 
    22 00000944 EB00                <1>     jmp setup_start
    23                              <1> 
    24                              <1> ; ******************************************************************
    25                              <1> ; Start the setup
    26                              <1> setup_start:
    27 00000946 60                  <1>     pusha
    28 00000947 B71F                <1>     mov bh, basic_colors
    29 00000949 E87702              <1>     call cls
    30                              <1> 
    31 0000094C BE[AE0B]            <1>     mov si, setup_string
    32 0000094F E86C09              <1>     call setup_bottom_string
    33                              <1> 
    34 00000952 BE[D309]            <1>     mov si, usr_set
    35 00000955 E8290C              <1>     call draw_setup_box
    36                              <1> 
    37 00000958 B8[BF09]            <1>     mov ax, usr_save
    38 0000095B E87809              <1>     call setup_input
    39                              <1> 
    40 0000095E B71F                <1>     mov bh, basic_colors
    41 00000960 E86002              <1>     call cls
    42                              <1> 
    43 00000963 BE[020A]            <1>     mov si, vid_set
    44 00000966 E8180C              <1>     call draw_setup_box
    45                              <1> 
    46 00000969 B8[790B]            <1>     mov ax, vid_opt1
    47 0000096C BB[820B]            <1>     mov bx, vid_opt2
    48 0000096F B9[8D0B]            <1>     mov cx, vid_opt3
    49 00000972 BAE11F              <1>     mov dx, 0x1fe1
    50 00000975 E8560A              <1>     call setup_choose
    51                              <1> 
    52 00000978 83F802              <1>     cmp ax, 2
    53 0000097B 7517                <1>     jne .setup_done
    54                              <1> 
    55                              <1>     ; User has choosen "cancel" and KronkOS will therefore shutdown
    56 0000097D 31C0                <1>     xor ax, ax
    57 0000097F CD13                <1>     int 0x13
    58                              <1> 
    59 00000981 B80010              <1>     mov ax, 0x1000
    60 00000984 8CD0                <1>     mov ax, ss
    61 00000986 BC00F0              <1>     mov sp, 0xf000
    62 00000989 B80753              <1>     mov ax, 0x5307
    63 0000098C BB0100              <1>     mov bx, 0x0001
    64 0000098F B90300              <1>     mov cx, 0x0003
    65 00000992 CD15                <1>     int 0x15
    66                              <1> 
    67                              <1> .setup_done:
    68 00000994 A3[8B00]            <1>     mov [vidMode], ax
    69                              <1> 
    70 00000997 BE[BF09]            <1>     mov si, usr_save
    71 0000099A BF[7600]            <1>     mov di, usrNam
    72 0000099D E8C202              <1>     call string_copy
    73                              <1> 
    74 000009A0 61                  <1>     popa
    75 000009A1 C3                  <1>     ret
    76                              <1> 
    77                              <1> ; ******************************************************************
    78                              <1> 
    79                              <1> ; ------------------------------------------------------------------
    80                              <1> ; VARIABLES
    81 000009A2 766964656F6D6F6465- <1>     vidmode_save:   db "videomode,", 0
    81 000009AB 2C00                <1>
    82 000009AD 300A0D00            <1>     cli_save:       db "0", 0x0a, 0x0d, 0
    83 000009B1 310A0D00            <1>     vid_save:       db "1", 0x0a, 0x0d, 0
    84 000009B5 757365726E616D652C- <1>     usrname_save:   db "username,", 0
    84 000009BE 00                  <1>
    85 000009BF 00<rept>            <1>     usr_save:       times 20 db 0
    86                              <1> 
    87 000009D3 506C6561736520656E- <1>     usr_set:    db "Please enter your username, and press enter...", 0
    87 000009DC 74657220796F757220- <1>
    87 000009E5 757365726E616D652C- <1>
    87 000009EE 20616E642070726573- <1>
    87 000009F7 7320656E7465722E2E- <1>
    87 00000A00 2E00                <1>
    88                              <1> 
    89 00000A02 506C65617365206368- <1>     vid_set:    db "Please choose a standard view mode...", 0x0a, 0x0a
    89 00000A0B 6F6F73652061207374- <1>
    89 00000A14 616E64617264207669- <1>
    89 00000A1D 6577206D6F64652E2E- <1>
    89 00000A26 2E0A0A              <1>
    90 00000A29 564944454F204D4F44- <1>                 db "VIDEO MODE is for the more casual user, that", 0x0a, "just want to be able to use KronkOS with ease by using a nice graphical interface.", 0x0a, 0x0a
    90 00000A32 4520697320666F7220- <1>
    90 00000A3B 746865206D6F726520- <1>
    90 00000A44 63617375616C207573- <1>
    90 00000A4D 65722C20746861740A- <1>
    90 00000A56 6A7573742077616E74- <1>
    90 00000A5F 20746F206265206162- <1>
    90 00000A68 6C6520746F20757365- <1>
    90 00000A71 204B726F6E6B4F5320- <1>
    90 00000A7A 776974682065617365- <1>
    90 00000A83 206279207573696E67- <1>
    90 00000A8C 2061206E6963652067- <1>
    90 00000A95 726170686963616C20- <1>
    90 00000A9E 696E74657266616365- <1>
    90 00000AA7 2E0A0A              <1>
    91 00000AAA 434C49204D4F444520- <1>                 db "CLI MODE is for the more advanced user, where", 0x0a, "instead of pressing buttons, you use commands to", 0x0a, "execute the various actions you desire.", 0x0a, 0x0a
    91 00000AB3 697320666F72207468- <1>
    91 00000ABC 65206D6F7265206164- <1>
    91 00000AC5 76616E636564207573- <1>
    91 00000ACE 65722C207768657265- <1>
    91 00000AD7 0A696E737465616420- <1>
    91 00000AE0 6F6620707265737369- <1>
    91 00000AE9 6E6720627574746F6E- <1>
    91 00000AF2 732C20796F75207573- <1>
    91 00000AFB 6520636F6D6D616E64- <1>
    91 00000B04 7320746F0A65786563- <1>
    91 00000B0D 757465207468652076- <1>
    91 00000B16 6172696F7573206163- <1>
    91 00000B1F 74696F6E7320796F75- <1>
    91 00000B28 206465736972652E0A- <1>
    91 00000B31 0A                  <1>
    92 00000B32 557365207468652061- <1>                 db "Use the arrow keys and 'ENTER' to select between the different options", 0
    92 00000B3B 72726F77206B657973- <1>
    92 00000B44 20616E642027454E54- <1>
    92 00000B4D 45522720746F207365- <1>
    92 00000B56 6C6563742062657477- <1>
    92 00000B5F 65656E207468652064- <1>
    92 00000B68 6966666572656E7420- <1>
    92 00000B71 6F7074696F6E7300    <1>
    93                              <1> 
    94 00000B79 434C49204D4F444500  <1>     vid_opt1:   db "CLI MODE", 0
    95 00000B82 564944454F204D4F44- <1>     vid_opt2:   db "VIDEO MODE", 0
    95 00000B8B 4500                <1>
    96 00000B8D 43616E63656C202857- <1>     vid_opt3:   db "Cancel (Will shutdown KronkOS)", 0
    96 00000B96 696C6C207368757464- <1>
    96 00000B9F 6F776E204B726F6E6B- <1>
    96 00000BA8 4F532900            <1>
    97                              <1> 
    98 00000BAC 0000                <1>     vid_chosen: dw 0
    99                              <1> 
   100 00000BAE 204B726F6E6B4F5320- <1>     setup_string: db " KronkOS ", KRONKOS_VER, " setup", 0
   100 00000BB7 302E332E3220736574- <1>
   100 00000BC0 757000              <1>
   198                                      %include "./includes/cls.asm"
     1                              <1> cls:
     2 00000BC3 60                  <1>     pusha
     3                              <1>     
     4 00000BC4 B406                <1>     mov ah, 0x06
     5 00000BC6 BA4F18              <1>     mov dx, 0x184f
     6                              <1> 
     7 00000BC9 30C0                <1>     xor al, al
     8 00000BCB 31C9                <1>     xor cx, cx
     9                              <1> 
    10 00000BCD CD10                <1>     int 0x10
    11                              <1>     
    12 00000BCF B402                <1>     mov ah, 0x2
    13 00000BD1 31D2                <1>     xor dx, dx
    14 00000BD3 30FF                <1>     xor bh, bh
    15                              <1> 
    16 00000BD5 CD10                <1>     int 0x10
    17                              <1>     
    18 00000BD7 61                  <1>     popa
    19 00000BD8 C3                  <1>     ret
   199                                      %include "./includes/string.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; KronkOS -- The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019-2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; STRING MANIPULATION ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; string_length -- Return length of a string
    10                              <1> ; IN: AX = string location
    11                              <1> ; OUT AX = length (other regs preserved)
    12                              <1> 
    13                              <1> string_length:
    14 00000BD9 60                  <1>     pusha
    15 00000BDA 89C3                <1>     mov bx, ax
    16 00000BDC B90000              <1>     mov cx, 0
    17                              <1> 
    18                              <1>     .more:
    19 00000BDF 803F00              <1>         cmp byte [bx], 0
    20 00000BE2 7404                <1>         je .done
    21 00000BE4 43                  <1>         inc bx
    22 00000BE5 41                  <1>         inc cx
    23 00000BE6 EBF7                <1>         jmp .more
    24                              <1> 
    25                              <1>     .done:
    26 00000BE8 890E[F10B]          <1>         mov word [.tmp_counter], cx
    27 00000BEC 61                  <1>         popa
    28                              <1> 
    29 00000BED A1[F10B]            <1>         mov ax, [.tmp_counter]
    30 00000BF0 C3                  <1>         ret
    31                              <1> 
    32 00000BF1 0000                <1>         .tmp_counter dw 0
    33                              <1> 
    34                              <1> ; ------------------------------------------------------------------
    35                              <1> ; find_char_in_string -- Find location of character in a string
    36                              <1> ; IN: SI = string location, AL = character to find
    37                              <1> ; OUT AX = location in string, or 0 if not present
    38                              <1> 
    39                              <1> find_char_in_string:
    40 00000BF3 60                  <1>     pusha
    41 00000BF4 B90100              <1>     mov cx, 1
    42                              <1> 
    43                              <1>     .more:
    44 00000BF7 3804                <1>         cmp byte [si], al
    45 00000BF9 7409                <1>         je .done
    46 00000BFB 803C00              <1>         cmp byte [si], 0
    47 00000BFE 740D                <1>         je .notfound
    48                              <1>         
    49 00000C00 46                  <1>         inc si
    50 00000C01 41                  <1>         inc cx
    51                              <1> 
    52 00000C02 EBF3                <1>         jmp .more
    53                              <1>     
    54                              <1>     .done:
    55 00000C04 890E[120C]          <1>         mov [.tmp], cx
    56 00000C08 61                  <1>         popa
    57 00000C09 A1[120C]            <1>         mov ax, [.tmp]
    58                              <1> 
    59 00000C0C C3                  <1>         ret
    60                              <1>     
    61                              <1>     .notfound:
    62 00000C0D 61                  <1>         popa
    63 00000C0E B80000              <1>         mov ax, 0
    64                              <1> 
    65 00000C11 C3                  <1>         ret
    66                              <1> 
    67 00000C12 0000                <1>     .tmp dw 0
    68                              <1> 
    69                              <1> ; ------------------------------------------------------------------
    70                              <1> ; string_charchange -- Change a character in a string
    71                              <1> ; IN: SI = string location, AL = char to find, BL = char to replace with
    72                              <1> 
    73                              <1> string_charchange:
    74 00000C14 60                  <1>     pusha
    75 00000C15 88C1                <1>     mov cl, al
    76                              <1> 
    77                              <1>     .loop:
    78 00000C17 8A04                <1>         mov byte al, [si]
    79 00000C19 3C00                <1>         cmp al, 0
    80 00000C1B 7409                <1>         je .finish
    81 00000C1D 38C8                <1>         cmp al, cl
    82 00000C1F 7502                <1>         jne .nochange
    83                              <1> 
    84 00000C21 881C                <1>         mov byte [si], bl
    85                              <1> 
    86                              <1>     .nochange:
    87 00000C23 46                  <1>         inc si
    88 00000C24 EBF1                <1>         jmp .loop
    89                              <1>     
    90                              <1>     .finish:
    91 00000C26 61                  <1>         popa
    92 00000C27 C3                  <1>         ret
    93                              <1> 
    94                              <1> ; ------------------------------------------------------------------
    95                              <1> ; string_uppercase -- Convert string to upper case
    96                              <1> ; IN/OUT: AX = string location
    97                              <1> 
    98                              <1> string_uppercase:
    99 00000C28 60                  <1>     pusha
   100 00000C29 89C6                <1>     mov si, ax
   101                              <1> 
   102                              <1>     .more:
   103 00000C2B 803C00              <1>         cmp byte [si], 0
   104 00000C2E 7413                <1>         je .done
   105                              <1> 
   106 00000C30 803C61              <1>         cmp byte [si], 'a'
   107 00000C33 720B                <1>         jb .noatoz
   108 00000C35 803C7A              <1>         cmp byte [si], 'z'
   109 00000C38 7706                <1>         ja .noatoz
   110                              <1> 
   111 00000C3A 802C20              <1>         sub byte [si], 0x20
   112                              <1> 
   113 00000C3D 46                  <1>         inc si
   114 00000C3E EBEB                <1>         jmp .more
   115                              <1> 
   116                              <1>     .noatoz:
   117 00000C40 46                  <1>         inc si
   118 00000C41 EBE8                <1>         jmp .more
   119                              <1> 
   120                              <1>     .done:
   121 00000C43 61                  <1>         popa
   122 00000C44 C3                  <1>         ret
   123                              <1> 
   124                              <1> ; ------------------------------------------------------------------
   125                              <1> ; string_lowercase -- Convert string to lower case
   126                              <1> ; IN/OUT: AX = string location
   127                              <1> 
   128                              <1> string_lowercase:
   129 00000C45 60                  <1>     pusha
   130 00000C46 89C6                <1>     mov si, ax
   131                              <1> 
   132                              <1>     .more:
   133 00000C48 803C00              <1>         cmp byte [si], 0
   134 00000C4B 7413                <1>         je .done
   135                              <1> 
   136 00000C4D 803C41              <1>         cmp byte [si], 'A'
   137 00000C50 720B                <1>         jb .noatoz
   138 00000C52 803C5A              <1>         cmp byte [si], 'Z'
   139 00000C55 7706                <1>         ja .noatoz
   140                              <1> 
   141 00000C57 800420              <1>         add byte [si], 0x20
   142                              <1> 
   143 00000C5A 46                  <1>         inc si
   144 00000C5B EBEB                <1>         jmp .more
   145                              <1>     
   146                              <1>     .noatoz:
   147 00000C5D 46                  <1>         inc si
   148 00000C5E EBE8                <1>         jmp .more
   149                              <1> 
   150                              <1>     .done:
   151 00000C60 61                  <1>         popa
   152 00000C61 C3                  <1>         ret
   153                              <1>         
   154                              <1> ; ------------------------------------------------------------------
   155                              <1> ; string_copy -- Copy one string on to another
   156                              <1> ; IN: SI = source
   157                              <1> ; OUT: DI = destination
   158                              <1> 
   159                              <1> string_copy:
   160 00000C62 60                  <1>     pusha
   161                              <1> 
   162                              <1>     .more:
   163 00000C63 AC                  <1>         lodsb
   164 00000C64 AA                  <1>         stosb
   165                              <1> 
   166 00000C65 84C0                <1>         test al, al
   167 00000C67 75FA                <1>         jnz .more
   168                              <1> 
   169                              <1>     .done:
   170 00000C69 61                  <1>         popa
   171 00000C6A C3                  <1>         ret
   172                              <1> 
   173                              <1> ; ------------------------------------------------------------------
   174                              <1> ; string_truncate -- Chop string down to specified number of characters
   175                              <1> ; IN: SI = string location, AX = number of characters
   176                              <1> ; OUT: Modified string
   177                              <1> 
   178                              <1> string_truncate:
   179 00000C6B 60                  <1>     pusha
   180                              <1> 
   181 00000C6C 01C6                <1>     add si, ax
   182 00000C6E C60400              <1>     mov byte [si], 0
   183                              <1> 
   184 00000C71 61                  <1>     popa
   185 00000C72 C3                  <1>     ret
   186                              <1> 
   187                              <1> ; ------------------------------------------------------------------
   188                              <1> ; string_add
   189                              <1> ; IN: AX = string one; BX = string two
   190                              <1> ; OUT AX = product
   191                              <1> 
   192                              <1> string_add:
   193                              <1>     .add_loop:
   194 00000C73 AC                  <1>         lodsb
   195 00000C74 AA                  <1>         stosb
   196                              <1> 
   197 00000C75 3C00                <1>         cmp al, 0
   198 00000C77 75FA                <1>         jne .add_loop
   199                              <1> 
   200 00000C79 C3                  <1>         ret
   201                              <1> 
   202                              <1> ; ------------------------------------------------------------------
   203                              <1> ; string_join -- Join two strings into a third seperate string
   204                              <1> ; IN/OUT: AX = string one, BX = string two, CX = product destination
   205                              <1> 
   206                              <1> string_join:
   207 00000C7A 60                  <1>     pusha
   208                              <1>     
   209 00000C7B 89C6                <1>     mov si, ax
   210 00000C7D 89CF                <1>     mov di, cx
   211                              <1> 
   212 00000C7F E8E0FF              <1>     call string_copy
   213 00000C82 E854FF              <1>     call string_length
   214                              <1> 
   215 00000C85 01C1                <1>     add cx, ax
   216                              <1> 
   217 00000C87 89DE                <1>     mov si, bx
   218 00000C89 89CF                <1>     mov di, cx
   219 00000C8B E8D4FF              <1>     call string_copy
   220                              <1> 
   221 00000C8E 61                  <1>     popa
   222 00000C8F C3                  <1>     ret
   223                              <1> 
   224                              <1> ; ------------------------------------------------------------------
   225                              <1> ; string_chomp -- Strip away extra spaces from a string
   226                              <1> ; IN: AX = string location
   227                              <1> 
   228                              <1> string_chomp:
   229 00000C90 60                  <1>     pusha
   230                              <1> 
   231 00000C91 89C2                <1>     mov dx, ax
   232                              <1> 
   233 00000C93 89C7                <1>     mov di, ax
   234 00000C95 B90000              <1>     mov cx, 0
   235                              <1> 
   236                              <1>     .keepcounting:
   237 00000C98 803D20              <1>         cmp byte [di], ' '
   238 00000C9B 7504                <1>         jne .counted
   239 00000C9D 41                  <1>         inc cx
   240 00000C9E 47                  <1>         inc di
   241 00000C9F EBF7                <1>         jmp .keepcounting
   242                              <1> 
   243                              <1>     .counted:
   244 00000CA1 83F900              <1>         cmp cx, 0
   245 00000CA4 740E                <1>         je .finished_copy
   246                              <1> 
   247 00000CA6 89FE                <1>         mov si, di
   248 00000CA8 89D7                <1>         mov di, dx
   249                              <1>     
   250                              <1>     .keep_copying:
   251 00000CAA AC                  <1>         lodsb
   252 00000CAB 8805                <1>         mov [di], al
   253 00000CAD 3C00                <1>         cmp al, 0
   254 00000CAF 7403                <1>         je .finished_copy
   255 00000CB1 47                  <1>         inc di
   256                              <1> 
   257 00000CB2 EBF6                <1>         jmp .keep_copying
   258                              <1> 
   259                              <1>     .finished_copy:
   260 00000CB4 89D0                <1>         mov ax, dx
   261                              <1> 
   262 00000CB6 E820FF              <1>         call string_length
   263 00000CB9 83F800              <1>         cmp ax, 0
   264 00000CBC 740F                <1>         je .done
   265                              <1> 
   266 00000CBE 89D6                <1>         mov si, dx
   267 00000CC0 01C6                <1>         add si, ax
   268                              <1>     
   269                              <1>     .more:
   270 00000CC2 4E                  <1>         dec si
   271 00000CC3 803C20              <1>         cmp byte [si], ' '
   272 00000CC6 7505                <1>         jne .done
   273 00000CC8 C60400              <1>         mov byte [si], 0
   274 00000CCB EBF5                <1>         jmp .more
   275                              <1>     
   276                              <1>     .done:
   277 00000CCD 61                  <1>         popa
   278 00000CCE C3                  <1>         ret
   279                              <1> 
   280                              <1> ; ------------------------------------------------------------------
   281                              <1> ; string_strip -- Remove a character from a string (max 255 chars)
   282                              <1> ; IN: SI = string location, AL = character to remove
   283                              <1> ; OUT: SI = modified string
   284                              <1> 
   285                              <1> string_strip:
   286 00000CCF 60                  <1>     pusha
   287                              <1> 
   288 00000CD0 89F7                <1>     mov di, si
   289 00000CD2 88C3                <1>     mov bl, al
   290                              <1> 
   291                              <1>     .nextchar:
   292 00000CD4 AC                  <1>         lodsb
   293 00000CD5 AA                  <1>         stosb
   294 00000CD6 3C00                <1>         cmp al, 0
   295 00000CD8 7407                <1>         je .finish
   296 00000CDA 38D8                <1>         cmp al, bl
   297 00000CDC 75F6                <1>         jne .nextchar
   298                              <1> 
   299                              <1>     .skip:
   300 00000CDE 4F                  <1>         dec di
   301 00000CDF EBF3                <1>         jmp .nextchar
   302                              <1> 
   303                              <1>     .finish:
   304 00000CE1 61                  <1>         popa
   305 00000CE2 C3                  <1>         ret
   306                              <1> 
   307                              <1> ; ------------------------------------------------------------------
   308                              <1> ; string_compare -- Check if two strings match
   309                              <1> ; IN: SI = string one, DI = string two
   310                              <1> ; OUT: carry set if same, clear if different
   311                              <1> 
   312                              <1> string_compare:
   313 00000CE3 60                  <1>     pusha
   314                              <1> 
   315                              <1>     .more:
   316 00000CE4 8A04                <1>         mov al, [si]
   317 00000CE6 8A1D                <1>         mov bl, [di]
   318                              <1> 
   319 00000CE8 80FB00              <1>         cmp bl, 0
   320 00000CEB 740B                <1>         je .terminated
   321                              <1> 
   322 00000CED 38D8                <1>         cmp al, bl
   323 00000CEF 7504                <1>         jne .not_same
   324                              <1> 
   325 00000CF1 46                  <1>         inc si
   326 00000CF2 47                  <1>         inc di
   327 00000CF3 EBEF                <1>         jmp .more
   328                              <1>     
   329                              <1>     .not_same:
   330 00000CF5 61                  <1>         popa
   331 00000CF6 F8                  <1>         clc
   332 00000CF7 C3                  <1>         ret
   333                              <1>     
   334                              <1>     .terminated:
   335 00000CF8 61                  <1>         popa
   336 00000CF9 F9                  <1>         stc
   337 00000CFA C3                  <1>         ret
   338                              <1> 
   339                              <1> ; ------------------------------------------------------------------
   340                              <1> ; string_to_int -- Convert string to an integer
   341                              <1> ; IN: SI = string (max 5 chars, up to '65536')
   342                              <1> ; OUT: AX = number
   343                              <1> 
   344                              <1> string_to_int:
   345 00000CFB 60                  <1>     pusha
   346                              <1> 
   347 00000CFC 89F0                <1>     mov ax, si
   348 00000CFE E8D8FE              <1>     call string_length
   349                              <1> 
   350 00000D01 01C6                <1>     add si, ax
   351 00000D03 4E                  <1>     dec si
   352                              <1> 
   353 00000D04 89C1                <1>     mov cx, ax
   354                              <1> 
   355 00000D06 BB0000              <1>     mov bx, 0
   356 00000D09 B80000              <1>     mov ax, 0
   357                              <1> 
   358 00000D0C C706[3E0D]0100      <1>     mov word [.multiplier], 1
   359                              <1> 
   360                              <1>     .loop:
   361 00000D12 B80000              <1>         mov ax, 0
   362 00000D15 8A04                <1>         mov byte al, [si]
   363 00000D17 2C30                <1>         sub al, 48
   364                              <1> 
   365 00000D19 F726[3E0D]          <1>         mul word [.multiplier]
   366 00000D1D 01C3                <1>         add bx, ax
   367                              <1> 
   368 00000D1F 50                  <1>         push ax
   369 00000D20 A1[3E0D]            <1>         mov word ax, [.multiplier]
   370 00000D23 BA0A00              <1>         mov dx, 10
   371 00000D26 F7E2                <1>         mul dx
   372 00000D28 A3[3E0D]            <1>         mov word [.multiplier], ax
   373 00000D2B 58                  <1>         pop ax
   374                              <1> 
   375 00000D2C 49                  <1>         dec cx
   376 00000D2D 83F900              <1>         cmp cx, 0
   377 00000D30 7403                <1>         je .finish
   378 00000D32 4E                  <1>         dec si
   379 00000D33 EBDD                <1>         jmp .loop
   380                              <1>     
   381                              <1>     .finish:
   382 00000D35 891E[400D]          <1>         mov word [.tmp], bx
   383 00000D39 61                  <1>         popa
   384 00000D3A A1[400D]            <1>         mov word ax, [.tmp]
   385                              <1> 
   386 00000D3D C3                  <1>         ret
   387                              <1> 
   388 00000D3E 0000                <1>     .multiplier dw 0
   389 00000D40 0000                <1>     .tmp        dw 0
   390                              <1> 
   391                              <1> ; ------------------------------------------------------------------
   392                              <1> ; int_to_string -- Convert unsigned integer to a string
   393                              <1> ; IN: AX = unsigned int
   394                              <1> ; OUT: AX = string
   395                              <1> 
   396                              <1> int_to_string:
   397 00000D42 60                  <1>     pusha
   398                              <1> 
   399 00000D43 B90000              <1>     mov cx, 0
   400 00000D46 BB0A00              <1>     mov bx, 10
   401 00000D49 BF[690D]            <1>     mov di, .t
   402                              <1> 
   403                              <1>     .push:
   404 00000D4C BA0000              <1>         mov dx, 0
   405 00000D4F F7F3                <1>         div bx
   406 00000D51 41                  <1>         inc cx
   407 00000D52 52                  <1>         push dx
   408 00000D53 85C0                <1>         test ax, ax
   409 00000D55 75F5                <1>         jnz .push
   410                              <1> 
   411                              <1>     .pop:
   412 00000D57 5A                  <1>         pop dx
   413 00000D58 80C230              <1>         add dl, '0'
   414 00000D5B 8815                <1>         mov [di], dl
   415 00000D5D 47                  <1>         inc di
   416 00000D5E 49                  <1>         dec cx
   417 00000D5F 75F6                <1>         jnz .pop
   418                              <1> 
   419 00000D61 C60500              <1>         mov byte [di], 0
   420                              <1> 
   421 00000D64 61                  <1>         popa
   422 00000D65 B8[690D]            <1>         mov ax, .t
   423 00000D68 C3                  <1>         ret
   424                              <1> 
   425 00000D69 00<rept>            <1>         .t times 7 db 0
   426                              <1> 
   427                              <1> ; ------------------------------------------------------------------
   428                              <1> ; sint_to_string -- Convert signed integer to string
   429                              <1> ; IN: AX = signed int
   430                              <1> ; OUT: AX = string location
   431                              <1> 
   432                              <1> sint_to_string:
   433 00000D70 60                  <1>     pusha
   434                              <1> 
   435 00000D71 B90000              <1>     mov cx, 0
   436 00000D74 BB0A00              <1>     mov bx, 10
   437 00000D77 BF[A50D]            <1>     mov di, .t
   438                              <1> 
   439 00000D7A 85C0                <1>     test ax, ax
   440 00000D7C 7802                <1>     js .neg
   441 00000D7E EB08                <1>     jmp .push
   442                              <1> 
   443                              <1>     .neg:
   444 00000D80 F7D8                <1>         neg ax
   445 00000D82 C606[A50D]2D        <1>         mov byte [.t], '-'
   446 00000D87 47                  <1>         inc di
   447                              <1>     
   448                              <1>     .push:
   449 00000D88 BA0000              <1>         mov dx, 0
   450 00000D8B F7F3                <1>         div bx
   451 00000D8D 41                  <1>         inc cx
   452 00000D8E 52                  <1>         push dx
   453 00000D8F 85C0                <1>         test ax, ax
   454 00000D91 75F5                <1>         jnz .push
   455                              <1> 
   456                              <1>     .pop:
   457 00000D93 5A                  <1>         pop dx
   458 00000D94 80C230              <1>         add dl, '0'
   459 00000D97 8815                <1>         mov [di], dl
   460 00000D99 47                  <1>         inc di
   461 00000D9A 49                  <1>         dec cx
   462 00000D9B 75F6                <1>         jnz .pop
   463                              <1> 
   464 00000D9D C60500              <1>         mov byte [di], 0
   465                              <1> 
   466 00000DA0 61                  <1>         popa
   467 00000DA1 B8[A50D]            <1>         mov ax, .t
   468 00000DA4 C3                  <1>         ret
   469                              <1> 
   470 00000DA5 00<rept>            <1>         .t times 7 db 0
   471                              <1>         
   472                              <1> ; ------------------------------------------------------------------
   473                              <1> ; lint_to_string -- Convert long integer to string
   474                              <1> ; IN: DX:AX = long unsigned int, BX = number base, DI = string location
   475                              <1> ; OUT: DI = location of converted string
   476                              <1> 
   477                              <1> lint_to_string:
   478 00000DAC 60                  <1>     pusha
   479                              <1> 
   480 00000DAD 89FE                <1>     mov si, di
   481 00000DAF C7050000            <1>     mov word [di], 0
   482                              <1> 
   483 00000DB3 83FB25              <1>     cmp bx, 37
   484 00000DB6 773B                <1>     ja .done
   485                              <1> 
   486 00000DB8 83FB00              <1>     cmp bx, 0
   487 00000DBB 7436                <1>     je .done
   488                              <1> 
   489                              <1>     .conversion_loop:
   490 00000DBD B90000              <1>         mov cx, 0
   491                              <1> 
   492 00000DC0 91                  <1>         xchg ax, cx
   493 00000DC1 92                  <1>         xchg ax, dx
   494 00000DC2 F7F3                <1>         div bx
   495                              <1> 
   496 00000DC4 91                  <1>         xchg ax, cx
   497 00000DC5 F7F3                <1>         div bx
   498 00000DC7 87CA                <1>         xchg cx, dx
   499                              <1>     
   500                              <1>     .save_digit:
   501 00000DC9 83F909              <1>         cmp cx, 9
   502 00000DCC 7E03                <1>         jle .convert_digit
   503                              <1> 
   504 00000DCE 83C107              <1>         add cx, 'A'-'9'-1
   505                              <1> 
   506                              <1>     .convert_digit:
   507 00000DD1 83C130              <1>         add cx, '0'
   508                              <1> 
   509 00000DD4 50                  <1>         push ax
   510 00000DD5 53                  <1>         push bx
   511 00000DD6 89F0                <1>         mov ax, si
   512 00000DD8 E8FEFD              <1>         call string_length
   513                              <1> 
   514 00000DDB 89F7                <1>         mov di, si
   515 00000DDD 01C7                <1>         add di, ax
   516 00000DDF 40                  <1>         inc ax
   517                              <1>     
   518                              <1>     .move_string_up:
   519 00000DE0 8A1D                <1>         mov bl, [di]
   520 00000DE2 885D01              <1>         mov [di+1], bl
   521 00000DE5 4F                  <1>         dec di
   522 00000DE6 48                  <1>         dec ax
   523 00000DE7 75F7                <1>         jnz .move_string_up
   524                              <1> 
   525 00000DE9 5B                  <1>         pop bx
   526 00000DEA 58                  <1>         pop ax
   527 00000DEB 880C                <1>         mov [si], cl
   528                              <1>     
   529                              <1>     .test_end:
   530 00000DED 89D1                <1>         mov cx, dx
   531 00000DEF 09C1                <1>         or cx, ax
   532 00000DF1 75CA                <1>         jnz .conversion_loop
   533                              <1>     
   534                              <1>     .done:
   535 00000DF3 61                  <1>         popa
   536 00000DF4 C3                  <1>         ret
   537                              <1>         
   538                              <1> ; ------------------------------------------------------------------
   539                              <1> ; set_time_fmt -- Set time reporting format (eg '10:25 AM' or '2300 hours')
   540                              <1> ; IN: AL = format flag, 0 = 12-hr format
   541                              <1> 
   542                              <1> set_time_fmt:
   543 00000DF5 60                  <1> 	pusha
   544 00000DF6 3C00                <1> 	cmp al, 0
   545 00000DF8 7402                <1> 	je .store
   546 00000DFA B0FF                <1> 	mov al, 0x0FF
   547                              <1> .store:
   548 00000DFC A2[A102]            <1> 	mov [fmt_12_24], al
   549 00000DFF 61                  <1> 	popa
   550 00000E00 C3                  <1> 	ret
   551                              <1> 
   552                              <1> 
   553                              <1> ; ------------------------------------------------------------------
   554                              <1> ; get_time_string -- Get current time in a string (eg '10:25')
   555                              <1> ; OUT: BX = string location
   556                              <1> 
   557                              <1> get_time_string:
   558 00000E01 60                  <1> 	pusha
   559                              <1> 
   560 00000E02 89DF                <1> 	mov di, bx
   561                              <1> 
   562 00000E04 F8                  <1> 	clc
   563 00000E05 B402                <1> 	mov ah, 2
   564 00000E07 CD1A                <1> 	int 0x1A
   565 00000E09 7305                <1> 	jnc .read
   566                              <1> 
   567 00000E0B F8                  <1> 	clc
   568 00000E0C B402                <1> 	mov ah, 2
   569 00000E0E CD1A                <1> 	int 0x1A
   570                              <1> 
   571                              <1> .read:
   572 00000E10 88E8                <1> 	mov al, ch
   573 00000E12 E8380B              <1> 	call bcd_to_int
   574 00000E15 89C2                <1> 	mov dx, ax
   575                              <1> 
   576 00000E17 88E8                <1> 	mov al,	ch
   577 00000E19 C0E804              <1> 	shr al, 4
   578 00000E1C 80E50F              <1> 	and ch, 0x0F
   579 00000E1F F606[A102]FF        <1> 	test byte [fmt_12_24], 0x0FF
   580 00000E24 740A                <1> 	jz .twelve_hr
   581                              <1> 
   582 00000E26 E86900              <1> 	call .add_digit
   583 00000E29 88E8                <1> 	mov al, ch
   584 00000E2B E86400              <1> 	call .add_digit
   585 00000E2E EB2F                <1> 	jmp short .minutes
   586                              <1> 
   587                              <1> .twelve_hr:
   588 00000E30 83FA00              <1> 	cmp dx, 0
   589 00000E33 741B                <1> 	je .midnight
   590                              <1> 
   591 00000E35 83FA0A              <1> 	cmp dx, 10
   592 00000E38 7C1D                <1> 	jl .twelve_st1
   593                              <1> 
   594 00000E3A 83FA0C              <1> 	cmp dx, 12
   595 00000E3D 7E15                <1> 	jle .twelve_st2
   596                              <1> 
   597 00000E3F 89D0                <1> 	mov ax, dx
   598 00000E41 83E80C              <1> 	sub ax, 12
   599 00000E44 B30A                <1> 	mov bl, 10
   600 00000E46 F6F3                <1> 	div bl
   601 00000E48 88E5                <1> 	mov ch, ah
   602                              <1> 
   603 00000E4A 3C00                <1> 	cmp al, 0
   604 00000E4C 7409                <1> 	je .twelve_st1
   605                              <1> 
   606 00000E4E EB04                <1> 	jmp short .twelve_st2
   607                              <1> 
   608                              <1> .midnight:
   609 00000E50 B001                <1> 	mov al, 1
   610 00000E52 B502                <1> 	mov ch, 2
   611                              <1> 
   612                              <1> .twelve_st2:
   613 00000E54 E83B00              <1> 	call .add_digit
   614                              <1> .twelve_st1:
   615 00000E57 88E8                <1> 	mov al, ch
   616 00000E59 E83600              <1> 	call .add_digit
   617                              <1> 
   618 00000E5C B03A                <1> 	mov al, ':'
   619 00000E5E AA                  <1> 	stosb
   620                              <1> 
   621                              <1> .minutes:
   622 00000E5F 88C8                <1> 	mov al, cl
   623 00000E61 C0E804              <1> 	shr al, 4
   624 00000E64 80E10F              <1> 	and cl, 0x0F
   625 00000E67 E82800              <1> 	call .add_digit
   626 00000E6A 88C8                <1> 	mov al, cl
   627 00000E6C E82300              <1> 	call .add_digit
   628                              <1> 
   629 00000E6F B020                <1> 	mov al, ' '
   630 00000E71 AA                  <1> 	stosb
   631                              <1> 
   632 00000E72 BE[960E]            <1> 	mov si, .hours_string
   633 00000E75 F606[A102]FF        <1> 	test byte [fmt_12_24], 0x0FF
   634 00000E7A 750B                <1> 	jnz .copy
   635                              <1> 
   636 00000E7C BE[9F0E]            <1> 	mov si, .pm_string
   637 00000E7F 83FA0C              <1> 	cmp dx, 12
   638 00000E82 7F03                <1> 	jg .copy
   639                              <1> 
   640 00000E84 BE[9C0E]            <1> 	mov si, .am_string
   641                              <1> 
   642                              <1> .copy:
   643 00000E87 80C301              <1>     add bl, 1
   644 00000E8A AC                  <1> 	lodsb
   645 00000E8B AA                  <1> 	stosb
   646 00000E8C 3C00                <1> 	cmp al, 0
   647 00000E8E 75F7                <1> 	jne .copy
   648                              <1> 
   649 00000E90 61                  <1> 	popa
   650 00000E91 C3                  <1> 	ret
   651                              <1> 
   652                              <1> .add_digit:
   653 00000E92 0430                <1> 	add al, '0'
   654 00000E94 AA                  <1> 	stosb
   655 00000E95 C3                  <1> 	ret
   656                              <1> 
   657                              <1> 
   658 00000E96 686F75727300        <1> 	.hours_string	db 'hours', 0
   659 00000E9C 414D00              <1> 	.am_string 	db 'AM', 0
   660 00000E9F 504D00              <1> 	.pm_string 	db 'PM', 0
   661                              <1> 
   662                              <1> 
   663                              <1> ; ------------------------------------------------------------------
   664                              <1> ; set_date_fmt -- Set date reporting format (M/D/Y, D/M/Y or Y/M/D - 0, 1, 2)
   665                              <1> ; IN: AX = format flag, 0-2
   666                              <1> ; If AX bit 7 = 1 = use name for months
   667                              <1> ; If AX bit 7 = 0, high byte = separator character
   668                              <1> 
   669                              <1> set_date_fmt:
   670 00000EA2 60                  <1> 	pusha
   671 00000EA3 A880                <1> 	test al, 0x80
   672 00000EA5 7505                <1> 	jnz .fmt_clear
   673                              <1> 
   674 00000EA7 25037F              <1> 	and ax, 0x7F03
   675 00000EAA EB03                <1> 	jmp short .fmt_test
   676                              <1> 
   677                              <1> .fmt_clear:
   678 00000EAC 83E003              <1> 	and ax, 0003
   679                              <1> 
   680                              <1> .fmt_test:
   681 00000EAF 3C03                <1> 	cmp al, 3
   682 00000EB1 7303                <1> 	jae .leave
   683 00000EB3 A3[A202]            <1> 	mov [fmt_date], ax
   684                              <1> 
   685                              <1> .leave:
   686 00000EB6 61                  <1> 	popa
   687 00000EB7 C3                  <1> 	ret
   688                              <1> 
   689                              <1> 
   690                              <1> ; ------------------------------------------------------------------
   691                              <1> ; get_date_string -- Get current date in a string (eg '12/31/2007')
   692                              <1> ; OUT: BX = string location
   693                              <1> 
   694                              <1> get_date_string:
   695 00000EB8 60                  <1> 	pusha
   696                              <1> 
   697 00000EB9 89DF                <1> 	mov di, bx
   698 00000EBB 8B1E[A202]          <1> 	mov bx, [fmt_date]
   699 00000EBF 81E3037F            <1> 	and bx, 0x7F03
   700                              <1> 
   701 00000EC3 F8                  <1> 	clc
   702 00000EC4 B404                <1> 	mov ah, 4
   703 00000EC6 CD1A                <1> 	int 0x1A
   704 00000EC8 7305                <1> 	jnc .read
   705                              <1> 
   706 00000ECA F8                  <1> 	clc
   707 00000ECB B404                <1> 	mov ah, 4
   708 00000ECD CD1A                <1> 	int 0x1A
   709                              <1> 
   710                              <1> .read:
   711 00000ECF 80FB02              <1> 	cmp bl, 2
   712 00000ED2 751C                <1> 	jne .try_fmt1
   713                              <1> 
   714 00000ED4 88EC                <1> 	mov ah, ch
   715 00000ED6 E8A000              <1> 	call .add_2digits
   716 00000ED9 88CC                <1> 	mov ah, cl
   717 00000EDB E89B00              <1> 	call .add_2digits
   718 00000EDE B02F                <1> 	mov al, '/'
   719 00000EE0 AA                  <1> 	stosb
   720                              <1> 
   721 00000EE1 88F4                <1> 	mov ah, dh
   722 00000EE3 E89300              <1> 	call .add_2digits
   723 00000EE6 B02F                <1> 	mov al, '/'
   724 00000EE8 AA                  <1> 	stosb
   725                              <1> 
   726 00000EE9 88D4                <1> 	mov ah, dl
   727 00000EEB E88B00              <1> 	call .add_2digits
   728 00000EEE EB71                <1> 	jmp .done
   729                              <1> 
   730                              <1> .try_fmt1:
   731 00000EF0 80FB01              <1> 	cmp bl, 1
   732 00000EF3 7536                <1> 	jne .do_fmt0
   733                              <1> 
   734 00000EF5 88D4                <1> 	mov ah, dl
   735 00000EF7 E86D00              <1> 	call .add_1or2digits
   736                              <1> 
   737 00000EFA 88F8                <1> 	mov al, bh
   738 00000EFC 80FF00              <1> 	cmp bh, 0
   739 00000EFF 7502                <1> 	jne .fmt1_day
   740                              <1> 
   741 00000F01 B020                <1> 	mov al, ' '
   742                              <1> 
   743                              <1> .fmt1_day:
   744 00000F03 AA                  <1> 	stosb
   745                              <1> 
   746 00000F04 88F4                <1> 	mov ah,	dh
   747 00000F06 80FF00              <1> 	cmp bh, 0
   748 00000F09 7509                <1> 	jne .fmt1_month
   749                              <1> 
   750 00000F0B E87F00              <1> 	call .add_month
   751 00000F0E B82C20              <1> 	mov ax, ', '
   752 00000F11 AB                  <1> 	stosw
   753 00000F12 EB06                <1> 	jmp short .fmt1_century
   754                              <1> 
   755                              <1> .fmt1_month:
   756 00000F14 E85000              <1> 	call .add_1or2digits
   757 00000F17 88F8                <1> 	mov al, bh
   758 00000F19 AA                  <1> 	stosb
   759                              <1> 
   760                              <1> .fmt1_century:
   761 00000F1A 88EC                <1> 	mov ah,	ch
   762 00000F1C 80FC00              <1> 	cmp ah, 0
   763 00000F1F 7403                <1> 	je .fmt1_year
   764                              <1> 
   765 00000F21 E84300              <1> 	call .add_1or2digits
   766                              <1> 
   767                              <1> .fmt1_year:
   768 00000F24 88CC                <1> 	mov ah, cl
   769 00000F26 E85000              <1> 	call .add_2digits
   770                              <1> 
   771 00000F29 EB36                <1> 	jmp .done
   772                              <1> 
   773                              <1> .do_fmt0:
   774 00000F2B 88F4                <1> 	mov ah,	dh
   775 00000F2D 80FF00              <1> 	cmp bh, 0
   776 00000F30 7508                <1> 	jne .fmt0_month
   777                              <1> 
   778 00000F32 E85800              <1> 	call .add_month
   779 00000F35 B020                <1> 	mov al, ' '
   780 00000F37 AA                  <1> 	stosb
   781 00000F38 EB06                <1> 	jmp short .fmt0_day
   782                              <1> 
   783                              <1> .fmt0_month:
   784 00000F3A E82A00              <1> 	call .add_1or2digits
   785 00000F3D 88F8                <1> 	mov al, bh
   786 00000F3F AA                  <1> 	stosb
   787                              <1> 
   788                              <1> .fmt0_day:
   789 00000F40 88D4                <1> 	mov ah, dl
   790 00000F42 E82200              <1> 	call .add_1or2digits
   791                              <1> 
   792 00000F45 88F8                <1> 	mov al, bh
   793 00000F47 80FF00              <1> 	cmp bh, 0
   794 00000F4A 7505                <1> 	jne .fmt0_day2
   795                              <1> 
   796 00000F4C B02C                <1> 	mov al, ','
   797 00000F4E AA                  <1> 	stosb
   798 00000F4F B020                <1> 	mov al, ' '
   799                              <1> 
   800                              <1> .fmt0_day2:
   801 00000F51 AA                  <1> 	stosb
   802                              <1> 
   803                              <1> .fmt0_century:
   804 00000F52 88EC                <1> 	mov ah,	ch
   805 00000F54 80FC00              <1> 	cmp ah, 0
   806 00000F57 7403                <1> 	je .fmt0_year
   807                              <1> 
   808 00000F59 E80B00              <1> 	call .add_1or2digits
   809                              <1> 
   810                              <1> .fmt0_year:
   811 00000F5C 88CC                <1> 	mov ah, cl
   812 00000F5E E81800              <1> 	call .add_2digits
   813                              <1> 
   814                              <1> 
   815                              <1> .done:
   816 00000F61 B80000              <1> 	mov ax, 0
   817 00000F64 AB                  <1> 	stosw
   818                              <1> 
   819 00000F65 61                  <1> 	popa
   820 00000F66 C3                  <1> 	ret
   821                              <1> 
   822                              <1> 
   823                              <1> .add_1or2digits:
   824 00000F67 F6C4F0              <1> 	test ah, 0x0F0
   825 00000F6A 7405                <1> 	jz .only_one
   826 00000F6C E80A00              <1> 	call .add_2digits
   827 00000F6F EB07                <1> 	jmp short .two_done
   828                              <1> .only_one:
   829 00000F71 88E0                <1> 	mov al, ah
   830 00000F73 240F                <1> 	and al, 0x0F
   831 00000F75 E81100              <1> 	call .add_digit
   832                              <1> .two_done:
   833 00000F78 C3                  <1> 	ret
   834                              <1> 
   835                              <1> .add_2digits:
   836 00000F79 88E0                <1> 	mov al, ah
   837 00000F7B C0E804              <1> 	shr al, 4
   838 00000F7E E80800              <1> 	call .add_digit
   839 00000F81 88E0                <1> 	mov al, ah
   840 00000F83 240F                <1> 	and al, 0x0F
   841 00000F85 E80100              <1> 	call .add_digit
   842 00000F88 C3                  <1> 	ret
   843                              <1> 
   844                              <1> .add_digit:
   845 00000F89 0430                <1> 	add al, '0'
   846 00000F8B AA                  <1> 	stosb
   847 00000F8C C3                  <1> 	ret
   848                              <1> 
   849                              <1> .add_month:
   850 00000F8D 53                  <1> 	push bx
   851 00000F8E 51                  <1> 	push cx
   852 00000F8F 88E0                <1> 	mov al, ah
   853 00000F91 E8B909              <1> 	call bcd_to_int
   854 00000F94 FEC8                <1> 	dec al
   855 00000F96 B304                <1> 	mov bl, 4
   856 00000F98 F6E3                <1> 	mul bl
   857 00000F9A BE[AE0F]            <1> 	mov si, .months
   858 00000F9D 01C6                <1> 	add si, ax
   859 00000F9F B90400              <1> 	mov cx, 4
   860 00000FA2 F3A4                <1> 	rep movsb
   861 00000FA4 807DFF20            <1> 	cmp byte [di-1], ' '
   862 00000FA8 7501                <1> 	jne .done_month
   863 00000FAA 4F                  <1> 	dec di
   864                              <1> .done_month:
   865 00000FAB 59                  <1> 	pop cx
   866 00000FAC 5B                  <1> 	pop bx
   867 00000FAD C3                  <1> 	ret
   868                              <1> 
   869 00000FAE 4A616E2E4665622E4D- <1> 	.months db 'Jan.Feb.Mar.Apr.May JuneJulyAug.SeptOct.Nov.Dec.'
   869 00000FB7 61722E4170722E4D61- <1>
   869 00000FC0 79204A756E654A756C- <1>
   869 00000FC9 794175672E53657074- <1>
   869 00000FD2 4F63742E4E6F762E44- <1>
   869 00000FDB 65632E              <1>
   870                              <1> 
   871                              <1> ; ------------------------------------------------------------------
   872                              <1> ; string_tokenize -- Reads tokens separated by specified char from
   873                              <1> ; a string. Returns pointer to next token, or 0 if none left
   874                              <1> ; IN: AL = separator char, SI = beginning
   875                              <1> ; OUT: DI = next token or 0 if none
   876                              <1> 
   877                              <1> string_tokenize:
   878 00000FDE 56                  <1> 	push si
   879                              <1> 
   880                              <1>     .next_char:
   881 00000FDF 3804                <1> 	    cmp byte [si], al
   882 00000FE1 7408                <1> 	    je .return_token
   883 00000FE3 803C00              <1> 	    cmp byte [si], 0
   884 00000FE6 740B                <1> 	    jz .no_more
   885 00000FE8 46                  <1> 	    inc si
   886 00000FE9 EBF4                <1> 	    jmp .next_char
   887                              <1> 
   888                              <1>     .return_token:
   889 00000FEB C60400              <1> 	    mov byte [si], 0
   890 00000FEE 46                  <1> 	    inc si
   891 00000FEF 89F7                <1> 	    mov di, si
   892 00000FF1 5E                  <1> 	    pop si
   893 00000FF2 C3                  <1> 	    ret
   894                              <1> 
   895                              <1>     .no_more:
   896 00000FF3 BF0000              <1> 	    mov di, 0
   897 00000FF6 5E                  <1> 	    pop si
   898 00000FF7 C3                  <1> 	    ret
   899                              <1> 
   900                              <1> ; ------------------------------------------------------------------
   901                              <1> ; string_clear -- Clears a variable
   902                              <1> ; IN: DI  = variable, AX = length
   903                              <1> ; OUT: empty variable
   904                              <1> 
   905                              <1> string_clear:
   906 00000FF8 60                  <1>     pusha
   907 00000FF9 BB0100              <1>     mov bx, 1
   908                              <1>     
   909                              <1>     .loop:
   910 00000FFC 30C0                <1>         xor al, al
   911 00000FFE AA                  <1>         stosb
   912 00000FFF 43                  <1>         inc bx
   913                              <1> 
   914 00001000 39D8                <1>         cmp ax, bx
   915 00001002 75F8                <1>         jne .loop
   916 00001004 61                  <1>         popa
   917 00001005 C3                  <1>         ret
   918                              <1> 
   919                              <1> ; ==================================================================
   200                                      %include "./includes/screen.asm"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; show_cursor -- Turns on cursor in text mode
     3                              <1> ; IN/OUT: Nothing
     4                              <1> 
     5                              <1> show_cursor:
     6 00001006 60                  <1> 	pusha
     7                              <1> 
     8 00001007 B506                <1> 	mov ch, 6
     9 00001009 B107                <1> 	mov cl, 7
    10 0000100B B401                <1> 	mov ah, 1
    11 0000100D B003                <1> 	mov al, 3
    12 0000100F CD10                <1> 	int 10h
    13                              <1> 
    14 00001011 61                  <1> 	popa
    15 00001012 C3                  <1> 	ret
    16                              <1> 
    17                              <1> ; ------------------------------------------------------------------
    18                              <1> ; change_cursor -- Change the cursors look
    19                              <1> ; IN: CH = 0x00/0x06
    20                              <1> 
    21                              <1> change_cursor:
    22 00001013 60                  <1> 	pusha
    23                              <1> 
    24 00001014 B401                <1> 	mov ah, 0x01
    25 00001016 B107                <1> 	mov cl, 0x07
    26 00001018 CD10                <1> 	int 10h
    27                              <1> 
    28 0000101A 61                  <1> 	popa
    29 0000101B C3                  <1> 	ret
    30                              <1> 
    31                              <1> ; ------------------------------------------------------------------
    32                              <1> ; hide_cursor -- Turns off cursor in text mode
    33                              <1> ; IN/OUT: Nothing
    34                              <1> 
    35                              <1> hide_cursor:
    36 0000101C 60                  <1> 	pusha
    37                              <1> 
    38 0000101D B520                <1> 	mov ch, 32
    39 0000101F B401                <1> 	mov ah, 1
    40 00001021 B003                <1> 	mov al, 3
    41 00001023 CD10                <1> 	int 10h
    42                              <1> 
    43 00001025 61                  <1> 	popa
    44 00001026 C3                  <1> 	ret
    45                              <1> 
    46                              <1> ; ------------------------------------------------------------------
    47                              <1> ; move_cursor -- Moves cursor in text mode
    48                              <1> ; IN: DH, DL = row, column
    49                              <1> 
    50                              <1> move_cursor:
    51 00001027 60                  <1> 	pusha
    52                              <1> 
    53 00001028 B700                <1> 	mov bh, 0
    54 0000102A B402                <1> 	mov ah, 2
    55 0000102C CD10                <1> 	int 0x10
    56                              <1> 
    57 0000102E 61                  <1> 	popa
    58 0000102F C3                  <1> 	ret
    59                              <1> 
    60                              <1> ; ------------------------------------------------------------------
    61                              <1> ; get_cursor_pos -- Return position of text cursor
    62                              <1> ; OUT: DH, DL = row, column
    63                              <1> 
    64                              <1> get_cursor_pos:
    65 00001030 60                  <1> 	pusha
    66                              <1> 
    67 00001031 B700                <1> 	mov bh, 0
    68 00001033 B403                <1> 	mov ah, 3
    69 00001035 CD10                <1> 	int 0x10
    70                              <1> 
    71 00001037 8916[4110]          <1> 	mov [.tmp], dx
    72 0000103B 61                  <1> 	popa
    73 0000103C 8B16[4110]          <1> 	mov dx, [.tmp]
    74 00001040 C3                  <1> 	ret
    75                              <1> 
    76 00001041 0000                <1> 	.tmp dw 0
    77                              <1> 
    78                              <1> ; ------------------------------------------------------------------
    79                              <1> ; print_horiz_line -- Draw a horizontal line on the screen
    80                              <1> ; IN: AX = line type (1 for double (=), otherwise single (-))
    81                              <1> 
    82                              <1> print_horiz_line:
    83 00001043 60                  <1> 	pusha
    84                              <1> 
    85 00001044 89C1                <1> 	mov cx, ax
    86 00001046 B0C4                <1> 	mov al, 196
    87                              <1> 
    88 00001048 83F901              <1> 	cmp cx, 1
    89 0000104B 7502                <1> 	jne .ready
    90 0000104D B0CD                <1> 	mov al, 205
    91                              <1> 
    92                              <1> 	.ready:
    93 0000104F B90000              <1> 		mov cx, 0
    94 00001052 B40E                <1> 		mov ah, 0Eh
    95                              <1> 
    96                              <1> 	.restart:
    97 00001054 CD10                <1> 		int 0x10
    98 00001056 41                  <1> 		inc cx
    99 00001057 83F950              <1> 		cmp cx, 80
   100 0000105A 7402                <1> 		je .done
   101 0000105C EBF6                <1> 		jmp .restart
   102                              <1> 
   103                              <1> 	.done:
   104 0000105E 61                  <1> 		popa
   105 0000105F C3                  <1> 		ret
   106                              <1> 
   107                              <1> ; ------------------------------------------------------------------
   108                              <1> ; input_dialog -- Get text string from user via a dialog box
   109                              <1> ; IN: AX = string location, BX = message to show
   110                              <1> ; OUT: AX = string location
   111                              <1> 
   112                              <1> input_dialog:
   113 00001060 60                  <1> 	pusha
   114                              <1> 
   115 00001061 50                  <1> 	push ax
   116 00001062 53                  <1> 	push bx
   117                              <1> 
   118                              <1> 
   119 00001063 B60A                <1> 	mov dh, 10
   120 00001065 B20C                <1> 	mov dl, 12
   121                              <1> 
   122                              <1> .redbox:
   123 00001067 E8BDFF              <1> 	call move_cursor
   124                              <1> 
   125 0000106A 60                  <1> 	pusha
   126 0000106B B409                <1> 	mov ah, 09h
   127 0000106D B700                <1> 	mov bh, 0
   128 0000106F B93700              <1> 	mov cx, 55
   129 00001072 B31F                <1> 	mov bl, 0x1F
   130 00001074 B020                <1> 	mov al, ' '
   131 00001076 CD10                <1> 	int 0x10
   132 00001078 61                  <1> 	popa
   133                              <1> 
   134 00001079 FEC6                <1> 	inc dh
   135 0000107B 80FE10              <1> 	cmp dh, 16
   136 0000107E 7402                <1> 	je .boxdone
   137 00001080 EBE5                <1> 	jmp .redbox
   138                              <1> 
   139                              <1> 
   140                              <1> .boxdone:
   141 00001082 B20E                <1> 	mov dl, 14
   142 00001084 B60B                <1> 	mov dh, 11
   143 00001086 E89EFF              <1> 	call move_cursor
   144                              <1> 
   145                              <1> 
   146 00001089 5B                  <1> 	pop bx
   147 0000108A 89DE                <1> 	mov si, bx
   148 0000108C E8E208              <1> 	call print
   149                              <1> 
   150 0000108F B20E                <1> 	mov dl, 14
   151 00001091 B60D                <1> 	mov dh, 13
   152 00001093 E891FF              <1> 	call move_cursor
   153                              <1> 
   154                              <1> 
   155 00001096 58                  <1> 	pop ax
   156 00001097 BB3200              <1> 	mov bx, 50
   157 0000109A E89B01              <1> 	call input_string
   158                              <1> 
   159 0000109D 61                  <1> 	popa
   160 0000109E C3                  <1> 	ret
   161                              <1> 
   162                              <1> ; ------------------------------------------------------------------
   163                              <1> ; draw_block -- Render block of specified colour
   164                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   165                              <1> 
   166                              <1> draw_block:
   167 0000109F 60                  <1> 	pusha
   168                              <1> 
   169                              <1> .more:
   170 000010A0 E884FF              <1> 	call move_cursor		; Move to block starting position
   171                              <1> 
   172 000010A3 B409                <1> 	mov ah, 09h			; Draw colour section
   173 000010A5 B700                <1> 	mov bh, 0
   174 000010A7 89F1                <1> 	mov cx, si
   175 000010A9 B020                <1> 	mov al, ' '
   176 000010AB CD10                <1> 	int 10h
   177                              <1> 
   178 000010AD FEC6                <1> 	inc dh				; Get ready for next line
   179                              <1> 
   180 000010AF B80000              <1> 	mov ax, 0
   181 000010B2 88F0                <1> 	mov al, dh			; Get current Y position into DL
   182 000010B4 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
   183 000010B6 75E8                <1> 	jne .more			; If not, keep drawing
   184                              <1> 
   185 000010B8 61                  <1> 	popa
   186 000010B9 C3                  <1> 	ret
   187                              <1> 
   188                              <1> ; ------------------------------------------------------------------
   189                              <1> ; dialog_box -- Print dialog box in middle of screen, with button(s)
   190                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display)
   191                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
   192                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   193                              <1> ; NOTE: Each string is limited to 40 characters
   194                              <1> 
   195                              <1> dialog_box:
   196 000010BA 60                  <1> 	pusha
   197                              <1> 
   198 000010BB 8916[3612]          <1> 	mov [.tmp], dx
   199                              <1> 
   200 000010BF E85AFF              <1> 	call hide_cursor
   201                              <1> 
   202 000010C2 B609                <1> 	mov dh, 9			; First, draw blue background box
   203 000010C4 B213                <1> 	mov dl, 19
   204                              <1> 
   205                              <1> .redbox:				; Loop to draw all lines of box
   206 000010C6 E85EFF              <1> 	call move_cursor
   207                              <1> 
   208 000010C9 60                  <1> 	pusha
   209 000010CA B409                <1> 	mov ah, 0x09
   210 000010CC B700                <1> 	mov bh, 0
   211 000010CE B92A00              <1> 	mov cx, 42
   212 000010D1 B31F                <1> 	mov bl, 0x1F		; White on blue
   213 000010D3 B020                <1> 	mov al, ' '
   214 000010D5 CD10                <1> 	int 10h
   215 000010D7 61                  <1> 	popa
   216                              <1> 
   217 000010D8 FEC6                <1> 	inc dh
   218 000010DA 80FE10              <1> 	cmp dh, 16
   219 000010DD 7402                <1> 	je .boxdone
   220 000010DF EBE5                <1> 	jmp .redbox
   221                              <1> 
   222                              <1> 
   223                              <1> .boxdone:
   224 000010E1 83F800              <1> 	cmp ax, 0			; Skip string params if zero
   225 000010E4 740C                <1> 	je .no_first_string
   226 000010E6 B214                <1> 	mov dl, 20
   227 000010E8 B60A                <1> 	mov dh, 10
   228 000010EA E83AFF              <1> 	call move_cursor
   229                              <1> 
   230 000010ED 89C6                <1> 	mov si, ax			; First string
   231 000010EF E87F08              <1> 	call print
   232                              <1> 
   233                              <1> .no_first_string:
   234 000010F2 83FB00              <1> 	cmp bx, 0
   235 000010F5 740C                <1> 	je .no_second_string
   236 000010F7 B214                <1> 	mov dl, 20
   237 000010F9 B60B                <1> 	mov dh, 11
   238 000010FB E829FF              <1> 	call move_cursor
   239                              <1> 
   240 000010FE 89DE                <1> 	mov si, bx			; Second string
   241 00001100 E86E08              <1> 	call print
   242                              <1> 
   243                              <1> .no_second_string:
   244 00001103 83F900              <1> 	cmp cx, 0
   245 00001106 740C                <1> 	je .no_third_string
   246 00001108 B214                <1> 	mov dl, 20
   247 0000110A B60C                <1> 	mov dh, 12
   248 0000110C E818FF              <1> 	call move_cursor
   249                              <1> 
   250 0000110F 89CE                <1> 	mov si, cx			; Third string
   251 00001111 E85D08              <1> 	call print
   252                              <1> 
   253                              <1> .no_third_string:
   254 00001114 8B16[3612]          <1> 	mov dx, [.tmp]
   255 00001118 83FA00              <1> 	cmp dx, 0
   256 0000111B 7405                <1> 	je .one_button
   257 0000111D 83FA01              <1> 	cmp dx, 1
   258 00001120 741E                <1> 	je .two_button
   259                              <1> 
   260                              <1> 
   261                              <1> .one_button:
   262 00001122 B3F0                <1> 	mov bl, 11110000b		; Black on white
   263 00001124 B60E                <1> 	mov dh, 14
   264 00001126 B223                <1> 	mov dl, 35
   265 00001128 BE0800              <1> 	mov si, 8
   266 0000112B BF0F00              <1> 	mov di, 15
   267 0000112E E86EFF              <1> 	call draw_block
   268                              <1> 
   269 00001131 B226                <1> 	mov dl, 38			; OK button, centred at bottom of box
   270 00001133 B60E                <1> 	mov dh, 14
   271 00001135 E8EFFE              <1> 	call move_cursor
   272 00001138 BE[1612]            <1> 	mov si, .ok_button_string
   273 0000113B E83308              <1> 	call print
   274                              <1> 
   275 0000113E EB2E                <1> 	jmp .one_button_wait
   276                              <1> 
   277                              <1> 
   278                              <1> .two_button:
   279 00001140 B3F0                <1> 	mov bl, 11110000b		; Black on white
   280 00001142 B60E                <1> 	mov dh, 14
   281 00001144 B21B                <1> 	mov dl, 27
   282 00001146 BE0800              <1> 	mov si, 8
   283 00001149 BF0F00              <1> 	mov di, 15
   284 0000114C E850FF              <1> 	call draw_block
   285                              <1> 
   286 0000114F B21E                <1> 	mov dl, 30			; OK button
   287 00001151 B60E                <1> 	mov dh, 14
   288 00001153 E8D1FE              <1> 	call move_cursor
   289 00001156 BE[1612]            <1> 	mov si, .ok_button_string
   290 00001159 E81508              <1> 	call print
   291                              <1> 
   292 0000115C B22C                <1> 	mov dl, 44			; Cancel button
   293 0000115E B60E                <1> 	mov dh, 14
   294 00001160 E8C4FE              <1> 	call move_cursor
   295 00001163 BE[1912]            <1> 	mov si, .cancel_button_string
   296 00001166 E80808              <1> 	call print
   297                              <1> 
   298 00001169 B90000              <1> 	mov cx, 0			; Default button = 0
   299 0000116C EB0D                <1> 	jmp .two_button_wait
   300                              <1> 
   301                              <1> 
   302                              <1> 
   303                              <1> .one_button_wait:
   304 0000116E B400                <1> 	mov ah, 0x00
   305 00001170 CD16                <1> 	int 0x16
   306                              <1> 
   307 00001172 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
   308 00001174 75F8                <1> 	jne .one_button_wait
   309                              <1> 
   310 00001176 E88DFE              <1> 	call show_cursor
   311                              <1> 
   312 00001179 61                  <1> 	popa
   313 0000117A C3                  <1> 	ret
   314                              <1> 
   315                              <1> 
   316                              <1> .two_button_wait:
   317 0000117B B400                <1> 	mov ah, 0x00
   318 0000117D CD16                <1> 	int 0x16
   319                              <1> 	
   320 0000117F 80FC4B              <1> 	cmp ah, 0x4B			; Left cursor key pressed?
   321 00001182 753D                <1> 	jne .noleft
   322                              <1> 
   323 00001184 B3F0                <1> 	mov bl, 11110000b		; Black on white
   324 00001186 B60E                <1> 	mov dh, 14
   325 00001188 B21B                <1> 	mov dl, 27
   326 0000118A BE0800              <1> 	mov si, 8
   327 0000118D BF0F00              <1> 	mov di, 15
   328 00001190 E80CFF              <1> 	call draw_block
   329                              <1> 
   330 00001193 B21E                <1> 	mov dl, 30				; OK button
   331 00001195 B60E                <1> 	mov dh, 14
   332 00001197 E88DFE              <1> 	call move_cursor
   333 0000119A BE[1612]            <1> 	mov si, .ok_button_string
   334 0000119D E8D107              <1> 	call print
   335                              <1> 
   336 000011A0 B31F                <1> 	mov bl, 0x1F		; White on blue for cancel button
   337 000011A2 B60E                <1> 	mov dh, 14
   338 000011A4 B22A                <1> 	mov dl, 42
   339 000011A6 BE0900              <1> 	mov si, 9
   340 000011A9 BF0F00              <1> 	mov di, 15
   341 000011AC E8F0FE              <1> 	call draw_block
   342                              <1> 
   343 000011AF B22C                <1> 	mov dl, 44				; Cancel button
   344 000011B1 B60E                <1> 	mov dh, 14
   345 000011B3 E871FE              <1> 	call move_cursor
   346 000011B6 BE[1912]            <1> 	mov si, .cancel_button_string
   347 000011B9 E8B507              <1> 	call print
   348                              <1> 
   349 000011BC B90000              <1> 	mov cx, 0				; And update result we'll return
   350 000011BF EBBA                <1> 	jmp .two_button_wait
   351                              <1> 
   352                              <1> 
   353                              <1> .noleft:
   354 000011C1 80FC4D              <1> 	cmp ah, 0x4D			; Right cursor key pressed?
   355 000011C4 753E                <1> 	jne .noright
   356                              <1> 
   357                              <1> 
   358 000011C6 B31F                <1> 	mov bl, 0x1F		; Black on white
   359 000011C8 B60E                <1> 	mov dh, 14
   360 000011CA B21B                <1> 	mov dl, 27
   361 000011CC BE0800              <1> 	mov si, 8
   362 000011CF BF0F00              <1> 	mov di, 15
   363 000011D2 E8CAFE              <1> 	call draw_block
   364                              <1> 
   365 000011D5 B21E                <1> 	mov dl, 30				; OK button
   366 000011D7 B60E                <1> 	mov dh, 14
   367 000011D9 E84BFE              <1> 	call move_cursor
   368 000011DC BE[1612]            <1> 	mov si, .ok_button_string
   369 000011DF E88F07              <1> 	call print
   370                              <1> 
   371 000011E2 B3F0                <1> 	mov bl, 11110000b		; White on blue for cancel button
   372 000011E4 B60E                <1> 	mov dh, 14
   373 000011E6 B22B                <1> 	mov dl, 43
   374 000011E8 BE0800              <1> 	mov si, 8
   375 000011EB BF0F00              <1> 	mov di, 15
   376 000011EE E8AEFE              <1> 	call draw_block
   377                              <1> 
   378 000011F1 B22C                <1> 	mov dl, 44				; Cancel button
   379 000011F3 B60E                <1> 	mov dh, 14
   380 000011F5 E82FFE              <1> 	call move_cursor
   381 000011F8 BE[1912]            <1> 	mov si, .cancel_button_string
   382 000011FB E87307              <1> 	call print
   383                              <1> 
   384 000011FE B90100              <1> 	mov cx, 1				; And update result we'll return
   385 00001201 E977FF              <1> 	jmp .two_button_wait
   386                              <1> 
   387                              <1> 
   388                              <1> .noright:
   389 00001204 3C0D                <1> 	cmp al, 13				; Wait for enter key (13) to be pressed
   390 00001206 0F8571FF            <1> 	jne .two_button_wait
   391                              <1> 
   392 0000120A E8F9FD              <1> 	call show_cursor
   393                              <1> 
   394 0000120D 890E[3612]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
   395 00001211 61                  <1> 	popa
   396 00001212 A1[3612]            <1> 	mov ax, [.tmp]
   397                              <1> 
   398 00001215 C3                  <1> 	ret
   399                              <1> 
   400                              <1> 
   401 00001216 4F4B00              <1> 	.ok_button_string	db 'OK', 0
   402 00001219 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
   403 00001220 2020204F4B20202000  <1> 	.ok_button_noselect	db '   OK   ', 0
   404 00001229 20202043616E63656C- <1> 	.cancel_button_noselect	db '   Cancel   ', 0
   404 00001232 20202000            <1>
   405                              <1> 
   406 00001236 0000                <1> 	.tmp dw 0
   407                              <1> 
   408                              <1> ; ------------------------------------------------------------------
   409                              <1> ; input_string --- Get a string from keyboard input
   410                              <1> ; IN: AX = output address, BX = maximum bytes of output string
   411                              <1> ; OUT: nothing
   412                              <1> 
   413                              <1> input_string:
   414 00001238 60                  <1> 	pusha
   415                              <1> 
   416                              <1> 	; If the character count is zero, don't do anything.
   417 00001239 83FB00              <1> 	cmp bx, 0
   418 0000123C 7424                <1> 	je .done
   419                              <1> 
   420 0000123E 89C7                <1> 	mov di, ax			; DI = Current position in buffer
   421                              <1> 	
   422 00001240 4B                  <1> 	dec bx				; BX = Maximum characters in string
   423 00001241 89D9                <1> 	mov cx, bx			; CX = Remaining character count
   424                              <1> 
   425                              <1> .get_char:
   426 00001243 B400                <1> 	mov ah, 0x00
   427 00001245 CD16                <1> 	int 0x16
   428                              <1> 
   429 00001247 3C08                <1> 	cmp al, 8
   430 00001249 7419                <1> 	je .backspace
   431                              <1> 
   432 0000124B 3C0D                <1> 	cmp al, 13			; The ENTER key ends the prompt
   433 0000124D 7410                <1> 	je .end_string
   434                              <1> 
   435                              <1> 	; Do not add any characters if the maximum size has been reached.
   436 0000124F E3F2                <1> 	jcxz .get_char
   437                              <1> 
   438                              <1> 	; Only add printable characters (ASCII Values 32-126)
   439 00001251 3C20                <1> 	cmp al, ' '
   440 00001253 72EE                <1> 	jb .get_char
   441                              <1> 
   442 00001255 3C7E                <1> 	cmp al, 126
   443 00001257 77EA                <1> 	ja .get_char
   444                              <1> 
   445 00001259 E83100              <1> 	call .add_char
   446                              <1> 
   447 0000125C 49                  <1> 	dec cx
   448 0000125D EBE4                <1> 	jmp .get_char
   449                              <1> 
   450                              <1> .end_string:
   451 0000125F B000                <1> 	mov al, 0
   452 00001261 AA                  <1> 	stosb
   453                              <1> 
   454                              <1> .done:
   455 00001262 61                  <1> 	popa
   456 00001263 C3                  <1> 	ret
   457                              <1> 
   458                              <1> .backspace:
   459                              <1> 	; Check if there are any characters to backspace
   460 00001264 39D9                <1> 	cmp cx, bx 
   461 00001266 73DB                <1> 	jae .get_char
   462                              <1> 
   463 00001268 41                  <1> 	inc cx				; Increase characters remaining
   464                              <1> 
   465 00001269 E80A00              <1> 	call .reverse_cursor		; Move back to the previous character
   466 0000126C B020                <1> 	mov al, ' '			; Print a space on the character
   467 0000126E E81C00              <1> 	call .add_char
   468 00001271 E80200              <1> 	call .reverse_cursor		; Now move the cursor back again
   469                              <1> 
   470 00001274 EBCD                <1> 	jmp .get_char
   471                              <1> 
   472                              <1> .reverse_cursor:
   473 00001276 4F                  <1> 	dec di				; Move the output pointer backwards
   474                              <1> 	
   475 00001277 E8B6FD              <1> 	call get_cursor_pos
   476 0000127A 80FA00              <1> 	cmp dl, 0			; Is the cursor at the start of line?
   477 0000127D 7406                <1> 	je .back_line
   478                              <1> 
   479 0000127F FECA                <1> 	dec dl				; If not, just decrease the column
   480 00001281 E8A3FD              <1> 	call move_cursor
   481 00001284 C3                  <1> 	ret
   482                              <1> 
   483                              <1> .back_line:
   484 00001285 FECE                <1> 	dec dh				; Otherwise, move the cursor to the end
   485 00001287 B24F                <1> 	mov dl, 79			; of the previous line.
   486 00001289 E89BFD              <1> 	call move_cursor
   487 0000128C C3                  <1> 	ret
   488                              <1> 
   489                              <1> 
   490                              <1> .add_char:
   491 0000128D AA                  <1> 	stosb
   492 0000128E B40E                <1> 	mov ah, 0x0E			; Teletype Function
   493 00001290 B700                <1> 	mov bh, 0			; Video Page 0
   494 00001292 55                  <1> 	push bp				; Some BIOS's may mess up BP
   495 00001293 CD10                <1> 	int 0x10
   496 00001295 5D                  <1> 	pop bp
   497 00001296 C3                  <1> 	ret
   498                              <1> 
   499                              <1> ; ------------------------------------------------------------------
   500                              <1> ; switch_mode -- Switch between VIDEO and CLI mode
   501                              <1> ; IN: AX = mode (0 for CLI and 1 for video)
   502                              <1> ;	  BH = color scheme (only background for video)
   503                              <1> ; OUT: Switches mode
   504                              <1> 
   505                              <1> switch_mode:
   506 00001297 60                  <1> 	pusha
   507 00001298 30DB                <1> 	xor bl, bl
   508                              <1> 
   509 0000129A 85C0                <1> 	test ax, ax
   510 0000129C 7405                <1> 	je .switch_cli
   511                              <1> 
   512 0000129E 83F801              <1> 	cmp ax, 1
   513 000012A1 740F                <1> 	je .switch_vid
   514                              <1> 
   515                              <1> .switch_cli:
   516                              <1> 	; Switch to text mode
   517 000012A3 B80300              <1> 	mov ax, cliRes
   518 000012A6 CD10                <1> 	int 0x10
   519                              <1> 
   520                              <1> 	; Change the cursor
   521 000012A8 31C9                <1> 	xor cx, cx
   522 000012AA E866FD              <1> 	call change_cursor
   523                              <1> 
   524                              <1> 	; Clear the screen and change color scheme
   525 000012AD E813F9              <1> 	call cls
   526                              <1> 
   527 000012B0 EB0A                <1> 	jmp .done
   528                              <1> 
   529                              <1> .switch_vid:
   530                              <1> 	; Switch to video mode
   531 000012B2 B81300              <1> 	mov ax, vidRes
   532 000012B5 CD10                <1> 	int 0x10
   533                              <1> 
   534                              <1> 	; Clear the screen and change the background color
   535 000012B7 E809F9              <1> 	call cls
   536                              <1> 
   537 000012BA EB00                <1> 	jmp .done
   538                              <1> 
   539                              <1> .done:
   540 000012BC 61                  <1> 	popa
   541 000012BD C3                  <1> 	ret
   542                              <1> 
   543                              <1> ; ------------------------------------------------------------------
   544                              <1> ; setup_bottom_string -- Draw a string in the bottom of the setup screen
   545                              <1> ; IN: SI = String location
   546                              <1> 
   547                              <1> setup_bottom_string:
   548 000012BE 56                  <1> 	push si
   549 000012BF B617                <1>     mov dh, 23
   550 000012C1 30D2                <1>     xor dl, dl
   551 000012C3 E861FD              <1>     call move_cursor
   552                              <1> 
   553 000012C6 B80100              <1>     mov ax, 1
   554 000012C9 E877FD              <1>     call print_horiz_line
   555                              <1> 	
   556 000012CC 5E                  <1> 	pop si
   557 000012CD E8A106              <1>     call print
   558                              <1> 
   559 000012D0 31D2                <1>     xor dx, dx
   560 000012D2 E852FD              <1>     call move_cursor
   561                              <1> 
   562 000012D5 C3                  <1> 	ret
   563                              <1> 
   564                              <1> ; ------------------------------------------------------------------
   565                              <1> ; setup_input -- Get keyboard input for the setup
   566                              <1> ; IN: AX = string location
   567                              <1> ; OUT: AX = string location
   568                              <1> 
   569                              <1> setup_input:
   570 000012D6 60                  <1> 	pusha
   571 000012D7 89C7                <1> 	mov di, ax
   572 000012D9 50                  <1> 	push ax
   573                              <1> 
   574                              <1> 	; Position the mouse
   575 000012DA B403                <1> 	mov ah, 0x03
   576 000012DC B700                <1> 	mov bh, 0
   577 000012DE CD10                <1> 	int 0x10
   578                              <1> 
   579 000012E0 B402                <1> 	mov ah, 0x02
   580 000012E2 B21B                <1> 	mov dl, 27
   581 000012E4 FEC6                <1> 	inc dh
   582 000012E6 CD10                <1> 	int 0x10
   583                              <1> 
   584                              <1> 	; And draw the top/sides
   585 000012E8 BE[9313]            <1> 	mov si, .top_bar
   586 000012EB E88306              <1> 	call print
   587                              <1> 
   588 000012EE B402                <1> 	mov ah, 0x02
   589 000012F0 B21B                <1> 	mov dl, 27
   590 000012F2 FEC6                <1> 	inc dh
   591 000012F4 CD10                <1> 	int 0x10
   592                              <1> 	
   593 000012F6 8836[CD13]          <1> 	mov [.mouse_pos], dh
   594 000012FA BE[AC13]            <1> 	mov si, .sidl_bar
   595 000012FD E87106              <1> 	call print
   596                              <1> 	
   597 00001300 B402                <1> 	mov ah, 0x02
   598 00001302 B21B                <1> 	mov dl, 27
   599 00001304 FEC6                <1> 	inc dh
   600 00001306 CD10                <1> 	int 0x10
   601                              <1> 
   602 00001308 BE[B313]            <1> 	mov si, .bot_bar
   603 0000130B E86306              <1> 	call print
   604                              <1> 
   605 0000130E B402                <1> 	mov ah, 0x02
   606 00001310 B21B                <1> 	mov dl, 27
   607 00001312 8A36[CD13]          <1> 	mov dh, [.mouse_pos]
   608 00001316 CD10                <1> 	int 0x10
   609                              <1> 
   610 00001318 30DB                <1> 	xor bl, bl
   611                              <1> 
   612                              <1> 	; Clear the string location
   613                              <1> .clear_loop:
   614 0000131A B000                <1> 	mov al, 0
   615 0000131C AA                  <1> 	stosb
   616 0000131D FEC3                <1> 	inc bl
   617                              <1> 
   618 0000131F 80FB14              <1> 	cmp bl, 20
   619 00001322 75F6                <1> 	jne .clear_loop
   620                              <1> 
   621 00001324 B403                <1> 	mov ah, 0x03
   622 00001326 B700                <1> 	mov bh, 0
   623 00001328 CD10                <1> 	int 0x10
   624                              <1> 
   625 0000132A B402                <1> 	mov ah, 0x02
   626 0000132C B21D                <1> 	mov dl, 29
   627 0000132E CD10                <1> 	int 0x10
   628                              <1> 
   629 00001330 58                  <1> 	pop ax
   630 00001331 89C7                <1> 	mov di, ax
   631 00001333 30DB                <1> 	xor bl, bl
   632                              <1> 
   633                              <1> .input_loop:
   634 00001335 B403                <1> 	mov ah, 0x03
   635 00001337 B700                <1> 	mov bh, 0
   636 00001339 CD10                <1> 	int 0x10
   637                              <1> 
   638 0000133B 8816[CD13]          <1> 	mov [.mouse_pos], dl
   639                              <1> 
   640 0000133F B402                <1> 	mov ah, 0x02
   641 00001341 B230                <1> 	mov dl, 48
   642 00001343 CD10                <1> 	int 0x10
   643                              <1> 
   644 00001345 BE[AF13]            <1> 	mov si, .sidr_bar
   645 00001348 E82606              <1> 	call print
   646                              <1> 
   647 0000134B B402                <1> 	mov ah, 0x02
   648 0000134D 8A16[CD13]          <1> 	mov dl, [.mouse_pos]
   649 00001351 CD10                <1> 	int 0x10
   650                              <1> 
   651 00001353 B400                <1> 	mov ah, 0x00
   652 00001355 CD16                <1> 	int 0x16
   653                              <1> 
   654 00001357 3C0D                <1> 	cmp al, 0x0d
   655 00001359 7436                <1> 	je .input_done
   656                              <1> 
   657 0000135B 3C08                <1> 	cmp al, 0x08
   658 0000135D 7524                <1> 	jne .not_back
   659                              <1> 
   660                              <1> 	; Pressed backspace
   661 0000135F B403                <1> 	mov ah, 0x03
   662 00001361 B700                <1> 	mov bh, 0
   663 00001363 CD10                <1> 	int 0x10
   664                              <1> 
   665 00001365 80FA1D              <1> 	cmp dl, 29
   666 00001368 74CB                <1> 	je .input_loop
   667                              <1> 
   668 0000136A FECA                <1> 	dec dl
   669 0000136C FECB                <1> 	dec bl
   670                              <1> 
   671 0000136E B402                <1> 	mov ah, 0x02
   672 00001370 CD10                <1> 	int 0x10
   673                              <1> 
   674 00001372 B40E                <1> 	mov ah, 0x0e
   675 00001374 B000                <1> 	mov al, 0
   676 00001376 CD10                <1> 	int 0x10
   677                              <1> 	
   678 00001378 B402                <1> 	mov ah, 0x02
   679 0000137A CD10                <1> 	int 0x10
   680                              <1> 
   681 0000137C 4F                  <1> 	dec di
   682 0000137D B000                <1> 	mov al, 0
   683 0000137F AA                  <1> 	stosb
   684 00001380 4F                  <1> 	dec di
   685                              <1> 
   686 00001381 EBB2                <1> 	jmp .input_loop
   687                              <1> 
   688                              <1> .not_back:
   689 00001383 80FB13              <1> 	cmp bl, 19
   690 00001386 74AD                <1> 	je .input_loop
   691 00001388 FEC3                <1> 	inc bl
   692                              <1> 
   693 0000138A AA                  <1> 	stosb
   694                              <1> 
   695 0000138B B40E                <1> 	mov ah, 0x0e
   696 0000138D CD10                <1> 	int 0x10
   697                              <1> 
   698 0000138F EBA4                <1> 	jmp .input_loop 
   699                              <1> 
   700                              <1> .input_done:
   701 00001391 61                  <1> 	popa
   702 00001392 C3                  <1> 	ret
   703                              <1> 
   704 00001393 DA                  <1> .top_bar:	db 0xda
   705 00001394 C4<rept>            <1> 			times 21 db 0xc4
   706 000013A9 BF0A00              <1> 			db 0xbf, 0x0a, 0
   707 000013AC B32000              <1> .sidl_bar:	db 0xb3, 0x20, 0
   708 000013AF 20B30A00            <1> .sidr_bar:	db 0x20, 0xb3, 0x0a, 0
   709 000013B3 C0                  <1> .bot_bar:	db 0xc0
   710 000013B4 C4<rept>            <1> 			times 21 db 0xc4
   711 000013C9 D90A0D00            <1> 			db 0xd9, 0x0a, 0x0d, 0
   712                              <1> 
   713 000013CD 1D                  <1> .mouse_pos:	db 29
   714                              <1> 
   715                              <1> ; ------------------------------------------------------------------
   716                              <1> ; setup_choose -- Draw text and use the cursors to choose between them
   717                              <1> ; IN: AX, BX, CX = options
   718                              <1> ;	  DH = not focused color
   719                              <1> ;	  DL = focused color
   720                              <1> ; OUT: AX = options choosen (starting at 0)
   721                              <1> 
   722                              <1> setup_choose:
   723 000013CE E84BFC              <1> 	call hide_cursor
   724 000013D1 60                  <1> 	pusha
   725 000013D2 52                  <1> 	push dx
   726                              <1> 
   727 000013D3 8A16[0615]          <1> 	mov dl, [.start_x]
   728 000013D7 8A36[0715]          <1> 	mov dh, [.start_y]
   729 000013DB E849FC              <1> 	call move_cursor
   730 000013DE 5A                  <1> 	pop dx
   731                              <1> 	
   732 000013DF 89C6                <1> 	mov si, ax
   733 000013E1 BF[0815]            <1> 	mov di, .option1
   734 000013E4 E87BF8              <1> 	call string_copy
   735                              <1> 	
   736 000013E7 89DE                <1> 	mov si, bx
   737 000013E9 BF[3015]            <1> 	mov di, .option2
   738 000013EC E873F8              <1> 	call string_copy
   739                              <1> 
   740 000013EF 89CE                <1> 	mov si, cx
   741 000013F1 BF[5815]            <1> 	mov di, .option3
   742 000013F4 E86BF8              <1> 	call string_copy
   743                              <1> 
   744 000013F7 31C9                <1> 	xor cx, cx
   745 000013F9 EB03                <1> 	jmp .choose_loop
   746                              <1> 
   747 000013FB E9F700              <1> 	jmp .done
   748                              <1> 
   749                              <1> .choose_loop:
   750 000013FE E84100              <1> 	call .print_options
   751 00001401 E80B00              <1> 	call .check_arrows
   752 00001404 E8C800              <1> 	call .clear_bottom
   753                              <1> 
   754 00001407 83F803              <1> 	cmp ax, 3
   755 0000140A 75F2                <1> 	jne .choose_loop
   756 0000140C E9E600              <1> 	jmp .done
   757                              <1> 
   758                              <1> .check_arrows:
   759 0000140F 60                  <1> 	pusha
   760 00001410 BE[AE0B]            <1>     mov si, setup_string
   761 00001413 E8A8FE              <1>     call setup_bottom_string
   762 00001416 61                  <1> 	popa
   763                              <1> 
   764 00001417 31C0                <1> 	xor ax, ax
   765 00001419 CD16                <1> 	int 0x16
   766                              <1> 
   767 0000141B 80FC48              <1> 	cmp ah, 0x48	; UP
   768 0000141E 740A                <1> 	je .up
   769 00001420 80FC50              <1> 	cmp ah, 0x50	; DOWN
   770 00001423 740F                <1> 	je .down
   771                              <1> 
   772 00001425 3C0D                <1> 	cmp al, 0x0D	; ENTER
   773 00001427 7415                <1> 	je .enter
   774                              <1> 
   775 00001429 C3                  <1> 	ret				; Failsafe return
   776                              <1> 
   777                              <1> 	.up:
   778 0000142A 85C9                <1> 		test cx, cx
   779 0000142C 7402                <1> 		jz .at_top
   780                              <1> 
   781 0000142E 49                  <1> 		dec cx
   782 0000142F C3                  <1> 		ret
   783                              <1> 	
   784                              <1> 		.at_top:
   785 00001430 B90200              <1> 			mov cx, 2
   786 00001433 C3                  <1> 			ret
   787                              <1> 	
   788                              <1> 	.down:
   789 00001434 83F902              <1> 		cmp cx, 2
   790 00001437 7402                <1> 		je .at_bottom
   791                              <1> 
   792 00001439 41                  <1> 		inc cx
   793 0000143A C3                  <1> 		ret
   794                              <1> 
   795                              <1> 		.at_bottom:
   796 0000143B 31C9                <1> 			xor cx, cx
   797 0000143D C3                  <1> 			ret
   798                              <1> 
   799                              <1> 	.enter:
   800 0000143E B80300              <1> 		mov ax, 3
   801 00001441 C3                  <1> 		ret
   802                              <1> 
   803                              <1> .print_options:
   804 00001442 83F900              <1> 	cmp cx, 0
   805 00001445 740A                <1> 	je .mark_1
   806                              <1> 
   807 00001447 83F901              <1> 	cmp cx, 1
   808 0000144A 7419                <1> 	je .mark_2
   809                              <1> 
   810 0000144C 83F902              <1> 	cmp cx, 2
   811 0000144F 7428                <1> 	je .mark_3
   812                              <1> 
   813                              <1> 	.mark_1:
   814 00001451 BE[0815]            <1> 		mov si, .option1
   815 00001454 E83F00              <1> 		call .print_marked
   816                              <1> 
   817 00001457 BE[3015]            <1> 		mov si, .option2
   818 0000145A E82F00              <1> 		call .print_normal
   819                              <1> 
   820 0000145D BE[5815]            <1> 		mov si, .option3
   821 00001460 E82900              <1> 		call .print_normal
   822                              <1> 
   823 00001463 EB26                <1> 		jmp .mark_done
   824                              <1> 	
   825                              <1> 	.mark_2:
   826 00001465 BE[0815]            <1> 		mov si, .option1
   827 00001468 E82100              <1> 		call .print_normal
   828                              <1> 
   829 0000146B BE[3015]            <1> 		mov si, .option2
   830 0000146E E82500              <1> 		call .print_marked
   831                              <1> 
   832 00001471 BE[5815]            <1> 		mov si, .option3
   833 00001474 E81500              <1> 		call .print_normal
   834                              <1> 
   835 00001477 EB12                <1> 		jmp .mark_done
   836                              <1> 	
   837                              <1> 	.mark_3:
   838 00001479 BE[0815]            <1> 		mov si, .option1
   839 0000147C E80D00              <1> 		call .print_normal
   840                              <1> 
   841 0000147F BE[3015]            <1> 		mov si, .option2
   842 00001482 E80700              <1> 		call .print_normal
   843                              <1> 
   844 00001485 BE[5815]            <1> 		mov si, .option3
   845 00001488 E80B00              <1> 		call .print_marked
   846                              <1> 
   847                              <1> 	.mark_done:
   848 0000148B C3                  <1> 		ret
   849                              <1> 
   850                              <1> .print_normal:
   851 0000148C E81700              <1> 	call .print_space
   852 0000148F E8DF04              <1> 	call print
   853 00001492 E82D00              <1> 	call .new_line
   854                              <1> 
   855 00001495 C3                  <1> 	ret
   856                              <1> 
   857                              <1> .print_marked:
   858 00001496 53                  <1> 	push bx
   859                              <1> 
   860 00001497 E80C00              <1> 	call .print_space
   861 0000149A 31DB                <1> 	xor bx, bx
   862 0000149C 88D3                <1> 	mov bl, dl
   863 0000149E E80905              <1> 	call print_atr
   864 000014A1 E81E00              <1> 	call .new_line
   865                              <1> 
   866 000014A4 5B                  <1> 	pop bx
   867 000014A5 C3                  <1> 	ret
   868                              <1> 
   869                              <1> .print_space:
   870 000014A6 53                  <1> 	push bx
   871                              <1> 
   872 000014A7 31DB                <1> 	xor bx, bx
   873 000014A9 BB2800              <1> 	mov bx, .screen_mid
   874                              <1> 	
   875 000014AC 89F0                <1> 	mov ax, si
   876 000014AE E828F7              <1> 	call string_length
   877 000014B1 D1F8                <1> 	sar ax, 1
   878                              <1> 
   879 000014B3 29C3                <1> 	sub bx, ax
   880                              <1> 
   881                              <1> 	.space_loop:
   882 000014B5 B40E                <1> 		mov ah, 0x0e
   883 000014B7 B020                <1> 		mov al, ' '
   884 000014B9 CD10                <1> 		int 0x10
   885                              <1> 
   886 000014BB 4B                  <1> 		dec bx
   887 000014BC 85DB                <1> 		test bx, bx
   888 000014BE 75F5                <1> 		jnz .space_loop
   889                              <1> 
   890 000014C0 5B                  <1> 	pop bx
   891 000014C1 C3                  <1> 	ret
   892                              <1> 
   893                              <1> .new_line:
   894 000014C2 50                  <1> 	push ax
   895                              <1> 
   896 000014C3 B80A0E              <1> 	mov ax, 0x0E0A
   897 000014C6 CD10                <1> 	int 0x10
   898 000014C8 B80D0E              <1> 	mov ax, 0x0E0D
   899 000014CB CD10                <1> 	int 0x10
   900                              <1> 
   901 000014CD 58                  <1> 	pop ax
   902 000014CE C3                  <1> 	ret
   903                              <1> 
   904                              <1> .clear_bottom:
   905 000014CF 60                  <1> 	pusha
   906                              <1> 
   907 000014D0 8A36[0715]          <1> 	mov dh, [.start_y]
   908 000014D4 8A16[0615]          <1> 	mov dl, [.start_x]
   909 000014D8 E84CFB              <1> 	call move_cursor
   910                              <1> 
   911 000014DB B80A07              <1> 	mov ax, 0x070A
   912 000014DE B71F                <1> 	mov bh, 0x1F
   913 000014E0 31C9                <1> 	xor cx, cx
   914 000014E2 BA4F18              <1> 	mov dx, 0x184f
   915 000014E5 CD10                <1> 	int 0x10
   916                              <1> 	
   917 000014E7 B80A06              <1> 	mov ax, 0x060A
   918 000014EA B71F                <1> 	mov bh, 0x1F
   919 000014EC 31C9                <1> 	xor cx, cx
   920 000014EE BA4F18              <1> 	mov dx, 0x184f
   921 000014F1 CD10                <1> 	int 0x10
   922                              <1> 
   923 000014F3 61                  <1> 	popa
   924 000014F4 C3                  <1> 	ret
   925                              <1> 
   926                              <1> .done:
   927 000014F5 E8D7FF              <1> 	call .clear_bottom
   928 000014F8 890E[8015]          <1> 	mov [.option_picked], cx
   929                              <1> 
   930 000014FC 61                  <1> 	popa
   931 000014FD E806FB              <1> 	call show_cursor
   932                              <1> 
   933 00001500 0FB606[8015]        <1> 	movzx ax, [.option_picked]
   934 00001505 C3                  <1> 	ret
   935                              <1> 
   936                              <1> .screen_mid		equ 40
   937 00001506 00                  <1> .start_x:		db 0
   938 00001507 12                  <1> .start_y:		db 18
   939                              <1> 
   940 00001508 00<rept>            <1> .option1:		times 40 db 0
   941 00001530 00<rept>            <1> .option2:		times 40 db 0
   942 00001558 00<rept>            <1> .option3:		times 40 db 0
   943                              <1> 
   944 00001580 00                  <1> .option_picked:	db 0
   945                              <1> 
   946                              <1> ; ------------------------------------------------------------------
   947                              <1> ; draw_setup_box -- Draw a text box for the setup
   948                              <1> ; IN: SI = location of the string
   949                              <1> ; OUT: prints a box that's meant for the setup
   950                              <1> 
   951                              <1> draw_setup_box:
   952 00001581 60                  <1> 	pusha
   953 00001582 30DB                <1> 	xor bl, bl
   954                              <1> 
   955 00001584 31D2                <1> 	xor dx, dx
   956 00001586 E89EFA              <1> 	call move_cursor
   957                              <1> 
   958 00001589 56                  <1> 	push si
   959 0000158A BE[ED15]            <1> 	mov si, .setbox_top
   960 0000158D E8E103              <1> 	call print
   961                              <1> 
   962 00001590 BE[7816]            <1> 	mov si, .setbox_nwl
   963 00001593 E8DB03              <1> 	call print
   964                              <1> 
   965 00001596 5E                  <1> 	pop si
   966                              <1> 
   967                              <1> .print_loop:
   968 00001597 AC                  <1> 	lodsb
   969 00001598 84C0                <1> 	test al, al
   970 0000159A 7446                <1> 	je .done
   971                              <1> 
   972 0000159C 3C0A                <1> 	cmp al, 0x0a
   973 0000159E 740D                <1> 	je .new_line
   974                              <1> 
   975 000015A0 80FB30              <1> 	cmp bl, 48
   976 000015A3 7408                <1> 	je .new_line
   977                              <1> 
   978 000015A5 B40E                <1> 	mov ah, 0x0e
   979 000015A7 CD10                <1> 	int 0x10
   980                              <1> 	
   981 000015A9 FEC3                <1> 	inc bl
   982                              <1> 
   983 000015AB EBEA                <1> 	jmp .print_loop
   984                              <1> 
   985                              <1> .new_line:
   986 000015AD E80A00              <1> 	call .finish_line
   987                              <1> 
   988 000015B0 56                  <1> 	push si
   989 000015B1 BE[7816]            <1> 	mov si, .setbox_nwl
   990 000015B4 E8BA03              <1> 	call print
   991 000015B7 5E                  <1> 	pop si
   992                              <1> 
   993 000015B8 EBDD                <1> 	jmp .print_loop
   994                              <1> 
   995                              <1> .finish_line:
   996 000015BA B730                <1> 	mov bh, border_length-2
   997 000015BC 28DF                <1> 	sub bh, bl
   998                              <1> 
   999                              <1> .finish_loop:
  1000 000015BE 80FF00              <1> 	cmp bh, 0
  1001 000015C1 760A                <1> 	jbe .loop_done
  1002                              <1> 
  1003 000015C3 B40E                <1> 	mov ah, 0x0e
  1004 000015C5 B020                <1> 	mov al, " "
  1005 000015C7 CD10                <1> 	int 0x10
  1006 000015C9 FECF                <1> 	dec bh
  1007                              <1> 
  1008 000015CB EBF1                <1> 	jmp .finish_loop
  1009                              <1> 
  1010                              <1> .loop_done:
  1011 000015CD 56                  <1> 	push si
  1012 000015CE BE[8916]            <1> 	mov si, .setbox_fnl
  1013 000015D1 E89D03              <1> 	call print
  1014 000015D4 5E                  <1> 	pop si
  1015 000015D5 31DB                <1> 	xor bx, bx
  1016                              <1> 
  1017 000015D7 B80A0E              <1> 	mov ax, 0x0e0a
  1018 000015DA CD10                <1> 	int 0x10
  1019                              <1> 
  1020 000015DC B80D0E              <1> 	mov ax, 0x0e0d
  1021 000015DF CD10                <1> 	int 0x10
  1022                              <1> 	
  1023 000015E1 C3                  <1> 	ret
  1024                              <1> 
  1025                              <1> .done:
  1026 000015E2 E8D5FF              <1> 	call .finish_line
  1027                              <1> 
  1028 000015E5 BE[3316]            <1> 	mov si, .setbox_bot
  1029 000015E8 E88603              <1> 	call print
  1030                              <1> 
  1031 000015EB 61                  <1> 	popa
  1032 000015EC C3                  <1> 	ret
  1033                              <1> 	
  1034                              <1> 
  1035 000015ED 0A                  <1> .setbox_top:	db 0x0a
  1036 000015EE 20<rept>            <1>         		times edge_width db " "
  1037 000015FC DA                  <1>                 db 0xDA
  1038 000015FD C4<rept>            <1>                 times border_length db 0xC4
  1039 0000162F BF0A0D00            <1>                 db 0xBF, 0x0a, 0x0d, 0
  1040                              <1> 
  1041 00001633 20<rept>            <1> .setbox_bot:	times edge_width db " "
  1042 00001641 C0                  <1>                 db 0xC0
  1043 00001642 C4<rept>            <1>                 times border_length db 0xC4
  1044 00001674 D90A0D00            <1>                 db 0xD9, 0x0a, 0x0d, 0
  1045                              <1> 
  1046 00001678 20<rept>            <1> .setbox_nwl:	times edge_width db " "
  1047 00001686 B32000              <1> 				db 0xB3, " ", 0
  1048                              <1> 
  1049 00001689 20B300              <1> .setbox_fnl:	db " ", 0xB3, 0
  1050                              <1> 
  1051                              <1> ; ------------------------------------------------------------------
  1052                              <1> ; draw_box -- Draw a box
  1053                              <1> ; IN: AL = color
  1054                              <1> ;	  BX = end x position
  1055                              <1> ;	  CX = end y position
  1056                              <1> ;	  DH = start x position
  1057                              <1> ;	  DL = start y position
  1058                              <1> ; OUT: Draws box
  1059                              <1> 
  1060                              <1> draw_box:
  1061 0000168C 60                  <1> 	pusha
  1062                              <1> 
  1063 0000168D 8836[C516]          <1> 	mov [.startx], dh
  1064 00001691 8816[C716]          <1> 	mov [.starty], dl
  1065 00001695 891E[C916]          <1> 	mov [.endx], bx
  1066 00001699 890E[CB16]          <1> 	mov [.endy], cx
  1067                              <1> 
  1068 0000169D 8B0E[C516]          <1> 	mov cx, [.startx]
  1069 000016A1 8B16[C716]          <1> 	mov dx, [.starty]
  1070 000016A5 B40C                <1> 	mov ah, 0x0C
  1071                              <1> 
  1072                              <1> 	.x_loop:
  1073 000016A7 3B0E[C916]          <1> 		cmp cx, [.endx]
  1074 000016AB 7405                <1> 		je .y_loop
  1075                              <1> 
  1076 000016AD CD10                <1> 		int 0x10
  1077                              <1> 
  1078 000016AF 41                  <1> 		inc cx
  1079 000016B0 EBF5                <1> 		jmp .x_loop
  1080                              <1> 
  1081                              <1> 	.y_loop:
  1082 000016B2 CD10                <1> 		int 0x10
  1083                              <1> 
  1084 000016B4 3B16[CB16]          <1> 		cmp dx, [.endy]
  1085 000016B8 7407                <1> 		je .done
  1086                              <1> 
  1087 000016BA 8B0E[C516]          <1> 		mov cx, [.startx]
  1088 000016BE 42                  <1> 		inc dx
  1089 000016BF EBE6                <1> 		jmp .x_loop
  1090                              <1> 	
  1091                              <1> 	.done:
  1092 000016C1 61                  <1> 		popa
  1093 000016C2 C3                  <1> 		ret
  1094                              <1> 
  1095 000016C3 0000                <1> 	.tmp:    dw 0
  1096 000016C5 0000                <1> 	.startx: dw 0
  1097 000016C7 0000                <1> 	.starty: dw 0
  1098 000016C9 0000                <1> 	.endx:   dw 0
  1099 000016CB 0000                <1> 	.endy:	 dw 0
  1100                              <1> 
  1101                              <1> ; ------------------------------------------------------------------
  1102                              <1> ; list_dialog -- Show a dialog with a list of options
  1103                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1104                              <1> ;     BX = first help string, CX = second help string
  1105                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1106                              <1> 
  1107                              <1> list_dialog:
  1108 000016CD 60                  <1> 	pusha
  1109                              <1> 
  1110 000016CE 50                  <1> 	push ax				; Store string list for now
  1111                              <1> 
  1112 000016CF 51                  <1> 	push cx				; And help strings
  1113 000016D0 53                  <1> 	push bx
  1114                              <1> 
  1115 000016D1 E848F9              <1> 	call hide_cursor
  1116                              <1> 
  1117                              <1> 
  1118 000016D4 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1119 000016D6 89C6                <1> 	mov si, ax
  1120                              <1> .count_loop:
  1121 000016D8 AC                  <1> 	lodsb
  1122 000016D9 3C00                <1> 	cmp al, 0
  1123 000016DB 7408                <1> 	je .done_count
  1124 000016DD 3C2C                <1> 	cmp al, ','
  1125 000016DF 75F7                <1> 	jne .count_loop
  1126 000016E1 FEC1                <1> 	inc cl
  1127 000016E3 EBF3                <1> 	jmp .count_loop
  1128                              <1> 
  1129                              <1> .done_count:
  1130 000016E5 FEC1                <1> 	inc cl
  1131 000016E7 880E[4018]          <1> 	mov byte [.num_of_entries], cl
  1132                              <1> 
  1133 000016EB B39F                <1> 	mov bl, 0x9F		; White on light blue
  1134 000016ED B20F                <1> 	mov dl, 15			; Start X position
  1135 000016EF B602                <1> 	mov dh, 2			; Start Y position
  1136 000016F1 BE3200              <1> 	mov si, 50			; Width
  1137 000016F4 BF1700              <1> 	mov di, 23			; Finish Y position
  1138 000016F7 E8A5F9              <1> 	call draw_block		; Draw option selector window
  1139                              <1> 
  1140 000016FA B210                <1> 	mov dl, 16			; Show first line of help text...
  1141 000016FC B603                <1> 	mov dh, 3
  1142 000016FE E826F9              <1> 	call move_cursor
  1143                              <1> 
  1144 00001701 5E                  <1> 	pop si				; Get back first string
  1145 00001702 E86C02              <1> 	call print
  1146                              <1> 
  1147 00001705 FEC6                <1> 	inc dh				; ...and the second
  1148 00001707 E81DF9              <1> 	call move_cursor
  1149                              <1> 
  1150 0000170A 5E                  <1> 	pop si
  1151 0000170B E86302              <1> 	call print
  1152                              <1> 
  1153                              <1> 
  1154 0000170E 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1155 0000170F 8936[4218]          <1> 	mov word [.list_string], si
  1156                              <1> 
  1157                              <1> 
  1158                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1159                              <1> 	; entry and let the user move up and down using the cursor keys
  1160                              <1> 
  1161 00001713 C606[4118]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1162                              <1> 
  1163 00001718 B214                <1> 	mov dl, 20			; Set up starting position for selector
  1164 0000171A B607                <1> 	mov dh, 7
  1165                              <1> 
  1166 0000171C E808F9              <1> 	call move_cursor
  1167                              <1> 
  1168                              <1> .more_select:
  1169 0000171F 60                  <1> 	pusha
  1170 00001720 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1171 00001722 B210                <1> 	mov dl, 16
  1172 00001724 B606                <1> 	mov dh, 6
  1173 00001726 BE3000              <1> 	mov si, 48
  1174 00001729 BF1600              <1> 	mov di, 22
  1175 0000172C E870F9              <1> 	call draw_block
  1176 0000172F 61                  <1> 	popa
  1177                              <1> 
  1178 00001730 E8E100              <1> 	call .draw_black_bar
  1179                              <1> 
  1180 00001733 8B36[4218]          <1> 	mov word si, [.list_string]
  1181 00001737 E89A00              <1> 	call .draw_list
  1182                              <1> 
  1183                              <1> .another_key:
  1184 0000173A B400                <1> 	mov ah, 0x00
  1185 0000173C CD16                <1> 	int 0x16
  1186                              <1> 
  1187 0000173E 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1188 00001741 740F                <1> 	je .go_up
  1189 00001743 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1190 00001746 741B                <1> 	je .go_down
  1191 00001748 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1192 0000174A 7468                <1> 	je .option_selected
  1193 0000174C 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1194 0000174E 747E                <1> 	je .esc_pressed
  1195 00001750 EBCD                <1> 	jmp .more_select		; If not, wait for another key
  1196                              <1> 
  1197                              <1> 
  1198                              <1> .go_up:
  1199 00001752 80FE07              <1> 	cmp dh, 7			; Already at top?
  1200 00001755 7E32                <1> 	jle .hit_top
  1201                              <1> 
  1202 00001757 E8CF00              <1> 	call .draw_white_bar
  1203                              <1> 
  1204 0000175A B219                <1> 	mov dl, 25
  1205 0000175C E8C8F8              <1> 	call move_cursor
  1206                              <1> 
  1207 0000175F FECE                <1> 	dec dh				; Row to select (increasing down)
  1208 00001761 EBBC                <1> 	jmp .more_select
  1209                              <1> 
  1210                              <1> 
  1211                              <1> .go_down:				; Already at bottom of list?
  1212 00001763 80FE14              <1> 	cmp dh, 20
  1213 00001766 7430                <1> 	je .hit_bottom
  1214                              <1> 
  1215 00001768 B90000              <1> 	mov cx, 0
  1216 0000176B 88F1                <1> 	mov byte cl, dh
  1217                              <1> 
  1218 0000176D 80E907              <1> 	sub cl, 7
  1219 00001770 FEC1                <1> 	inc cl
  1220 00001772 020E[4118]          <1> 	add byte cl, [.skip_num]
  1221                              <1> 
  1222 00001776 A0[4018]            <1> 	mov byte al, [.num_of_entries]
  1223 00001779 38C1                <1> 	cmp cl, al
  1224 0000177B 74BD                <1> 	je .another_key
  1225                              <1> 
  1226 0000177D E8A900              <1> 	call .draw_white_bar
  1227                              <1> 
  1228 00001780 B219                <1> 	mov dl, 25
  1229 00001782 E8A2F8              <1> 	call move_cursor
  1230                              <1> 
  1231 00001785 FEC6                <1> 	inc dh
  1232 00001787 EB96                <1> 	jmp .more_select
  1233                              <1> 
  1234                              <1> 
  1235                              <1> .hit_top:
  1236 00001789 8A0E[4118]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1237 0000178D 80F900              <1> 	cmp cl, 0
  1238 00001790 74A8                <1> 	je .another_key			; If not, wait for another key
  1239                              <1> 
  1240 00001792 FE0E[4118]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1241 00001796 EB87                <1> 	jmp .more_select
  1242                              <1> 
  1243                              <1> 
  1244                              <1> .hit_bottom:				; See if there's more to scroll
  1245 00001798 B90000              <1> 	mov cx, 0
  1246 0000179B 88F1                <1> 	mov byte cl, dh
  1247                              <1> 
  1248 0000179D 80E907              <1> 	sub cl, 7
  1249 000017A0 FEC1                <1> 	inc cl
  1250 000017A2 020E[4118]          <1> 	add byte cl, [.skip_num]
  1251                              <1> 
  1252 000017A6 A0[4018]            <1> 	mov byte al, [.num_of_entries]
  1253 000017A9 38C1                <1> 	cmp cl, al
  1254 000017AB 748D                <1> 	je .another_key
  1255                              <1> 
  1256 000017AD FE06[4118]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1257 000017B1 E96BFF              <1> 	jmp .more_select
  1258                              <1> 
  1259                              <1> 
  1260                              <1> 
  1261                              <1> .option_selected:
  1262 000017B4 E84FF8              <1> 	call show_cursor
  1263                              <1> 
  1264 000017B7 80EE07              <1> 	sub dh, 7
  1265                              <1> 
  1266 000017BA B80000              <1> 	mov ax, 0
  1267 000017BD 88F0                <1> 	mov al, dh
  1268                              <1> 
  1269 000017BF FEC0                <1> 	inc al				; Options start from 1
  1270 000017C1 0206[4118]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1271                              <1> 
  1272 000017C5 A3[3E18]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1273                              <1> 
  1274 000017C8 61                  <1> 	popa
  1275                              <1> 
  1276 000017C9 A1[3E18]            <1> 	mov word ax, [.tmp]
  1277 000017CC F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1278 000017CD C3                  <1> 	ret
  1279                              <1> 
  1280                              <1> 
  1281                              <1> 
  1282                              <1> .esc_pressed:
  1283 000017CE E835F8              <1> 	call show_cursor
  1284 000017D1 61                  <1> 	popa
  1285 000017D2 F9                  <1> 	stc				; Set carry for Esc
  1286 000017D3 C3                  <1> 	ret
  1287                              <1> 
  1288                              <1> 
  1289                              <1> 
  1290                              <1> .draw_list:
  1291 000017D4 60                  <1> 	pusha
  1292                              <1> 
  1293 000017D5 B212                <1> 	mov dl, 18			; Get into position for option list text
  1294 000017D7 B607                <1> 	mov dh, 7
  1295 000017D9 E84BF8              <1> 	call move_cursor
  1296                              <1> 
  1297                              <1> 
  1298 000017DC B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  1299 000017DF 8A0E[4118]          <1> 	mov byte cl, [.skip_num]
  1300                              <1> 
  1301                              <1> .skip_loop:
  1302 000017E3 83F900              <1> 	cmp cx, 0
  1303 000017E6 7408                <1> 	je .skip_loop_finished
  1304                              <1> .more_lodsb:
  1305 000017E8 AC                  <1> 	lodsb
  1306 000017E9 3C2C                <1> 	cmp al, ','
  1307 000017EB 75FB                <1> 	jne .more_lodsb
  1308 000017ED 49                  <1> 	dec cx
  1309 000017EE EBF3                <1> 	jmp .skip_loop
  1310                              <1> 
  1311                              <1> 
  1312                              <1> .skip_loop_finished:
  1313 000017F0 BB0000              <1> 	mov bx, 0			; Counter for total number of options
  1314                              <1> 
  1315                              <1> 
  1316                              <1> .more:
  1317 000017F3 AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  1318                              <1> 
  1319 000017F4 3C00                <1> 	cmp al, 0			; End of string?
  1320 000017F6 7417                <1> 	je .done_list
  1321                              <1> 
  1322 000017F8 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1323 000017FA 7406                <1> 	je .newline
  1324                              <1> 
  1325 000017FC B40E                <1> 	mov ah, 0Eh
  1326 000017FE CD10                <1> 	int 10h
  1327 00001800 EBF1                <1> 	jmp .more
  1328                              <1> 
  1329                              <1> .newline:
  1330 00001802 B212                <1> 	mov dl, 18			; Go back to starting X position
  1331 00001804 FEC6                <1> 	inc dh				; But jump down a line
  1332 00001806 E81EF8              <1> 	call move_cursor
  1333                              <1> 
  1334 00001809 43                  <1> 	inc bx				; Update the number-of-options counter
  1335 0000180A 83FB0E              <1> 	cmp bx, 14			; Limit to one screen of options
  1336 0000180D 7CE4                <1> 	jl .more
  1337                              <1> 
  1338                              <1> .done_list:
  1339 0000180F 61                  <1> 	popa
  1340 00001810 E814F8              <1> 	call move_cursor
  1341                              <1> 
  1342 00001813 C3                  <1> 	ret
  1343                              <1> 
  1344                              <1> 
  1345                              <1> 
  1346                              <1> .draw_black_bar:
  1347 00001814 60                  <1> 	pusha
  1348                              <1> 
  1349 00001815 B211                <1> 	mov dl, 17
  1350 00001817 E80DF8              <1> 	call move_cursor
  1351                              <1> 
  1352 0000181A B409                <1> 	mov ah, 09h			; Draw white bar at top
  1353 0000181C B700                <1> 	mov bh, 0
  1354 0000181E B92E00              <1> 	mov cx, 46
  1355 00001821 B30F                <1> 	mov bl, 00001111b		; White text on black background
  1356 00001823 B020                <1> 	mov al, ' '
  1357 00001825 CD10                <1> 	int 10h
  1358                              <1> 
  1359 00001827 61                  <1> 	popa
  1360 00001828 C3                  <1> 	ret
  1361                              <1> 
  1362                              <1> 
  1363                              <1> 
  1364                              <1> .draw_white_bar:
  1365 00001829 60                  <1> 	pusha
  1366                              <1> 
  1367 0000182A B211                <1> 	mov dl, 17
  1368 0000182C E8F8F7              <1> 	call move_cursor
  1369                              <1> 
  1370 0000182F B409                <1> 	mov ah, 09h			; Draw white bar at top
  1371 00001831 B700                <1> 	mov bh, 0
  1372 00001833 B92E00              <1> 	mov cx, 46
  1373 00001836 B3F0                <1> 	mov bl, 11110000b		; Black text on white background
  1374 00001838 B020                <1> 	mov al, ' '
  1375 0000183A CD10                <1> 	int 10h
  1376                              <1> 
  1377 0000183C 61                  <1> 	popa
  1378 0000183D C3                  <1> 	ret
  1379                              <1> 
  1380                              <1> 
  1381 0000183E 0000                <1> 	.tmp			dw 0
  1382 00001840 00                  <1> 	.num_of_entries		db 0
  1383 00001841 00                  <1> 	.skip_num		db 0
  1384 00001842 0000                <1> 	.list_string		dw 0
   201                                      %include "./includes/misc.asm"
     1                              <1> ; get_api_version -- Return current version of KronkOS API
     2                              <1> ; OUT: AL = API version number
     3                              <1> 
     4                              <1> get_api_version:
     5 00001844 B004                <1> 	mov al, KRONKOS_API
     6 00001846 C3                  <1> 	ret
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; fatal_error -- Display error message and halt execution
    10                              <1> ; IN: AX = error message string location
    11                              <1> 
    12                              <1> fatal_error:
    13 00001847 89C3                <1> 	mov bx, ax			; Store string location for now
    14                              <1> 
    15 00001849 B600                <1> 	mov dh, 0
    16 0000184B B200                <1> 	mov dl, 0
    17 0000184D E8D7F7              <1> 	call move_cursor
    18                              <1> 
    19 00001850 60                  <1> 	pusha
    20 00001851 B409                <1> 	mov ah, 0x09		; Draw red bar at top
    21 00001853 B700                <1> 	mov bh, 0
    22 00001855 B9F000              <1> 	mov cx, 240
    23 00001858 B34F                <1> 	mov bl, 01001111b
    24 0000185A B020                <1> 	mov al, ' '
    25 0000185C CD10                <1> 	int 10h
    26 0000185E 61                  <1> 	popa
    27                              <1> 
    28 0000185F B600                <1> 	mov dh, 0
    29 00001861 B200                <1> 	mov dl, 0
    30 00001863 E8C1F7              <1> 	call move_cursor
    31                              <1> 
    32 00001866 BE[7318]            <1> 	mov si, .msg_inform		; Inform of fatal error
    33 00001869 E80501              <1> 	call print
    34                              <1> 
    35 0000186C 89DE                <1> 	mov si, bx			; Program-supplied error message
    36 0000186E E80001              <1> 	call print
    37                              <1> 
    38 00001871 EBFE                <1> 	jmp $				; Halt execution
    39                              <1> 
    40                              <1> 	
    41 00001873 464154414C204F5045- <1> 	.msg_inform		db 'FATAL OPERATING SYSTEM ERROR!', 0x0d, 0x0a, 0
    41 0000187C 524154494E47205359- <1>
    41 00001885 5354454D204552524F- <1>
    41 0000188E 52210D0A00          <1>
    42                              <1> 
    43                              <1> ; ------------------------------------------------------------------
    44                              <1> ; bios_wait -- Wait
    45                              <1> ; IN: CX:DX time
    46                              <1> 
    47                              <1> bios_wait:
    48 00001893 B80086              <1> 	mov ax, 0x8600
    49 00001896 CD15                <1>     int 0x15
    50 00001898 C3                  <1>     ret
   202                                      %include "./includes/input.asm"
     1                              <1> get_input:
     2 00001899 60                  <1>     pusha
     3 0000189A B200                <1>     mov dl, 0
     4 0000189C BE[A800]            <1>     mov si, in_buffer
     5                              <1> 
     6                              <1>     ; Clear the input buffer for use
     7                              <1>     .clear_loop:
     8 0000189F C60400              <1>         mov byte [si], 0
     9                              <1> 
    10 000018A2 46                  <1>         inc si
    11 000018A3 FEC2                <1>         inc dl
    12                              <1> 
    13 000018A5 80FA1E              <1>         cmp dl, 30
    14 000018A8 75F5                <1>         jne .clear_loop
    15                              <1> 
    16 000018AA BE[A800]            <1>     mov si, in_buffer
    17 000018AD 30DB                <1>     xor bl, bl ; Used for checking the length of the buffer
    18                              <1> 
    19                              <1> ; The actual loop
    20                              <1> .input_loop:
    21 000018AF B400                <1>     mov ah, 0x00
    22 000018B1 CD16                <1>     int 0x16
    23                              <1> 
    24                              <1>     ; Check if the user pressed enter
    25 000018B3 3C0D                <1>     cmp al, 0x0d
    26 000018B5 7442                <1>     je .input_done
    27                              <1> 
    28                              <1>     ; Check if the user pressed backspace
    29 000018B7 3C08                <1>     cmp al, 0x08
    30 000018B9 7524                <1>     jne .not_back
    31                              <1> 
    32                              <1>     ; ******************************
    33                              <1>     ; The user pressed backspace!
    34                              <1> 
    35                              <1>     ; Get current cursor position
    36 000018BB B403                <1>     mov ah, 0x03
    37 000018BD B700                <1>     mov bh, 0
    38 000018BF CD10                <1>     int 0x10
    39                              <1> 
    40 000018C1 80FA03              <1>     cmp dl, 3 ; 3 = backspace limit
    41 000018C4 74E9                <1>     je .input_loop
    42                              <1> 
    43 000018C6 FECA                <1>     dec dl
    44 000018C8 FECB                <1>     dec bl
    45                              <1> 
    46                              <1>     ; Move one back
    47 000018CA B402                <1>     mov ah, 0x02
    48 000018CC CD10                <1>     int 0x10
    49                              <1> 
    50 000018CE B40E                <1>     mov ah, 0x0e
    51 000018D0 B000                <1>     mov al, 0
    52 000018D2 CD10                <1>     int 0x10
    53                              <1> 
    54 000018D4 B402                <1>     mov ah, 0x02
    55 000018D6 CD10                <1>     int 0x10
    56                              <1> 
    57                              <1>     ; Remove the last character from the input buffer
    58 000018D8 4E                  <1>     dec si
    59 000018D9 B000                <1>     mov al, 0
    60 000018DB 8804                <1>     mov [si], al
    61                              <1> 
    62 000018DD EBD0                <1>     jmp .input_loop
    63                              <1>     
    64                              <1>     ; ******************************
    65                              <1> 
    66                              <1>     ; Show the pressed character and save it to the input buffer
    67                              <1>     .not_back:
    68 000018DF 80FB28              <1>         cmp bl, 40
    69 000018E2 74CB                <1>         je .input_loop
    70 000018E4 FEC3                <1>         inc bl
    71                              <1> 
    72 000018E6 8804                <1>         mov [si], al
    73 000018E8 46                  <1>         inc si
    74                              <1> 
    75 000018E9 B40E                <1>         mov ah, 0x0e
    76 000018EB 3C61                <1>         cmp al, 'a'
    77 000018ED 7206                <1>         jb .noatoz
    78 000018EF 3C7A                <1>         cmp al, 'z'
    79 000018F1 7702                <1>         ja .noatoz
    80                              <1>         
    81 000018F3 24DF                <1>         and al, 0xdf
    82                              <1>         .noatoz:
    83 000018F5 CD10                <1>         int 0x10
    84                              <1> 
    85 000018F7 EBB6                <1>         jmp .input_loop
    86                              <1> 
    87                              <1>     ; Return the cursor to the start and return
    88                              <1>     .input_done:
    89 000018F9 B8[A800]            <1>         mov ax, in_buffer
    90 000018FC E846F3              <1>         call string_lowercase
    91                              <1> 
    92 000018FF B40E                <1>         mov ah, 0x0e
    93 00001901 B00D                <1>         mov al, 0x0d
    94 00001903 CD10                <1>         int 0x10
    95                              <1> 
    96 00001905 61                  <1>         popa
    97 00001906 C3                  <1>         ret
   203                                      %include "./includes/math.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; KronkOS -- The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; MATH ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; seed_random -- Seed the random number generator based on clock
    10                              <1> 
    11                              <1> seed_random:
    12 00001907 53                  <1> 	push bx
    13 00001908 50                  <1> 	push ax
    14                              <1> 
    15 00001909 BB0000              <1> 	mov bx, 0
    16 0000190C B002                <1> 	mov al, 0x02
    17 0000190E E670                <1> 	out 0x70, al
    18 00001910 E471                <1> 	in al, 0x71
    19                              <1> 
    20 00001912 88C3                <1> 	mov bl, al
    21 00001914 C1E308              <1> 	shl bx, 8
    22 00001917 B000                <1> 	mov al, 0
    23 00001919 E670                <1> 	out 0x70, al
    24 0000191B E471                <1> 	in al, 0x71
    25                              <1> 
    26 0000191D 891E[2419]          <1> 	mov word [random_seed], bx
    27                              <1> 
    28 00001921 58                  <1> 	pop ax
    29 00001922 5B                  <1> 	pop bx
    30 00001923 C3                  <1> 	ret
    31                              <1> 
    32 00001924 0000                <1> 	random_seed dw 0
    33                              <1> 
    34                              <1> ; ------------------------------------------------------------------
    35                              <1> ; get_random -- Return a random integer between low and high (inclusive)
    36                              <1> ; IN: AX = low integer, BX = high integer
    37                              <1> ; OUT: CX = random integer
    38                              <1> 
    39                              <1> get_random:
    40 00001926 52                  <1> 	push dx
    41 00001927 53                  <1> 	push bx
    42 00001928 50                  <1> 	push ax
    43                              <1> 
    44 00001929 29C3                <1> 	sub bx, ax
    45 0000192B E80F00              <1> 	call .generate_random
    46 0000192E 89DA                <1> 	mov dx, bx
    47 00001930 83C201              <1> 	add dx, 1
    48 00001933 F7E2                <1> 	mul dx
    49 00001935 89D1                <1> 	mov cx, dx
    50                              <1> 
    51 00001937 58                  <1> 	pop ax
    52 00001938 5B                  <1> 	pop bx
    53 00001939 5A                  <1> 	pop dx
    54 0000193A 01C1                <1> 	add cx, ax
    55 0000193C C3                  <1> 	ret
    56                              <1> 
    57                              <1> 	.generate_random:
    58 0000193D 52                  <1> 		push dx
    59 0000193E 53                  <1> 		push bx
    60                              <1> 
    61 0000193F A1[2419]            <1> 		mov ax, [random_seed]
    62 00001942 BA8373              <1> 		mov dx, 0x7383
    63 00001945 F7E2                <1> 		mul dx
    64 00001947 A3[2419]            <1> 		mov [random_seed], ax
    65                              <1> 
    66 0000194A 5B                  <1> 		pop bx
    67 0000194B 5A                  <1> 		pop dx
    68                              <1> 		
    69 0000194C C3                  <1> 		ret
    70                              <1> 
    71                              <1> ; ------------------------------------------------------------------
    72                              <1> ; bcd_to_int -- Converts binary coded decimal number to an integer
    73                              <1> ; IN: AL = BCD number
    74                              <1> ; OUT: AX = integer value
    75                              <1> 
    76                              <1> bcd_to_int:
    77 0000194D 60                  <1> 	pusha
    78                              <1> 
    79 0000194E 88C3                <1> 	mov bl, al
    80                              <1> 
    81 00001950 83E00F              <1> 	and ax, 0x0F
    82 00001953 89C1                <1> 	mov cx, ax
    83                              <1> 
    84 00001955 C0EB04              <1> 	shr bl, 4
    85 00001958 B00A                <1> 	mov al, 10
    86 0000195A F6E3                <1> 	mul bl
    87                              <1> 
    88 0000195C 01C8                <1> 	add ax, cx
    89 0000195E A3[6619]            <1> 	mov [.tmp], ax
    90                              <1> 
    91 00001961 61                  <1> 	popa
    92 00001962 A1[6619]            <1> 	mov ax, [.tmp]
    93 00001965 C3                  <1> 	ret
    94                              <1> 
    95 00001966 0000                <1> 	.tmp	dw 0
    96                              <1> 	
    97                              <1> ; ------------------------------------------------------------------
    98                              <1> ; long_int_negate -- Multiply value in DX:AX by -1
    99                              <1> ; IN: DX:AX = long integer
   100                              <1> ; OUT: DX:AX = -(initial DX:AX)
   101                              <1> 
   102                              <1> long_int_negate:
   103 00001968 F7D8                <1> 	neg ax
   104 0000196A 83D200              <1> 	adc dx, 0
   105 0000196D F7DA                <1> 	neg dx
   106 0000196F C3                  <1> 	ret
   107                              <1> 
   108                              <1> ; ------------------------------------------------------------------
   109                              <1> ; hex_to_int -- Convert a hexadecimal to decimal
   110                              <1> ; IN: AX = number to be converted, BX = base
   111                              <1> 
   112                              <1> hex_to_int:
   113 00001970 C3                  <1> 	ret
   114                              <1> 
   115                              <1> ; ==================================================================
   204                                      %include "./includes/print.asm"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; print -- Print a string to the screen
     3                              <1> ; IN: SI = The location of the string
     4                              <1> 
     5                              <1> print:
     6 00001971 60                  <1>     pusha
     7 00001972 B40E                <1>     mov ah, 0x0e
     8                              <1> 
     9                              <1> .repeat:
    10 00001974 AC                  <1>     lodsb
    11 00001975 84C0                <1>     test al, al
    12 00001977 7404                <1>     jz .done
    13                              <1> 
    14 00001979 CD10                <1>     int 0x10
    15 0000197B EBF7                <1>     jmp short .repeat
    16                              <1> 
    17                              <1> .done:
    18 0000197D 61                  <1>     popa
    19 0000197E C3                  <1>     ret
    20                              <1> 
    21                              <1> ; ------------------------------------------------------------------
    22                              <1> ; welcome_print -- Print the welcome message
    23                              <1> ; IN: SI = The location of the string
    24                              <1> 
    25                              <1> welcome_print:
    26 0000197F B409                <1>     mov ah, 0x09
    27 00001981 B90100              <1>     mov cx, 1
    28 00001984 31DB                <1>     xor bx, bx
    29 00001986 B330                <1>     mov bl, mb_color
    30                              <1> 
    31                              <1>     .repeat:
    32 00001988 AC                  <1>         lodsb
    33 00001989 3C00                <1>         cmp al, 0
    34 0000198B 741C                <1>         je .done
    35                              <1> 
    36 0000198D 3C0A                <1>         cmp al, 0x0a
    37 0000198F 7410                <1>         je .other_char
    38 00001991 3C0D                <1>         cmp al, 0x0d
    39 00001993 740C                <1>         je .other_char
    40                              <1> 
    41 00001995 E898F6              <1>         call get_cursor_pos
    42 00001998 FEC2                <1>         inc dl
    43 0000199A E88AF6              <1>         call move_cursor
    44                              <1> 
    45 0000199D CD10                <1>         int 0x10
    46 0000199F EBE7                <1>         jmp short .repeat
    47                              <1> 
    48                              <1>     .other_char:
    49 000019A1 B40E                <1>         mov ah, 0x0e
    50 000019A3 CD10                <1>         int 0x10
    51                              <1> 
    52 000019A5 B409                <1>         mov ah, 0x09
    53 000019A7 EBDF                <1>         jmp .repeat
    54                              <1> 
    55                              <1>     .done:
    56 000019A9 C3                  <1>         ret
    57                              <1> 
    58                              <1> ; ------------------------------------------------------------------
    59                              <1> ; print_atr -- Print a string with attribute to the screen
    60                              <1> ; IN: SI = The location of the string
    61                              <1> ;     BH = Page number
    62                              <1> ;     BL = Attribute
    63                              <1> 
    64                              <1> print_atr:
    65 000019AA 60                  <1>     pusha
    66 000019AB B90100              <1>     mov cx, 1
    67 000019AE B409                <1>     mov ah, 0x09
    68                              <1> 
    69                              <1> .repeat:
    70 000019B0 AC                  <1>     lodsb
    71 000019B1 84C0                <1>     test al, al
    72 000019B3 741C                <1>     jz .done
    73                              <1> 
    74 000019B5 3C0A                <1>     cmp al, 0x0a
    75 000019B7 7410                <1>     je .special_char
    76                              <1> 
    77 000019B9 3C0D                <1>     cmp al, 0x0d
    78 000019BB 740C                <1>     je .special_char
    79                              <1> 
    80 000019BD CD10                <1>     int 0x10
    81                              <1> 
    82 000019BF E86EF6              <1>     call get_cursor_pos
    83 000019C2 FEC2                <1>     inc dl
    84 000019C4 E860F6              <1>     call move_cursor
    85                              <1> 
    86 000019C7 EBE7                <1>     jmp short .repeat
    87                              <1> 
    88                              <1> .special_char:
    89 000019C9 B40E                <1>     mov ah, 0x0e
    90 000019CB CD10                <1>     int 0x10
    91 000019CD B409                <1>     mov ah, 0x09
    92                              <1> 
    93 000019CF EBDF                <1>     jmp short .repeat
    94                              <1> 
    95                              <1> .done:
    96 000019D1 61                  <1>     popa
    97 000019D2 C3                  <1>     ret
   205                                      %include "./includes/mouse.asm"
     1                              <1> HW_EQUIP_PS2     equ 4          ; PS2 mouse installed?
     2                              <1> MOUSE_PKT_BYTES  equ 3          ; Number of bytes in mouse packet
     3                              <1> MOUSE_RESOLUTION equ 3          ; Mouse resolution 8 counts/mm
     4                              <1> ARG_OFFSETS      equ 6          ; Offset of args from BP
     5                              <1> 
     6                              <1> mouse_initialize:
     7 000019D3 06                  <1>     push es
     8 000019D4 53                  <1>     push bx
     9                              <1> 
    10 000019D5 CD11                <1>     int 0x11
    11 000019D7 A90400              <1>     test ax, HW_EQUIP_PS2
    12 000019DA 7421                <1>     jz .no_mouse
    13                              <1> 
    14 000019DC B805C2              <1>     mov ax, 0xC205
    15 000019DF B703                <1>     mov bh, MOUSE_PKT_BYTES
    16 000019E1 CD15                <1>     int 0x15
    17 000019E3 7218                <1>     jc .no_mouse
    18                              <1> 
    19 000019E5 B803C2              <1>     mov ax, 0xC203
    20 000019E8 B703                <1>     mov bh, MOUSE_RESOLUTION
    21 000019EA CD15                <1>     int 0x15
    22 000019EC 720F                <1>     jc .no_mouse
    23                              <1> 
    24 000019EE 0E                  <1>     push cs
    25 000019EF 07                  <1>     pop es
    26                              <1> 
    27 000019F0 BB[681A]            <1>     mov bx, mouse_callback_dummy
    28 000019F3 B807C2              <1>     mov ax, 0xC207
    29 000019F6 CD15                <1>     int 0x15
    30 000019F8 7203                <1>     jc .no_mouse
    31                              <1> 
    32 000019FA F8                  <1>     clc
    33 000019FB EB01                <1>     jmp .finished
    34                              <1>     
    35                              <1>     .no_mouse:
    36 000019FD F9                  <1>         stc
    37                              <1>     
    38                              <1>     .finished:
    39 000019FE 5B                  <1>         pop bx
    40 000019FF 07                  <1>         pop es
    41 00001A00 C3                  <1>         ret
    42                              <1> 
    43                              <1> 
    44                              <1> mouse_enable:
    45 00001A01 06                  <1>     push es
    46 00001A02 53                  <1>     push bx
    47                              <1> 
    48 00001A03 E81400              <1>     call mouse_disable
    49                              <1> 
    50 00001A06 0E                  <1>     push cs
    51 00001A07 07                  <1>     pop es
    52 00001A08 BB[2D1A]            <1>     mov bx, mouse_callback
    53 00001A0B B807C2              <1>     mov ax, 0xC207
    54 00001A0E CD15                <1>     int 0x15
    55                              <1> 
    56 00001A10 B800C2              <1>     mov ax, 0xC200
    57 00001A13 B701                <1>     mov bh, 1
    58 00001A15 CD15                <1>     int 0x15
    59                              <1> 
    60 00001A17 5B                  <1>     pop bx
    61 00001A18 07                  <1>     pop es
    62 00001A19 C3                  <1>     ret
    63                              <1> 
    64                              <1> 
    65                              <1> mouse_disable:
    66 00001A1A 06                  <1>     push es
    67 00001A1B 53                  <1>     push bx
    68                              <1> 
    69 00001A1C B800C2              <1>     mov ax, 0xC200
    70 00001A1F 31DB                <1>     xor bx, bx
    71 00001A21 CD15                <1>     int 0x15
    72                              <1> 
    73 00001A23 8EC3                <1>     mov es, bx
    74 00001A25 B807C2              <1>     mov ax, 0xC207
    75 00001A28 CD15                <1>     int 0x15
    76                              <1> 
    77 00001A2A 5B                  <1>     pop bx
    78 00001A2B 07                  <1>     pop es
    79 00001A2C C3                  <1>     ret
    80                              <1> 
    81                              <1> 
    82                              <1> mouse_callback:
    83 00001A2D 55                  <1>     push bp
    84 00001A2E 89E5                <1>     mov bp, sp
    85                              <1> 
    86 00001A30 1E                  <1>     push ds
    87 00001A31 50                  <1>     push ax
    88 00001A32 53                  <1>     push bx
    89 00001A33 51                  <1>     push cx
    90 00001A34 52                  <1>     push dx
    91                              <1> 
    92 00001A35 0E                  <1>     push cs
    93 00001A36 1F                  <1>     pop ds
    94                              <1> 
    95 00001A37 8A460C              <1>     mov al, [bp+ARG_OFFSETS+6]
    96 00001A3A 88C3                <1>     mov bl, al
    97 00001A3C B103                <1>     mov cl, 3
    98 00001A3E D2E0                <1>     shl al, cl
    99                              <1> 
   100 00001A40 18F6                <1>     sbb dh, dh
   101 00001A42 98                  <1>     cbw
   102 00001A43 8A5608              <1>     mov dl, [bp+ARG_OFFSETS+2]
   103 00001A46 8A460A              <1>     mov al, [bp+ARG_OFFSETS+4]
   104                              <1> 
   105 00001A49 F7DA                <1>     neg dx
   106 00001A4B 8B0E[1B1B]          <1>     mov cx, [mouseY]
   107 00001A4F 01CA                <1>     add dx, cx
   108 00001A51 8B0E[191B]          <1>     mov cx, [mouseX]
   109 00001A55 01C8                <1>     add ax, cx
   110                              <1> 
   111 00001A57 881E[1D1B]          <1>     mov [curStatus], bl
   112 00001A5B A3[191B]            <1>     mov [mouseX], ax
   113 00001A5E 8916[1B1B]          <1>     mov [mouseY], dx
   114                              <1> 
   115 00001A62 5A                  <1>     pop dx
   116 00001A63 59                  <1>     pop cx
   117 00001A64 5B                  <1>     pop bx
   118 00001A65 58                  <1>     pop ax
   119 00001A66 1F                  <1>     pop ds
   120 00001A67 5D                  <1>     pop bp
   121                              <1> 
   122                              <1> mouse_callback_dummy:
   123 00001A68 CB                  <1>     retf
   124                              <1> 
   125                              <1> poll_mouse:
   126 00001A69 50                  <1>     push ax
   127 00001A6A 53                  <1>     push bx
   128 00001A6B 52                  <1>     push dx
   129                              <1>     
   130 00001A6C BB0200              <1>     mov bx, 0x0002
   131                              <1> 
   132 00001A6F FA                  <1>     cli
   133 00001A70 A1[191B]            <1>     mov ax, [mouseX]
   134 00001A73 8B16[1B1B]          <1>     mov dx, [mouseY]
   135 00001A77 FB                  <1>     sti
   136                              <1> 
   137 00001A78 5A                  <1>     pop dx
   138 00001A79 5B                  <1>     pop bx
   139 00001A7A 58                  <1>     pop ax
   140 00001A7B C3                  <1>     ret
   141                              <1> 
   142                              <1> clamp_mouse:
   143 00001A7C A1[191B]            <1>     mov ax, [mouseX]
   144                              <1> 
   145 00001A7F 83F84E              <1>     cmp ax, screenmaxW
   146 00001A82 7D17                <1>     jge .r_edge
   147                              <1> 
   148 00001A84 BA0100              <1>     mov dx, screenminW
   149 00001A87 39D0                <1>     cmp ax, dx
   150 00001A89 7E22                <1>     jle .l_edge
   151                              <1> 
   152 00001A8B BA0100              <1>     mov dx, screenminH
   153 00001A8E A1[1B1B]            <1>     mov ax, [mouseY]
   154 00001A91 39D0                <1>     cmp ax, dx
   155 00001A93 7E2A                <1>     jle .t_edge
   156                              <1> 
   157 00001A95 83F817              <1>     cmp ax, screenmaxH
   158 00001A98 7D37                <1>     jge .b_edge
   159                              <1> 
   160 00001A9A C3                  <1>     ret
   161                              <1> 
   162                              <1> .r_edge:
   163 00001A9B C706[191B]4E00      <1>     mov word [mouseX], screenmaxW
   164 00001AA1 8A16[191B]          <1>     mov dl, [mouseX]
   165 00001AA5 8A36[1B1B]          <1>     mov dh, [mouseY]
   166 00001AA9 E87BF5              <1>     call move_cursor
   167 00001AAC C3                  <1>     ret
   168                              <1> 
   169                              <1> .l_edge:
   170 00001AAD C706[191B]0100      <1>     mov word [mouseX], screenminW
   171 00001AB3 8A16[191B]          <1>     mov dl, [mouseX]
   172 00001AB7 8A36[1B1B]          <1>     mov dh, [mouseY]
   173 00001ABB E869F5              <1>     call move_cursor
   174 00001ABE C3                  <1>     ret
   175                              <1> 
   176                              <1> .t_edge:
   177 00001ABF C706[1B1B]0100      <1>     mov word [mouseY], screenminH
   178 00001AC5 8A16[191B]          <1>     mov dl, [mouseX]
   179 00001AC9 8A36[1B1B]          <1>     mov dh, [mouseY]
   180 00001ACD E857F5              <1>     call move_cursor
   181 00001AD0 C3                  <1>     ret
   182                              <1> 
   183                              <1> .b_edge:
   184 00001AD1 C706[1B1B]1700      <1>     mov word [mouseY], screenmaxH
   185 00001AD7 8A16[191B]          <1>     mov dl, [mouseX]
   186 00001ADB 8A36[1B1B]          <1>     mov dh, [mouseY]
   187 00001ADF E845F5              <1>     call move_cursor
   188 00001AE2 C3                  <1>     ret
   189                              <1> 
   190                              <1> no_mouse:
   191 00001AE3 B8[2201]            <1>     mov ax, mouse_yes
   192 00001AE6 31DB                <1>     xor bx, bx
   193 00001AE8 31C9                <1>     xor cx, cx
   194 00001AEA BA0000              <1>     mov dx, 0
   195 00001AED E8CAF5              <1>     call dialog_box
   196                              <1> 
   197 00001AF0 31C0                <1>     xor ax, ax
   198 00001AF2 CD13                <1>     int 0x13
   199                              <1> 
   200 00001AF4 B80010              <1>     mov ax, 0x1000
   201 00001AF7 8CD0                <1>     mov ax, ss
   202 00001AF9 BC00F0              <1>     mov sp, 0xf000
   203 00001AFC B80753              <1>     mov ax, 0x5307
   204 00001AFF BB0100              <1>     mov bx, 0x0001
   205 00001B02 B90300              <1>     mov cx, 0x0003
   206 00001B05 CD15                <1>     int 0x15
   207                              <1> 
   208                              <1> mouse_loop:
   209 00001B07 E85FFF              <1>     call poll_mouse
   210 00001B0A 8A16[191B]          <1>     mov dl, [mouseX]
   211 00001B0E 8A36[1B1B]          <1>     mov dh, [mouseY]
   212                              <1>     
   213 00001B12 E812F5              <1>     call move_cursor
   214 00001B15 E864FF              <1>     call clamp_mouse
   215                              <1> 
   216 00001B18 C3                  <1>     ret
   217                              <1> 
   218 00001B19 0000                <1> mouseX:         dw 0
   219 00001B1B 0000                <1> mouseY:         dw 0
   220 00001B1D 00                  <1> curStatus:      db 0
   221 00001B1E 0D4572726F72207365- <1> noMouseMsg:     db 0x0d, "Error setting up and initializing mouse", 0x0a, 0x0d, 0
   221 00001B27 7474696E6720757020- <1>
   221 00001B30 616E6420696E697469- <1>
   221 00001B39 616C697A696E67206D- <1>
   221 00001B42 6F7573650A0D00      <1>
   206                                      %include "./includes/disk.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; FAT12 FLOPPY DISK ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
    10                              <1> ; IN/OUT: AX = location to store zero-terminated filename string
    11                              <1> 
    12                              <1> os_get_file_list:
    13 00001B49 60                  <1> 	pusha
    14                              <1> 
    15 00001B4A A3[EB1B]            <1> 	mov word [.file_list_tmp], ax
    16                              <1> 
    17 00001B4D 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
    18                              <1> 
    19 00001B53 E84007              <1> 	call disk_reset_floppy		; Just in case disk was changed
    20                              <1> 
    21 00001B56 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
    22 00001B59 E84907              <1> 	call disk_convert_l2hts
    23                              <1> 
    24 00001B5C BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
    25 00001B5F 89F3                <1> 	mov bx, si
    26                              <1> 
    27 00001B61 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
    28 00001B63 B00E                <1> 	mov al, 14			; And read 14 of them
    29                              <1> 
    30 00001B65 60                  <1> 	pusha				; Prepare to enter loop
    31                              <1> 
    32                              <1> 
    33                              <1> .read_root_dir:
    34 00001B66 61                  <1> 	popa
    35 00001B67 60                  <1> 	pusha
    36                              <1> 
    37 00001B68 F9                  <1> 	stc
    38 00001B69 CD13                <1> 	int 13h				; Read sectors
    39 00001B6B E82807              <1> 	call disk_reset_floppy		; Check we've read them OK
    40 00001B6E 7307                <1> 	jnc .show_dir_init		; No errors, continue
    41                              <1> 
    42 00001B70 E82307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
    43 00001B73 73F1                <1> 	jnc .read_root_dir
    44 00001B75 EB6E                <1> 	jmp .done			; Double error, exit 'dir' routine
    45                              <1> 
    46                              <1> .show_dir_init:
    47 00001B77 61                  <1> 	popa
    48                              <1> 
    49 00001B78 B80000              <1> 	mov ax, 0
    50 00001B7B BE0060              <1> 	mov si, disk_buffer		; Data reader from start of filenames
    51                              <1> 
    52 00001B7E 8B3E[EB1B]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
    53                              <1> 
    54                              <1> 
    55                              <1> .start_entry:
    56 00001B82 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
    57 00001B85 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
    58 00001B87 7457                <1> 	je .skip
    59                              <1> 
    60 00001B89 A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
    61 00001B8B 7553                <1> 	jnz .skip			; Yes, ignore it
    62                              <1> 
    63 00001B8D 8A04                <1> 	mov al, [si]
    64 00001B8F 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
    65 00001B91 744D                <1> 	je .skip
    66                              <1> 
    67 00001B93 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
    68 00001B95 744E                <1> 	je .done
    69                              <1> 
    70                              <1> 
    71 00001B97 B90100              <1> 	mov cx, 1			; Set char counter
    72 00001B9A 89F2                <1> 	mov dx, si			; Beginning of possible entry
    73                              <1> 
    74                              <1> .testdirentry:
    75 00001B9C 46                  <1> 	inc si
    76 00001B9D 8A04                <1> 	mov al, [si]			; Test for most unusable characters
    77 00001B9F 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
    78 00001BA1 7C3B                <1> 	jl .nxtdirentry
    79 00001BA3 3C7E                <1> 	cmp al, '~'
    80 00001BA5 7737                <1> 	ja .nxtdirentry
    81                              <1> 
    82 00001BA7 41                  <1> 	inc cx
    83 00001BA8 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
    84 00001BAB 7402                <1> 	je .gotfilename
    85 00001BAD EBED                <1> 	jmp .testdirentry
    86                              <1> 
    87                              <1> 
    88                              <1> .gotfilename:				; Got a filename that passes testing
    89 00001BAF 89D6                <1> 	mov si, dx			; DX = where getting string
    90                              <1> 
    91 00001BB1 B90000              <1> 	mov cx, 0
    92                              <1> .loopy:
    93 00001BB4 8A04                <1> 	mov byte al, [si]
    94 00001BB6 3C20                <1> 	cmp al, ' '
    95 00001BB8 7411                <1> 	je .ignore_space
    96 00001BBA 8805                <1> 	mov byte [di], al
    97 00001BBC 46                  <1> 	inc si
    98 00001BBD 47                  <1> 	inc di
    99 00001BBE 41                  <1> 	inc cx
   100 00001BBF 83F908              <1> 	cmp cx, 8
   101 00001BC2 7410                <1> 	je .add_dot
   102 00001BC4 83F90B              <1> 	cmp cx, 11
   103 00001BC7 7411                <1> 	je .done_copy
   104 00001BC9 EBE9                <1> 	jmp .loopy
   105                              <1> 
   106                              <1> .ignore_space:
   107 00001BCB 46                  <1> 	inc si
   108 00001BCC 41                  <1> 	inc cx
   109 00001BCD 83F908              <1> 	cmp cx, 8
   110 00001BD0 7402                <1> 	je .add_dot
   111 00001BD2 EBE0                <1> 	jmp .loopy
   112                              <1> 
   113                              <1> .add_dot:
   114 00001BD4 C6052E              <1> 	mov byte [di], '.'
   115 00001BD7 47                  <1> 	inc di
   116 00001BD8 EBDA                <1> 	jmp .loopy
   117                              <1> 
   118                              <1> .done_copy:
   119 00001BDA C6052C              <1> 	mov byte [di], ','
   120 00001BDD 47                  <1> 	inc di
   121                              <1> 
   122                              <1> .nxtdirentry:
   123 00001BDE 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
   124                              <1> 
   125                              <1> .skip:
   126 00001BE0 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
   127 00001BE3 EB9D                <1> 	jmp .start_entry
   128                              <1> 
   129                              <1> 
   130                              <1> .done:
   131 00001BE5 4F                  <1> 	dec di
   132 00001BE6 C60500              <1> 	mov byte [di], 0		; Zero-terminate string (gets rid of final comma)
   133                              <1> 
   134 00001BE9 61                  <1> 	popa
   135 00001BEA C3                  <1> 	ret
   136                              <1> 
   137 00001BEB 0000                <1> 	.file_list_tmp		dw 0
   138                              <1> 
   139                              <1> ; ------------------------------------------------------------------
   140                              <1> ; os_load_file -- Load file into RAM
   141                              <1> ; IN: AX = location of filename, CX = location in RAM to load file
   142                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
   143                              <1> 
   144                              <1> os_load_file:
   145 00001BED E838F0              <1> 	call string_uppercase
   146 00001BF0 E87205              <1> 	call int_filename_convert
   147                              <1> 
   148 00001BF3 A3[F51C]            <1> 	mov [.filename_loc], ax		; Store filename location
   149 00001BF6 890E[F71C]          <1> 	mov [.load_position], cx	; And where to load the file!
   150                              <1> 
   151 00001BFA 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   152                              <1> 
   153 00001C00 E89306              <1> 	call disk_reset_floppy		; In case floppy has been changed
   154 00001C03 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
   155                              <1> 
   156 00001C05 B8[071D]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
   157 00001C08 E93CFC              <1> 	jmp fatal_error
   158                              <1> 
   159                              <1> 
   160                              <1> .floppy_ok:				; Ready to read first block of data
   161 00001C0B B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   162 00001C0E E89406              <1> 	call disk_convert_l2hts
   163                              <1> 
   164 00001C11 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   165 00001C14 89F3                <1> 	mov bx, si
   166                              <1> 
   167 00001C16 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   168 00001C18 B00E                <1> 	mov al, 14			; 14 root directory sectors
   169                              <1> 
   170 00001C1A 60                  <1> 	pusha				; Prepare to enter loop
   171                              <1> 
   172                              <1> 
   173                              <1> .read_root_dir:
   174 00001C1B 61                  <1> 	popa
   175 00001C1C 60                  <1> 	pusha
   176                              <1> 
   177 00001C1D F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
   178 00001C1E CD13                <1> 	int 13h				; Read sectors
   179 00001C20 7308                <1> 	jnc .search_root_dir		; No errors = continue
   180                              <1> 
   181 00001C22 E87106              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
   182 00001C25 73F4                <1> 	jnc .read_root_dir
   183                              <1> 
   184 00001C27 61                  <1> 	popa
   185 00001C28 EB38                <1> 	jmp .root_problem		; Double error = exit
   186                              <1> 
   187                              <1> .search_root_dir:
   188 00001C2A 61                  <1> 	popa
   189                              <1> 
   190 00001C2B B9E000              <1> 	mov cx, word 224		; Search all entries in root dir
   191 00001C2E BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
   192                              <1> 
   193                              <1> .next_root_entry:
   194 00001C31 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
   195 00001C34 BF0060              <1> 	mov di, disk_buffer		; Point root dir at next entry
   196 00001C37 01DF                <1> 	add di, bx
   197                              <1> 
   198 00001C39 8A05                <1> 	mov al, [di]			; First character of name
   199                              <1> 
   200 00001C3B 3C00                <1> 	cmp al, 0			; Last file name already checked?
   201 00001C3D 7423                <1> 	je .root_problem
   202                              <1> 
   203 00001C3F 3CE5                <1> 	cmp al, 229			; Was this file deleted?
   204 00001C41 74EE                <1> 	je .next_root_entry		; If yes, skip it
   205                              <1> 
   206 00001C43 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
   207                              <1> 
   208 00001C46 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
   209 00001C48 74E7                <1> 	je .next_root_entry
   210                              <1> 
   211 00001C4A A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   212 00001C4C 75E3                <1> 	jnz .next_root_entry
   213                              <1> 
   214 00001C4E C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
   215                              <1> 
   216 00001C52 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
   217 00001C54 E8D1EF              <1> 	call string_uppercase
   218                              <1> 
   219 00001C57 8B36[F51C]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
   220                              <1> 
   221 00001C5B E885F0              <1> 	call string_compare		; Current entry same as requested?
   222 00001C5E 7207                <1> 	jc .found_file_to_load
   223                              <1> 
   224 00001C60 E2CF                <1> 	loop .next_root_entry
   225                              <1> 
   226                              <1> .root_problem:
   227 00001C62 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
   228 00001C65 F9                  <1> 	stc				; return with size = 0 and carry set
   229 00001C66 C3                  <1> 	ret
   230                              <1> 
   231                              <1> 
   232                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
   233 00001C67 8B451C              <1> 	mov ax, [di+28]			; Store file size to return to calling routine
   234 00001C6A A3[F91C]            <1> 	mov word [.file_size], ax
   235                              <1> 
   236 00001C6D 83F800              <1> 	cmp ax, 0			; If the file size is zero, don't bother trying
   237 00001C70 7478                <1> 	je .end				; to read more clusters
   238                              <1> 
   239 00001C72 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
   240 00001C75 A3[F11C]            <1> 	mov word [.cluster], ax
   241                              <1> 
   242 00001C78 B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
   243 00001C7B E82706              <1> 	call disk_convert_l2hts
   244                              <1> 
   245 00001C7E BF0060              <1> 	mov di, disk_buffer		; ES:BX points to our buffer
   246 00001C81 89FB                <1> 	mov bx, di
   247                              <1> 
   248 00001C83 B402                <1> 	mov ah, 2			; int 13h params: read sectors
   249 00001C85 B009                <1> 	mov al, 9			; And read 9 of them
   250                              <1> 
   251 00001C87 60                  <1> 	pusha
   252                              <1> 
   253                              <1> .read_fat:
   254 00001C88 61                  <1> 	popa				; In case registers altered by int 13h
   255 00001C89 60                  <1> 	pusha
   256                              <1> 
   257 00001C8A F9                  <1> 	stc
   258 00001C8B CD13                <1> 	int 13h
   259 00001C8D 7308                <1> 	jnc .read_fat_ok
   260                              <1> 
   261 00001C8F E80406              <1> 	call disk_reset_floppy
   262 00001C92 73F4                <1> 	jnc .read_fat
   263                              <1> 
   264 00001C94 61                  <1> 	popa
   265 00001C95 EBCB                <1> 	jmp .root_problem
   266                              <1> 
   267                              <1> 
   268                              <1> .read_fat_ok:
   269 00001C97 61                  <1> 	popa
   270                              <1> 
   271                              <1> 
   272                              <1> .load_file_sector:
   273 00001C98 A1[F11C]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
   274 00001C9B 83C01F              <1> 	add ax, 31
   275                              <1> 
   276 00001C9E E80406              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
   277                              <1> 
   278 00001CA1 8B1E[F71C]          <1> 	mov bx, [.load_position]
   279                              <1> 
   280                              <1> 
   281 00001CA5 B402                <1> 	mov ah, 02			; AH = read sectors, AL = just read 1
   282 00001CA7 B001                <1> 	mov al, 01
   283                              <1> 
   284 00001CA9 F9                  <1> 	stc
   285 00001CAA CD13                <1> 	int 13h
   286 00001CAC 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
   287                              <1> 
   288 00001CAE E8E505              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
   289 00001CB1 73E5                <1> 	jnc .load_file_sector
   290                              <1> 
   291 00001CB3 B8[071D]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
   292 00001CB6 E98EFB              <1> 	jmp fatal_error
   293                              <1> 
   294                              <1> 
   295                              <1> .calculate_next_cluster:
   296 00001CB9 A1[F11C]            <1> 	mov ax, [.cluster]
   297 00001CBC BB0300              <1> 	mov bx, 3
   298 00001CBF F7E3                <1> 	mul bx
   299 00001CC1 BB0200              <1> 	mov bx, 2
   300 00001CC4 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
   301 00001CC6 BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   302 00001CC9 01C6                <1> 	add si, ax
   303 00001CCB 3E8B04              <1> 	mov ax, word [ds:si]
   304                              <1> 
   305 00001CCE 09D2                <1> 	or dx, dx			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
   306                              <1> 
   307 00001CD0 7405                <1> 	jz .even			; If [CLUSTER] = even, drop last 4 bits of word
   308                              <1> 					; with next cluster; if odd, drop first 4 bits
   309                              <1> 
   310                              <1> .odd:
   311 00001CD2 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
   312 00001CD5 EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   313                              <1> 
   314                              <1> .even:
   315 00001CD7 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
   316                              <1> 
   317                              <1> .calculate_cluster_cont:
   318 00001CDA A3[F11C]            <1> 	mov word [.cluster], ax		; Store cluster
   319                              <1> 
   320 00001CDD 3DF80F              <1> 	cmp ax, 0FF8h
   321 00001CE0 7308                <1> 	jae .end
   322                              <1> 
   323 00001CE2 8106[F71C]0002      <1> 	add word [.load_position], 512
   324 00001CE8 EBAE                <1> 	jmp .load_file_sector		; Onto next sector!
   325                              <1> 
   326                              <1> 
   327                              <1> .end:
   328 00001CEA 8B1E[F91C]          <1> 	mov bx, [.file_size]		; Get file size to pass back in BX
   329 00001CEE F8                  <1> 	clc				; Carry clear = good load
   330 00001CEF C3                  <1> 	ret
   331                              <1> 
   332                              <1> 
   333 00001CF0 00                  <1> 	.bootd		db 0 		; Boot device number
   334 00001CF1 0000                <1> 	.cluster	dw 0 		; Cluster of the file we want to load
   335 00001CF3 0000                <1> 	.pointer	dw 0 		; Pointer into disk_buffer, for loading 'file2load'
   336                              <1> 
   337 00001CF5 0000                <1> 	.filename_loc	dw 0		; Temporary store of filename location
   338 00001CF7 0000                <1> 	.load_position	dw 0		; Where we'll load the file
   339 00001CF9 0000                <1> 	.file_size	dw 0		; Size of the file
   340                              <1> 
   341 00001CFB 00<rept>            <1> 	.string_buff	times 12 db 0	; For size (integer) printing
   342                              <1> 
   343 00001D07 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy failed to reset', 0
   343 00001D10 696C653A20466C6F70- <1>
   343 00001D19 7079206661696C6564- <1>
   343 00001D22 20746F207265736574- <1>
   343 00001D2B 00                  <1>
   344                              <1> 
   345                              <1> 
   346                              <1> ; --------------------------------------------------------------------------
   347                              <1> ; os_write_file -- Save (max 64K) file to disk
   348                              <1> ; IN: AX = filename, BX = data location, CX = bytes to write
   349                              <1> ; OUT: Carry clear if OK, set if failure
   350                              <1> 
   351                              <1> os_write_file:
   352 00001D2C 60                  <1> 	pusha
   353                              <1> 
   354 00001D2D 89C6                <1> 	mov si, ax
   355 00001D2F E8A7EE              <1> 	call string_length
   356 00001D32 83F800              <1> 	cmp ax, 0
   357 00001D35 0F849201            <1> 	je near .failure
   358 00001D39 89F0                <1> 	mov ax, si
   359                              <1> 
   360 00001D3B E8EAEE              <1> 	call string_uppercase
   361 00001D3E E82404              <1> 	call int_filename_convert	; Make filename FAT12-style
   362 00001D41 0F828601            <1> 	jc near .failure
   363                              <1> 
   364 00001D45 890E[CE1E]          <1> 	mov word [.filesize], cx
   365 00001D49 891E[D41E]          <1> 	mov word [.location], bx
   366 00001D4D A3[D81E]            <1> 	mov word [.filename], ax
   367                              <1> 
   368 00001D50 E88702              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
   369 00001D53 0F837401            <1> 	jnc near .failure
   370                              <1> 
   371                              <1> 
   372                              <1> 	; First, zero out the .free_clusters list from any previous execution
   373 00001D57 60                  <1> 	pusha
   374                              <1> 
   375 00001D58 BF[DA1E]            <1> 	mov di, .free_clusters
   376 00001D5B B98000              <1> 	mov cx, 128
   377                              <1> .clean_free_loop:
   378 00001D5E C7050000            <1> 	mov word [di], 0
   379 00001D62 47                  <1> 	inc di
   380 00001D63 47                  <1> 	inc di
   381 00001D64 E2F8                <1> 	loop .clean_free_loop
   382                              <1> 
   383 00001D66 61                  <1> 	popa
   384                              <1> 
   385                              <1> 
   386                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
   387                              <1> 
   388 00001D67 89C8                <1> 	mov ax, cx
   389 00001D69 BA0000              <1> 	mov dx, 0
   390 00001D6C BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
   391 00001D6F F7F3                <1> 	div bx
   392 00001D71 83FA00              <1> 	cmp dx, 0
   393 00001D74 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
   394 00001D76 EB03                <1> 	jmp .carry_on
   395                              <1> 
   396                              <1> .add_a_bit:
   397 00001D78 83C001              <1> 	add ax, 1
   398                              <1> .carry_on:
   399                              <1> 
   400 00001D7B A3[D61E]            <1> 	mov word [.clusters_needed], ax
   401                              <1> 
   402 00001D7E A1[D81E]            <1> 	mov word ax, [.filename]	; Get filename back
   403                              <1> 
   404 00001D81 E87502              <1> 	call os_create_file		; Create empty root dir entry for this file
   405 00001D84 0F824301            <1> 	jc near .failure		; If we can't write to the media, jump out
   406                              <1> 
   407 00001D88 8B1E[CE1E]          <1> 	mov word bx, [.filesize]
   408 00001D8C 83FB00              <1> 	cmp bx, 0
   409 00001D8F 0F843501            <1> 	je near .finished
   410                              <1> 
   411 00001D93 E86B04              <1> 	call disk_read_fat		; Get FAT copy into RAM
   412 00001D96 BE0360              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
   413                              <1> 
   414 00001D99 BB0200              <1> 	mov bx, 2			; Current cluster counter
   415 00001D9C 8B0E[D61E]          <1> 	mov word cx, [.clusters_needed]
   416 00001DA0 BA0000              <1> 	mov dx, 0			; Offset in .free_clusters list
   417                              <1> 
   418                              <1> .find_free_cluster:
   419 00001DA3 AD                  <1> 	lodsw				; Get a word
   420 00001DA4 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
   421 00001DA7 740D                <1> 	jz .found_free_even		; Free entry?
   422                              <1> 
   423                              <1> .more_odd:
   424 00001DA9 43                  <1> 	inc bx				; If not, bump our counter
   425 00001DAA 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
   426                              <1> 
   427 00001DAB AD                  <1> 	lodsw				; Get word
   428 00001DAC C1E804              <1> 	shr ax, 4			; Shift for odd
   429 00001DAF 09C0                <1> 	or ax, ax			; Free entry?
   430 00001DB1 7416                <1> 	jz .found_free_odd
   431                              <1> 
   432                              <1> .more_even:
   433 00001DB3 43                  <1> 	inc bx				; If not, keep going
   434 00001DB4 EBED                <1> 	jmp .find_free_cluster
   435                              <1> 
   436                              <1> 
   437                              <1> .found_free_even:
   438 00001DB6 56                  <1> 	push si
   439 00001DB7 BE[DA1E]            <1> 	mov si, .free_clusters		; Store cluster
   440 00001DBA 01D6                <1> 	add si, dx
   441 00001DBC 891C                <1> 	mov word [si], bx
   442 00001DBE 5E                  <1> 	pop si
   443                              <1> 
   444 00001DBF 49                  <1> 	dec cx				; Got all the clusters we need?
   445 00001DC0 83F900              <1> 	cmp cx, 0
   446 00001DC3 7417                <1> 	je .finished_list
   447                              <1> 
   448 00001DC5 42                  <1> 	inc dx				; Next word in our list
   449 00001DC6 42                  <1> 	inc dx
   450 00001DC7 EBE0                <1> 	jmp .more_odd
   451                              <1> 
   452                              <1> .found_free_odd:
   453 00001DC9 56                  <1> 	push si
   454 00001DCA BE[DA1E]            <1> 	mov si, .free_clusters		; Store cluster
   455 00001DCD 01D6                <1> 	add si, dx
   456 00001DCF 891C                <1> 	mov word [si], bx
   457 00001DD1 5E                  <1> 	pop si
   458                              <1> 
   459 00001DD2 49                  <1> 	dec cx
   460 00001DD3 83F900              <1> 	cmp cx, 0
   461 00001DD6 7404                <1> 	je .finished_list
   462                              <1> 
   463 00001DD8 42                  <1> 	inc dx				; Next word in our list
   464 00001DD9 42                  <1> 	inc dx
   465 00001DDA EBD7                <1> 	jmp .more_even
   466                              <1> 
   467                              <1> 
   468                              <1> 
   469                              <1> .finished_list:
   470                              <1> 
   471                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
   472                              <1> 	; that correspond to free clusters on the disk; the next job is to
   473                              <1> 	; create a cluster chain in the FAT for our file
   474                              <1> 
   475 00001DDC B90000              <1> 	mov cx, 0			; .free_clusters offset counter
   476 00001DDF C706[D21E]0100      <1> 	mov word [.count], 1		; General cluster counter
   477                              <1> 
   478                              <1> .chain_loop:
   479 00001DE5 A1[D21E]            <1> 	mov word ax, [.count]		; Is this the last cluster?
   480 00001DE8 3B06[D61E]          <1> 	cmp word ax, [.clusters_needed]
   481 00001DEC 7455                <1> 	je .last_cluster
   482                              <1> 
   483 00001DEE BF[DA1E]            <1> 	mov di, .free_clusters
   484                              <1> 
   485 00001DF1 01CF                <1> 	add di, cx
   486 00001DF3 8B1D                <1> 	mov word bx, [di]		; Get cluster
   487                              <1> 
   488 00001DF5 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
   489 00001DF7 BA0000              <1> 	mov dx, 0
   490 00001DFA BB0300              <1> 	mov bx, 3
   491 00001DFD F7E3                <1> 	mul bx
   492 00001DFF BB0200              <1> 	mov bx, 2
   493 00001E02 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   494 00001E04 BE0060              <1> 	mov si, disk_buffer
   495 00001E07 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   496 00001E09 3E8B04              <1> 	mov ax, word [ds:si]
   497                              <1> 
   498 00001E0C 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   499 00001E0E 741B                <1> 	jz .even
   500                              <1> 
   501                              <1> .odd:
   502 00001E10 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
   503 00001E13 BF[DA1E]            <1> 	mov di, .free_clusters
   504 00001E16 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   505 00001E18 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
   506 00001E1B C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
   507 00001E1E 01D8                <1> 	add ax, bx
   508                              <1> 
   509 00001E20 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   510                              <1> 
   511 00001E23 FF06[D21E]          <1> 	inc word [.count]
   512 00001E27 41                  <1> 	inc cx				; Move on a word in .free_clusters
   513 00001E28 41                  <1> 	inc cx
   514                              <1> 
   515 00001E29 EBBA                <1> 	jmp .chain_loop
   516                              <1> 
   517                              <1> .even:
   518 00001E2B 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
   519 00001E2E BF[DA1E]            <1> 	mov di, .free_clusters
   520 00001E31 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   521 00001E33 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
   522                              <1> 
   523 00001E36 01D8                <1> 	add ax, bx
   524                              <1> 
   525 00001E38 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   526                              <1> 
   527 00001E3B FF06[D21E]          <1> 	inc word [.count]
   528 00001E3F 41                  <1> 	inc cx				; Move on a word in .free_clusters
   529 00001E40 41                  <1> 	inc cx
   530                              <1> 
   531 00001E41 EBA2                <1> 	jmp .chain_loop
   532                              <1> 
   533                              <1> 
   534                              <1> 
   535                              <1> .last_cluster:
   536 00001E43 BF[DA1E]            <1> 	mov di, .free_clusters
   537 00001E46 01CF                <1> 	add di, cx
   538 00001E48 8B1D                <1> 	mov word bx, [di]		; Get cluster
   539                              <1> 
   540 00001E4A 89D8                <1> 	mov ax, bx
   541                              <1> 
   542 00001E4C BA0000              <1> 	mov dx, 0
   543 00001E4F BB0300              <1> 	mov bx, 3
   544 00001E52 F7E3                <1> 	mul bx
   545 00001E54 BB0200              <1> 	mov bx, 2
   546 00001E57 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   547 00001E59 BE0060              <1> 	mov si, disk_buffer
   548 00001E5C 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   549 00001E5E 3E8B04              <1> 	mov ax, word [ds:si]
   550                              <1> 
   551 00001E61 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   552 00001E63 7408                <1> 	jz .even_last
   553                              <1> 
   554                              <1> .odd_last:
   555 00001E65 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
   556 00001E68 83C080              <1> 	add ax, 0FF80h
   557 00001E6B EB06                <1> 	jmp .finito
   558                              <1> 
   559                              <1> .even_last:
   560 00001E6D 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
   561 00001E70 05F80F              <1> 	add ax, 0FF8h
   562                              <1> 
   563                              <1> 
   564                              <1> .finito:
   565 00001E73 3E8904              <1> 	mov word [ds:si], ax
   566                              <1> 
   567 00001E76 E8B403              <1> 	call disk_write_fat		; Save our FAT back to disk
   568                              <1> 
   569                              <1> 
   570                              <1> 	; Now it's time to save the sectors to disk!
   571                              <1> 
   572 00001E79 B90000              <1> 	mov cx, 0
   573                              <1> 
   574                              <1> .save_loop:
   575 00001E7C BF[DA1E]            <1> 	mov di, .free_clusters
   576 00001E7F 01CF                <1> 	add di, cx
   577 00001E81 8B05                <1> 	mov word ax, [di]
   578                              <1> 
   579 00001E83 83F800              <1> 	cmp ax, 0
   580 00001E86 0F841D00            <1> 	je near .write_root_entry
   581                              <1> 
   582 00001E8A 60                  <1> 	pusha
   583                              <1> 
   584 00001E8B 83C01F              <1> 	add ax, 31
   585                              <1> 
   586 00001E8E E81404              <1> 	call disk_convert_l2hts
   587                              <1> 
   588 00001E91 8B1E[D41E]          <1> 	mov word bx, [.location]
   589                              <1> 
   590 00001E95 B403                <1> 	mov ah, 3
   591 00001E97 B001                <1> 	mov al, 1
   592 00001E99 F9                  <1> 	stc
   593 00001E9A CD13                <1> 	int 13h
   594                              <1> 
   595 00001E9C 61                  <1> 	popa
   596                              <1> 
   597 00001E9D 8106[D41E]0002      <1> 	add word [.location], 512
   598 00001EA3 41                  <1> 	inc cx
   599 00001EA4 41                  <1> 	inc cx
   600 00001EA5 EBD5                <1> 	jmp .save_loop
   601                              <1> 
   602                              <1> 
   603                              <1> .write_root_entry:
   604                              <1> 
   605                              <1> 	; Now it's time to head back to the root directory, find our
   606                              <1> 	; entry and update it with the cluster in use and file size
   607                              <1> 
   608 00001EA7 E8A203              <1> 	call disk_read_root_dir
   609                              <1> 
   610 00001EAA A1[D81E]            <1> 	mov word ax, [.filename]
   611 00001EAD E81903              <1> 	call disk_get_root_entry
   612                              <1> 
   613 00001EB0 A1[DA1E]            <1> 	mov word ax, [.free_clusters]	; Get first free cluster
   614                              <1> 
   615 00001EB3 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
   616                              <1> 
   617 00001EB6 8B0E[CE1E]          <1> 	mov word cx, [.filesize]
   618 00001EBA 894D1C              <1> 	mov word [di+28], cx
   619                              <1> 
   620 00001EBD C6451E00            <1> 	mov byte [di+30], 0		; File size
   621 00001EC1 C6451F00            <1> 	mov byte [di+31], 0
   622                              <1> 
   623 00001EC5 E8AF03              <1> 	call disk_write_root_dir
   624                              <1> 
   625                              <1> .finished:
   626 00001EC8 61                  <1> 	popa
   627 00001EC9 F8                  <1> 	clc
   628 00001ECA C3                  <1> 	ret
   629                              <1> 
   630                              <1> .failure:
   631 00001ECB 61                  <1> 	popa
   632 00001ECC F9                  <1> 	stc				; Couldn't write!
   633 00001ECD C3                  <1> 	ret
   634                              <1> 
   635                              <1> 
   636 00001ECE 0000                <1> 	.filesize	dw 0
   637 00001ED0 0000                <1> 	.cluster	dw 0
   638 00001ED2 0000                <1> 	.count		dw 0
   639 00001ED4 0000                <1> 	.location	dw 0
   640                              <1> 
   641 00001ED6 0000                <1> 	.clusters_needed	dw 0
   642                              <1> 
   643 00001ED8 0000                <1> 	.filename	dw 0
   644                              <1> 
   645 00001EDA 0000<rept>          <1> 	.free_clusters	times 128 dw 0
   646                              <1> 
   647                              <1> 
   648                              <1> ; --------------------------------------------------------------------------
   649                              <1> ; os_file_exists -- Check for presence of file on the floppy
   650                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
   651                              <1> 
   652                              <1> os_file_exists:
   653 00001FDA E84BEC              <1> 	call string_uppercase
   654 00001FDD E88501              <1> 	call int_filename_convert	; Make FAT12-style filename
   655                              <1> 
   656 00001FE0 50                  <1> 	push ax
   657 00001FE1 E8F5EB              <1> 	call string_length
   658 00001FE4 83F800              <1> 	cmp ax, 0
   659 00001FE7 740D                <1> 	je .failure
   660 00001FE9 58                  <1> 	pop ax
   661                              <1> 
   662 00001FEA 50                  <1> 	push ax
   663 00001FEB E85E02              <1> 	call disk_read_root_dir
   664                              <1> 
   665 00001FEE 58                  <1> 	pop ax				; Restore filename
   666 00001FEF BF0060              <1> 	mov di, disk_buffer
   667 00001FF2 E8D401              <1> 	call disk_get_root_entry	; Set or clear carry flag
   668                              <1> 	
   669 00001FF5 C3                  <1> 	ret
   670                              <1> 
   671                              <1> .failure:
   672 00001FF6 58                  <1> 	pop ax
   673 00001FF7 F9                  <1> 	stc
   674 00001FF8 C3                  <1> 	ret
   675                              <1> 
   676                              <1> 
   677                              <1> ; --------------------------------------------------------------------------
   678                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
   679                              <1> ; IN: AX = location of filename
   680                              <1> 
   681                              <1> os_create_file:
   682 00001FF9 F8                  <1> 	clc
   683                              <1> 
   684 00001FFA E82BEC              <1> 	call string_uppercase
   685 00001FFD E86501              <1> 	call int_filename_convert	; Make FAT12-style filename
   686 00002000 60                  <1> 	pusha
   687                              <1> 
   688 00002001 50                  <1> 	push ax				; Save filename for now
   689                              <1> 
   690 00002002 E8D5FF              <1> 	call os_file_exists		; Does the file already exist?
   691 00002005 7315                <1> 	jnc .exists_error
   692                              <1> 
   693                              <1> 
   694                              <1> 	; Root dir already read into disk_buffer by os_file_exists
   695                              <1> 
   696 00002007 BF0060              <1> 	mov di, disk_buffer		; So point DI at it!
   697                              <1> 
   698                              <1> 
   699 0000200A B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
   700                              <1> .next_entry:
   701 0000200D 8A05                <1> 	mov byte al, [di]
   702 0000200F 3C00                <1> 	cmp al, 0			; Is this a free entry?
   703 00002011 740D                <1> 	je .found_free_entry
   704 00002013 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
   705 00002015 7409                <1> 	je .found_free_entry
   706 00002017 83C720              <1> 	add di, 32			; If not, go onto next entry
   707 0000201A E2F1                <1> 	loop .next_entry
   708                              <1> 
   709                              <1> .exists_error:				; We also get here if above loop finds nothing
   710 0000201C 58                  <1> 	pop ax				; Get filename back
   711                              <1> 
   712 0000201D 61                  <1> 	popa
   713 0000201E F9                  <1> 	stc				; Set carry for failure
   714 0000201F C3                  <1> 	ret
   715                              <1> 
   716                              <1> 
   717                              <1> .found_free_entry:
   718 00002020 5E                  <1> 	pop si				; Get filename back
   719 00002021 B90B00              <1> 	mov cx, 11
   720 00002024 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
   721                              <1> 
   722                              <1> 
   723 00002026 83EF0B              <1> 	sub di, 11			; Back to start of root dir entry, for clarity
   724                              <1> 
   725                              <1> 
   726 00002029 C6450B00            <1> 	mov byte [di+11], 0		; Attributes
   727 0000202D C6450C00            <1> 	mov byte [di+12], 0		; Reserved
   728 00002031 C6450D00            <1> 	mov byte [di+13], 0		; Reserved
   729 00002035 C6450EC6            <1> 	mov byte [di+14], 0C6h		; Creation time
   730 00002039 C6450F7E            <1> 	mov byte [di+15], 07Eh		; Creation time
   731 0000203D C6451000            <1> 	mov byte [di+16], 0		; Creation date
   732 00002041 C6451100            <1> 	mov byte [di+17], 0		; Creation date
   733 00002045 C6451200            <1> 	mov byte [di+18], 0		; Last access date
   734 00002049 C6451300            <1> 	mov byte [di+19], 0		; Last access date
   735 0000204D C6451400            <1> 	mov byte [di+20], 0		; Ignore in FAT12
   736 00002051 C6451500            <1> 	mov byte [di+21], 0		; Ignore in FAT12
   737 00002055 C64516C6            <1> 	mov byte [di+22], 0C6h		; Last write time
   738 00002059 C645177E            <1> 	mov byte [di+23], 07Eh		; Last write time
   739 0000205D C6451800            <1> 	mov byte [di+24], 0		; Last write date
   740 00002061 C6451900            <1> 	mov byte [di+25], 0		; Last write date
   741 00002065 C6451A00            <1> 	mov byte [di+26], 0		; First logical cluster
   742 00002069 C6451B00            <1> 	mov byte [di+27], 0		; First logical cluster
   743 0000206D C6451C00            <1> 	mov byte [di+28], 0		; File size
   744 00002071 C6451D00            <1> 	mov byte [di+29], 0		; File size
   745 00002075 C6451E00            <1> 	mov byte [di+30], 0		; File size
   746 00002079 C6451F00            <1> 	mov byte [di+31], 0		; File size
   747                              <1> 
   748 0000207D E8F701              <1> 	call disk_write_root_dir
   749 00002080 7203                <1> 	jc .failure
   750                              <1> 
   751 00002082 61                  <1> 	popa
   752 00002083 F8                  <1> 	clc				; Clear carry for success
   753 00002084 C3                  <1> 	ret
   754                              <1> 
   755                              <1> .failure:
   756 00002085 61                  <1> 	popa
   757 00002086 F9                  <1> 	stc
   758 00002087 C3                  <1> 	ret
   759                              <1> 
   760                              <1> 
   761                              <1> ; --------------------------------------------------------------------------
   762                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
   763                              <1> ; IN: AX = location of filename to remove
   764                              <1> 
   765                              <1> os_remove_file:
   766 00002088 60                  <1> 	pusha
   767 00002089 E89CEB              <1> 	call string_uppercase
   768 0000208C E8D600              <1> 	call int_filename_convert	; Make filename FAT12-style
   769 0000208F 50                  <1> 	push ax				; Save filename
   770                              <1> 
   771 00002090 F8                  <1> 	clc
   772                              <1> 
   773 00002091 E8B801              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
   774                              <1> 
   775 00002094 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
   776                              <1> 
   777 00002097 58                  <1> 	pop ax				; Get chosen filename back
   778                              <1> 
   779 00002098 E82E01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
   780 0000209B 7269                <1> 	jc .failure			; If entry can't be found
   781                              <1> 
   782                              <1> 
   783 0000209D 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
   784 000020A1 A3[0921]            <1> 	mov word [.cluster], ax		; And save it
   785                              <1> 
   786 000020A4 C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
   787                              <1> 
   788 000020A7 47                  <1> 	inc di
   789                              <1> 
   790 000020A8 B90000              <1> 	mov cx, 0			; Set rest of data in root dir entry to zeros
   791                              <1> .clean_loop:
   792 000020AB C60500              <1> 	mov byte [di], 0
   793 000020AE 47                  <1> 	inc di
   794 000020AF 41                  <1> 	inc cx
   795 000020B0 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
   796 000020B3 7CF6                <1> 	jl .clean_loop
   797                              <1> 
   798 000020B5 E8BF01              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
   799                              <1> 
   800                              <1> 
   801 000020B8 E84601              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
   802 000020BB BF0060              <1> 	mov di, disk_buffer		; And DI points to it
   803                              <1> 
   804                              <1> 
   805                              <1> .more_clusters:
   806 000020BE A1[0921]            <1> 	mov word ax, [.cluster]		; Get cluster contents
   807                              <1> 
   808 000020C1 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
   809 000020C4 743D                <1> 	je .nothing_to_do
   810                              <1> 
   811 000020C6 BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
   812 000020C9 F7E3                <1> 	mul bx
   813 000020CB BB0200              <1> 	mov bx, 2
   814 000020CE F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
   815 000020D0 BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   816 000020D3 01C6                <1> 	add si, ax
   817 000020D5 3E8B04              <1> 	mov ax, word [ds:si]
   818                              <1> 
   819 000020D8 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
   820                              <1> 
   821 000020DA 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
   822                              <1> 					; with next cluster; if odd, drop first 4 bits
   823                              <1> .odd:
   824 000020DC 50                  <1> 	push ax
   825 000020DD 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
   826 000020E0 3E8904              <1> 	mov word [ds:si], ax
   827 000020E3 58                  <1> 	pop ax
   828                              <1> 
   829 000020E4 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
   830 000020E7 EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   831                              <1> 
   832                              <1> .even:
   833 000020E9 50                  <1> 	push ax
   834 000020EA 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
   835 000020ED 3E8904              <1> 	mov word [ds:si], ax
   836 000020F0 58                  <1> 	pop ax
   837                              <1> 
   838 000020F1 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
   839                              <1> 
   840                              <1> .calculate_cluster_cont:
   841 000020F4 A3[0921]            <1> 	mov word [.cluster], ax		; Store cluster
   842                              <1> 
   843 000020F7 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
   844 000020FA 7302                <1> 	jae .end
   845                              <1> 
   846 000020FC EBC0                <1> 	jmp .more_clusters		; If not, grab more
   847                              <1> 
   848                              <1> .end:
   849 000020FE E82C01              <1> 	call disk_write_fat
   850 00002101 7203                <1> 	jc .failure
   851                              <1> 
   852                              <1> .nothing_to_do:
   853 00002103 61                  <1> 	popa
   854 00002104 F8                  <1> 	clc
   855 00002105 C3                  <1> 	ret
   856                              <1> 
   857                              <1> .failure:
   858 00002106 61                  <1> 	popa
   859 00002107 F9                  <1> 	stc
   860 00002108 C3                  <1> 	ret
   861                              <1> 
   862                              <1> 
   863 00002109 0000                <1> 	.cluster dw 0
   864                              <1> 
   865                              <1> 
   866                              <1> ; --------------------------------------------------------------------------
   867                              <1> ; os_rename_file -- Change the name of a file on the disk
   868                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
   869                              <1> ; OUT: carry set on error
   870                              <1> 
   871                              <1> os_rename_file:
   872 0000210B 53                  <1> 	push bx
   873 0000210C 50                  <1> 	push ax
   874                              <1> 
   875 0000210D F8                  <1> 	clc
   876                              <1> 
   877 0000210E E83B01              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
   878                              <1> 
   879 00002111 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
   880                              <1> 
   881 00002114 58                  <1> 	pop ax				; Get chosen filename back
   882                              <1> 
   883 00002115 E810EB              <1> 	call string_uppercase
   884 00002118 E84A00              <1> 	call int_filename_convert
   885                              <1> 
   886 0000211B E8AB00              <1> 	call disk_get_root_entry	; Entry will be returned in DI
   887 0000211E 7217                <1> 	jc .fail_read			; Quit out if file not found
   888                              <1> 
   889 00002120 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
   890                              <1> 
   891 00002121 89D8                <1> 	mov ax, bx
   892                              <1> 
   893 00002123 E802EB              <1> 	call string_uppercase
   894 00002126 E83C00              <1> 	call int_filename_convert
   895                              <1> 
   896 00002129 89C6                <1> 	mov si, ax
   897                              <1> 
   898 0000212B B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
   899 0000212E F3A4                <1> 	rep movsb
   900                              <1> 
   901 00002130 E84401              <1> 	call disk_write_root_dir	; Save root dir to disk
   902 00002133 7205                <1> 	jc .fail_write
   903                              <1> 
   904 00002135 F8                  <1> 	clc
   905 00002136 C3                  <1> 	ret
   906                              <1> 
   907                              <1> .fail_read:
   908 00002137 58                  <1> 	pop ax
   909 00002138 F9                  <1> 	stc
   910 00002139 C3                  <1> 	ret
   911                              <1> 
   912                              <1> .fail_write:
   913 0000213A F9                  <1> 	stc
   914 0000213B C3                  <1> 	ret
   915                              <1> 
   916                              <1> 
   917                              <1> ; --------------------------------------------------------------------------
   918                              <1> ; os_get_file_size -- Get file size information for specified file
   919                              <1> ; IN: AX = filename; OUT: BX = file size in bytes (up to 64K)
   920                              <1> ; or carry set if file not found
   921                              <1> 
   922                              <1> os_get_file_size:
   923 0000213C 60                  <1> 	pusha
   924                              <1> 
   925 0000213D E8E8EA              <1> 	call string_uppercase
   926 00002140 E82200              <1> 	call int_filename_convert
   927                              <1> 
   928 00002143 F8                  <1> 	clc
   929                              <1> 
   930 00002144 50                  <1> 	push ax
   931                              <1> 
   932 00002145 E80401              <1> 	call disk_read_root_dir
   933 00002148 7216                <1> 	jc .failure
   934                              <1> 
   935 0000214A 58                  <1> 	pop ax
   936                              <1> 
   937 0000214B BF0060              <1> 	mov di, disk_buffer
   938                              <1> 
   939 0000214E E87800              <1> 	call disk_get_root_entry
   940 00002151 720D                <1> 	jc .failure
   941                              <1> 
   942 00002153 8B5D1C              <1> 	mov word bx, [di+28]
   943                              <1> 
   944 00002156 891E[6321]          <1> 	mov word [.tmp], bx
   945                              <1> 
   946 0000215A 61                  <1> 	popa
   947                              <1> 
   948 0000215B 8B1E[6321]          <1> 	mov word bx, [.tmp]
   949                              <1> 
   950 0000215F C3                  <1> 	ret
   951                              <1> 
   952                              <1> .failure:
   953 00002160 61                  <1> 	popa
   954 00002161 F9                  <1> 	stc
   955 00002162 C3                  <1> 	ret
   956                              <1> 
   957                              <1> 
   958 00002163 0000                <1> 	.tmp	dw 0
   959                              <1> 
   960                              <1> 
   961                              <1> ; ==================================================================
   962                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
   963                              <1> 
   964                              <1> ; ------------------------------------------------------------------
   965                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
   966                              <1> ; IN: AX = filename string
   967                              <1> ; OUT: AX = location of converted string (carry set if invalid)
   968                              <1> 
   969                              <1> int_filename_convert:
   970 00002165 60                  <1> 	pusha
   971                              <1> 
   972 00002166 89C6                <1> 	mov si, ax
   973                              <1> 
   974 00002168 E86EEA              <1> 	call string_length
   975 0000216B 83F80E              <1> 	cmp ax, 14			; Filename too long?
   976 0000216E 7F49                <1> 	jg .failure			; Fail if so
   977                              <1> 
   978 00002170 83F800              <1> 	cmp ax, 0
   979 00002173 7444                <1> 	je .failure			; Similarly, fail if zero-char string
   980                              <1> 
   981 00002175 89C2                <1> 	mov dx, ax			; Store string length for now
   982                              <1> 
   983 00002177 BF[BC21]            <1> 	mov di, .dest_string
   984                              <1> 
   985 0000217A B90000              <1> 	mov cx, 0
   986                              <1> .copy_loop:
   987 0000217D AC                  <1> 	lodsb
   988 0000217E 3C2E                <1> 	cmp al, '.'
   989 00002180 7408                <1> 	je .extension_found
   990 00002182 AA                  <1> 	stosb
   991 00002183 41                  <1> 	inc cx
   992 00002184 39D1                <1> 	cmp cx, dx
   993 00002186 7F31                <1> 	jg .failure			; No extension found = wrong
   994 00002188 EBF3                <1> 	jmp .copy_loop
   995                              <1> 
   996                              <1> .extension_found:
   997 0000218A 83F900              <1> 	cmp cx, 0
   998 0000218D 742A                <1> 	je .failure			; Fail if extension dot is first char
   999                              <1> 
  1000 0000218F 83F908              <1> 	cmp cx, 8
  1001 00002192 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  1002                              <1> 
  1003                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  1004                              <1> 	; with spaces, if necessary
  1005                              <1> 
  1006                              <1> .add_spaces:
  1007 00002194 C60520              <1> 	mov byte [di], ' '
  1008 00002197 47                  <1> 	inc di
  1009 00002198 41                  <1> 	inc cx
  1010 00002199 83F908              <1> 	cmp cx, 8
  1011 0000219C 7CF6                <1> 	jl .add_spaces
  1012                              <1> 
  1013                              <1> 	; Finally, copy over the extension
  1014                              <1> .do_extension:
  1015 0000219E AC                  <1> 	lodsb				; 3 characters
  1016 0000219F 3C00                <1> 	cmp al, 0
  1017 000021A1 7416                <1> 	je .failure
  1018 000021A3 AA                  <1> 	stosb
  1019 000021A4 AC                  <1> 	lodsb
  1020 000021A5 3C00                <1> 	cmp al, 0
  1021 000021A7 7410                <1> 	je .failure
  1022 000021A9 AA                  <1> 	stosb
  1023 000021AA AC                  <1> 	lodsb
  1024 000021AB 3C00                <1> 	cmp al, 0
  1025 000021AD 740A                <1> 	je .failure
  1026 000021AF AA                  <1> 	stosb
  1027                              <1> 
  1028 000021B0 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  1029                              <1> 
  1030 000021B3 61                  <1> 	popa
  1031 000021B4 B8[BC21]            <1> 	mov ax, .dest_string
  1032 000021B7 F8                  <1> 	clc				; Clear carry for success
  1033 000021B8 C3                  <1> 	ret
  1034                              <1> 
  1035                              <1> 
  1036                              <1> .failure:
  1037 000021B9 61                  <1> 	popa
  1038 000021BA F9                  <1> 	stc				; Set carry for failure
  1039 000021BB C3                  <1> 	ret
  1040                              <1> 
  1041                              <1> 
  1042 000021BC 00<rept>            <1> 	.dest_string	times 13 db 0
  1043                              <1> 
  1044                              <1> 
  1045                              <1> ; --------------------------------------------------------------------------
  1046                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  1047                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  1048                              <1> ; or carry set if file not found
  1049                              <1> 
  1050                              <1> disk_get_root_entry:
  1051 000021C9 60                  <1> 	pusha
  1052                              <1> 
  1053 000021CA A3[FD21]            <1> 	mov word [.filename], ax
  1054                              <1> 
  1055 000021CD B9E000              <1> 	mov cx, 224			; Search all (224) entries
  1056 000021D0 B80000              <1> 	mov ax, 0			; Searching at offset 0
  1057                              <1> 
  1058                              <1> .to_next_root_entry:
  1059 000021D3 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  1060                              <1> 
  1061 000021D5 8B36[FD21]          <1> 	mov word si, [.filename]	; Start searching for filename
  1062 000021D9 B90B00              <1> 	mov cx, 11
  1063 000021DC F3A6                <1> 	rep cmpsb
  1064 000021DE 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  1065                              <1> 
  1066 000021E0 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  1067                              <1> 
  1068 000021E3 BF0060              <1> 	mov di, disk_buffer		; Point to next root dir entry
  1069 000021E6 01C7                <1> 	add di, ax
  1070                              <1> 
  1071 000021E8 87D1                <1> 	xchg dx, cx			; Get the original CX back
  1072 000021EA E2E7                <1> 	loop .to_next_root_entry
  1073                              <1> 
  1074 000021EC 61                  <1> 	popa
  1075                              <1> 
  1076 000021ED F9                  <1> 	stc				; Set carry if entry not found
  1077 000021EE C3                  <1> 	ret
  1078                              <1> 
  1079                              <1> 
  1080                              <1> .found_file:
  1081 000021EF 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  1082                              <1> 
  1083 000021F2 893E[FF21]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  1084                              <1> 
  1085 000021F6 61                  <1> 	popa
  1086                              <1> 
  1087 000021F7 8B3E[FF21]          <1> 	mov word di, [.tmp]
  1088                              <1> 
  1089 000021FB F8                  <1> 	clc
  1090 000021FC C3                  <1> 	ret
  1091                              <1> 
  1092                              <1> 
  1093 000021FD 0000                <1> 	.filename	dw 0
  1094 000021FF 0000                <1> 	.tmp		dw 0
  1095                              <1> 
  1096                              <1> 
  1097                              <1> ; --------------------------------------------------------------------------
  1098                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  1099                              <1> ; IN: Nothing; OUT: carry set if failure
  1100                              <1> 
  1101                              <1> disk_read_fat:
  1102 00002201 60                  <1> 	pusha
  1103                              <1> 
  1104 00002202 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1105 00002205 E89D00              <1> 	call disk_convert_l2hts
  1106                              <1> 
  1107 00002208 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1108 0000220B BB0020              <1> 	mov bx, 2000h
  1109 0000220E 8EC3                <1> 	mov es, bx
  1110 00002210 89F3                <1> 	mov bx, si
  1111                              <1> 
  1112 00002212 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1113 00002214 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  1114                              <1> 
  1115 00002216 60                  <1> 	pusha				; Prepare to enter loop
  1116                              <1> 
  1117                              <1> 
  1118                              <1> .read_fat_loop:
  1119 00002217 61                  <1> 	popa
  1120 00002218 60                  <1> 	pusha
  1121                              <1> 
  1122 00002219 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1123 0000221A CD13                <1> 	int 13h				; Read sectors
  1124                              <1> 
  1125 0000221C 7308                <1> 	jnc .fat_done
  1126 0000221E E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  1127 00002221 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  1128                              <1> 
  1129 00002223 61                  <1> 	popa
  1130 00002224 EB04                <1> 	jmp .read_failure		; Fatal double error
  1131                              <1> 
  1132                              <1> .fat_done:
  1133 00002226 61                  <1> 	popa				; Restore registers from main loop
  1134                              <1> 
  1135 00002227 61                  <1> 	popa				; And restore registers from start of system call
  1136 00002228 F8                  <1> 	clc
  1137 00002229 C3                  <1> 	ret
  1138                              <1> 
  1139                              <1> .read_failure:
  1140 0000222A 61                  <1> 	popa
  1141 0000222B F9                  <1> 	stc				; Set carry flag (for failure)
  1142 0000222C C3                  <1> 	ret
  1143                              <1> 
  1144                              <1> 
  1145                              <1> ; --------------------------------------------------------------------------
  1146                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  1147                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  1148                              <1> 
  1149                              <1> disk_write_fat:
  1150 0000222D 60                  <1> 	pusha
  1151                              <1> 
  1152 0000222E B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1153 00002231 E87100              <1> 	call disk_convert_l2hts
  1154                              <1> 
  1155 00002234 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1156 00002237 8CDB                <1> 	mov bx, ds
  1157 00002239 8EC3                <1> 	mov es, bx
  1158 0000223B 89F3                <1> 	mov bx, si
  1159                              <1> 
  1160 0000223D B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1161 0000223F B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  1162                              <1> 
  1163 00002241 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1164 00002242 CD13                <1> 	int 13h				; Write sectors
  1165                              <1> 
  1166 00002244 7203                <1> 	jc .write_failure		; Fatal double error
  1167                              <1> 
  1168 00002246 61                  <1> 	popa				; And restore from start of system call
  1169 00002247 F8                  <1> 	clc
  1170 00002248 C3                  <1> 	ret
  1171                              <1> 
  1172                              <1> .write_failure:
  1173 00002249 61                  <1> 	popa
  1174 0000224A F9                  <1> 	stc				; Set carry flag (for failure)
  1175 0000224B C3                  <1> 	ret
  1176                              <1> 
  1177                              <1> 
  1178                              <1> ; --------------------------------------------------------------------------
  1179                              <1> ; disk_read_root_dir -- Get the root directory contents
  1180                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  1181                              <1> 
  1182                              <1> disk_read_root_dir:
  1183 0000224C 60                  <1> 	pusha
  1184                              <1> 
  1185 0000224D B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1186 00002250 E85200              <1> 	call disk_convert_l2hts
  1187                              <1> 
  1188 00002253 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1189 00002256 8CDB                <1> 	mov bx, ds
  1190 00002258 8EC3                <1> 	mov es, bx
  1191 0000225A 89F3                <1> 	mov bx, si
  1192                              <1> 
  1193 0000225C B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1194 0000225E B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  1195                              <1> 
  1196 00002260 60                  <1> 	pusha				; Prepare to enter loop
  1197                              <1> 
  1198                              <1> 
  1199                              <1> .read_root_dir_loop:
  1200 00002261 61                  <1> 	popa
  1201 00002262 60                  <1> 	pusha
  1202                              <1> 
  1203 00002263 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1204 00002264 CD13                <1> 	int 13h				; Read sectors
  1205                              <1> 
  1206 00002266 7308                <1> 	jnc .root_dir_finished
  1207 00002268 E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  1208 0000226B 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  1209                              <1> 
  1210 0000226D 61                  <1> 	popa
  1211 0000226E EB04                <1> 	jmp .read_failure		; Fatal double error
  1212                              <1> 
  1213                              <1> 
  1214                              <1> .root_dir_finished:
  1215 00002270 61                  <1> 	popa				; Restore registers from main loop
  1216                              <1> 
  1217 00002271 61                  <1> 	popa				; And restore from start of this system call
  1218 00002272 F8                  <1> 	clc				; Clear carry (for success)
  1219 00002273 C3                  <1> 	ret
  1220                              <1> 
  1221                              <1> .read_failure:
  1222 00002274 61                  <1> 	popa
  1223 00002275 F9                  <1> 	stc				; Set carry flag (for failure)
  1224 00002276 C3                  <1> 	ret
  1225                              <1> 
  1226                              <1> 
  1227                              <1> ; --------------------------------------------------------------------------
  1228                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  1229                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  1230                              <1> 
  1231                              <1> disk_write_root_dir:
  1232 00002277 60                  <1> 	pusha
  1233                              <1> 
  1234 00002278 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1235 0000227B E82700              <1> 	call disk_convert_l2hts
  1236                              <1> 
  1237 0000227E BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1238 00002281 8CDB                <1> 	mov bx, ds
  1239 00002283 8EC3                <1> 	mov es, bx
  1240 00002285 89F3                <1> 	mov bx, si
  1241                              <1> 
  1242 00002287 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1243 00002289 B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  1244                              <1> 
  1245 0000228B F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1246 0000228C CD13                <1> 	int 13h				; Write sectors
  1247 0000228E 7203                <1> 	jc .write_failure
  1248                              <1> 
  1249 00002290 61                  <1> 	popa				; And restore from start of this system call
  1250 00002291 F8                  <1> 	clc
  1251 00002292 C3                  <1> 	ret
  1252                              <1> 
  1253                              <1> .write_failure:
  1254 00002293 61                  <1> 	popa
  1255 00002294 F9                  <1> 	stc				; Set carry flag (for failure)
  1256 00002295 C3                  <1> 	ret
  1257                              <1> 
  1258                              <1> 
  1259                              <1> ; --------------------------------------------------------------------------
  1260                              <1> ; Reset floppy disk
  1261                              <1> 
  1262                              <1> disk_reset_floppy:
  1263 00002296 50                  <1> 	push ax
  1264 00002297 52                  <1> 	push dx
  1265 00002298 B80000              <1> 	mov ax, 0
  1266                              <1> ; ******************************************************************
  1267 0000229B 8A16[D422]          <1> 	mov dl, [bootdev]
  1268                              <1> ; ******************************************************************
  1269 0000229F F9                  <1> 	stc
  1270 000022A0 CD13                <1> 	int 13h
  1271 000022A2 5A                  <1> 	pop dx
  1272 000022A3 58                  <1> 	pop ax
  1273 000022A4 C3                  <1> 	ret
  1274                              <1> 
  1275                              <1> 
  1276                              <1> ; --------------------------------------------------------------------------
  1277                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  1278                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  1279                              <1> 
  1280                              <1> disk_convert_l2hts:
  1281 000022A5 53                  <1> 	push bx
  1282 000022A6 50                  <1> 	push ax
  1283                              <1> 
  1284 000022A7 89C3                <1> 	mov bx, ax			; Save logical sector
  1285                              <1> 
  1286 000022A9 BA0000              <1> 	mov dx, 0			; First the sector
  1287 000022AC F736[D222]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1288 000022B0 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  1289 000022B3 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  1290 000022B5 89D8                <1> 	mov ax, bx
  1291                              <1> 
  1292 000022B7 BA0000              <1> 	mov dx, 0			; Now calculate the head
  1293 000022BA F736[D222]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1294 000022BE BA0000              <1> 	mov dx, 0
  1295 000022C1 F736[D022]          <1> 	div word [Sides]		; Floppy sides
  1296 000022C5 88D6                <1> 	mov dh, dl			; Head/side
  1297 000022C7 88C5                <1> 	mov ch, al			; Track
  1298                              <1> 
  1299 000022C9 58                  <1> 	pop ax
  1300 000022CA 5B                  <1> 	pop bx
  1301                              <1> 
  1302                              <1> ; ******************************************************************
  1303 000022CB 8A16[D422]          <1> 	mov dl, [bootdev]		; Set correct device
  1304                              <1> ; ******************************************************************
  1305                              <1> 
  1306 000022CF C3                  <1> 	ret
  1307                              <1> 
  1308                              <1> 
  1309 000022D0 0200                <1> 	Sides dw 2
  1310 000022D2 1200                <1> 	SecsPerTrack dw 18
  1311                              <1> ; ******************************************************************
  1312 000022D4 00                  <1> 	bootdev db 0			; Boot device number
  1313                              <1> ; ******************************************************************
  1314                              <1> ; ==================================================================
   207                                      %include "./includes/checkin.asm"
     1                              <1> check_com:      ; AX = command
     2 000022D5 BE[A800]            <1>     mov si, in_buffer
     3 000022D8 89C7                <1>     mov di, ax
     4                              <1> 
     5                              <1> .check_loop:
     6 000022DA AC                  <1>     lodsb
     7 000022DB 3A05                <1>     cmp al, [di]
     8 000022DD 7509                <1>     jne .not_equal
     9                              <1>     
    10 000022DF B000                <1>     mov al, 0
    11 000022E1 3805                <1>     cmp [di], al
    12 000022E3 7405                <1>     je .done
    13                              <1> 
    14 000022E5 47                  <1>     inc di
    15 000022E6 EBF2                <1>     jmp .check_loop
    16                              <1> 
    17                              <1> .not_equal:
    18 000022E8 F9                  <1>     stc
    19 000022E9 C3                  <1>     ret
    20                              <1> 
    21                              <1> .done:
    22 000022EA F8                  <1>     clc
    23 000022EB C3                  <1>     ret
   208                                  
   209                                  ; ==================================================================
   210                                  ; END OF KERNEL
   211                                  ; ==================================================================
