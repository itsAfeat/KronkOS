     1                                  ; ==================================================================
     2                                  ; The Kronk Operating System kernel
     3                                  ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                                  ;
     5                                  ; This is loaded from the drive by BOOTLOAD.BIN, as KERNEL.BIN
     6                                  ; ==================================================================
     7                                  
     8                                      ORG 0x0000
     9                                      BITS 16
    10                                      
    11                                      %define KRONKOS_VER '0.3.2'
    12                                      %define KRONKOS_API 4
    13                                      
    14                                      ; RAM locations
    15                                      disk_buffer     equ 24576
    16                                      prg_load_loc    equ 32768
    17                                      set_load_loc    equ 36864
    18                                  
    19                                      ; Screen mouse clamps
    20                                      screenmaxW      equ 0x004E
    21                                      screenminW      equ 0x0001
    22                                      screenmaxH      equ 0x0017
    23                                      screenminH      equ 0x0001
    24                                      
    25                                      ; Mouse buttons
    26                                      leftMButton     equ 0x09
    27                                      rightMButton    equ 0x0A
    28                                  
    29                                      ; Screen modes
    30                                      vidRes          equ 0x13
    31                                      cliRes          equ 0x03
    32                                  
    33                                  ; ******************************************************************
    34                                  ; Start the kernel
    35                                  kernel_start:
    36 00000000 E8341B                      call seed_random
    37                                  
    38 00000003 FA                          cli                         ; Clear interrupts
    39 00000004 B80020                      mov ax, 0x2000              ; The bootloader loads us at 0x2000
    40 00000007 8ED8                        mov ds, ax                  ; Set DS and ES to 0x2000
    41 00000009 8EC0                        mov es, ax
    42                                  
    43                                      ; Stack just below 0x2000:0x0000 starting at 0x1000:0x0000.
    44                                      ; First push will set SS:SP to 0x1000:0xfffe because SP will wrap.
    45 0000000B B80010                      mov ax, 0x1000
    46 0000000E 8ED0                        mov ss, ax
    47 00000010 31E4                        xor sp, sp
    48                                  
    49 00000012 FC                          cld                         ; Clear Direction Flag (DF=0 is for forward string movement)
    50                                  ; ******************************************************************
    51                                  
    52                                  
    53                                  ; ==================================================================
    54                                  ; START OF KERNEL
    55                                  ; ==================================================================
    56                                  
    57                                  RESET:
    58 00000013 31C0                    	xor ax, ax
    59 00000015 31DB                    	xor bx, bx
    60 00000017 31C9                    	xor cx, cx
    61 00000019 31D2                    	xor dx, dx
    62 0000001B 31F6                    	xor si, si
    63 0000001D 31FF                    	xor di, di
    64                                  
    65                                      ; Change the cursor to a solid block
    66 0000001F B500                        mov ch, 0x00
    67 00000021 E81112                      call change_cursor
    68                                  
    69                                      ; Check if SETTINGS.KSF exists
    70 00000024 B8[2303]                    mov ax, settings_filename
    71 00000027 E82522                      call os_file_exists
    72 0000002A 7311                        jnc .skip_setup     ; If it does... skip the setup
    73                                  
    74 0000002C E82F0B                      call setup_init
    75                                  
    76                                      ; Save the settings
    77 0000002F B8[2303]                    mov ax, settings_filename
    78 00000032 BB0090                      mov bx, set_load_loc
    79 00000035 B9[8401]                    mov cx, usrNam
    80 00000038 E8661F                      call os_write_file
    81                                  
    82 0000003B EBD6                        jmp RESET
    83                                  
    84                                  .skip_setup:
    85                                      ; Load the settings file
    86 0000003D B8[2303]                    mov ax, settings_filename
    87 00000040 B90090                      mov cx, set_load_loc
    88 00000043 31DB                        xor bx, bx
    89 00000045 E81A1E                      call os_load_file
    90                                  
    91 00000048 89DE                        mov si, bx
    92 0000004A BF[8401]                    mov di, usrNam
    93 0000004D E8340E                      call string_copy
    94                                  
    95 00000050 8A26[9901]                  mov ah, [vidMode]
    96 00000054 80FC00                      cmp ah, 0
    97 00000057 7405                        je .startCli
    98 00000059 80FC01                      cmp ah, 1
    99 0000005C 7404                        je .startVideo
   100                                  
   101                                  .startCli:
   102 0000005E E8E704                      call kronk_cli
   103 00000061 F4                          hlt
   104                                  
   105                                  .startVideo:
   106 00000062 E89C0A                      call kronk_vid
   107 00000065 F4                          hlt
   108                                  
   109                                  
   110                                  ; ==================================================================
   111                                  ; JUMP VECTORS
   112                                  ; ==================================================================
   113                                  
   114                                  JUMP_VECTORS:
   115 00000066 EB98                        jmp kernel_start        ; 0x0066
   116 00000068 E9361B                      jmp print               ; 0x0068
   117 0000006B E9770D                      jmp cls                 ; 0x006B
   118 0000006E E9DE21                      jmp os_file_exists      ; 0x006E
   119 00000071 E9EE1D                      jmp os_load_file        ; 0x0071
   120 00000074 E9F721                      jmp os_create_file      ; 0x0074
   121 00000077 E98322                      jmp os_remove_file      ; 0x0077
   122 0000007A E9241F                      jmp os_write_file       ; 0x007A
   123 0000007D E9E70D                      jmp string_lowercase    ; 0x007D
   124 00000080 E9C70D                      jmp string_uppercase    ; 0x0080
   125 00000083 E9070E                      jmp string_truncate     ; 0x0083
   126 00000086 E9720D                      jmp string_length       ; 0x0086
   127 00000089 E9BD11                      jmp move_cursor         ; 0x0089
   128 0000008C E9C311                      jmp get_cursor_pos      ; 0x008C
   129 0000008F E9D311                      jmp print_horiz_line    ; 0x008F
   130 00000092 E9ED11                      jmp input_dialog        ; 0x0092
   131 00000095 E95818                      jmp list_dialog         ; 0x0095
   132 00000098 E94012                      jmp dialog_box          ; 0x0098
   133 0000009B E99711                      jmp change_cursor       ; 0x009B
   134 0000009E E97911                      jmp string_clear        ; 0x009E
   135 000000A1 E91A1D                      jmp os_get_file_list    ; 0x00A1
   136 000000A4 E9C319                      jmp clear_regs          ; 0x00A4
   137 000000A7 E9BA0E                      jmp int_to_string       ; 0x00A7
   138 000000AA E96D24                      jmp chk_string_ext      ; 0x00AA
   139 000000AD E9EC0D                      jmp string_join         ; 0x00AD
   140 000000B0 E9E20D                      jmp string_add          ; 0x00B0
   141 000000B3 E9CE0D                      jmp string_copy         ; 0x00B3
   142 000000B6 E9211B                      jmp print_atr           ; 0x00B6
   143 000000B9 E99D13                      jmp input_string        ; 0x00B9
   144                                  
   145                                  
   146                                  ; ==================================================================
   147                                  ; KERNEL SUBROUTINES
   148                                  ; ==================================================================
   149                                  
   150                                      error_ext:
   151 000000BC 5E                              pop si
   152                                  
   153 000000BD B8[3603]                        mov ax, err1_ext
   154 000000C0 BB[4803]                        mov bx, err2_ext
   155 000000C3 31C9                            xor cx, cx
   156 000000C5 31D2                            xor dx, dx
   157 000000C7 E81112                          call dialog_box
   158                                  
   159 000000CA B70F                            mov bh, cli_color
   160 000000CC E8160D                          call cls
   161                                  
   162 000000CF C3                              ret
   163                                  
   164                                      try_run_file:
   165 000000D0 E8770D                          call string_uppercase
   166 000000D3 89C6                            mov si, ax
   167 000000D5 BF[1803]                        mov di, kern_filename
   168 000000D8 E82A0E                          call string_compare
   169 000000DB 7230                            jc load_kern_err
   170                                  
   171 000000DD E86F21                          call os_file_exists
   172 000000E0 7229                            jc .not_found
   173 000000E2 F8                              clc
   174                                  
   175 000000E3 89C6                            mov si, ax
   176 000000E5 56                              push si 
   177                                  
   178 000000E6 89F3                            mov bx, si
   179 000000E8 89F0                            mov ax, si
   180 000000EA E80E0D                          call string_length
   181                                  
   182 000000ED 89DE                            mov si, bx
   183 000000EF 01C6                            add si, ax
   184                                  
   185 000000F1 83EE03                          sub si, 3
   186                                  
   187 000000F4 BF[3003]                        mov di, bin_ext
   188 000000F7 B90300                          mov cx, 3
   189 000000FA F3A6                            rep cmpsb
   190 000000FC 7523                            jne execute_bas_program
   191 000000FE 5E                              pop si
   192                                  
   193 000000FF 89F0                            mov ax, si
   194 00000101 B90080                          mov cx, prg_load_loc
   195 00000104 E85B1D                          call os_load_file
   196                                  
   197 00000107 E85000                          call execute_bin_program
   198 0000010A C3                              ret
   199                                  
   200                                          .not_found:
   201 0000010B F9                                  stc
   202 0000010C C3                                  ret
   203                                  
   204                                          load_kern_err:
   205 0000010D 5E                                  pop si
   206                                  
   207 0000010E B8[6603]                            mov ax, err3_ext
   208 00000111 BB[7903]                            mov bx, err4_ext
   209 00000114 31C9                                xor cx, cx
   210 00000116 31D2                                xor dx, dx
   211 00000118 E8C011                              call dialog_box
   212                                  
   213 0000011B B70F                                mov bh, cli_color
   214 0000011D E8C50C                              call cls
   215                                  
   216 00000120 C3                                  ret
   217                                  
   218                                      execute_bas_program:
   219 00000121 5E                              pop si
   220 00000122 56                              push si
   221                                          
   222 00000123 89F3                            mov bx, si
   223 00000125 89F0                            mov ax, si
   224 00000127 E8D10C                          call string_length
   225                                  
   226 0000012A 89DE                            mov si, bx
   227 0000012C 01C6                            add si, ax
   228                                  
   229 0000012E 83EE03                          sub si, 3
   230                                  
   231 00000131 BF[3303]                        mov di, bas_ext
   232 00000134 B90300                          mov cx, 3
   233 00000137 F3A6                            rep cmpsb
   234 00000139 7581                            jne error_ext
   235                                  
   236 0000013B 5E                              pop si
   237                                          
   238 0000013C 89F0                            mov ax, si
   239 0000013E B90080                          mov cx, prg_load_loc
   240 00000141 E81E1D                          call os_load_file
   241                                  
   242 00000144 B70F                            mov bh, 0x0F
   243 00000146 E89C0C                          call cls
   244                                  
   245 00000149 B80080                          mov ax, prg_load_loc
   246 0000014C 31F6                            xor si, si
   247                                          ;call os_run_basic
   248                                  
   249 0000014E BE[C603]                        mov si, new_line
   250 00000151 E84D1A                          call print
   251                                  
   252 00000154 B70F                            mov bh, cli_color
   253 00000156 E88C0C                          call cls
   254                                  
   255 00000159 C3                              ret
   256                                  
   257                                      execute_bin_program:
   258 0000015A BE[C603]                        mov si, new_line
   259 0000015D E8411A                          call print
   260                                  
   261 00000160 31C0                    		xor ax, ax
   262 00000162 31DB                    		xor bx, bx
   263 00000164 31C9                    		xor cx, cx
   264 00000166 31D2                    		xor dx, dx
   265 00000168 31F6                    		xor si, si
   266 0000016A 31FF                    		xor di, di
   267                                  
   268 0000016C E8(0080)                        call prg_load_loc
   269                                          
   270 0000016F B80000                          mov ax, 0
   271 00000172 B70F                            mov bh, 0x0F
   272 00000174 E84313                          call switch_mode
   273                                  
   274 00000177 C3                              ret
   275                                  
   276                                  
   277                                  ; ------------------------------------------------------------------
   278                                  ; STRINGS AND OTHER VARIABLES
   279                                  
   280                                      ; DEBUG VARIABLES START
   281 00000178 4D653F20476F6E6761-         tmp:                db "Me? Gongaga", 0
   281 00000181 676100             
   282                                      ; END
   283                                  
   284                                      ; USER RELATED VARIABLES START
   285 00000184 00<rept>                    usrNam:             times 21 db 0
   286                                  
   287 00000199 0000                        vidMode:            dw 0x00
   288                                      cli_color:          equ 0x0f
   289                                      vid_backcolor:      equ 0x01
   290                                      vid_forecolor:      equ 0x0f
   291                                      ; END
   292                                  
   293                                      ; TMP VARIABLES START
   294 0000019B 4D4F555345204C4546-         mouse_left:         db "MOUSE LEFT", 0
   294 000001A4 5400               
   295 000001A6 4D4F55534520524947-         mouse_right:        db "MOUSE RIGHT", 0
   295 000001AF 485400             
   296                                      ; END
   297                                  
   298                                      ; CLI SPECIFIC VARIABLES START
   299 000001B2 3A3E2000                	in_msg:				db ":> ", 0
   300 000001B6 00<rept>                	in_buffer: 			times 41 db 0
   301 000001DF 206973206E6F74206B-         not_com:            db " is not known command", 0x0a, 0x0d, 0
   301 000001E8 6E6F776E20636F6D6D-
   301 000001F1 616E640A0D00       
   302                                      ; END
   303                                  
   304                                      ; CLI COMMANDS START
   305 000001F7 7265737461727400            restart_com:        db "restart", 0
   306 000001FF 73687574646F776E00          shutdown_com:       db "shutdown", 0
   307 00000208 73657474696E677300          settings_com:       db "settings", 0
   308 00000211 636C65617200                clear_com:          db "clear", 0
   309 00000217 64697200                    dir_com:            db "dir", 0
   310 0000021B 68656C7000                  help_com:           db "help", 0
   311 00000220 6564697400                  edit_com:           db "edit", 0
   312 00000225 6C6F616400                  load_com:           db "load", 0
   313 0000022A 6D6B00                      mk_com:             db "mk", 0
   314 0000022D 726D00                      rm_com:             db "rm", 0
   315                                      ; END
   316                                  
   317                                      ; MOUSE VARIABLES START
   318 00000230 4D4F55534520495320-         mouse_yes:          db "MOUSE IS CONNECTED!", 0
   318 00000239 434F4E4E4543544544-
   318 00000242 2100               
   319 00000244 4D4F55534520495320-         mouse_no:           db "MOUSE IS NOT CONNECTED!", 0
   319 0000024D 4E4F5420434F4E4E45-
   319 00000256 435445442100       
   320                                      ; END
   321                                  
   322                                      ; WELCOME SCREEN VARIABLES START
   323 0000025C 0A0D204B726F6E6B4F-     	welcome_msg1:		db 0x0a, 0x0d, " KronkOS ver. ", KRONKOS_VER
   323 00000265 53207665722E20302E-
   323 0000026E 332E32             
   324 00000271 20<rept>                						times 44-18 db " "
   325 0000028B 0A0D2000                						db 0x0a, 0x0d, " ", 0
   326 0000028F 204279746573206F66-     	welcome_msg2:		db " Bytes of total memory available.      ", 0x0a, 0x0d, 0
   326 00000298 20746F74616C206D65-
   326 000002A1 6D6F72792061766169-
   326 000002AA 6C61626C652E202020-
   326 000002B3 2020200A0D00       
   327 000002B9 20<rept>                	welcome_msg3:		times 45 db " "
   328 000002E6 0A0D20547970652027-     						db 0x0a, 0x0d, " Type 'help' and press enter to start off.   ", 0x0a, 0x0d, 0
   328 000002EF 68656C702720616E64-
   328 000002F8 20707265737320656E-
   328 00000301 74657220746F207374-
   328 0000030A 617274206F66662E20-
   328 00000313 20200A0D00         
   329                                  	; END
   330                                  
   331                                      ; FILE RELATED VARIABLES START
   332 00000318 4B45524E454C2E4249-     	kern_filename:		db 'KERNEL.BIN', 0
   332 00000321 4E00               
   333 00000323 53455454494E47532E-         settings_filename:  db 'SETTINGS.KSF', 0
   333 0000032C 4B534600           
   334                                  
   335 00000330 424B46                  	bin_ext:			db 'BKF'
   336 00000333 424153                  	bas_ext:			db 'BAS'
   337 00000336 556E6B6E6F776E2065-     	err1_ext:			db "Unknown extension", 0
   337 0000033F 7874656E73696F6E00 
   338 00000348 4F6E6C79202E424B46-     	err2_ext:			db "Only .BKF and .BAS is allowed", 0
   338 00000351 20616E64202E424153-
   338 0000035A 20697320616C6C6F77-
   338 00000363 656400             
   339 00000366 4572726F72206C6F61-     	err3_ext:			db "Error loading file", 0
   339 0000036F 64696E672066696C65-
   339 00000378 00                 
   340 00000379 596F752063616E2774-     	err4_ext:			db "You can't load KERNEL.BIN", 0
   340 00000382 206C6F6164204B4552-
   340 0000038B 4E454C2E42494E00   
   341 00000393 596F752063616E2774-         err5_ext:           db "You can't load SETTINGS.KSF", 0
   341 0000039C 206C6F616420534554-
   341 000003A5 54494E47532E4B5346-
   341 000003AE 00                 
   342 000003AF 0A0D46696C65206E6F-         notfound_msg:	    db 0x0a, 0x0d, "File not found", 0x0a, 0x0a, 0x0d, 0
   342 000003B8 7420666F756E640A0A-
   342 000003C1 0D00               
   343                                      ; END
   344                                  
   345                                      ; OTHER VARIABLES START
   346 000003C3 00                      	fmt_12_24:			db 0 		; (Non-zero = 24 hour format)
   347 000003C4 012F                    	fmt_date:			db 1, '/'	; 0, 1, 2 = M/D/Y, D/M/Y or Y/M/D
   348                                  									; Bit 7 = use name for months
   349                                  									; If bit 7 = 0, second byte = separator character
   350                                  
   351 000003C6 0A0D00                  	new_line:			db 0x0a, 0x0d, 0
   352 000003C9 202D2D2000              	file_size_sep:		db " -- ", 0
   353 000003CE 2042797465730A0D00      	file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   354                                      ; END
   355                                  
   356                                      ; MENUBAR VARIABLES START
   357                                      mb_color:           equ 0x30
   358 000003D7 20<rept>                    mb_fill:            times 79 db " "
   359 00000426 00                                              db 0
   360                                      ; END
   361                                  
   362                                  ; ------------------------------------------------------------------
   363                                  ; INCLUDED FILES
   364                                  
   365                                      %include "./includes/settings_menu.asm"
     1                              <1> show_settings:
     2 00000427 60                  <1>     pusha
     3                              <1> 
     4                              <1> .main_menu:
     5 00000428 B8[9604]            <1>     mov ax, .main_options
     6 0000042B BB[B104]            <1>     mov bx, .main_header
     7 0000042E B9[BA04]            <1>     mov cx, .main_string
     8 00000431 E8BC14              <1>     call list_dialog
     9                              <1> 
    10 00000434 83F801              <1>     cmp ax, 1
    11 00000437 7402                <1>     je .display_menu
    12                              <1> 
    13 00000439 EB54                <1>     jmp .end
    14                              <1> 
    15                              <1> .display_menu:
    16 0000043B B8[D904]            <1>     mov ax, .display_options
    17 0000043E BB[F204]            <1>     mov bx, .display_header
    18 00000441 B9[0105]            <1>     mov cx, .display_string
    19 00000444 E8A914              <1>     call list_dialog
    20                              <1> 
    21 00000447 83F801              <1>     cmp ax, 1
    22 0000044A 7407                <1>     je .change_cli
    23                              <1> 
    24 0000044C 83F802              <1>     cmp ax, 2
    25 0000044F 7420                <1>     je .change_vid
    26                              <1> 
    27 00000451 EBD5                <1>     jmp .main_menu
    28                              <1> 
    29                              <1> .change_cli:
    30 00000453 B8[1705]            <1>     mov ax, .display_restart1
    31 00000456 BB[3105]            <1>     mov bx, .display_restart2
    32 00000459 31C9                <1>     xor cx, cx
    33 0000045B BA0100              <1>     mov dx, 1
    34 0000045E E87A0E              <1>     call dialog_box
    35                              <1> 
    36 00000461 85C0                <1>     test ax, ax
    37 00000463 75D6                <1>     jnz .display_menu
    38                              <1> 
    39                              <1> 
    40 00000465 C606[9901]00        <1>     mov byte [vidMode], 0
    41 0000046A 31C0                <1>     xor ax, ax
    42 0000046C CD13                <1>     int 0x13
    43 0000046E E9A2FB              <1>     jmp RESET
    44                              <1> 
    45                              <1> .change_vid:
    46 00000471 B8[1705]            <1>     mov ax, .display_restart1
    47 00000474 BB[3105]            <1>     mov bx, .display_restart2
    48 00000477 31C9                <1>     xor cx, cx
    49 00000479 BA0100              <1>     mov dx, 1
    50 0000047C E85C0E              <1>     call dialog_box
    51                              <1> 
    52 0000047F 85C0                <1>     test ax, ax
    53 00000481 75B8                <1>     jnz .display_menu
    54                              <1> 
    55 00000483 C606[9901]01        <1>     mov byte [vidMode], 1
    56 00000488 31C0                <1>     xor ax, ax
    57 0000048A CD13                <1>     int 0x13
    58 0000048C E984FB              <1>     jmp RESET
    59                              <1> 
    60                              <1> .end:
    61 0000048F B70F                <1>     mov bh, cli_color
    62 00000491 E85109              <1>     call cls
    63                              <1> 
    64 00000494 61                  <1>     popa
    65 00000495 C3                  <1>     ret
    66                              <1> 
    67                              <1> 
    68 00000496 444953504C41592C    <1> .main_options:      db "DISPLAY,"
    69 0000049E 555345522C          <1>                     db "USER,"
    70 000004A3 455849542053455454- <1>                     db "EXIT SETTINGS", 0
    70 000004AC 494E475300          <1>
    71 000004B1 53455454494E475300  <1> .main_header:       db "SETTINGS", 0
    72 000004BA 4368616E6765207468- <1> .main_string:       db "Change the settings of KronkOS", 0
    72 000004C3 652073657474696E67- <1>
    72 000004CC 73206F66204B726F6E- <1>
    72 000004D5 6B4F5300            <1>
    73                              <1> 
    74 000004D9 434C49204D4F44452C  <1> .display_options:   db "CLI MODE,"
    75 000004E2 564944454F204D4F44- <1>                     db "VIDEO MODE,"
    75 000004EB 452C                <1>
    76 000004ED 4241434B00          <1>                     db "BACK", 0
    77 000004F2 564944454F20534554- <1> .display_header:    db "VIDEO SETTINGS", 0
    77 000004FB 54494E475300        <1>
    78 00000501 4368616E6765207468- <1> .display_string:    db "Change the video mode", 0
    78 0000050A 6520766964656F206D- <1>
    78 00000513 6F646500            <1>
    79 00000517 546869732077696C6C- <1> .display_restart1:  db "This will restart KronkOS", 0
    79 00000520 207265737461727420- <1>
    79 00000529 4B726F6E6B4F5300    <1>
    80 00000531 507265737320274F4B- <1> .display_restart2:  db "Press 'OK' to continue", 0
    80 0000053A 2720746F20636F6E74- <1>
    80 00000543 696E756500          <1>
   366                                      %include "./includes/cli.asm"
     1                              <1> kronk_cli:
     2 00000548 B80000              <1>     mov ax, 0
     3 0000054B B70F                <1>     mov bh, cli_color
     4 0000054D E86A0F              <1>     call switch_mode
     5                              <1>     
     6                              <1>     ; Disable color blinking
     7 00000550 B80310              <1>     mov ax, 0x1003
     8 00000553 BB0000              <1>     mov bx, 0x0000
     9 00000556 CD10                <1>     int 0x10
    10                              <1> 
    11                              <1> 	; Let's see if there's a file called AUTORUN.BIN and execute
    12                              <1> 	; it if so, before going to the terminal
    13                              <1> 
    14 00000558 B8[270A]            <1>     mov ax, .autobin_filename
    15 0000055B E8F11C              <1>     call os_file_exists
    16 0000055E 7209                <1>     jc .no_autorun_bin
    17                              <1> 
    18 00000560 B90080              <1>     mov cx, prg_load_loc
    19 00000563 E8FC18              <1>     call os_load_file
    20 00000566 E8F1FB              <1>     call execute_bin_program
    21                              <1> 
    22                              <1> .no_autorun_bin:
    23 00000569 B8[330A]            <1>     mov ax, .autobas_filename
    24 0000056C E8E01C              <1>     call os_file_exists
    25 0000056F 7209                <1>     jc .no_autorun_bas
    26                              <1> 
    27 00000571 B90080              <1>     mov cx, prg_load_loc
    28 00000574 E8EB18              <1>     call os_load_file
    29 00000577 E8A7FB              <1>     call execute_bas_program
    30                              <1> 
    31                              <1> .no_autorun_bas:
    32                              <1>     ; Draw welcome menu
    33 0000057A BE[5C02]            <1>     mov si, welcome_msg1
    34 0000057D E82F16              <1>     call welcome_print
    35                              <1> 
    36 00000580 B488                <1>     mov ah, 0x88
    37 00000582 CD15                <1>     int 0x15
    38 00000584 E8DD09              <1>     call int_to_string
    39 00000587 89C6                <1>     mov si, ax
    40 00000589 E82316              <1>     call welcome_print
    41                              <1> 
    42 0000058C BE[8F02]            <1>     mov si, welcome_msg2
    43 0000058F E81D16              <1>     call welcome_print
    44 00000592 BE[B902]            <1>     mov si, welcome_msg3
    45 00000595 E81716              <1>     call welcome_print
    46                              <1> 
    47 00000598 B80A0E              <1>     mov ax, 0x0e0a
    48 0000059B CD10                <1>     int 0x10
    49                              <1> 
    50                              <1> ; The loop that gets the input
    51                              <1> .input_loop:
    52                              <1>     ; Change the cursor to a solid block
    53 0000059D B500                <1>     mov ch, 0x00
    54 0000059F E8930C              <1>     call change_cursor
    55                              <1> 
    56 000005A2 E8C104              <1>     call check_pos
    57 000005A5 E8E404              <1>     call draw_menu_bar
    58                              <1> 
    59                              <1>     ; Print the username and the input msg
    60                              <1>     ;mov si, usrNam
    61                              <1>     ;call print
    62 000005A8 BE[B201]            <1>     mov si, in_msg
    63 000005AB E8F315              <1>     call print
    64                              <1> 
    65                              <1>     ; Get the input and save it in in_buffer 
    66 000005AE E81815              <1>     call get_input
    67                              <1> 
    68                              <1>     ; Check the input
    69 000005B1 B8[0802]            <1>     mov ax, settings_com
    70 000005B4 E8CD1F              <1>     call check_com
    71 000005B7 0F83C400            <1>     jnc .settings
    72                              <1> 
    73 000005BB B8[1102]            <1>     mov ax, clear_com
    74 000005BE E8C31F              <1>     call check_com
    75 000005C1 0F83C000            <1>     jnc .clear
    76                              <1> 
    77 000005C5 B8[1702]            <1>     mov ax, dir_com
    78 000005C8 E8B91F              <1>     call check_com
    79 000005CB 0F83BE00            <1>     jnc .dir
    80                              <1> 
    81 000005CF B8[1B02]            <1>     mov ax, help_com
    82 000005D2 E8AF1F              <1>     call check_com
    83 000005D5 0F836301            <1>     jnc .show_help
    84                              <1>     
    85                              <1>     ; ----------------------------------
    86                              <1>     ; MK AND RM
    87                              <1> 
    88 000005D9 60                  <1>     pusha
    89                              <1> 
    90 000005DA BE[B901]            <1>     mov si, in_buffer+3
    91 000005DD BF[B809]            <1>     mov di, .tmp_filename
    92 000005E0 E8A108              <1>     call string_copy
    93                              <1> 
    94 000005E3 BE[B601]            <1>     mov si, in_buffer
    95 000005E6 BF[CC09]            <1>     mov di, .tmp_inbuffer
    96 000005E9 E89808              <1>     call string_copy
    97                              <1> 
    98 000005EC BE[B601]            <1>     mov si, in_buffer
    99 000005EF B80200              <1>     mov ax, 2
   100 000005F2 E89808              <1>     call string_truncate
   101                              <1>     
   102 000005F5 B8[2A02]            <1>     mov ax, mk_com
   103 000005F8 E8891F              <1>     call check_com
   104 000005FB 0F831003            <1>     jnc .make_file
   105                              <1> 
   106 000005FF B8[2D02]            <1>     mov ax, rm_com
   107 00000602 E87F1F              <1>     call check_com
   108 00000605 0F833E03            <1>     jnc .remove_file
   109                              <1> 
   110 00000609 BE[CC09]            <1>     mov si, .tmp_inbuffer
   111 0000060C BF[B601]            <1>     mov di, in_buffer
   112 0000060F E87208              <1>     call string_copy
   113                              <1> 
   114 00000612 61                  <1>     popa
   115                              <1> 
   116                              <1>     ; ----------------------------------
   117                              <1>     ; LOAD AND EDIT
   118                              <1> 
   119 00000613 60                  <1>     pusha
   120                              <1> 
   121 00000614 BE[BB01]            <1>     mov si, in_buffer+5
   122 00000617 BF[B809]            <1>     mov di, .tmp_filename
   123 0000061A E86708              <1>     call string_copy
   124                              <1> 
   125 0000061D BE[B601]            <1>     mov si, in_buffer
   126 00000620 BF[CC09]            <1>     mov di, .tmp_inbuffer
   127 00000623 E85E08              <1>     call string_copy
   128                              <1> 
   129 00000626 BE[B601]            <1>     mov si, in_buffer
   130 00000629 B80400              <1>     mov ax, 4
   131 0000062C E85E08              <1>     call string_truncate
   132                              <1> 
   133 0000062F B8[2502]            <1>     mov ax, load_com
   134 00000632 E84F1F              <1>     call check_com
   135 00000635 0F834303            <1>     jnc .load_file
   136                              <1> 
   137 00000639 BE[CC09]            <1>     mov si, .tmp_inbuffer
   138 0000063C BF[B601]            <1>     mov di, in_buffer
   139 0000063F E84208              <1>     call string_copy
   140                              <1> 
   141 00000642 61                  <1>     popa
   142                              <1> 
   143 00000643 B8[F701]            <1>     mov ax, restart_com
   144 00000646 E83B1F              <1>     call check_com
   145 00000649 0F834B03            <1>     jnc .restart
   146                              <1> 
   147 0000064D B8[FF01]            <1>     mov ax, shutdown_com
   148 00000650 E8311F              <1>     call check_com
   149 00000653 0F834903            <1>     jnc .shutdown
   150 00000657 7200                <1>     jc .not_equal
   151                              <1> 
   152                              <1> .not_equal:
   153 00000659 B40E                <1>     mov ah, 0x0e
   154 0000065B B00A                <1>     mov al, 0x0a
   155 0000065D CD10                <1>     int 0x10
   156                              <1> 
   157 0000065F B40E                <1>     mov ah, 0x0e
   158 00000661 B022                <1>     mov al, '"'
   159 00000663 CD10                <1>     int 0x10
   160                              <1> 
   161 00000665 BE[B601]            <1>     mov si, in_buffer
   162 00000668 E83615              <1>     call print
   163                              <1> 
   164 0000066B B40E                <1>     mov ah, 0x0e
   165 0000066D B022                <1>     mov al, '"'
   166 0000066F CD10                <1>     int 0x10
   167                              <1>     
   168 00000671 BE[DF01]            <1>     mov si, not_com
   169 00000674 E82A15              <1>     call print
   170                              <1>     
   171                              <1>     ; Create a new line
   172 00000677 B80A0E              <1>     mov ax, 0x0e0a
   173 0000067A CD10                <1>     int 0x10
   174                              <1> 
   175 0000067C E91EFF              <1>     jmp .input_loop
   176                              <1> 
   177                              <1> ; ----------------------------------
   178                              <1> ; SETTINGS
   179                              <1> 
   180                              <1> .settings:
   181 0000067F E8A5FD              <1>     call show_settings
   182 00000682 E918FF              <1>     jmp .input_loop
   183                              <1> 
   184                              <1> ; ----------------------------------
   185                              <1> ; CLEAR
   186                              <1> 
   187                              <1> .clear:
   188 00000685 B70F                <1>     mov bh, cli_color
   189 00000687 E85B07              <1>     call cls
   190 0000068A E910FF              <1>     jmp .input_loop
   191                              <1> 
   192                              <1> ; ----------------------------------
   193                              <1> ; DIR
   194                              <1> 
   195                              <1> .dir:
   196 0000068D 31C0                <1>     xor ax, ax
   197 0000068F E82C17              <1>     call os_get_file_list
   198                              <1> 
   199 00000692 50                  <1>     push ax
   200 00000693 B80A0E              <1>     mov ax, 0x0e0a
   201 00000696 CD10                <1>     int 0x10
   202 00000698 CD10                <1>     int 0x10
   203 0000069A B00D                <1>     mov al, 0x0d
   204 0000069C CD10                <1>     int 0x10
   205 0000069E 58                  <1>     pop ax
   206                              <1> 
   207 0000069F 89C6                <1>     mov si, ax
   208 000006A1 BF[B809]            <1>     mov di, .tmp_filename
   209 000006A4 BA0000              <1>     mov dx, 0
   210                              <1> 
   211 000006A7 B40E                <1>     mov ah, 0x0e
   212 000006A9 B020                <1>     mov al, ' '
   213 000006AB CD10                <1>     int 0x10
   214                              <1> 
   215                              <1>     .loop:
   216 000006AD AC                  <1>         lodsb
   217 000006AE 3C2C                <1>         cmp al, ','
   218 000006B0 740C                <1>         je .add_size
   219 000006B2 3C00                <1>         cmp al, 0
   220 000006B4 744C                <1>         je .done
   221                              <1> 
   222 000006B6 AA                  <1>         stosb
   223 000006B7 42                  <1>         inc dx
   224                              <1> 
   225 000006B8 B40E                <1>         mov ah, 0x0e
   226 000006BA CD10                <1>         int 0x10
   227                              <1> 
   228 000006BC EBEF                <1>         jmp .loop
   229                              <1> 
   230                              <1>     .add_size:
   231 000006BE 60                  <1>         pusha
   232 000006BF 83FA0C              <1>         cmp dx, 12
   233 000006C2 7D03                <1>         jge .continue
   234                              <1> 
   235 000006C4 E82F00              <1>         call .add_spaces
   236                              <1> 
   237                              <1>         .continue:
   238 000006C7 BE[F509]            <1>         mov si, .file_size_sep
   239 000006CA E8D414              <1>         call print
   240                              <1> 
   241 000006CD 89D0                <1>         mov ax, dx
   242 000006CF E8BB07              <1>         call string_truncate
   243                              <1> 
   244 000006D2 B8[B809]            <1>         mov ax, .tmp_filename
   245 000006D5 E8D91C              <1>         call os_get_file_size
   246                              <1> 
   247 000006D8 89D8                <1>         mov ax, bx
   248 000006DA E88708              <1>         call int_to_string
   249 000006DD 89C6                <1>         mov si, ax
   250 000006DF E8BF14              <1>         call print
   251                              <1> 
   252 000006E2 BE[CE03]            <1>         mov si, file_size_typ
   253 000006E5 E8B914              <1>         call print
   254                              <1> 
   255 000006E8 B8200E              <1>         mov ax, 0x0e20
   256 000006EB CD10                <1>         int 0x10
   257                              <1> 
   258 000006ED 61                  <1>         popa
   259                              <1> 
   260 000006EE BF[B809]            <1>         mov di, .tmp_filename
   261 000006F1 BA0000              <1>         mov dx, 0
   262 000006F4 EBB7                <1>         jmp .loop
   263                              <1> 
   264                              <1>     .add_spaces:
   265 000006F6 B8200E              <1>         mov ax, 0x0e20
   266 000006F9 CD10                <1>         int 0x10
   267 000006FB 42                  <1>         inc dx
   268 000006FC 83FA0C              <1>         cmp dx, 12
   269 000006FF 75F5                <1>         jne .add_spaces
   270 00000701 C3                  <1>         ret
   271                              <1> 
   272                              <1>     .done:
   273 00000702 83FA0C              <1>         cmp dx, 12
   274 00000705 7D03                <1>         jge .done_c
   275                              <1> 
   276 00000707 E8ECFF              <1>         call .add_spaces
   277                              <1> 
   278                              <1>         .done_c:
   279 0000070A BE[F509]            <1>         mov si, .file_size_sep
   280 0000070D E89114              <1>         call print
   281                              <1> 
   282 00000710 BE[B809]            <1>         mov si, .tmp_filename
   283 00000713 89D0                <1>         mov ax, dx
   284 00000715 E87507              <1>         call string_truncate
   285                              <1> 
   286 00000718 B8[B809]            <1>         mov ax, .tmp_filename
   287 0000071B E8931C              <1>         call os_get_file_size
   288                              <1> 
   289 0000071E 89D8                <1>         mov ax, bx
   290 00000720 E84108              <1>         call int_to_string
   291 00000723 89C6                <1>         mov si, ax
   292 00000725 E87914              <1>         call print
   293                              <1> 
   294 00000728 BE[FA09]            <1>         mov si, .file_size_typ
   295 0000072B E87314              <1>         call print
   296                              <1> 
   297 0000072E 50                  <1>     push ax
   298                              <1> 
   299 0000072F B80A0E              <1>     mov ax, 0x0e0a
   300 00000732 CD10                <1>     int 0x10
   301 00000734 B00D                <1>     mov al, 0x0d
   302 00000736 CD10                <1>     int 0x10
   303                              <1> 
   304 00000738 58                  <1>     pop ax
   305                              <1> 
   306 00000739 E961FE              <1>     jmp .input_loop
   307                              <1> 
   308                              <1> ; ----------------------------------
   309                              <1> ; HELP
   310                              <1> 
   311                              <1> .show_help:
   312 0000073C B8[6C07]            <1>     mov ax, .help_commands
   313 0000073F BB[DE08]            <1>     mov bx, .help_header
   314 00000742 B9[E808]            <1>     mov cx, .help_string
   315 00000745 E8A811              <1>     call list_dialog
   316                              <1> 
   317 00000748 83F804              <1>     cmp ax, 4
   318 0000074B 0F8430FF            <1>     je .settings
   319                              <1>     
   320 0000074F B70F                <1>     mov bh, cli_color
   321 00000751 E89106              <1>     call cls
   322                              <1> 
   323 00000754 83F802              <1>     cmp ax, 2
   324 00000757 0F8432FF            <1>     je .dir
   325 0000075B 83F809              <1>     cmp ax, 9
   326 0000075E 0F843602            <1>     je .restart
   327 00000762 83F80A              <1>     cmp ax, 10
   328 00000765 0F843702            <1>     je .shutdown
   329                              <1> 
   330 00000769 E931FE              <1>     jmp .input_loop
   331                              <1> 
   332 0000076C 48454C502020202020- <1>     .help_commands:     db "HELP       --  What you're looking at,"
   332 00000775 20202D2D2020576861- <1>
   332 0000077E 7420796F7527726520- <1>
   332 00000787 6C6F6F6B696E672061- <1>
   332 00000790 742C                <1>
   333 00000792 444952202020202020- <1>                         db "DIR        --  Show a list of all files,"
   333 0000079B 20202D2D202053686F- <1>
   333 000007A4 772061206C69737420- <1>
   333 000007AD 6F6620616C6C206669- <1>
   333 000007B6 6C65732C            <1>
   334 000007BA 434C45415220202020- <1>                         db "CLEAR      --  Clear the terminal,"
   334 000007C3 20202D2D2020436C65- <1>
   334 000007CC 617220746865207465- <1>
   334 000007D5 726D696E616C2C      <1>
   335 000007DC 53455454494E475320- <1>                         db "SETTINGS   --  Show the settings menu,"
   335 000007E5 20202D2D202053686F- <1>
   335 000007EE 772074686520736574- <1>
   335 000007F7 74696E6773206D656E- <1>
   335 00000800 752C                <1>
   336 00000802 4D4B2046494C452020- <1>                         db "MK FILE    --  Create a file,"
   336 0000080B 20202D2D2020437265- <1>
   336 00000814 61746520612066696C- <1>
   336 0000081D 652C                <1>
   337 0000081F 524D2046494C452020- <1>                         db "RM FILE    --  Delete a file,"
   337 00000828 20202D2D202044656C- <1>
   337 00000831 65746520612066696C- <1>
   337 0000083A 652C                <1>
   338 0000083C 4C4F41442046494C45- <1>                         db "LOAD FILE  --  Load/run a file,"
   338 00000845 20202D2D20204C6F61- <1>
   338 0000084E 642F72756E20612066- <1>
   338 00000857 696C652C            <1>
   339 0000085B 454449542046494C45- <1>                         db "EDIT FILE  --  Load and edit a file,"
   339 00000864 20202D2D20204C6F61- <1>
   339 0000086D 6420616E6420656469- <1>
   339 00000876 7420612066696C652C  <1>
   340 0000087F 524553544152542020- <1>                         db "RESTART    --  Restart KronkOS,"
   340 00000888 20202D2D2020526573- <1>
   340 00000891 74617274204B726F6E- <1>
   340 0000089A 6B4F532C            <1>
   341 0000089E 53485554444F574E20- <1>                         db "SHUTDOWN   --  Shutdown KronkOS,,"
   341 000008A7 20202D2D2020536875- <1>
   341 000008B0 74646F776E204B726F- <1>
   341 000008B9 6E6B4F532C2C        <1>
   342 000008BF 43414E43454C202020- <1>                         db "CANCEL     --  Leave this menu", 0
   342 000008C8 20202D2D20204C6561- <1>
   342 000008D1 76652074686973206D- <1>
   342 000008DA 656E7500            <1>
   343 000008DE 48454C50204D454E55- <1>     .help_header:       db "HELP MENU", 0
   343 000008E7 00                  <1>
   344 000008E8 507265737320454E54- <1>     .help_string:       db "Press ENTER to run any of the commands", 0
   344 000008F1 455220746F2072756E- <1>
   344 000008FA 20616E79206F662074- <1>
   344 00000903 686520636F6D6D616E- <1>
   344 0000090C 647300              <1>
   345                              <1> 
   346                              <1> ; ----------------------------------
   347                              <1> ; MAKE FILE
   348                              <1> 
   349                              <1> .make_file:
   350 0000090F 60                  <1>     pusha
   351 00000910 B8[B809]            <1>     mov ax, .tmp_filename
   352 00000913 E83919              <1>     call os_file_exists
   353 00000916 731A                <1>     jnc .file_exists
   354                              <1> 
   355 00000918 E85319              <1>     call os_create_file
   356                              <1>     
   357 0000091B B80A0E              <1>     mov ax, 0x0e0a
   358 0000091E CD10                <1>     int 0x10
   359 00000920 B00D                <1>     mov al, 0x0d
   360 00000922 CD10                <1>     int 0x10
   361                              <1> 
   362 00000924 BE[B809]            <1>     mov si, .tmp_filename
   363 00000927 E87712              <1>     call print
   364 0000092A BE[150A]            <1>     mov si, .tmp_filemk
   365 0000092D E87112              <1>     call print
   366 00000930 EB06                <1>     jmp .make_done
   367                              <1> 
   368                              <1>     .file_exists:
   369 00000932 BE[500A]            <1>         mov si, .file_found
   370 00000935 E86912              <1>         call print
   371                              <1> 
   372                              <1>     .make_done:
   373 00000938 B80A0E              <1>         mov ax, 0x0e0a
   374 0000093B CD10                <1>         int 0x10
   375 0000093D CD10                <1>         int 0x10
   376 0000093F B00D                <1>         mov al, 0x0d
   377 00000941 CD10                <1>         int 0x10
   378 00000943 61                  <1>         popa
   379 00000944 E956FC              <1>         jmp .input_loop
   380                              <1> 
   381                              <1> ; ----------------------------------
   382                              <1> ; REMOVE FILE
   383                              <1> 
   384                              <1> .remove_file:
   385 00000947 60                  <1>     pusha
   386 00000948 B8[B809]            <1>     mov ax, .tmp_filename
   387 0000094B E8AF19              <1>     call os_remove_file
   388 0000094E 7217                <1>     jc .not_file
   389                              <1> 
   390 00000950 B80A0E              <1>     mov ax, 0x0e0a
   391 00000953 CD10                <1>     int 0x10
   392 00000955 B00D                <1>     mov al, 0x0d
   393 00000957 CD10                <1>     int 0x10
   394                              <1> 
   395 00000959 BE[B809]            <1>     mov si, .tmp_filename
   396 0000095C E84212              <1>     call print
   397 0000095F BE[030A]            <1>     mov si, .tmp_filerm
   398 00000962 E83C12              <1>     call print
   399 00000965 EB06                <1>     jmp .finished
   400                              <1> 
   401                              <1>     .not_file:
   402 00000967 BE[3F0A]            <1>         mov si, .file_not_found
   403 0000096A E83412              <1>         call print
   404                              <1> 
   405                              <1>     .finished:
   406 0000096D B80A0E              <1>         mov ax, 0x0e0a
   407 00000970 CD10                <1>         int 0x10
   408 00000972 CD10                <1>         int 0x10
   409 00000974 B00D                <1>         mov al, 0x0d
   410 00000976 CD10                <1>         int 0x10
   411                              <1> 
   412 00000978 61                  <1>     popa
   413                              <1> 
   414 00000979 E921FC              <1>     jmp .input_loop
   415                              <1> 
   416                              <1> ; ----------------------------------
   417                              <1> ; LOAD FILE
   418                              <1> 
   419                              <1> .load_file:
   420 0000097C 60                  <1>     pusha
   421 0000097D 31C0                <1>     xor ax, ax
   422                              <1> 
   423 0000097F B8[B809]            <1>     mov ax, .tmp_filename
   424 00000982 E84BF7              <1>     call try_run_file
   425 00000985 7204                <1>     jc .not_found
   426                              <1> 
   427 00000987 61                  <1>     popa
   428 00000988 E912FC              <1>     jmp .input_loop
   429                              <1> 
   430                              <1>     .not_found:
   431 0000098B BE[AF03]            <1>         mov si, notfound_msg
   432 0000098E E81012              <1>         call print
   433                              <1> 
   434 00000991 61                  <1>         popa
   435 00000992 E908FC              <1>         jmp .input_loop
   436                              <1> 
   437                              <1> ; ----------------------------------
   438                              <1> ; EDIT FILE
   439                              <1> 
   440                              <1> .edit_file:
   441 00000995 E905FC              <1>     jmp .input_loop
   442                              <1> 
   443                              <1> ; ----------------------------------
   444                              <1> ; RESTART
   445                              <1> 
   446                              <1> .restart:
   447 00000998 B80000              <1>     mov ax, 0x00
   448 0000099B CD13                <1>     int 0x13
   449 0000099D CD19                <1>     int 0x19
   450                              <1> 
   451                              <1>     ; Halt cpu if restart fails
   452 0000099F F4                  <1>     hlt
   453                              <1> 
   454                              <1> ; ----------------------------------
   455                              <1> ; SHUTDOWN
   456                              <1> 
   457                              <1> .shutdown:
   458 000009A0 31C0                <1>     xor ax, ax
   459 000009A2 CD13                <1>     int 0x13
   460                              <1> 
   461 000009A4 B80010              <1>     mov ax, 0x1000
   462 000009A7 8CD0                <1>     mov ax, ss
   463 000009A9 BC00F0              <1>     mov sp, 0xf000
   464 000009AC B80753              <1>     mov ax, 0x5307
   465 000009AF BB0100              <1>     mov bx, 0x0001
   466 000009B2 B90300              <1>     mov cx, 0x0003
   467 000009B5 CD15                <1>     int 0x15
   468                              <1> 
   469                              <1>     ; Halt cpu if shutdown fails
   470 000009B7 F4                  <1>     hlt
   471                              <1> 
   472                              <1> 
   473 000009B8 00<rept>            <1> .tmp_filename:      times 20 db 0
   474 000009CC 00<rept>            <1> .tmp_inbuffer:      times 41 db 0
   475 000009F5 202D2D2000          <1> .file_size_sep:		db " -- ", 0
   476 000009FA 2042797465730A0D00  <1> .file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   477 00000A03 20686173206265656E- <1> .tmp_filerm:        db " has been deleted", 0
   477 00000A0C 2064656C6574656400  <1>
   478 00000A15 20686173206265656E- <1> .tmp_filemk:        db " has been created", 0
   478 00000A1E 206372656174656400  <1>
   479 00000A27 4155544F52554E2E42- <1> .autobin_filename:  db "AUTORUN.BKF", 0
   479 00000A30 4B4600              <1>
   480 00000A33 4155544F52554E2E42- <1> .autobas_filename:  db "AUTORUN.BAS", 0
   480 00000A3C 415300              <1>
   481 00000A3F 0A0D46696C65206E6F- <1> .file_not_found:    db 0x0a, 0x0d, "File not found", 0
   481 00000A48 7420666F756E6400    <1>
   482 00000A50 0A0D46696C6520616C- <1> .file_found:        db 0x0a, 0x0d, "File already exists", 0
   482 00000A59 726561647920657869- <1>
   482 00000A62 73747300            <1>
   367                                      %include "./includes/menubar.asm"
     1                              <1> check_pos:
     2 00000A66 60                  <1>     pusha
     3                              <1> 
     4 00000A67 B403                <1>     mov ah, 0x03
     5 00000A69 30FF                <1>     xor bh, bh
     6 00000A6B CD10                <1>     int 0x10
     7                              <1> 
     8 00000A6D 80FE18              <1>     cmp dh, 24
     9 00000A70 7402                <1>     je .at_end
    10                              <1> 
    11 00000A72 61                  <1>     popa
    12 00000A73 C3                  <1>     ret
    13                              <1> 
    14                              <1> .at_end:
    15 00000A74 B80306              <1>     mov ax, 0x0603
    16 00000A77 B70F                <1>     mov bh, cli_color
    17 00000A79 BA4F18              <1> 	mov dx, 0x184f
    18 00000A7C 31C9                <1> 	xor cx, cx
    19 00000A7E CD10                <1>     int 0x10
    20                              <1> 
    21 00000A80 B402                <1>     mov ah, 0x02
    22 00000A82 30FF                <1>     xor bh, bh
    23 00000A84 30D2                <1>     xor dl, dl
    24 00000A86 B615                <1>     mov dh, 21
    25 00000A88 CD10                <1>     int 0x10
    26                              <1> 
    27 00000A8A 61                  <1>     popa
    28 00000A8B C3                  <1>     ret
    29                              <1> 
    30                              <1> draw_menu_bar:
    31 00000A8C 60                  <1>     pusha
    32                              <1> 
    33 00000A8D B403                <1>     mov ah, 0x03
    34 00000A8F 30FF                <1>     xor bh, bh
    35 00000A91 CD10                <1>     int 0x10
    36                              <1> 
    37 00000A93 52                  <1>     push dx
    38                              <1> 
    39 00000A94 B80407              <1>     mov ax, 0x0704
    40 00000A97 B70F                <1>     mov bh, cli_color
    41 00000A99 BA4F18              <1> 	mov dx, 0x184f
    42 00000A9C 31C9                <1> 	xor cx, cx
    43 00000A9E CD10                <1>     int 0x10
    44 00000AA0 B80406              <1>     mov ax, 0x0604
    45 00000AA3 CD10                <1>     int 0x10
    46                              <1>     
    47 00000AA5 B402                <1>     mov ah, 0x02
    48 00000AA7 B618                <1>     mov dh, 24
    49 00000AA9 30FF                <1>     xor bh, bh
    50 00000AAB 30D2                <1>     xor dl, dl
    51 00000AAD CD10                <1>     int 0x10
    52                              <1> 
    53 00000AAF BE[D703]            <1>     mov si, mb_fill
    54 00000AB2 B330                <1>     mov bl, mb_color
    55 00000AB4 E82311              <1>     call print_atr
    56                              <1> 
    57 00000AB7 B402                <1>     mov ah, 0x02
    58 00000AB9 B618                <1>     mov dh, 24
    59 00000ABB B201                <1>     mov dl, 1
    60 00000ABD 30FF                <1>     xor bh, bh
    61 00000ABF CD10                <1>     int 0x10
    62                              <1> 
    63 00000AC1 E85F05              <1>     call get_time_string
    64 00000AC4 89DE                <1>     mov si, bx
    65 00000AC6 B330                <1>     mov bl, mb_color
    66 00000AC8 E80F11              <1>     call print_atr
    67                              <1> 
    68 00000ACB B402                <1>     mov ah, 0x02
    69 00000ACD B618                <1>     mov dh, 24
    70 00000ACF B21C                <1>     mov dl, 28
    71 00000AD1 30FF                <1>     xor bh, bh
    72 00000AD3 CD10                <1>     int 0x10
    73                              <1> 
    74 00000AD5 B8[8401]            <1>     mov ax, usrNam
    75 00000AD8 E86F03              <1>     call string_uppercase
    76 00000ADB 89C6                <1>     mov si, ax
    77 00000ADD B330                <1>     mov bl, mb_color
    78 00000ADF E8F810              <1>     call print_atr
    79                              <1> 
    80 00000AE2 B402                <1>     mov ah, 0x02
    81 00000AE4 B618                <1>     mov dh, 24
    82 00000AE6 B245                <1>     mov dl, 69
    83 00000AE8 30FF                <1>     xor bh, bh
    84 00000AEA CD10                <1>     int 0x10
    85                              <1> 
    86 00000AEC E8EB05              <1>     call get_date_string
    87 00000AEF 89DE                <1>     mov si, bx
    88 00000AF1 B330                <1>     mov bl, mb_color
    89 00000AF3 E8E410              <1>     call print_atr
    90                              <1> 
    91 00000AF6 B402                <1>     mov ah, 0x02
    92 00000AF8 30FF                <1>     xor bh, bh
    93 00000AFA 30D2                <1>     xor dl, dl
    94 00000AFC 5A                  <1>     pop dx
    95 00000AFD CD10                <1>     int 0x10
    96                              <1> 
    97 00000AFF 61                  <1>     popa
    98 00000B00 C3                  <1>     ret
   368                                      %include "./includes/video.asm"
     1                              <1> kronk_vid:
     2 00000B01 B80100              <1>     mov ax, 1
     3 00000B04 B701                <1>     mov bh, vid_backcolor
     4 00000B06 E8B109              <1>     call switch_mode
     5                              <1>     
     6                              <1>     ; Disable color blinking
     7 00000B09 B80310              <1>     mov ax, 0x1003
     8 00000B0C BB0000              <1>     mov bx, 0x0000
     9 00000B0F CD10                <1>     int 0x10
    10                              <1> 
    11                              <1>     ; Initalize and enable the mouse if possible
    12 00000B11 E83411              <1>     call mouse_initialize
    13 00000B14 7205                <1>     jc error
    14 00000B16 E85D11              <1>     call mouse_enable
    15 00000B19 EB07                <1>     jmp vid_input
    16                              <1> 
    17                              <1> error: 
    18 00000B1B B700                <1>     mov bh, 0x00
    19 00000B1D E8C502              <1>     call cls
    20 00000B20 EBFE                <1>     jmp $
    21                              <1> 
    22                              <1> 
    23                              <1> vid_input:
    24 00000B22 B701                <1>     mov bh, vid_backcolor
    25 00000B24 E8BE02              <1>     call cls
    26                              <1> 
    27                              <1> .at_same:
    28 00000B27 E85212              <1>     call mouse_loop
    29 00000B2A 3A16[590B]          <1>     cmp dl, [lastX]
    30 00000B2E 7511                <1>     jne .moved
    31                              <1> 
    32 00000B30 3A36[5A0B]          <1>     cmp dh, [lastY]
    33 00000B34 750B                <1>     jne .moved
    34                              <1> 
    35 00000B36 BE[5C0B]            <1>     mov si, sejt
    36 00000B39 BB0F00              <1>     mov bx, 0x000F
    37 00000B3C E89B10              <1>     call print_atr
    38                              <1> 
    39 00000B3F EBE6                <1>     jmp .at_same
    40                              <1> 
    41                              <1> .moved:
    42 00000B41 8816[590B]          <1>     mov [lastX], dl
    43 00000B45 8836[5A0B]          <1>     mov [lastY], dh
    44                              <1> 
    45 00000B49 BE[5C0B]            <1>     mov si, sejt
    46 00000B4C BB0F00              <1>     mov bx, 0x000F
    47 00000B4F E88810              <1>     call print_atr
    48                              <1> 
    49 00000B52 EBCE                <1>     jmp vid_input
    50                              <1> 
    51 00000B54 2C2000              <1>     .separator: db ", ", 0
    52 00000B57 0000                <1>     .lastPos:   dw 0
    53                              <1> 
    54                              <1> ; ------------------------------------------------------------------
    55                              <1> ; STRINGS AND OTHER VARIABLES
    56                              <1> 
    57 00000B59 00                  <1>     lastX:              db 0
    58 00000B5A 00                  <1>     lastY:              db 0
    59 00000B5B 00                  <1>     mouse_working:      db 0
    60 00000B5C 5800                <1>     sejt:               db "X", 0
   369                                      %include "./includes/setup.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; The Kronk Operating System setup file
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; This is loaded from the drive by KERNEL.BIN, at first boot
     6                              <1> ; ==================================================================
     7                              <1> setup_init:
     8                              <1> 
     9                              <1>     ; Color variables
    10                              <1>     basic_colors    equ 0x1F
    11                              <1>     marked_colors   equ 0x1E
    12                              <1> 
    13                              <1>     ; Setup text box variables
    14                              <1>     edge_width      equ 14
    15                              <1>     border_length   equ 50
    16                              <1>     
    17                              <1>     ; Disable color blinking
    18 00000B5E B80310              <1>     mov ax, 0x1003
    19 00000B61 BB0000              <1>     mov bx, 0x0000
    20 00000B64 CD10                <1>     int 0x10
    21                              <1> 
    22 00000B66 EB00                <1>     jmp setup_start
    23                              <1> 
    24                              <1> ; ******************************************************************
    25                              <1> ; Start the setup
    26                              <1> setup_start:
    27 00000B68 60                  <1>     pusha
    28 00000B69 B71F                <1>     mov bh, basic_colors
    29 00000B6B E87702              <1>     call cls
    30                              <1> 
    31 00000B6E BE[D00D]            <1>     mov si, setup_string
    32 00000B71 E86D09              <1>     call setup_bottom_string
    33                              <1> 
    34 00000B74 BE[F50B]            <1>     mov si, usr_set
    35 00000B77 E82A0C              <1>     call draw_setup_box
    36                              <1> 
    37 00000B7A B8[E10B]            <1>     mov ax, usr_save
    38 00000B7D E87909              <1>     call setup_input
    39                              <1> 
    40 00000B80 B71F                <1>     mov bh, basic_colors
    41 00000B82 E86002              <1>     call cls
    42                              <1> 
    43 00000B85 BE[240C]            <1>     mov si, vid_set
    44 00000B88 E8190C              <1>     call draw_setup_box
    45                              <1> 
    46 00000B8B B8[9B0D]            <1>     mov ax, vid_opt1
    47 00000B8E BB[A40D]            <1>     mov bx, vid_opt2
    48 00000B91 B9[AF0D]            <1>     mov cx, vid_opt3
    49 00000B94 BAE11F              <1>     mov dx, 0x1fe1
    50 00000B97 E8570A              <1>     call setup_choose
    51                              <1> 
    52 00000B9A 83F802              <1>     cmp ax, 2
    53 00000B9D 7517                <1>     jne .setup_done
    54                              <1> 
    55                              <1>     ; User has choosen "cancel" and KronkOS will therefore shutdown
    56 00000B9F 31C0                <1>     xor ax, ax
    57 00000BA1 CD13                <1>     int 0x13
    58                              <1> 
    59 00000BA3 B80010              <1>     mov ax, 0x1000
    60 00000BA6 8CD0                <1>     mov ax, ss
    61 00000BA8 BC00F0              <1>     mov sp, 0xf000
    62 00000BAB B80753              <1>     mov ax, 0x5307
    63 00000BAE BB0100              <1>     mov bx, 0x0001
    64 00000BB1 B90300              <1>     mov cx, 0x0003
    65 00000BB4 CD15                <1>     int 0x15
    66                              <1> 
    67                              <1> .setup_done:
    68 00000BB6 A3[9901]            <1>     mov [vidMode], ax
    69                              <1> 
    70 00000BB9 BE[E10B]            <1>     mov si, usr_save
    71 00000BBC BF[8401]            <1>     mov di, usrNam
    72 00000BBF E8C202              <1>     call string_copy
    73                              <1> 
    74 00000BC2 61                  <1>     popa
    75 00000BC3 C3                  <1>     ret
    76                              <1> 
    77                              <1> ; ******************************************************************
    78                              <1> 
    79                              <1> ; ------------------------------------------------------------------
    80                              <1> ; VARIABLES
    81 00000BC4 766964656F6D6F6465- <1>     vidmode_save:   db "videomode,", 0
    81 00000BCD 2C00                <1>
    82 00000BCF 300A0D00            <1>     cli_save:       db "0", 0x0a, 0x0d, 0
    83 00000BD3 310A0D00            <1>     vid_save:       db "1", 0x0a, 0x0d, 0
    84 00000BD7 757365726E616D652C- <1>     usrname_save:   db "username,", 0
    84 00000BE0 00                  <1>
    85 00000BE1 00<rept>            <1>     usr_save:       times 20 db 0
    86                              <1> 
    87 00000BF5 506C6561736520656E- <1>     usr_set:    db "Please enter your username, and press enter...", 0
    87 00000BFE 74657220796F757220- <1>
    87 00000C07 757365726E616D652C- <1>
    87 00000C10 20616E642070726573- <1>
    87 00000C19 7320656E7465722E2E- <1>
    87 00000C22 2E00                <1>
    88                              <1> 
    89 00000C24 506C65617365206368- <1>     vid_set:    db "Please choose a standard view mode...", 0x0a, 0x0a
    89 00000C2D 6F6F73652061207374- <1>
    89 00000C36 616E64617264207669- <1>
    89 00000C3F 6577206D6F64652E2E- <1>
    89 00000C48 2E0A0A              <1>
    90 00000C4B 564944454F204D4F44- <1>                 db "VIDEO MODE is for the more casual user, that", 0x0a, "just want to be able to use KronkOS with ease by using a nice graphical interface.", 0x0a, 0x0a
    90 00000C54 4520697320666F7220- <1>
    90 00000C5D 746865206D6F726520- <1>
    90 00000C66 63617375616C207573- <1>
    90 00000C6F 65722C20746861740A- <1>
    90 00000C78 6A7573742077616E74- <1>
    90 00000C81 20746F206265206162- <1>
    90 00000C8A 6C6520746F20757365- <1>
    90 00000C93 204B726F6E6B4F5320- <1>
    90 00000C9C 776974682065617365- <1>
    90 00000CA5 206279207573696E67- <1>
    90 00000CAE 2061206E6963652067- <1>
    90 00000CB7 726170686963616C20- <1>
    90 00000CC0 696E74657266616365- <1>
    90 00000CC9 2E0A0A              <1>
    91 00000CCC 434C49204D4F444520- <1>                 db "CLI MODE is for the more advanced user, where", 0x0a, "instead of pressing buttons, you use commands to", 0x0a, "execute the various actions you desire.", 0x0a, 0x0a
    91 00000CD5 697320666F72207468- <1>
    91 00000CDE 65206D6F7265206164- <1>
    91 00000CE7 76616E636564207573- <1>
    91 00000CF0 65722C207768657265- <1>
    91 00000CF9 0A696E737465616420- <1>
    91 00000D02 6F6620707265737369- <1>
    91 00000D0B 6E6720627574746F6E- <1>
    91 00000D14 732C20796F75207573- <1>
    91 00000D1D 6520636F6D6D616E64- <1>
    91 00000D26 7320746F0A65786563- <1>
    91 00000D2F 757465207468652076- <1>
    91 00000D38 6172696F7573206163- <1>
    91 00000D41 74696F6E7320796F75- <1>
    91 00000D4A 206465736972652E0A- <1>
    91 00000D53 0A                  <1>
    92 00000D54 557365207468652061- <1>                 db "Use the arrow keys and 'ENTER' to select between the different options", 0
    92 00000D5D 72726F77206B657973- <1>
    92 00000D66 20616E642027454E54- <1>
    92 00000D6F 45522720746F207365- <1>
    92 00000D78 6C6563742062657477- <1>
    92 00000D81 65656E207468652064- <1>
    92 00000D8A 6966666572656E7420- <1>
    92 00000D93 6F7074696F6E7300    <1>
    93                              <1> 
    94 00000D9B 434C49204D4F444500  <1>     vid_opt1:   db "CLI MODE", 0
    95 00000DA4 564944454F204D4F44- <1>     vid_opt2:   db "VIDEO MODE", 0
    95 00000DAD 4500                <1>
    96 00000DAF 43616E63656C202857- <1>     vid_opt3:   db "Cancel (Will shutdown KronkOS)", 0
    96 00000DB8 696C6C207368757464- <1>
    96 00000DC1 6F776E204B726F6E6B- <1>
    96 00000DCA 4F532900            <1>
    97                              <1> 
    98 00000DCE 0000                <1>     vid_chosen: dw 0
    99                              <1> 
   100 00000DD0 204B726F6E6B4F5320- <1>     setup_string: db " KronkOS ", KRONKOS_VER, " setup", 0
   100 00000DD9 302E332E3220736574- <1>
   100 00000DE2 757000              <1>
   370                                      %include "./includes/cls.asm"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; cls -- Clear the screen with a self choosen color
     3                              <1> ; IN: BH = Color to clear with
     4                              <1> 
     5                              <1> cls:
     6 00000DE5 60                  <1>     pusha
     7                              <1>     
     8 00000DE6 B406                <1>     mov ah, 0x06
     9 00000DE8 BA4F18              <1>     mov dx, 0x184f
    10                              <1> 
    11 00000DEB 30C0                <1>     xor al, al
    12 00000DED 31C9                <1>     xor cx, cx
    13                              <1> 
    14 00000DEF CD10                <1>     int 0x10
    15                              <1>     
    16 00000DF1 B402                <1>     mov ah, 0x2
    17 00000DF3 31D2                <1>     xor dx, dx
    18 00000DF5 30FF                <1>     xor bh, bh
    19                              <1> 
    20 00000DF7 CD10                <1>     int 0x10
    21                              <1>     
    22 00000DF9 61                  <1>     popa
    23 00000DFA C3                  <1>     ret
   371                                      %include "./includes/string.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; KronkOS -- The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019-2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; STRING MANIPULATION ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; string_length -- Return length of a string
    10                              <1> ; IN: AX = string location
    11                              <1> ; OUT AX = length (other regs preserved)
    12                              <1> 
    13                              <1> string_length:
    14 00000DFB 60                  <1>     pusha
    15 00000DFC 89C3                <1>     mov bx, ax
    16 00000DFE B90000              <1>     mov cx, 0
    17                              <1> 
    18                              <1>     .more:
    19 00000E01 803F00              <1>         cmp byte [bx], 0
    20 00000E04 7404                <1>         je .done
    21 00000E06 43                  <1>         inc bx
    22 00000E07 41                  <1>         inc cx
    23 00000E08 EBF7                <1>         jmp .more
    24                              <1> 
    25                              <1>     .done:
    26 00000E0A 890E[130E]          <1>         mov word [.tmp_counter], cx
    27 00000E0E 61                  <1>         popa
    28                              <1> 
    29 00000E0F A1[130E]            <1>         mov ax, [.tmp_counter]
    30 00000E12 C3                  <1>         ret
    31                              <1> 
    32 00000E13 0000                <1>         .tmp_counter dw 0
    33                              <1> 
    34                              <1> ; ------------------------------------------------------------------
    35                              <1> ; find_char_in_string -- Find location of character in a string
    36                              <1> ; IN: SI = string location, AL = character to find
    37                              <1> ; OUT AX = location in string, or 0 if not present
    38                              <1> 
    39                              <1> find_char_in_string:
    40 00000E15 60                  <1>     pusha
    41 00000E16 B90100              <1>     mov cx, 1
    42                              <1> 
    43                              <1>     .more:
    44 00000E19 3804                <1>         cmp byte [si], al
    45 00000E1B 7409                <1>         je .done
    46 00000E1D 803C00              <1>         cmp byte [si], 0
    47 00000E20 740D                <1>         je .notfound
    48                              <1>         
    49 00000E22 46                  <1>         inc si
    50 00000E23 41                  <1>         inc cx
    51                              <1> 
    52 00000E24 EBF3                <1>         jmp .more
    53                              <1>     
    54                              <1>     .done:
    55 00000E26 890E[340E]          <1>         mov [.tmp], cx
    56 00000E2A 61                  <1>         popa
    57 00000E2B A1[340E]            <1>         mov ax, [.tmp]
    58                              <1> 
    59 00000E2E C3                  <1>         ret
    60                              <1>     
    61                              <1>     .notfound:
    62 00000E2F 61                  <1>         popa
    63 00000E30 B80000              <1>         mov ax, 0
    64                              <1> 
    65 00000E33 C3                  <1>         ret
    66                              <1> 
    67 00000E34 0000                <1>     .tmp dw 0
    68                              <1> 
    69                              <1> ; ------------------------------------------------------------------
    70                              <1> ; string_charchange -- Change a character in a string
    71                              <1> ; IN: SI = string location, AL = char to find, BL = char to replace with
    72                              <1> 
    73                              <1> string_charchange:
    74 00000E36 60                  <1>     pusha
    75 00000E37 88C1                <1>     mov cl, al
    76                              <1> 
    77                              <1>     .loop:
    78 00000E39 8A04                <1>         mov byte al, [si]
    79 00000E3B 3C00                <1>         cmp al, 0
    80 00000E3D 7409                <1>         je .finish
    81 00000E3F 38C8                <1>         cmp al, cl
    82 00000E41 7502                <1>         jne .nochange
    83                              <1> 
    84 00000E43 881C                <1>         mov byte [si], bl
    85                              <1> 
    86                              <1>     .nochange:
    87 00000E45 46                  <1>         inc si
    88 00000E46 EBF1                <1>         jmp .loop
    89                              <1>     
    90                              <1>     .finish:
    91 00000E48 61                  <1>         popa
    92 00000E49 C3                  <1>         ret
    93                              <1> 
    94                              <1> ; ------------------------------------------------------------------
    95                              <1> ; string_uppercase -- Convert string to upper case
    96                              <1> ; IN/OUT: AX = string location
    97                              <1> 
    98                              <1> string_uppercase:
    99 00000E4A 60                  <1>     pusha
   100 00000E4B 89C6                <1>     mov si, ax
   101                              <1> 
   102                              <1>     .more:
   103 00000E4D 803C00              <1>         cmp byte [si], 0
   104 00000E50 7413                <1>         je .done
   105                              <1> 
   106 00000E52 803C61              <1>         cmp byte [si], 'a'
   107 00000E55 720B                <1>         jb .noatoz
   108 00000E57 803C7A              <1>         cmp byte [si], 'z'
   109 00000E5A 7706                <1>         ja .noatoz
   110                              <1> 
   111 00000E5C 802C20              <1>         sub byte [si], 0x20
   112                              <1> 
   113 00000E5F 46                  <1>         inc si
   114 00000E60 EBEB                <1>         jmp .more
   115                              <1> 
   116                              <1>     .noatoz:
   117 00000E62 46                  <1>         inc si
   118 00000E63 EBE8                <1>         jmp .more
   119                              <1> 
   120                              <1>     .done:
   121 00000E65 61                  <1>         popa
   122 00000E66 C3                  <1>         ret
   123                              <1> 
   124                              <1> ; ------------------------------------------------------------------
   125                              <1> ; string_lowercase -- Convert string to lower case
   126                              <1> ; IN/OUT: AX = string location
   127                              <1> 
   128                              <1> string_lowercase:
   129 00000E67 60                  <1>     pusha
   130 00000E68 89C6                <1>     mov si, ax
   131                              <1> 
   132                              <1>     .more:
   133 00000E6A 803C00              <1>         cmp byte [si], 0
   134 00000E6D 7413                <1>         je .done
   135                              <1> 
   136 00000E6F 803C41              <1>         cmp byte [si], 'A'
   137 00000E72 720B                <1>         jb .noatoz
   138 00000E74 803C5A              <1>         cmp byte [si], 'Z'
   139 00000E77 7706                <1>         ja .noatoz
   140                              <1> 
   141 00000E79 800420              <1>         add byte [si], 0x20
   142                              <1> 
   143 00000E7C 46                  <1>         inc si
   144 00000E7D EBEB                <1>         jmp .more
   145                              <1>     
   146                              <1>     .noatoz:
   147 00000E7F 46                  <1>         inc si
   148 00000E80 EBE8                <1>         jmp .more
   149                              <1> 
   150                              <1>     .done:
   151 00000E82 61                  <1>         popa
   152 00000E83 C3                  <1>         ret
   153                              <1>         
   154                              <1> ; ------------------------------------------------------------------
   155                              <1> ; string_copy -- Copy one string on to another
   156                              <1> ; IN: SI = source
   157                              <1> ; OUT: DI = destination
   158                              <1> 
   159                              <1> string_copy:
   160 00000E84 60                  <1>     pusha
   161                              <1> 
   162                              <1>     .more:
   163 00000E85 AC                  <1>         lodsb
   164 00000E86 AA                  <1>         stosb
   165                              <1> 
   166 00000E87 84C0                <1>         test al, al
   167 00000E89 75FA                <1>         jnz .more
   168                              <1> 
   169                              <1>     .done:
   170 00000E8B 61                  <1>         popa
   171 00000E8C C3                  <1>         ret
   172                              <1> 
   173                              <1> ; ------------------------------------------------------------------
   174                              <1> ; string_truncate -- Chop string down to specified number of characters
   175                              <1> ; IN: SI = string location, AX = number of characters
   176                              <1> ; OUT: Modified string
   177                              <1> 
   178                              <1> string_truncate:
   179 00000E8D 60                  <1>     pusha
   180                              <1> 
   181 00000E8E 01C6                <1>     add si, ax
   182 00000E90 C60400              <1>     mov byte [si], 0
   183                              <1> 
   184 00000E93 61                  <1>     popa
   185 00000E94 C3                  <1>     ret
   186                              <1> 
   187                              <1> ; ------------------------------------------------------------------
   188                              <1> ; string_add
   189                              <1> ; IN: AX = string one; BX = string two
   190                              <1> ; OUT AX = product
   191                              <1> 
   192                              <1> string_add:
   193                              <1>     .add_loop:
   194 00000E95 AC                  <1>         lodsb
   195 00000E96 AA                  <1>         stosb
   196                              <1> 
   197 00000E97 3C00                <1>         cmp al, 0
   198 00000E99 75FA                <1>         jne .add_loop
   199                              <1> 
   200 00000E9B C3                  <1>         ret
   201                              <1> 
   202                              <1> ; ------------------------------------------------------------------
   203                              <1> ; string_join -- Join two strings into a third seperate string
   204                              <1> ; IN/OUT: AX = string one, BX = string two, CX = product destination
   205                              <1> 
   206                              <1> string_join:
   207 00000E9C 60                  <1>     pusha
   208                              <1>     
   209 00000E9D 89C6                <1>     mov si, ax
   210 00000E9F 89CF                <1>     mov di, cx
   211                              <1> 
   212 00000EA1 E8E0FF              <1>     call string_copy
   213 00000EA4 E854FF              <1>     call string_length
   214                              <1> 
   215 00000EA7 01C1                <1>     add cx, ax
   216                              <1> 
   217 00000EA9 89DE                <1>     mov si, bx
   218 00000EAB 89CF                <1>     mov di, cx
   219 00000EAD E8D4FF              <1>     call string_copy
   220                              <1> 
   221 00000EB0 61                  <1>     popa
   222 00000EB1 C3                  <1>     ret
   223                              <1> 
   224                              <1> ; ------------------------------------------------------------------
   225                              <1> ; string_chomp -- Strip away extra spaces from a string
   226                              <1> ; IN: AX = string location
   227                              <1> 
   228                              <1> string_chomp:
   229 00000EB2 60                  <1>     pusha
   230                              <1> 
   231 00000EB3 89C2                <1>     mov dx, ax
   232                              <1> 
   233 00000EB5 89C7                <1>     mov di, ax
   234 00000EB7 B90000              <1>     mov cx, 0
   235                              <1> 
   236                              <1>     .keepcounting:
   237 00000EBA 803D20              <1>         cmp byte [di], ' '
   238 00000EBD 7504                <1>         jne .counted
   239 00000EBF 41                  <1>         inc cx
   240 00000EC0 47                  <1>         inc di
   241 00000EC1 EBF7                <1>         jmp .keepcounting
   242                              <1> 
   243                              <1>     .counted:
   244 00000EC3 83F900              <1>         cmp cx, 0
   245 00000EC6 740E                <1>         je .finished_copy
   246                              <1> 
   247 00000EC8 89FE                <1>         mov si, di
   248 00000ECA 89D7                <1>         mov di, dx
   249                              <1>     
   250                              <1>     .keep_copying:
   251 00000ECC AC                  <1>         lodsb
   252 00000ECD 8805                <1>         mov [di], al
   253 00000ECF 3C00                <1>         cmp al, 0
   254 00000ED1 7403                <1>         je .finished_copy
   255 00000ED3 47                  <1>         inc di
   256                              <1> 
   257 00000ED4 EBF6                <1>         jmp .keep_copying
   258                              <1> 
   259                              <1>     .finished_copy:
   260 00000ED6 89D0                <1>         mov ax, dx
   261                              <1> 
   262 00000ED8 E820FF              <1>         call string_length
   263 00000EDB 83F800              <1>         cmp ax, 0
   264 00000EDE 740F                <1>         je .done
   265                              <1> 
   266 00000EE0 89D6                <1>         mov si, dx
   267 00000EE2 01C6                <1>         add si, ax
   268                              <1>     
   269                              <1>     .more:
   270 00000EE4 4E                  <1>         dec si
   271 00000EE5 803C20              <1>         cmp byte [si], ' '
   272 00000EE8 7505                <1>         jne .done
   273 00000EEA C60400              <1>         mov byte [si], 0
   274 00000EED EBF5                <1>         jmp .more
   275                              <1>     
   276                              <1>     .done:
   277 00000EEF 61                  <1>         popa
   278 00000EF0 C3                  <1>         ret
   279                              <1> 
   280                              <1> ; ------------------------------------------------------------------
   281                              <1> ; string_strip -- Remove a character from a string (max 255 chars)
   282                              <1> ; IN: SI = string location, AL = character to remove
   283                              <1> ; OUT: SI = modified string
   284                              <1> 
   285                              <1> string_strip:
   286 00000EF1 60                  <1>     pusha
   287                              <1> 
   288 00000EF2 89F7                <1>     mov di, si
   289 00000EF4 88C3                <1>     mov bl, al
   290                              <1> 
   291                              <1>     .nextchar:
   292 00000EF6 AC                  <1>         lodsb
   293 00000EF7 AA                  <1>         stosb
   294 00000EF8 3C00                <1>         cmp al, 0
   295 00000EFA 7407                <1>         je .finish
   296 00000EFC 38D8                <1>         cmp al, bl
   297 00000EFE 75F6                <1>         jne .nextchar
   298                              <1> 
   299                              <1>     .skip:
   300 00000F00 4F                  <1>         dec di
   301 00000F01 EBF3                <1>         jmp .nextchar
   302                              <1> 
   303                              <1>     .finish:
   304 00000F03 61                  <1>         popa
   305 00000F04 C3                  <1>         ret
   306                              <1> 
   307                              <1> ; ------------------------------------------------------------------
   308                              <1> ; string_compare -- Check if two strings match
   309                              <1> ; IN: SI = string one, DI = string two
   310                              <1> ; OUT: carry set if same, clear if different
   311                              <1> 
   312                              <1> string_compare:
   313 00000F05 60                  <1>     pusha
   314                              <1> 
   315                              <1>     .more:
   316 00000F06 8A04                <1>         mov al, [si]
   317 00000F08 8A1D                <1>         mov bl, [di]
   318                              <1> 
   319 00000F0A 80FB00              <1>         cmp bl, 0
   320 00000F0D 740B                <1>         je .terminated
   321                              <1> 
   322 00000F0F 38D8                <1>         cmp al, bl
   323 00000F11 7504                <1>         jne .not_same
   324                              <1> 
   325 00000F13 46                  <1>         inc si
   326 00000F14 47                  <1>         inc di
   327 00000F15 EBEF                <1>         jmp .more
   328                              <1>     
   329                              <1>     .not_same:
   330 00000F17 61                  <1>         popa
   331 00000F18 F8                  <1>         clc
   332 00000F19 C3                  <1>         ret
   333                              <1>     
   334                              <1>     .terminated:
   335 00000F1A 61                  <1>         popa
   336 00000F1B F9                  <1>         stc
   337 00000F1C C3                  <1>         ret
   338                              <1> 
   339                              <1> ; ------------------------------------------------------------------
   340                              <1> ; string_to_int -- Convert string to an integer
   341                              <1> ; IN: SI = string (max 5 chars, up to '65536')
   342                              <1> ; OUT: AX = number
   343                              <1> 
   344                              <1> string_to_int:
   345 00000F1D 60                  <1>     pusha
   346                              <1> 
   347 00000F1E 89F0                <1>     mov ax, si
   348 00000F20 E8D8FE              <1>     call string_length
   349                              <1> 
   350 00000F23 01C6                <1>     add si, ax
   351 00000F25 4E                  <1>     dec si
   352                              <1> 
   353 00000F26 89C1                <1>     mov cx, ax
   354                              <1> 
   355 00000F28 BB0000              <1>     mov bx, 0
   356 00000F2B B80000              <1>     mov ax, 0
   357                              <1> 
   358 00000F2E C706[600F]0100      <1>     mov word [.multiplier], 1
   359                              <1> 
   360                              <1>     .loop:
   361 00000F34 B80000              <1>         mov ax, 0
   362 00000F37 8A04                <1>         mov byte al, [si]
   363 00000F39 2C30                <1>         sub al, 48
   364                              <1> 
   365 00000F3B F726[600F]          <1>         mul word [.multiplier]
   366 00000F3F 01C3                <1>         add bx, ax
   367                              <1> 
   368 00000F41 50                  <1>         push ax
   369 00000F42 A1[600F]            <1>         mov word ax, [.multiplier]
   370 00000F45 BA0A00              <1>         mov dx, 10
   371 00000F48 F7E2                <1>         mul dx
   372 00000F4A A3[600F]            <1>         mov word [.multiplier], ax
   373 00000F4D 58                  <1>         pop ax
   374                              <1> 
   375 00000F4E 49                  <1>         dec cx
   376 00000F4F 83F900              <1>         cmp cx, 0
   377 00000F52 7403                <1>         je .finish
   378 00000F54 4E                  <1>         dec si
   379 00000F55 EBDD                <1>         jmp .loop
   380                              <1>     
   381                              <1>     .finish:
   382 00000F57 891E[620F]          <1>         mov word [.tmp], bx
   383 00000F5B 61                  <1>         popa
   384 00000F5C A1[620F]            <1>         mov word ax, [.tmp]
   385                              <1> 
   386 00000F5F C3                  <1>         ret
   387                              <1> 
   388 00000F60 0000                <1>     .multiplier dw 0
   389 00000F62 0000                <1>     .tmp        dw 0
   390                              <1> 
   391                              <1> ; ------------------------------------------------------------------
   392                              <1> ; int_to_string -- Convert unsigned integer to a string
   393                              <1> ; IN: AX = unsigned int
   394                              <1> ; OUT: AX = string
   395                              <1> 
   396                              <1> int_to_string:
   397 00000F64 60                  <1>     pusha
   398                              <1> 
   399 00000F65 B90000              <1>     mov cx, 0
   400 00000F68 BB0A00              <1>     mov bx, 10
   401 00000F6B BF[8B0F]            <1>     mov di, .t
   402                              <1> 
   403                              <1>     .push:
   404 00000F6E BA0000              <1>         mov dx, 0
   405 00000F71 F7F3                <1>         div bx
   406 00000F73 41                  <1>         inc cx
   407 00000F74 52                  <1>         push dx
   408 00000F75 85C0                <1>         test ax, ax
   409 00000F77 75F5                <1>         jnz .push
   410                              <1> 
   411                              <1>     .pop:
   412 00000F79 5A                  <1>         pop dx
   413 00000F7A 80C230              <1>         add dl, '0'
   414 00000F7D 8815                <1>         mov [di], dl
   415 00000F7F 47                  <1>         inc di
   416 00000F80 49                  <1>         dec cx
   417 00000F81 75F6                <1>         jnz .pop
   418                              <1> 
   419 00000F83 C60500              <1>         mov byte [di], 0
   420                              <1> 
   421 00000F86 61                  <1>         popa
   422 00000F87 B8[8B0F]            <1>         mov ax, .t
   423 00000F8A C3                  <1>         ret
   424                              <1> 
   425 00000F8B 00<rept>            <1>         .t times 7 db 0
   426                              <1> 
   427                              <1> ; ------------------------------------------------------------------
   428                              <1> ; sint_to_string -- Convert signed integer to string
   429                              <1> ; IN: AX = signed int
   430                              <1> ; OUT: AX = string location
   431                              <1> 
   432                              <1> sint_to_string:
   433 00000F92 60                  <1>     pusha
   434                              <1> 
   435 00000F93 B90000              <1>     mov cx, 0
   436 00000F96 BB0A00              <1>     mov bx, 10
   437 00000F99 BF[C70F]            <1>     mov di, .t
   438                              <1> 
   439 00000F9C 85C0                <1>     test ax, ax
   440 00000F9E 7802                <1>     js .neg
   441 00000FA0 EB08                <1>     jmp .push
   442                              <1> 
   443                              <1>     .neg:
   444 00000FA2 F7D8                <1>         neg ax
   445 00000FA4 C606[C70F]2D        <1>         mov byte [.t], '-'
   446 00000FA9 47                  <1>         inc di
   447                              <1>     
   448                              <1>     .push:
   449 00000FAA BA0000              <1>         mov dx, 0
   450 00000FAD F7F3                <1>         div bx
   451 00000FAF 41                  <1>         inc cx
   452 00000FB0 52                  <1>         push dx
   453 00000FB1 85C0                <1>         test ax, ax
   454 00000FB3 75F5                <1>         jnz .push
   455                              <1> 
   456                              <1>     .pop:
   457 00000FB5 5A                  <1>         pop dx
   458 00000FB6 80C230              <1>         add dl, '0'
   459 00000FB9 8815                <1>         mov [di], dl
   460 00000FBB 47                  <1>         inc di
   461 00000FBC 49                  <1>         dec cx
   462 00000FBD 75F6                <1>         jnz .pop
   463                              <1> 
   464 00000FBF C60500              <1>         mov byte [di], 0
   465                              <1> 
   466 00000FC2 61                  <1>         popa
   467 00000FC3 B8[C70F]            <1>         mov ax, .t
   468 00000FC6 C3                  <1>         ret
   469                              <1> 
   470 00000FC7 00<rept>            <1>         .t times 7 db 0
   471                              <1>         
   472                              <1> ; ------------------------------------------------------------------
   473                              <1> ; lint_to_string -- Convert long integer to string
   474                              <1> ; IN: DX:AX = long unsigned int, BX = number base, DI = string location
   475                              <1> ; OUT: DI = location of converted string
   476                              <1> 
   477                              <1> lint_to_string:
   478 00000FCE 60                  <1>     pusha
   479                              <1> 
   480 00000FCF 89FE                <1>     mov si, di
   481 00000FD1 C7050000            <1>     mov word [di], 0
   482                              <1> 
   483 00000FD5 83FB25              <1>     cmp bx, 37
   484 00000FD8 773B                <1>     ja .done
   485                              <1> 
   486 00000FDA 83FB00              <1>     cmp bx, 0
   487 00000FDD 7436                <1>     je .done
   488                              <1> 
   489                              <1>     .conversion_loop:
   490 00000FDF B90000              <1>         mov cx, 0
   491                              <1> 
   492 00000FE2 91                  <1>         xchg ax, cx
   493 00000FE3 92                  <1>         xchg ax, dx
   494 00000FE4 F7F3                <1>         div bx
   495                              <1> 
   496 00000FE6 91                  <1>         xchg ax, cx
   497 00000FE7 F7F3                <1>         div bx
   498 00000FE9 87CA                <1>         xchg cx, dx
   499                              <1>     
   500                              <1>     .save_digit:
   501 00000FEB 83F909              <1>         cmp cx, 9
   502 00000FEE 7E03                <1>         jle .convert_digit
   503                              <1> 
   504 00000FF0 83C107              <1>         add cx, 'A'-'9'-1
   505                              <1> 
   506                              <1>     .convert_digit:
   507 00000FF3 83C130              <1>         add cx, '0'
   508                              <1> 
   509 00000FF6 50                  <1>         push ax
   510 00000FF7 53                  <1>         push bx
   511 00000FF8 89F0                <1>         mov ax, si
   512 00000FFA E8FEFD              <1>         call string_length
   513                              <1> 
   514 00000FFD 89F7                <1>         mov di, si
   515 00000FFF 01C7                <1>         add di, ax
   516 00001001 40                  <1>         inc ax
   517                              <1>     
   518                              <1>     .move_string_up:
   519 00001002 8A1D                <1>         mov bl, [di]
   520 00001004 885D01              <1>         mov [di+1], bl
   521 00001007 4F                  <1>         dec di
   522 00001008 48                  <1>         dec ax
   523 00001009 75F7                <1>         jnz .move_string_up
   524                              <1> 
   525 0000100B 5B                  <1>         pop bx
   526 0000100C 58                  <1>         pop ax
   527 0000100D 880C                <1>         mov [si], cl
   528                              <1>     
   529                              <1>     .test_end:
   530 0000100F 89D1                <1>         mov cx, dx
   531 00001011 09C1                <1>         or cx, ax
   532 00001013 75CA                <1>         jnz .conversion_loop
   533                              <1>     
   534                              <1>     .done:
   535 00001015 61                  <1>         popa
   536 00001016 C3                  <1>         ret
   537                              <1>         
   538                              <1> ; ------------------------------------------------------------------
   539                              <1> ; set_time_fmt -- Set time reporting format (eg '10:25 AM' or '2300 hours')
   540                              <1> ; IN: AL = format flag, 0 = 12-hr format
   541                              <1> 
   542                              <1> set_time_fmt:
   543 00001017 60                  <1> 	pusha
   544 00001018 3C00                <1> 	cmp al, 0
   545 0000101A 7402                <1> 	je .store
   546 0000101C B0FF                <1> 	mov al, 0x0FF
   547                              <1> .store:
   548 0000101E A2[C303]            <1> 	mov [fmt_12_24], al
   549 00001021 61                  <1> 	popa
   550 00001022 C3                  <1> 	ret
   551                              <1> 
   552                              <1> 
   553                              <1> ; ------------------------------------------------------------------
   554                              <1> ; get_time_string -- Get current time in a string (eg '10:25')
   555                              <1> ; OUT: BX = string location
   556                              <1> 
   557                              <1> get_time_string:
   558 00001023 60                  <1> 	pusha
   559                              <1> 
   560 00001024 89DF                <1> 	mov di, bx
   561                              <1> 
   562 00001026 F8                  <1> 	clc
   563 00001027 B402                <1> 	mov ah, 2
   564 00001029 CD1A                <1> 	int 0x1A
   565 0000102B 7305                <1> 	jnc .read
   566                              <1> 
   567 0000102D F8                  <1> 	clc
   568 0000102E B402                <1> 	mov ah, 2
   569 00001030 CD1A                <1> 	int 0x1A
   570                              <1> 
   571                              <1> .read:
   572 00001032 88E8                <1> 	mov al, ch
   573 00001034 E8460B              <1> 	call bcd_to_int
   574 00001037 89C2                <1> 	mov dx, ax
   575                              <1> 
   576 00001039 88E8                <1> 	mov al,	ch
   577 0000103B C0E804              <1> 	shr al, 4
   578 0000103E 80E50F              <1> 	and ch, 0x0F
   579 00001041 F606[C303]FF        <1> 	test byte [fmt_12_24], 0x0FF
   580 00001046 740A                <1> 	jz .twelve_hr
   581                              <1> 
   582 00001048 E86900              <1> 	call .add_digit
   583 0000104B 88E8                <1> 	mov al, ch
   584 0000104D E86400              <1> 	call .add_digit
   585 00001050 EB2F                <1> 	jmp short .minutes
   586                              <1> 
   587                              <1> .twelve_hr:
   588 00001052 83FA00              <1> 	cmp dx, 0
   589 00001055 741B                <1> 	je .midnight
   590                              <1> 
   591 00001057 83FA0A              <1> 	cmp dx, 10
   592 0000105A 7C1D                <1> 	jl .twelve_st1
   593                              <1> 
   594 0000105C 83FA0C              <1> 	cmp dx, 12
   595 0000105F 7E15                <1> 	jle .twelve_st2
   596                              <1> 
   597 00001061 89D0                <1> 	mov ax, dx
   598 00001063 83E80C              <1> 	sub ax, 12
   599 00001066 B30A                <1> 	mov bl, 10
   600 00001068 F6F3                <1> 	div bl
   601 0000106A 88E5                <1> 	mov ch, ah
   602                              <1> 
   603 0000106C 3C00                <1> 	cmp al, 0
   604 0000106E 7409                <1> 	je .twelve_st1
   605                              <1> 
   606 00001070 EB04                <1> 	jmp short .twelve_st2
   607                              <1> 
   608                              <1> .midnight:
   609 00001072 B001                <1> 	mov al, 1
   610 00001074 B502                <1> 	mov ch, 2
   611                              <1> 
   612                              <1> .twelve_st2:
   613 00001076 E83B00              <1> 	call .add_digit
   614                              <1> .twelve_st1:
   615 00001079 88E8                <1> 	mov al, ch
   616 0000107B E83600              <1> 	call .add_digit
   617                              <1> 
   618 0000107E B03A                <1> 	mov al, ':'
   619 00001080 AA                  <1> 	stosb
   620                              <1> 
   621                              <1> .minutes:
   622 00001081 88C8                <1> 	mov al, cl
   623 00001083 C0E804              <1> 	shr al, 4
   624 00001086 80E10F              <1> 	and cl, 0x0F
   625 00001089 E82800              <1> 	call .add_digit
   626 0000108C 88C8                <1> 	mov al, cl
   627 0000108E E82300              <1> 	call .add_digit
   628                              <1> 
   629 00001091 B020                <1> 	mov al, ' '
   630 00001093 AA                  <1> 	stosb
   631                              <1> 
   632 00001094 BE[B810]            <1> 	mov si, .hours_string
   633 00001097 F606[C303]FF        <1> 	test byte [fmt_12_24], 0x0FF
   634 0000109C 750B                <1> 	jnz .copy
   635                              <1> 
   636 0000109E BE[C110]            <1> 	mov si, .pm_string
   637 000010A1 83FA0C              <1> 	cmp dx, 12
   638 000010A4 7F03                <1> 	jg .copy
   639                              <1> 
   640 000010A6 BE[BE10]            <1> 	mov si, .am_string
   641                              <1> 
   642                              <1> .copy:
   643 000010A9 80C301              <1>     add bl, 1
   644 000010AC AC                  <1> 	lodsb
   645 000010AD AA                  <1> 	stosb
   646 000010AE 3C00                <1> 	cmp al, 0
   647 000010B0 75F7                <1> 	jne .copy
   648                              <1> 
   649 000010B2 61                  <1> 	popa
   650 000010B3 C3                  <1> 	ret
   651                              <1> 
   652                              <1> .add_digit:
   653 000010B4 0430                <1> 	add al, '0'
   654 000010B6 AA                  <1> 	stosb
   655 000010B7 C3                  <1> 	ret
   656                              <1> 
   657                              <1> 
   658 000010B8 686F75727300        <1> 	.hours_string	db 'hours', 0
   659 000010BE 414D00              <1> 	.am_string 	db 'AM', 0
   660 000010C1 504D00              <1> 	.pm_string 	db 'PM', 0
   661                              <1> 
   662                              <1> 
   663                              <1> ; ------------------------------------------------------------------
   664                              <1> ; set_date_fmt -- Set date reporting format (M/D/Y, D/M/Y or Y/M/D - 0, 1, 2)
   665                              <1> ; IN: AX = format flag, 0-2
   666                              <1> ; If AX bit 7 = 1 = use name for months
   667                              <1> ; If AX bit 7 = 0, high byte = separator character
   668                              <1> 
   669                              <1> set_date_fmt:
   670 000010C4 60                  <1> 	pusha
   671 000010C5 A880                <1> 	test al, 0x80
   672 000010C7 7505                <1> 	jnz .fmt_clear
   673                              <1> 
   674 000010C9 25037F              <1> 	and ax, 0x7F03
   675 000010CC EB03                <1> 	jmp short .fmt_test
   676                              <1> 
   677                              <1> .fmt_clear:
   678 000010CE 83E003              <1> 	and ax, 0003
   679                              <1> 
   680                              <1> .fmt_test:
   681 000010D1 3C03                <1> 	cmp al, 3
   682 000010D3 7303                <1> 	jae .leave
   683 000010D5 A3[C403]            <1> 	mov [fmt_date], ax
   684                              <1> 
   685                              <1> .leave:
   686 000010D8 61                  <1> 	popa
   687 000010D9 C3                  <1> 	ret
   688                              <1> 
   689                              <1> 
   690                              <1> ; ------------------------------------------------------------------
   691                              <1> ; get_date_string -- Get current date in a string (eg '12/31/2007')
   692                              <1> ; OUT: BX = string location
   693                              <1> 
   694                              <1> get_date_string:
   695 000010DA 60                  <1> 	pusha
   696                              <1> 
   697 000010DB 89DF                <1> 	mov di, bx
   698 000010DD 8B1E[C403]          <1> 	mov bx, [fmt_date]
   699 000010E1 81E3037F            <1> 	and bx, 0x7F03
   700                              <1> 
   701 000010E5 F8                  <1> 	clc
   702 000010E6 B404                <1> 	mov ah, 4
   703 000010E8 CD1A                <1> 	int 0x1A
   704 000010EA 7305                <1> 	jnc .read
   705                              <1> 
   706 000010EC F8                  <1> 	clc
   707 000010ED B404                <1> 	mov ah, 4
   708 000010EF CD1A                <1> 	int 0x1A
   709                              <1> 
   710                              <1> .read:
   711 000010F1 80FB02              <1> 	cmp bl, 2
   712 000010F4 751C                <1> 	jne .try_fmt1
   713                              <1> 
   714 000010F6 88EC                <1> 	mov ah, ch
   715 000010F8 E8A000              <1> 	call .add_2digits
   716 000010FB 88CC                <1> 	mov ah, cl
   717 000010FD E89B00              <1> 	call .add_2digits
   718 00001100 B02F                <1> 	mov al, '/'
   719 00001102 AA                  <1> 	stosb
   720                              <1> 
   721 00001103 88F4                <1> 	mov ah, dh
   722 00001105 E89300              <1> 	call .add_2digits
   723 00001108 B02F                <1> 	mov al, '/'
   724 0000110A AA                  <1> 	stosb
   725                              <1> 
   726 0000110B 88D4                <1> 	mov ah, dl
   727 0000110D E88B00              <1> 	call .add_2digits
   728 00001110 EB71                <1> 	jmp .done
   729                              <1> 
   730                              <1> .try_fmt1:
   731 00001112 80FB01              <1> 	cmp bl, 1
   732 00001115 7536                <1> 	jne .do_fmt0
   733                              <1> 
   734 00001117 88D4                <1> 	mov ah, dl
   735 00001119 E86D00              <1> 	call .add_1or2digits
   736                              <1> 
   737 0000111C 88F8                <1> 	mov al, bh
   738 0000111E 80FF00              <1> 	cmp bh, 0
   739 00001121 7502                <1> 	jne .fmt1_day
   740                              <1> 
   741 00001123 B020                <1> 	mov al, ' '
   742                              <1> 
   743                              <1> .fmt1_day:
   744 00001125 AA                  <1> 	stosb
   745                              <1> 
   746 00001126 88F4                <1> 	mov ah,	dh
   747 00001128 80FF00              <1> 	cmp bh, 0
   748 0000112B 7509                <1> 	jne .fmt1_month
   749                              <1> 
   750 0000112D E87F00              <1> 	call .add_month
   751 00001130 B82C20              <1> 	mov ax, ', '
   752 00001133 AB                  <1> 	stosw
   753 00001134 EB06                <1> 	jmp short .fmt1_century
   754                              <1> 
   755                              <1> .fmt1_month:
   756 00001136 E85000              <1> 	call .add_1or2digits
   757 00001139 88F8                <1> 	mov al, bh
   758 0000113B AA                  <1> 	stosb
   759                              <1> 
   760                              <1> .fmt1_century:
   761 0000113C 88EC                <1> 	mov ah,	ch
   762 0000113E 80FC00              <1> 	cmp ah, 0
   763 00001141 7403                <1> 	je .fmt1_year
   764                              <1> 
   765 00001143 E84300              <1> 	call .add_1or2digits
   766                              <1> 
   767                              <1> .fmt1_year:
   768 00001146 88CC                <1> 	mov ah, cl
   769 00001148 E85000              <1> 	call .add_2digits
   770                              <1> 
   771 0000114B EB36                <1> 	jmp .done
   772                              <1> 
   773                              <1> .do_fmt0:
   774 0000114D 88F4                <1> 	mov ah,	dh
   775 0000114F 80FF00              <1> 	cmp bh, 0
   776 00001152 7508                <1> 	jne .fmt0_month
   777                              <1> 
   778 00001154 E85800              <1> 	call .add_month
   779 00001157 B020                <1> 	mov al, ' '
   780 00001159 AA                  <1> 	stosb
   781 0000115A EB06                <1> 	jmp short .fmt0_day
   782                              <1> 
   783                              <1> .fmt0_month:
   784 0000115C E82A00              <1> 	call .add_1or2digits
   785 0000115F 88F8                <1> 	mov al, bh
   786 00001161 AA                  <1> 	stosb
   787                              <1> 
   788                              <1> .fmt0_day:
   789 00001162 88D4                <1> 	mov ah, dl
   790 00001164 E82200              <1> 	call .add_1or2digits
   791                              <1> 
   792 00001167 88F8                <1> 	mov al, bh
   793 00001169 80FF00              <1> 	cmp bh, 0
   794 0000116C 7505                <1> 	jne .fmt0_day2
   795                              <1> 
   796 0000116E B02C                <1> 	mov al, ','
   797 00001170 AA                  <1> 	stosb
   798 00001171 B020                <1> 	mov al, ' '
   799                              <1> 
   800                              <1> .fmt0_day2:
   801 00001173 AA                  <1> 	stosb
   802                              <1> 
   803                              <1> .fmt0_century:
   804 00001174 88EC                <1> 	mov ah,	ch
   805 00001176 80FC00              <1> 	cmp ah, 0
   806 00001179 7403                <1> 	je .fmt0_year
   807                              <1> 
   808 0000117B E80B00              <1> 	call .add_1or2digits
   809                              <1> 
   810                              <1> .fmt0_year:
   811 0000117E 88CC                <1> 	mov ah, cl
   812 00001180 E81800              <1> 	call .add_2digits
   813                              <1> 
   814                              <1> 
   815                              <1> .done:
   816 00001183 B80000              <1> 	mov ax, 0
   817 00001186 AB                  <1> 	stosw
   818                              <1> 
   819 00001187 61                  <1> 	popa
   820 00001188 C3                  <1> 	ret
   821                              <1> 
   822                              <1> 
   823                              <1> .add_1or2digits:
   824 00001189 F6C4F0              <1> 	test ah, 0x0F0
   825 0000118C 7405                <1> 	jz .only_one
   826 0000118E E80A00              <1> 	call .add_2digits
   827 00001191 EB07                <1> 	jmp short .two_done
   828                              <1> .only_one:
   829 00001193 88E0                <1> 	mov al, ah
   830 00001195 240F                <1> 	and al, 0x0F
   831 00001197 E81100              <1> 	call .add_digit
   832                              <1> .two_done:
   833 0000119A C3                  <1> 	ret
   834                              <1> 
   835                              <1> .add_2digits:
   836 0000119B 88E0                <1> 	mov al, ah
   837 0000119D C0E804              <1> 	shr al, 4
   838 000011A0 E80800              <1> 	call .add_digit
   839 000011A3 88E0                <1> 	mov al, ah
   840 000011A5 240F                <1> 	and al, 0x0F
   841 000011A7 E80100              <1> 	call .add_digit
   842 000011AA C3                  <1> 	ret
   843                              <1> 
   844                              <1> .add_digit:
   845 000011AB 0430                <1> 	add al, '0'
   846 000011AD AA                  <1> 	stosb
   847 000011AE C3                  <1> 	ret
   848                              <1> 
   849                              <1> .add_month:
   850 000011AF 53                  <1> 	push bx
   851 000011B0 51                  <1> 	push cx
   852 000011B1 88E0                <1> 	mov al, ah
   853 000011B3 E8C709              <1> 	call bcd_to_int
   854 000011B6 FEC8                <1> 	dec al
   855 000011B8 B304                <1> 	mov bl, 4
   856 000011BA F6E3                <1> 	mul bl
   857 000011BC BE[D011]            <1> 	mov si, .months
   858 000011BF 01C6                <1> 	add si, ax
   859 000011C1 B90400              <1> 	mov cx, 4
   860 000011C4 F3A4                <1> 	rep movsb
   861 000011C6 807DFF20            <1> 	cmp byte [di-1], ' '
   862 000011CA 7501                <1> 	jne .done_month
   863 000011CC 4F                  <1> 	dec di
   864                              <1> .done_month:
   865 000011CD 59                  <1> 	pop cx
   866 000011CE 5B                  <1> 	pop bx
   867 000011CF C3                  <1> 	ret
   868                              <1> 
   869 000011D0 4A616E2E4665622E4D- <1> 	.months db 'Jan.Feb.Mar.Apr.May JuneJulyAug.SeptOct.Nov.Dec.'
   869 000011D9 61722E4170722E4D61- <1>
   869 000011E2 79204A756E654A756C- <1>
   869 000011EB 794175672E53657074- <1>
   869 000011F4 4F63742E4E6F762E44- <1>
   869 000011FD 65632E              <1>
   870                              <1> 
   871                              <1> ; ------------------------------------------------------------------
   872                              <1> ; string_tokenize -- Reads tokens separated by specified char from
   873                              <1> ; a string. Returns pointer to next token, or 0 if none left
   874                              <1> ; IN: AL = separator char, SI = beginning
   875                              <1> ; OUT: DI = next token or 0 if none
   876                              <1> 
   877                              <1> string_tokenize:
   878 00001200 56                  <1> 	push si
   879                              <1> 
   880                              <1>     .next_char:
   881 00001201 3804                <1> 	    cmp byte [si], al
   882 00001203 7408                <1> 	    je .return_token
   883 00001205 803C00              <1> 	    cmp byte [si], 0
   884 00001208 740B                <1> 	    jz .no_more
   885 0000120A 46                  <1> 	    inc si
   886 0000120B EBF4                <1> 	    jmp .next_char
   887                              <1> 
   888                              <1>     .return_token:
   889 0000120D C60400              <1> 	    mov byte [si], 0
   890 00001210 46                  <1> 	    inc si
   891 00001211 89F7                <1> 	    mov di, si
   892 00001213 5E                  <1> 	    pop si
   893 00001214 C3                  <1> 	    ret
   894                              <1> 
   895                              <1>     .no_more:
   896 00001215 BF0000              <1> 	    mov di, 0
   897 00001218 5E                  <1> 	    pop si
   898 00001219 C3                  <1> 	    ret
   899                              <1> 
   900                              <1> ; ------------------------------------------------------------------
   901                              <1> ; string_clear -- Clears a variable
   902                              <1> ; IN: DI  = variable, AX = length
   903                              <1> ; OUT: empty variable
   904                              <1> 
   905                              <1> string_clear:
   906 0000121A 60                  <1>     pusha
   907 0000121B BBFFFF              <1>     mov bx, -1
   908                              <1>     
   909                              <1>     .loop:
   910 0000121E 30C0                <1>         xor al, al
   911 00001220 AA                  <1>         stosb
   912                              <1>         
   913 00001221 43                  <1>         inc bx
   914                              <1> 
   915 00001222 39D8                <1>         cmp ax, bx
   916 00001224 75F8                <1>         jne .loop
   917 00001226 61                  <1>         popa
   918 00001227 C3                  <1>         ret
   919                              <1> 
   920                              <1> ; ==================================================================
   372                                      %include "./includes/screen.asm"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; show_cursor -- Turns on cursor in text mode
     3                              <1> ; IN/OUT: Nothing
     4                              <1> 
     5                              <1> show_cursor:
     6 00001228 60                  <1> 	pusha
     7                              <1> 
     8 00001229 B506                <1> 	mov ch, 6
     9 0000122B B107                <1> 	mov cl, 7
    10 0000122D B401                <1> 	mov ah, 1
    11 0000122F B003                <1> 	mov al, 3
    12 00001231 CD10                <1> 	int 10h
    13                              <1> 
    14 00001233 61                  <1> 	popa
    15 00001234 C3                  <1> 	ret
    16                              <1> 
    17                              <1> ; ------------------------------------------------------------------
    18                              <1> ; change_cursor -- Change the cursors look
    19                              <1> ; IN: CH = 0x00/0x06
    20                              <1> 
    21                              <1> change_cursor:
    22 00001235 60                  <1> 	pusha
    23                              <1> 
    24 00001236 B401                <1> 	mov ah, 0x01
    25 00001238 B107                <1> 	mov cl, 0x07
    26 0000123A CD10                <1> 	int 10h
    27                              <1> 
    28 0000123C 61                  <1> 	popa
    29 0000123D C3                  <1> 	ret
    30                              <1> 
    31                              <1> ; ------------------------------------------------------------------
    32                              <1> ; hide_cursor -- Turns off cursor in text mode
    33                              <1> ; IN/OUT: Nothing
    34                              <1> 
    35                              <1> hide_cursor:
    36 0000123E 60                  <1> 	pusha
    37                              <1> 
    38 0000123F B520                <1> 	mov ch, 32
    39 00001241 B401                <1> 	mov ah, 1
    40 00001243 B003                <1> 	mov al, 3
    41 00001245 CD10                <1> 	int 10h
    42                              <1> 
    43 00001247 61                  <1> 	popa
    44 00001248 C3                  <1> 	ret
    45                              <1> 
    46                              <1> ; ------------------------------------------------------------------
    47                              <1> ; move_cursor -- Moves cursor in text mode
    48                              <1> ; IN: DH, DL = row, column
    49                              <1> 
    50                              <1> move_cursor:
    51 00001249 60                  <1> 	pusha
    52                              <1> 
    53 0000124A B700                <1> 	mov bh, 0
    54 0000124C B402                <1> 	mov ah, 2
    55 0000124E CD10                <1> 	int 0x10
    56                              <1> 
    57 00001250 61                  <1> 	popa
    58 00001251 C3                  <1> 	ret
    59                              <1> 
    60                              <1> ; ------------------------------------------------------------------
    61                              <1> ; get_cursor_pos -- Return position of text cursor
    62                              <1> ; OUT: DH, DL = row, column
    63                              <1> 
    64                              <1> get_cursor_pos:
    65 00001252 60                  <1> 	pusha
    66                              <1> 
    67 00001253 B700                <1> 	mov bh, 0
    68 00001255 B403                <1> 	mov ah, 3
    69 00001257 CD10                <1> 	int 0x10
    70                              <1> 
    71 00001259 8916[6312]          <1> 	mov [.tmp], dx
    72 0000125D 61                  <1> 	popa
    73 0000125E 8B16[6312]          <1> 	mov dx, [.tmp]
    74 00001262 C3                  <1> 	ret
    75                              <1> 
    76 00001263 0000                <1> 	.tmp dw 0
    77                              <1> 
    78                              <1> ; ------------------------------------------------------------------
    79                              <1> ; print_horiz_line -- Draw a horizontal line on the screen
    80                              <1> ; IN: AX = line type (1 for double (=), otherwise single (-))
    81                              <1> 
    82                              <1> print_horiz_line:
    83 00001265 60                  <1> 	pusha
    84                              <1> 
    85 00001266 89C1                <1> 	mov cx, ax
    86 00001268 B0C4                <1> 	mov al, 196
    87                              <1> 
    88 0000126A 83F901              <1> 	cmp cx, 1
    89 0000126D 7502                <1> 	jne .ready
    90 0000126F B0CD                <1> 	mov al, 205
    91                              <1> 
    92                              <1> 	.ready:
    93 00001271 B90000              <1> 		mov cx, 0
    94 00001274 B40E                <1> 		mov ah, 0Eh
    95                              <1> 
    96                              <1> 	.restart:
    97 00001276 CD10                <1> 		int 0x10
    98 00001278 41                  <1> 		inc cx
    99 00001279 83F950              <1> 		cmp cx, 80
   100 0000127C 7402                <1> 		je .done
   101 0000127E EBF6                <1> 		jmp .restart
   102                              <1> 
   103                              <1> 	.done:
   104 00001280 61                  <1> 		popa
   105 00001281 C3                  <1> 		ret
   106                              <1> 
   107                              <1> ; ------------------------------------------------------------------
   108                              <1> ; input_dialog -- Get text string from user via a dialog box
   109                              <1> ; IN: AX = string location, BX = message to show, CX = max length
   110                              <1> ; OUT: AX = string location
   111                              <1> 
   112                              <1> input_dialog:
   113 00001282 60                  <1> 	pusha
   114                              <1> 
   115 00001283 50                  <1> 	push ax
   116 00001284 53                  <1> 	push bx
   117                              <1> 
   118 00001285 B60A                <1> 	mov dh, 10
   119 00001287 B20C                <1> 	mov dl, 12
   120                              <1> 
   121                              <1> .redbox:
   122 00001289 E8BDFF              <1> 	call move_cursor
   123                              <1> 
   124 0000128C 60                  <1> 	pusha
   125 0000128D B409                <1> 	mov ah, 09h
   126 0000128F B700                <1> 	mov bh, 0
   127 00001291 B93700              <1> 	mov cx, 55
   128 00001294 B31F                <1> 	mov bl, 0x1F
   129 00001296 B020                <1> 	mov al, ' '
   130 00001298 CD10                <1> 	int 0x10
   131 0000129A 61                  <1> 	popa
   132                              <1> 
   133 0000129B FEC6                <1> 	inc dh
   134 0000129D 80FE10              <1> 	cmp dh, 16
   135 000012A0 7402                <1> 	je .boxdone
   136 000012A2 EBE5                <1> 	jmp .redbox
   137                              <1> 
   138                              <1> 
   139                              <1> .boxdone:
   140 000012A4 B20E                <1> 	mov dl, 14
   141 000012A6 B60B                <1> 	mov dh, 11
   142 000012A8 E89EFF              <1> 	call move_cursor
   143                              <1> 
   144 000012AB 5B                  <1> 	pop bx
   145 000012AC 89DE                <1> 	mov si, bx
   146 000012AE E8F008              <1> 	call print
   147                              <1> 
   148 000012B1 B20E                <1> 	mov dl, 14
   149 000012B3 B60D                <1> 	mov dh, 13
   150 000012B5 E891FF              <1> 	call move_cursor
   151                              <1> 
   152 000012B8 58                  <1> 	pop ax
   153 000012B9 89CB                <1> 	mov bx, cx
   154 000012BB E89B01              <1> 	call input_string
   155                              <1> 
   156 000012BE 61                  <1> 	popa
   157 000012BF C3                  <1> 	ret
   158                              <1> 
   159                              <1> ; ------------------------------------------------------------------
   160                              <1> ; draw_block -- Render block of specified colour
   161                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   162                              <1> 
   163                              <1> draw_block:
   164 000012C0 60                  <1> 	pusha
   165                              <1> 
   166                              <1> .more:
   167 000012C1 E885FF              <1> 	call move_cursor		; Move to block starting position
   168                              <1> 
   169 000012C4 B409                <1> 	mov ah, 09h			; Draw colour section
   170 000012C6 B700                <1> 	mov bh, 0
   171 000012C8 89F1                <1> 	mov cx, si
   172 000012CA B020                <1> 	mov al, ' '
   173 000012CC CD10                <1> 	int 10h
   174                              <1> 
   175 000012CE FEC6                <1> 	inc dh				; Get ready for next line
   176                              <1> 
   177 000012D0 B80000              <1> 	mov ax, 0
   178 000012D3 88F0                <1> 	mov al, dh			; Get current Y position into DL
   179 000012D5 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
   180 000012D7 75E8                <1> 	jne .more			; If not, keep drawing
   181                              <1> 
   182 000012D9 61                  <1> 	popa
   183 000012DA C3                  <1> 	ret
   184                              <1> 
   185                              <1> ; ------------------------------------------------------------------
   186                              <1> ; dialog_box -- Print dialog box in middle of screen, with button(s)
   187                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display)
   188                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
   189                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   190                              <1> ; NOTE: Each string is limited to 40 characters
   191                              <1> 
   192                              <1> dialog_box:
   193 000012DB 60                  <1> 	pusha
   194                              <1> 
   195 000012DC 8916[5714]          <1> 	mov [.tmp], dx
   196                              <1> 
   197 000012E0 E85BFF              <1> 	call hide_cursor
   198                              <1> 
   199 000012E3 B609                <1> 	mov dh, 9			; First, draw blue background box
   200 000012E5 B213                <1> 	mov dl, 19
   201                              <1> 
   202                              <1> .redbox:				; Loop to draw all lines of box
   203 000012E7 E85FFF              <1> 	call move_cursor
   204                              <1> 
   205 000012EA 60                  <1> 	pusha
   206 000012EB B409                <1> 	mov ah, 0x09
   207 000012ED B700                <1> 	mov bh, 0
   208 000012EF B92A00              <1> 	mov cx, 42
   209 000012F2 B31F                <1> 	mov bl, 0x1F		; White on blue
   210 000012F4 B020                <1> 	mov al, ' '
   211 000012F6 CD10                <1> 	int 10h
   212 000012F8 61                  <1> 	popa
   213                              <1> 
   214 000012F9 FEC6                <1> 	inc dh
   215 000012FB 80FE10              <1> 	cmp dh, 16
   216 000012FE 7402                <1> 	je .boxdone
   217 00001300 EBE5                <1> 	jmp .redbox
   218                              <1> 
   219                              <1> 
   220                              <1> .boxdone:
   221 00001302 83F800              <1> 	cmp ax, 0			; Skip string params if zero
   222 00001305 740C                <1> 	je .no_first_string
   223 00001307 B214                <1> 	mov dl, 20
   224 00001309 B60A                <1> 	mov dh, 10
   225 0000130B E83BFF              <1> 	call move_cursor
   226                              <1> 
   227 0000130E 89C6                <1> 	mov si, ax			; First string
   228 00001310 E88E08              <1> 	call print
   229                              <1> 
   230                              <1> .no_first_string:
   231 00001313 83FB00              <1> 	cmp bx, 0
   232 00001316 740C                <1> 	je .no_second_string
   233 00001318 B214                <1> 	mov dl, 20
   234 0000131A B60B                <1> 	mov dh, 11
   235 0000131C E82AFF              <1> 	call move_cursor
   236                              <1> 
   237 0000131F 89DE                <1> 	mov si, bx			; Second string
   238 00001321 E87D08              <1> 	call print
   239                              <1> 
   240                              <1> .no_second_string:
   241 00001324 83F900              <1> 	cmp cx, 0
   242 00001327 740C                <1> 	je .no_third_string
   243 00001329 B214                <1> 	mov dl, 20
   244 0000132B B60C                <1> 	mov dh, 12
   245 0000132D E819FF              <1> 	call move_cursor
   246                              <1> 
   247 00001330 89CE                <1> 	mov si, cx			; Third string
   248 00001332 E86C08              <1> 	call print
   249                              <1> 
   250                              <1> .no_third_string:
   251 00001335 8B16[5714]          <1> 	mov dx, [.tmp]
   252 00001339 83FA00              <1> 	cmp dx, 0
   253 0000133C 7405                <1> 	je .one_button
   254 0000133E 83FA01              <1> 	cmp dx, 1
   255 00001341 741E                <1> 	je .two_button
   256                              <1> 
   257                              <1> 
   258                              <1> .one_button:
   259 00001343 B3F0                <1> 	mov bl, 11110000b		; Black on white
   260 00001345 B60E                <1> 	mov dh, 14
   261 00001347 B223                <1> 	mov dl, 35
   262 00001349 BE0800              <1> 	mov si, 8
   263 0000134C BF0F00              <1> 	mov di, 15
   264 0000134F E86EFF              <1> 	call draw_block
   265                              <1> 
   266 00001352 B226                <1> 	mov dl, 38			; OK button, centred at bottom of box
   267 00001354 B60E                <1> 	mov dh, 14
   268 00001356 E8F0FE              <1> 	call move_cursor
   269 00001359 BE[3714]            <1> 	mov si, .ok_button_string
   270 0000135C E84208              <1> 	call print
   271                              <1> 
   272 0000135F EB2E                <1> 	jmp .one_button_wait
   273                              <1> 
   274                              <1> 
   275                              <1> .two_button:
   276 00001361 B3F0                <1> 	mov bl, 11110000b		; Black on white
   277 00001363 B60E                <1> 	mov dh, 14
   278 00001365 B21B                <1> 	mov dl, 27
   279 00001367 BE0800              <1> 	mov si, 8
   280 0000136A BF0F00              <1> 	mov di, 15
   281 0000136D E850FF              <1> 	call draw_block
   282                              <1> 
   283 00001370 B21E                <1> 	mov dl, 30			; OK button
   284 00001372 B60E                <1> 	mov dh, 14
   285 00001374 E8D2FE              <1> 	call move_cursor
   286 00001377 BE[3714]            <1> 	mov si, .ok_button_string
   287 0000137A E82408              <1> 	call print
   288                              <1> 
   289 0000137D B22C                <1> 	mov dl, 44			; Cancel button
   290 0000137F B60E                <1> 	mov dh, 14
   291 00001381 E8C5FE              <1> 	call move_cursor
   292 00001384 BE[3A14]            <1> 	mov si, .cancel_button_string
   293 00001387 E81708              <1> 	call print
   294                              <1> 
   295 0000138A B90000              <1> 	mov cx, 0			; Default button = 0
   296 0000138D EB0D                <1> 	jmp .two_button_wait
   297                              <1> 
   298                              <1> 
   299                              <1> 
   300                              <1> .one_button_wait:
   301 0000138F B400                <1> 	mov ah, 0x00
   302 00001391 CD16                <1> 	int 0x16
   303                              <1> 
   304 00001393 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
   305 00001395 75F8                <1> 	jne .one_button_wait
   306                              <1> 
   307 00001397 E88EFE              <1> 	call show_cursor
   308                              <1> 
   309 0000139A 61                  <1> 	popa
   310 0000139B C3                  <1> 	ret
   311                              <1> 
   312                              <1> 
   313                              <1> .two_button_wait:
   314 0000139C B400                <1> 	mov ah, 0x00
   315 0000139E CD16                <1> 	int 0x16
   316                              <1> 	
   317 000013A0 80FC4B              <1> 	cmp ah, 0x4B			; Left cursor key pressed?
   318 000013A3 753D                <1> 	jne .noleft
   319                              <1> 
   320 000013A5 B3F0                <1> 	mov bl, 11110000b		; Black on white
   321 000013A7 B60E                <1> 	mov dh, 14
   322 000013A9 B21B                <1> 	mov dl, 27
   323 000013AB BE0800              <1> 	mov si, 8
   324 000013AE BF0F00              <1> 	mov di, 15
   325 000013B1 E80CFF              <1> 	call draw_block
   326                              <1> 
   327 000013B4 B21E                <1> 	mov dl, 30				; OK button
   328 000013B6 B60E                <1> 	mov dh, 14
   329 000013B8 E88EFE              <1> 	call move_cursor
   330 000013BB BE[3714]            <1> 	mov si, .ok_button_string
   331 000013BE E8E007              <1> 	call print
   332                              <1> 
   333 000013C1 B31F                <1> 	mov bl, 0x1F		; White on blue for cancel button
   334 000013C3 B60E                <1> 	mov dh, 14
   335 000013C5 B22A                <1> 	mov dl, 42
   336 000013C7 BE0900              <1> 	mov si, 9
   337 000013CA BF0F00              <1> 	mov di, 15
   338 000013CD E8F0FE              <1> 	call draw_block
   339                              <1> 
   340 000013D0 B22C                <1> 	mov dl, 44				; Cancel button
   341 000013D2 B60E                <1> 	mov dh, 14
   342 000013D4 E872FE              <1> 	call move_cursor
   343 000013D7 BE[3A14]            <1> 	mov si, .cancel_button_string
   344 000013DA E8C407              <1> 	call print
   345                              <1> 
   346 000013DD B90000              <1> 	mov cx, 0				; And update result we'll return
   347 000013E0 EBBA                <1> 	jmp .two_button_wait
   348                              <1> 
   349                              <1> 
   350                              <1> .noleft:
   351 000013E2 80FC4D              <1> 	cmp ah, 0x4D			; Right cursor key pressed?
   352 000013E5 753E                <1> 	jne .noright
   353                              <1> 
   354                              <1> 
   355 000013E7 B31F                <1> 	mov bl, 0x1F		; Black on white
   356 000013E9 B60E                <1> 	mov dh, 14
   357 000013EB B21B                <1> 	mov dl, 27
   358 000013ED BE0800              <1> 	mov si, 8
   359 000013F0 BF0F00              <1> 	mov di, 15
   360 000013F3 E8CAFE              <1> 	call draw_block
   361                              <1> 
   362 000013F6 B21E                <1> 	mov dl, 30				; OK button
   363 000013F8 B60E                <1> 	mov dh, 14
   364 000013FA E84CFE              <1> 	call move_cursor
   365 000013FD BE[3714]            <1> 	mov si, .ok_button_string
   366 00001400 E89E07              <1> 	call print
   367                              <1> 
   368 00001403 B3F0                <1> 	mov bl, 11110000b		; White on blue for cancel button
   369 00001405 B60E                <1> 	mov dh, 14
   370 00001407 B22B                <1> 	mov dl, 43
   371 00001409 BE0800              <1> 	mov si, 8
   372 0000140C BF0F00              <1> 	mov di, 15
   373 0000140F E8AEFE              <1> 	call draw_block
   374                              <1> 
   375 00001412 B22C                <1> 	mov dl, 44				; Cancel button
   376 00001414 B60E                <1> 	mov dh, 14
   377 00001416 E830FE              <1> 	call move_cursor
   378 00001419 BE[3A14]            <1> 	mov si, .cancel_button_string
   379 0000141C E88207              <1> 	call print
   380                              <1> 
   381 0000141F B90100              <1> 	mov cx, 1				; And update result we'll return
   382 00001422 E977FF              <1> 	jmp .two_button_wait
   383                              <1> 
   384                              <1> 
   385                              <1> .noright:
   386 00001425 3C0D                <1> 	cmp al, 13				; Wait for enter key (13) to be pressed
   387 00001427 0F8571FF            <1> 	jne .two_button_wait
   388                              <1> 
   389 0000142B E8FAFD              <1> 	call show_cursor
   390                              <1> 
   391 0000142E 890E[5714]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
   392 00001432 61                  <1> 	popa
   393 00001433 A1[5714]            <1> 	mov ax, [.tmp]
   394                              <1> 
   395 00001436 C3                  <1> 	ret
   396                              <1> 
   397                              <1> 
   398 00001437 4F4B00              <1> 	.ok_button_string	db 'OK', 0
   399 0000143A 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
   400 00001441 2020204F4B20202000  <1> 	.ok_button_noselect	db '   OK   ', 0
   401 0000144A 20202043616E63656C- <1> 	.cancel_button_noselect	db '   Cancel   ', 0
   401 00001453 20202000            <1>
   402                              <1> 
   403 00001457 0000                <1> 	.tmp dw 0
   404                              <1> 
   405                              <1> ; ------------------------------------------------------------------
   406                              <1> ; input_string --- Get a string from keyboard input
   407                              <1> ; IN: AX = output address, BX = maximum bytes of output string
   408                              <1> ; OUT: nothing
   409                              <1> 
   410                              <1> input_string:
   411 00001459 60                  <1> 	pusha
   412                              <1> 
   413                              <1> 	; If the character count is zero, don't do anything.
   414 0000145A 83FB00              <1> 	cmp bx, 0
   415 0000145D 7424                <1> 	je .done
   416                              <1> 
   417 0000145F 89C7                <1> 	mov di, ax			; DI = Current position in buffer
   418                              <1> 	
   419 00001461 4B                  <1> 	dec bx				; BX = Maximum characters in string
   420 00001462 89D9                <1> 	mov cx, bx			; CX = Remaining character count
   421                              <1> 
   422                              <1> .get_char:
   423 00001464 B400                <1> 	mov ah, 0x00
   424 00001466 CD16                <1> 	int 0x16
   425                              <1> 
   426 00001468 3C08                <1> 	cmp al, 8
   427 0000146A 7419                <1> 	je .backspace
   428                              <1> 
   429 0000146C 3C0D                <1> 	cmp al, 13			; The ENTER key ends the prompt
   430 0000146E 7410                <1> 	je .end_string
   431                              <1> 
   432                              <1> 	; Do not add any characters if the maximum size has been reached.
   433 00001470 E3F2                <1> 	jcxz .get_char
   434                              <1> 
   435                              <1> 	; Only add printable characters (ASCII Values 32-126)
   436 00001472 3C20                <1> 	cmp al, ' '
   437 00001474 72EE                <1> 	jb .get_char
   438                              <1> 
   439 00001476 3C7E                <1> 	cmp al, 126
   440 00001478 77EA                <1> 	ja .get_char
   441                              <1> 
   442 0000147A E83100              <1> 	call .add_char
   443                              <1> 
   444 0000147D 49                  <1> 	dec cx
   445 0000147E EBE4                <1> 	jmp .get_char
   446                              <1> 
   447                              <1> .end_string:
   448 00001480 B000                <1> 	mov al, 0
   449 00001482 AA                  <1> 	stosb
   450                              <1> 
   451                              <1> .done:
   452 00001483 61                  <1> 	popa
   453 00001484 C3                  <1> 	ret
   454                              <1> 
   455                              <1> .backspace:
   456                              <1> 	; Check if there are any characters to backspace
   457 00001485 39D9                <1> 	cmp cx, bx 
   458 00001487 73DB                <1> 	jae .get_char
   459                              <1> 
   460 00001489 41                  <1> 	inc cx				; Increase characters remaining
   461                              <1> 
   462 0000148A E80A00              <1> 	call .reverse_cursor		; Move back to the previous character
   463 0000148D B020                <1> 	mov al, ' '			; Print a space on the character
   464 0000148F E81C00              <1> 	call .add_char
   465 00001492 E80200              <1> 	call .reverse_cursor		; Now move the cursor back again
   466                              <1> 
   467 00001495 EBCD                <1> 	jmp .get_char
   468                              <1> 
   469                              <1> .reverse_cursor:
   470 00001497 4F                  <1> 	dec di				; Move the output pointer backwards
   471                              <1> 	
   472 00001498 E8B7FD              <1> 	call get_cursor_pos
   473 0000149B 80FA00              <1> 	cmp dl, 0			; Is the cursor at the start of line?
   474 0000149E 7406                <1> 	je .back_line
   475                              <1> 
   476 000014A0 FECA                <1> 	dec dl				; If not, just decrease the column
   477 000014A2 E8A4FD              <1> 	call move_cursor
   478 000014A5 C3                  <1> 	ret
   479                              <1> 
   480                              <1> .back_line:
   481 000014A6 FECE                <1> 	dec dh				; Otherwise, move the cursor to the end
   482 000014A8 B24F                <1> 	mov dl, 79			; of the previous line.
   483 000014AA E89CFD              <1> 	call move_cursor
   484 000014AD C3                  <1> 	ret
   485                              <1> 
   486                              <1> 
   487                              <1> .add_char:
   488 000014AE AA                  <1> 	stosb
   489 000014AF B40E                <1> 	mov ah, 0x0E			; Teletype Function
   490 000014B1 B700                <1> 	mov bh, 0			; Video Page 0
   491 000014B3 B30F                <1> 	mov bl, 0x0f
   492 000014B5 55                  <1> 	push bp				; Some BIOS's may mess up BP
   493 000014B6 CD10                <1> 	int 0x10
   494 000014B8 5D                  <1> 	pop bp
   495 000014B9 C3                  <1> 	ret
   496                              <1> 
   497                              <1> ; ------------------------------------------------------------------
   498                              <1> ; switch_mode -- Switch between VIDEO and CLI mode
   499                              <1> ; IN: AX = mode (0 for CLI and 1 for video)
   500                              <1> ;	  BH = color scheme (only background for video)
   501                              <1> ; OUT: Switches mode
   502                              <1> 
   503                              <1> switch_mode:
   504 000014BA 60                  <1> 	pusha
   505 000014BB 30DB                <1> 	xor bl, bl
   506                              <1> 
   507 000014BD 85C0                <1> 	test ax, ax
   508 000014BF 7405                <1> 	je .switch_cli
   509                              <1> 
   510 000014C1 83F801              <1> 	cmp ax, 1
   511 000014C4 740F                <1> 	je .switch_vid
   512                              <1> 
   513                              <1> .switch_cli:
   514                              <1> 	; Switch to text mode
   515 000014C6 B80300              <1> 	mov ax, cliRes
   516 000014C9 CD10                <1> 	int 0x10
   517                              <1> 
   518                              <1> 	; Change the cursor
   519 000014CB 31C9                <1> 	xor cx, cx
   520 000014CD E865FD              <1> 	call change_cursor
   521                              <1> 
   522                              <1> 	; Clear the screen and change color scheme
   523 000014D0 E812F9              <1> 	call cls
   524                              <1> 
   525 000014D3 EB0A                <1> 	jmp .done
   526                              <1> 
   527                              <1> .switch_vid:
   528                              <1> 	; Switch to video mode
   529 000014D5 B81300              <1> 	mov ax, vidRes
   530 000014D8 CD10                <1> 	int 0x10
   531                              <1> 
   532                              <1> 	; Clear the screen and change the background color
   533 000014DA E808F9              <1> 	call cls
   534                              <1> 
   535 000014DD EB00                <1> 	jmp .done
   536                              <1> 
   537                              <1> .done:
   538 000014DF 61                  <1> 	popa
   539 000014E0 C3                  <1> 	ret
   540                              <1> 
   541                              <1> ; ------------------------------------------------------------------
   542                              <1> ; setup_bottom_string -- Draw a string in the bottom of the setup screen
   543                              <1> ; IN: SI = String location
   544                              <1> 
   545                              <1> setup_bottom_string:
   546 000014E1 56                  <1> 	push si
   547 000014E2 B617                <1>     mov dh, 23
   548 000014E4 30D2                <1>     xor dl, dl
   549 000014E6 E860FD              <1>     call move_cursor
   550                              <1> 
   551 000014E9 B80100              <1>     mov ax, 1
   552 000014EC E876FD              <1>     call print_horiz_line
   553                              <1> 	
   554 000014EF 5E                  <1> 	pop si
   555 000014F0 E8AE06              <1>     call print
   556                              <1> 
   557 000014F3 31D2                <1>     xor dx, dx
   558 000014F5 E851FD              <1>     call move_cursor
   559                              <1> 
   560 000014F8 C3                  <1> 	ret
   561                              <1> 
   562                              <1> ; ------------------------------------------------------------------
   563                              <1> ; setup_input -- Get keyboard input for the setup
   564                              <1> ; IN: AX = string location
   565                              <1> ; OUT: AX = string location
   566                              <1> 
   567                              <1> setup_input:
   568 000014F9 60                  <1> 	pusha
   569 000014FA 89C7                <1> 	mov di, ax
   570 000014FC 50                  <1> 	push ax
   571                              <1> 
   572                              <1> 	; Position the mouse
   573 000014FD B403                <1> 	mov ah, 0x03
   574 000014FF B700                <1> 	mov bh, 0
   575 00001501 CD10                <1> 	int 0x10
   576                              <1> 
   577 00001503 B402                <1> 	mov ah, 0x02
   578 00001505 B21B                <1> 	mov dl, 27
   579 00001507 FEC6                <1> 	inc dh
   580 00001509 CD10                <1> 	int 0x10
   581                              <1> 
   582                              <1> 	; And draw the top/sides
   583 0000150B BE[B615]            <1> 	mov si, .top_bar
   584 0000150E E89006              <1> 	call print
   585                              <1> 
   586 00001511 B402                <1> 	mov ah, 0x02
   587 00001513 B21B                <1> 	mov dl, 27
   588 00001515 FEC6                <1> 	inc dh
   589 00001517 CD10                <1> 	int 0x10
   590                              <1> 	
   591 00001519 8836[F015]          <1> 	mov [.mouse_pos], dh
   592 0000151D BE[CF15]            <1> 	mov si, .sidl_bar
   593 00001520 E87E06              <1> 	call print
   594                              <1> 	
   595 00001523 B402                <1> 	mov ah, 0x02
   596 00001525 B21B                <1> 	mov dl, 27
   597 00001527 FEC6                <1> 	inc dh
   598 00001529 CD10                <1> 	int 0x10
   599                              <1> 
   600 0000152B BE[D615]            <1> 	mov si, .bot_bar
   601 0000152E E87006              <1> 	call print
   602                              <1> 
   603 00001531 B402                <1> 	mov ah, 0x02
   604 00001533 B21B                <1> 	mov dl, 27
   605 00001535 8A36[F015]          <1> 	mov dh, [.mouse_pos]
   606 00001539 CD10                <1> 	int 0x10
   607                              <1> 
   608 0000153B 30DB                <1> 	xor bl, bl
   609                              <1> 
   610                              <1> 	; Clear the string location
   611                              <1> .clear_loop:
   612 0000153D B000                <1> 	mov al, 0
   613 0000153F AA                  <1> 	stosb
   614 00001540 FEC3                <1> 	inc bl
   615                              <1> 
   616 00001542 80FB14              <1> 	cmp bl, 20
   617 00001545 75F6                <1> 	jne .clear_loop
   618                              <1> 
   619 00001547 B403                <1> 	mov ah, 0x03
   620 00001549 B700                <1> 	mov bh, 0
   621 0000154B CD10                <1> 	int 0x10
   622                              <1> 
   623 0000154D B402                <1> 	mov ah, 0x02
   624 0000154F B21D                <1> 	mov dl, 29
   625 00001551 CD10                <1> 	int 0x10
   626                              <1> 
   627 00001553 58                  <1> 	pop ax
   628 00001554 89C7                <1> 	mov di, ax
   629 00001556 30DB                <1> 	xor bl, bl
   630                              <1> 
   631                              <1> .input_loop:
   632 00001558 B403                <1> 	mov ah, 0x03
   633 0000155A B700                <1> 	mov bh, 0
   634 0000155C CD10                <1> 	int 0x10
   635                              <1> 
   636 0000155E 8816[F015]          <1> 	mov [.mouse_pos], dl
   637                              <1> 
   638 00001562 B402                <1> 	mov ah, 0x02
   639 00001564 B230                <1> 	mov dl, 48
   640 00001566 CD10                <1> 	int 0x10
   641                              <1> 
   642 00001568 BE[D215]            <1> 	mov si, .sidr_bar
   643 0000156B E83306              <1> 	call print
   644                              <1> 
   645 0000156E B402                <1> 	mov ah, 0x02
   646 00001570 8A16[F015]          <1> 	mov dl, [.mouse_pos]
   647 00001574 CD10                <1> 	int 0x10
   648                              <1> 
   649 00001576 B400                <1> 	mov ah, 0x00
   650 00001578 CD16                <1> 	int 0x16
   651                              <1> 
   652 0000157A 3C0D                <1> 	cmp al, 0x0d
   653 0000157C 7436                <1> 	je .input_done
   654                              <1> 
   655 0000157E 3C08                <1> 	cmp al, 0x08
   656 00001580 7524                <1> 	jne .not_back
   657                              <1> 
   658                              <1> 	; Pressed backspace
   659 00001582 B403                <1> 	mov ah, 0x03
   660 00001584 B700                <1> 	mov bh, 0
   661 00001586 CD10                <1> 	int 0x10
   662                              <1> 
   663 00001588 80FA1D              <1> 	cmp dl, 29
   664 0000158B 74CB                <1> 	je .input_loop
   665                              <1> 
   666 0000158D FECA                <1> 	dec dl
   667 0000158F FECB                <1> 	dec bl
   668                              <1> 
   669 00001591 B402                <1> 	mov ah, 0x02
   670 00001593 CD10                <1> 	int 0x10
   671                              <1> 
   672 00001595 B40E                <1> 	mov ah, 0x0e
   673 00001597 B000                <1> 	mov al, 0
   674 00001599 CD10                <1> 	int 0x10
   675                              <1> 	
   676 0000159B B402                <1> 	mov ah, 0x02
   677 0000159D CD10                <1> 	int 0x10
   678                              <1> 
   679 0000159F 4F                  <1> 	dec di
   680 000015A0 B000                <1> 	mov al, 0
   681 000015A2 AA                  <1> 	stosb
   682 000015A3 4F                  <1> 	dec di
   683                              <1> 
   684 000015A4 EBB2                <1> 	jmp .input_loop
   685                              <1> 
   686                              <1> .not_back:
   687 000015A6 80FB13              <1> 	cmp bl, 19
   688 000015A9 74AD                <1> 	je .input_loop
   689 000015AB FEC3                <1> 	inc bl
   690                              <1> 
   691 000015AD AA                  <1> 	stosb
   692                              <1> 
   693 000015AE B40E                <1> 	mov ah, 0x0e
   694 000015B0 CD10                <1> 	int 0x10
   695                              <1> 
   696 000015B2 EBA4                <1> 	jmp .input_loop 
   697                              <1> 
   698                              <1> .input_done:
   699 000015B4 61                  <1> 	popa
   700 000015B5 C3                  <1> 	ret
   701                              <1> 
   702 000015B6 DA                  <1> .top_bar:	db 0xda
   703 000015B7 C4<rept>            <1> 			times 21 db 0xc4
   704 000015CC BF0A00              <1> 			db 0xbf, 0x0a, 0
   705 000015CF B32000              <1> .sidl_bar:	db 0xb3, 0x20, 0
   706 000015D2 20B30A00            <1> .sidr_bar:	db 0x20, 0xb3, 0x0a, 0
   707 000015D6 C0                  <1> .bot_bar:	db 0xc0
   708 000015D7 C4<rept>            <1> 			times 21 db 0xc4
   709 000015EC D90A0D00            <1> 			db 0xd9, 0x0a, 0x0d, 0
   710                              <1> 
   711 000015F0 1D                  <1> .mouse_pos:	db 29
   712                              <1> 
   713                              <1> ; ------------------------------------------------------------------
   714                              <1> ; setup_choose -- Draw text and use the cursors to choose between them
   715                              <1> ; IN: AX, BX, CX = options
   716                              <1> ;	  DH = not focused color
   717                              <1> ;	  DL = focused color
   718                              <1> ; OUT: AX = options choosen (starting at 0)
   719                              <1> 
   720                              <1> setup_choose:
   721 000015F1 E84AFC              <1> 	call hide_cursor
   722 000015F4 60                  <1> 	pusha
   723 000015F5 52                  <1> 	push dx
   724                              <1> 
   725 000015F6 8A16[2917]          <1> 	mov dl, [.start_x]
   726 000015FA 8A36[2A17]          <1> 	mov dh, [.start_y]
   727 000015FE E848FC              <1> 	call move_cursor
   728 00001601 5A                  <1> 	pop dx
   729                              <1> 	
   730 00001602 89C6                <1> 	mov si, ax
   731 00001604 BF[2B17]            <1> 	mov di, .option1
   732 00001607 E87AF8              <1> 	call string_copy
   733                              <1> 	
   734 0000160A 89DE                <1> 	mov si, bx
   735 0000160C BF[5317]            <1> 	mov di, .option2
   736 0000160F E872F8              <1> 	call string_copy
   737                              <1> 
   738 00001612 89CE                <1> 	mov si, cx
   739 00001614 BF[7B17]            <1> 	mov di, .option3
   740 00001617 E86AF8              <1> 	call string_copy
   741                              <1> 
   742 0000161A 31C9                <1> 	xor cx, cx
   743 0000161C EB03                <1> 	jmp .choose_loop
   744                              <1> 
   745 0000161E E9F700              <1> 	jmp .done
   746                              <1> 
   747                              <1> .choose_loop:
   748 00001621 E84100              <1> 	call .print_options
   749 00001624 E80B00              <1> 	call .check_arrows
   750 00001627 E8C800              <1> 	call .clear_bottom
   751                              <1> 
   752 0000162A 83F803              <1> 	cmp ax, 3
   753 0000162D 75F2                <1> 	jne .choose_loop
   754 0000162F E9E600              <1> 	jmp .done
   755                              <1> 
   756                              <1> .check_arrows:
   757 00001632 60                  <1> 	pusha
   758 00001633 BE[D00D]            <1>     mov si, setup_string
   759 00001636 E8A8FE              <1>     call setup_bottom_string
   760 00001639 61                  <1> 	popa
   761                              <1> 
   762 0000163A 31C0                <1> 	xor ax, ax
   763 0000163C CD16                <1> 	int 0x16
   764                              <1> 
   765 0000163E 80FC48              <1> 	cmp ah, 0x48	; UP
   766 00001641 740A                <1> 	je .up
   767 00001643 80FC50              <1> 	cmp ah, 0x50	; DOWN
   768 00001646 740F                <1> 	je .down
   769                              <1> 
   770 00001648 3C0D                <1> 	cmp al, 0x0D	; ENTER
   771 0000164A 7415                <1> 	je .enter
   772                              <1> 
   773 0000164C C3                  <1> 	ret				; Failsafe return
   774                              <1> 
   775                              <1> 	.up:
   776 0000164D 85C9                <1> 		test cx, cx
   777 0000164F 7402                <1> 		jz .at_top
   778                              <1> 
   779 00001651 49                  <1> 		dec cx
   780 00001652 C3                  <1> 		ret
   781                              <1> 	
   782                              <1> 		.at_top:
   783 00001653 B90200              <1> 			mov cx, 2
   784 00001656 C3                  <1> 			ret
   785                              <1> 	
   786                              <1> 	.down:
   787 00001657 83F902              <1> 		cmp cx, 2
   788 0000165A 7402                <1> 		je .at_bottom
   789                              <1> 
   790 0000165C 41                  <1> 		inc cx
   791 0000165D C3                  <1> 		ret
   792                              <1> 
   793                              <1> 		.at_bottom:
   794 0000165E 31C9                <1> 			xor cx, cx
   795 00001660 C3                  <1> 			ret
   796                              <1> 
   797                              <1> 	.enter:
   798 00001661 B80300              <1> 		mov ax, 3
   799 00001664 C3                  <1> 		ret
   800                              <1> 
   801                              <1> .print_options:
   802 00001665 83F900              <1> 	cmp cx, 0
   803 00001668 740A                <1> 	je .mark_1
   804                              <1> 
   805 0000166A 83F901              <1> 	cmp cx, 1
   806 0000166D 7419                <1> 	je .mark_2
   807                              <1> 
   808 0000166F 83F902              <1> 	cmp cx, 2
   809 00001672 7428                <1> 	je .mark_3
   810                              <1> 
   811                              <1> 	.mark_1:
   812 00001674 BE[2B17]            <1> 		mov si, .option1
   813 00001677 E83F00              <1> 		call .print_marked
   814                              <1> 
   815 0000167A BE[5317]            <1> 		mov si, .option2
   816 0000167D E82F00              <1> 		call .print_normal
   817                              <1> 
   818 00001680 BE[7B17]            <1> 		mov si, .option3
   819 00001683 E82900              <1> 		call .print_normal
   820                              <1> 
   821 00001686 EB26                <1> 		jmp .mark_done
   822                              <1> 	
   823                              <1> 	.mark_2:
   824 00001688 BE[2B17]            <1> 		mov si, .option1
   825 0000168B E82100              <1> 		call .print_normal
   826                              <1> 
   827 0000168E BE[5317]            <1> 		mov si, .option2
   828 00001691 E82500              <1> 		call .print_marked
   829                              <1> 
   830 00001694 BE[7B17]            <1> 		mov si, .option3
   831 00001697 E81500              <1> 		call .print_normal
   832                              <1> 
   833 0000169A EB12                <1> 		jmp .mark_done
   834                              <1> 	
   835                              <1> 	.mark_3:
   836 0000169C BE[2B17]            <1> 		mov si, .option1
   837 0000169F E80D00              <1> 		call .print_normal
   838                              <1> 
   839 000016A2 BE[5317]            <1> 		mov si, .option2
   840 000016A5 E80700              <1> 		call .print_normal
   841                              <1> 
   842 000016A8 BE[7B17]            <1> 		mov si, .option3
   843 000016AB E80B00              <1> 		call .print_marked
   844                              <1> 
   845                              <1> 	.mark_done:
   846 000016AE C3                  <1> 		ret
   847                              <1> 
   848                              <1> .print_normal:
   849 000016AF E81700              <1> 	call .print_space
   850 000016B2 E8EC04              <1> 	call print
   851 000016B5 E82D00              <1> 	call .new_line
   852                              <1> 
   853 000016B8 C3                  <1> 	ret
   854                              <1> 
   855                              <1> .print_marked:
   856 000016B9 53                  <1> 	push bx
   857                              <1> 
   858 000016BA E80C00              <1> 	call .print_space
   859 000016BD 31DB                <1> 	xor bx, bx
   860 000016BF 88D3                <1> 	mov bl, dl
   861 000016C1 E81605              <1> 	call print_atr
   862 000016C4 E81E00              <1> 	call .new_line
   863                              <1> 
   864 000016C7 5B                  <1> 	pop bx
   865 000016C8 C3                  <1> 	ret
   866                              <1> 
   867                              <1> .print_space:
   868 000016C9 53                  <1> 	push bx
   869                              <1> 
   870 000016CA 31DB                <1> 	xor bx, bx
   871 000016CC BB2800              <1> 	mov bx, .screen_mid
   872                              <1> 	
   873 000016CF 89F0                <1> 	mov ax, si
   874 000016D1 E827F7              <1> 	call string_length
   875 000016D4 D1F8                <1> 	sar ax, 1
   876                              <1> 
   877 000016D6 29C3                <1> 	sub bx, ax
   878                              <1> 
   879                              <1> 	.space_loop:
   880 000016D8 B40E                <1> 		mov ah, 0x0e
   881 000016DA B020                <1> 		mov al, ' '
   882 000016DC CD10                <1> 		int 0x10
   883                              <1> 
   884 000016DE 4B                  <1> 		dec bx
   885 000016DF 85DB                <1> 		test bx, bx
   886 000016E1 75F5                <1> 		jnz .space_loop
   887                              <1> 
   888 000016E3 5B                  <1> 	pop bx
   889 000016E4 C3                  <1> 	ret
   890                              <1> 
   891                              <1> .new_line:
   892 000016E5 50                  <1> 	push ax
   893                              <1> 
   894 000016E6 B80A0E              <1> 	mov ax, 0x0E0A
   895 000016E9 CD10                <1> 	int 0x10
   896 000016EB B80D0E              <1> 	mov ax, 0x0E0D
   897 000016EE CD10                <1> 	int 0x10
   898                              <1> 
   899 000016F0 58                  <1> 	pop ax
   900 000016F1 C3                  <1> 	ret
   901                              <1> 
   902                              <1> .clear_bottom:
   903 000016F2 60                  <1> 	pusha
   904                              <1> 
   905 000016F3 8A36[2A17]          <1> 	mov dh, [.start_y]
   906 000016F7 8A16[2917]          <1> 	mov dl, [.start_x]
   907 000016FB E84BFB              <1> 	call move_cursor
   908                              <1> 
   909 000016FE B80A07              <1> 	mov ax, 0x070A
   910 00001701 B71F                <1> 	mov bh, 0x1F
   911 00001703 31C9                <1> 	xor cx, cx
   912 00001705 BA4F18              <1> 	mov dx, 0x184f
   913 00001708 CD10                <1> 	int 0x10
   914                              <1> 	
   915 0000170A B80A06              <1> 	mov ax, 0x060A
   916 0000170D B71F                <1> 	mov bh, 0x1F
   917 0000170F 31C9                <1> 	xor cx, cx
   918 00001711 BA4F18              <1> 	mov dx, 0x184f
   919 00001714 CD10                <1> 	int 0x10
   920                              <1> 
   921 00001716 61                  <1> 	popa
   922 00001717 C3                  <1> 	ret
   923                              <1> 
   924                              <1> .done:
   925 00001718 E8D7FF              <1> 	call .clear_bottom
   926 0000171B 890E[A317]          <1> 	mov [.option_picked], cx
   927                              <1> 
   928 0000171F 61                  <1> 	popa
   929 00001720 E805FB              <1> 	call show_cursor
   930                              <1> 
   931 00001723 0FB606[A317]        <1> 	movzx ax, [.option_picked]
   932 00001728 C3                  <1> 	ret
   933                              <1> 
   934                              <1> .screen_mid		equ 40
   935 00001729 00                  <1> .start_x:		db 0
   936 0000172A 12                  <1> .start_y:		db 18
   937                              <1> 
   938 0000172B 00<rept>            <1> .option1:		times 40 db 0
   939 00001753 00<rept>            <1> .option2:		times 40 db 0
   940 0000177B 00<rept>            <1> .option3:		times 40 db 0
   941                              <1> 
   942 000017A3 00                  <1> .option_picked:	db 0
   943                              <1> 
   944                              <1> ; ------------------------------------------------------------------
   945                              <1> ; draw_setup_box -- Draw a text box for the setup
   946                              <1> ; IN: SI = location of the string
   947                              <1> ; OUT: prints a box that's meant for the setup
   948                              <1> 
   949                              <1> draw_setup_box:
   950 000017A4 60                  <1> 	pusha
   951 000017A5 30DB                <1> 	xor bl, bl
   952                              <1> 
   953 000017A7 31D2                <1> 	xor dx, dx
   954 000017A9 E89DFA              <1> 	call move_cursor
   955                              <1> 
   956 000017AC 56                  <1> 	push si
   957 000017AD BE[1018]            <1> 	mov si, .setbox_top
   958 000017B0 E8EE03              <1> 	call print
   959                              <1> 
   960 000017B3 BE[9B18]            <1> 	mov si, .setbox_nwl
   961 000017B6 E8E803              <1> 	call print
   962                              <1> 
   963 000017B9 5E                  <1> 	pop si
   964                              <1> 
   965                              <1> .print_loop:
   966 000017BA AC                  <1> 	lodsb
   967 000017BB 84C0                <1> 	test al, al
   968 000017BD 7446                <1> 	je .done
   969                              <1> 
   970 000017BF 3C0A                <1> 	cmp al, 0x0a
   971 000017C1 740D                <1> 	je .new_line
   972                              <1> 
   973 000017C3 80FB30              <1> 	cmp bl, 48
   974 000017C6 7408                <1> 	je .new_line
   975                              <1> 
   976 000017C8 B40E                <1> 	mov ah, 0x0e
   977 000017CA CD10                <1> 	int 0x10
   978                              <1> 	
   979 000017CC FEC3                <1> 	inc bl
   980                              <1> 
   981 000017CE EBEA                <1> 	jmp .print_loop
   982                              <1> 
   983                              <1> .new_line:
   984 000017D0 E80A00              <1> 	call .finish_line
   985                              <1> 
   986 000017D3 56                  <1> 	push si
   987 000017D4 BE[9B18]            <1> 	mov si, .setbox_nwl
   988 000017D7 E8C703              <1> 	call print
   989 000017DA 5E                  <1> 	pop si
   990                              <1> 
   991 000017DB EBDD                <1> 	jmp .print_loop
   992                              <1> 
   993                              <1> .finish_line:
   994 000017DD B730                <1> 	mov bh, border_length-2
   995 000017DF 28DF                <1> 	sub bh, bl
   996                              <1> 
   997                              <1> .finish_loop:
   998 000017E1 80FF00              <1> 	cmp bh, 0
   999 000017E4 760A                <1> 	jbe .loop_done
  1000                              <1> 
  1001 000017E6 B40E                <1> 	mov ah, 0x0e
  1002 000017E8 B020                <1> 	mov al, " "
  1003 000017EA CD10                <1> 	int 0x10
  1004 000017EC FECF                <1> 	dec bh
  1005                              <1> 
  1006 000017EE EBF1                <1> 	jmp .finish_loop
  1007                              <1> 
  1008                              <1> .loop_done:
  1009 000017F0 56                  <1> 	push si
  1010 000017F1 BE[AC18]            <1> 	mov si, .setbox_fnl
  1011 000017F4 E8AA03              <1> 	call print
  1012 000017F7 5E                  <1> 	pop si
  1013 000017F8 31DB                <1> 	xor bx, bx
  1014                              <1> 
  1015 000017FA B80A0E              <1> 	mov ax, 0x0e0a
  1016 000017FD CD10                <1> 	int 0x10
  1017                              <1> 
  1018 000017FF B80D0E              <1> 	mov ax, 0x0e0d
  1019 00001802 CD10                <1> 	int 0x10
  1020                              <1> 	
  1021 00001804 C3                  <1> 	ret
  1022                              <1> 
  1023                              <1> .done:
  1024 00001805 E8D5FF              <1> 	call .finish_line
  1025                              <1> 
  1026 00001808 BE[5618]            <1> 	mov si, .setbox_bot
  1027 0000180B E89303              <1> 	call print
  1028                              <1> 
  1029 0000180E 61                  <1> 	popa
  1030 0000180F C3                  <1> 	ret
  1031                              <1> 	
  1032                              <1> 
  1033 00001810 0A                  <1> .setbox_top:	db 0x0a
  1034 00001811 20<rept>            <1>         		times edge_width db " "
  1035 0000181F DA                  <1>                 db 0xDA
  1036 00001820 C4<rept>            <1>                 times border_length db 0xC4
  1037 00001852 BF0A0D00            <1>                 db 0xBF, 0x0a, 0x0d, 0
  1038                              <1> 
  1039 00001856 20<rept>            <1> .setbox_bot:	times edge_width db " "
  1040 00001864 C0                  <1>                 db 0xC0
  1041 00001865 C4<rept>            <1>                 times border_length db 0xC4
  1042 00001897 D90A0D00            <1>                 db 0xD9, 0x0a, 0x0d, 0
  1043                              <1> 
  1044 0000189B 20<rept>            <1> .setbox_nwl:	times edge_width db " "
  1045 000018A9 B32000              <1> 				db 0xB3, " ", 0
  1046                              <1> 
  1047 000018AC 20B300              <1> .setbox_fnl:	db " ", 0xB3, 0
  1048                              <1> 
  1049                              <1> ; ------------------------------------------------------------------
  1050                              <1> ; draw_box -- Draw a box
  1051                              <1> ; IN: AL = color
  1052                              <1> ;	  BX = end x position
  1053                              <1> ;	  CX = end y position
  1054                              <1> ;	  DH = start x position
  1055                              <1> ;	  DL = start y position
  1056                              <1> ; OUT: Draws box
  1057                              <1> 
  1058                              <1> draw_box:
  1059 000018AF 60                  <1> 	pusha
  1060                              <1> 
  1061 000018B0 8836[E818]          <1> 	mov [.startx], dh
  1062 000018B4 8816[EA18]          <1> 	mov [.starty], dl
  1063 000018B8 891E[EC18]          <1> 	mov [.endx], bx
  1064 000018BC 890E[EE18]          <1> 	mov [.endy], cx
  1065                              <1> 
  1066 000018C0 8B0E[E818]          <1> 	mov cx, [.startx]
  1067 000018C4 8B16[EA18]          <1> 	mov dx, [.starty]
  1068 000018C8 B40C                <1> 	mov ah, 0x0C
  1069                              <1> 
  1070                              <1> 	.x_loop:
  1071 000018CA 3B0E[EC18]          <1> 		cmp cx, [.endx]
  1072 000018CE 7405                <1> 		je .y_loop
  1073                              <1> 
  1074 000018D0 CD10                <1> 		int 0x10
  1075                              <1> 
  1076 000018D2 41                  <1> 		inc cx
  1077 000018D3 EBF5                <1> 		jmp .x_loop
  1078                              <1> 
  1079                              <1> 	.y_loop:
  1080 000018D5 CD10                <1> 		int 0x10
  1081                              <1> 
  1082 000018D7 3B16[EE18]          <1> 		cmp dx, [.endy]
  1083 000018DB 7407                <1> 		je .done
  1084                              <1> 
  1085 000018DD 8B0E[E818]          <1> 		mov cx, [.startx]
  1086 000018E1 42                  <1> 		inc dx
  1087 000018E2 EBE6                <1> 		jmp .x_loop
  1088                              <1> 	
  1089                              <1> 	.done:
  1090 000018E4 61                  <1> 		popa
  1091 000018E5 C3                  <1> 		ret
  1092                              <1> 
  1093 000018E6 0000                <1> 	.tmp:    dw 0
  1094 000018E8 0000                <1> 	.startx: dw 0
  1095 000018EA 0000                <1> 	.starty: dw 0
  1096 000018EC 0000                <1> 	.endx:   dw 0
  1097 000018EE 0000                <1> 	.endy:	 dw 0
  1098                              <1> 
  1099                              <1> ; ------------------------------------------------------------------
  1100                              <1> ; list_dialog -- Show a dialog with a list of options
  1101                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1102                              <1> ;     BX = first help string, CX = second help string
  1103                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1104                              <1> 
  1105                              <1> list_dialog:
  1106 000018F0 60                  <1> 	pusha
  1107                              <1> 
  1108 000018F1 50                  <1> 	push ax				; Store string list for now
  1109                              <1> 
  1110 000018F2 51                  <1> 	push cx				; And help strings
  1111 000018F3 53                  <1> 	push bx
  1112                              <1> 
  1113 000018F4 E847F9              <1> 	call hide_cursor
  1114                              <1> 
  1115                              <1> 
  1116 000018F7 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1117 000018F9 89C6                <1> 	mov si, ax
  1118                              <1> .count_loop:
  1119 000018FB AC                  <1> 	lodsb
  1120 000018FC 3C00                <1> 	cmp al, 0
  1121 000018FE 7408                <1> 	je .done_count
  1122 00001900 3C2C                <1> 	cmp al, ','
  1123 00001902 75F7                <1> 	jne .count_loop
  1124 00001904 FEC1                <1> 	inc cl
  1125 00001906 EBF3                <1> 	jmp .count_loop
  1126                              <1> 
  1127                              <1> .done_count:
  1128 00001908 FEC1                <1> 	inc cl
  1129 0000190A 880E[631A]          <1> 	mov byte [.num_of_entries], cl
  1130                              <1> 
  1131 0000190E B39F                <1> 	mov bl, 0x9F		; White on light blue
  1132 00001910 B20F                <1> 	mov dl, 15			; Start X position
  1133 00001912 B602                <1> 	mov dh, 2			; Start Y position
  1134 00001914 BE3200              <1> 	mov si, 50			; Width
  1135 00001917 BF1700              <1> 	mov di, 23			; Finish Y position
  1136 0000191A E8A3F9              <1> 	call draw_block		; Draw option selector window
  1137                              <1> 
  1138 0000191D B210                <1> 	mov dl, 16			; Show first line of help text...
  1139 0000191F B603                <1> 	mov dh, 3
  1140 00001921 E825F9              <1> 	call move_cursor
  1141                              <1> 
  1142 00001924 5E                  <1> 	pop si				; Get back first string
  1143 00001925 E87902              <1> 	call print
  1144                              <1> 
  1145 00001928 FEC6                <1> 	inc dh				; ...and the second
  1146 0000192A E81CF9              <1> 	call move_cursor
  1147                              <1> 
  1148 0000192D 5E                  <1> 	pop si
  1149 0000192E E87002              <1> 	call print
  1150                              <1> 
  1151                              <1> 
  1152 00001931 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1153 00001932 8936[651A]          <1> 	mov word [.list_string], si
  1154                              <1> 
  1155                              <1> 
  1156                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1157                              <1> 	; entry and let the user move up and down using the cursor keys
  1158                              <1> 
  1159 00001936 C606[641A]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1160                              <1> 
  1161 0000193B B214                <1> 	mov dl, 20			; Set up starting position for selector
  1162 0000193D B607                <1> 	mov dh, 7
  1163                              <1> 
  1164 0000193F E807F9              <1> 	call move_cursor
  1165                              <1> 
  1166                              <1> .more_select:
  1167 00001942 60                  <1> 	pusha
  1168 00001943 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1169 00001945 B210                <1> 	mov dl, 16
  1170 00001947 B606                <1> 	mov dh, 6
  1171 00001949 BE3000              <1> 	mov si, 48
  1172 0000194C BF1600              <1> 	mov di, 22
  1173 0000194F E86EF9              <1> 	call draw_block
  1174 00001952 61                  <1> 	popa
  1175                              <1> 
  1176 00001953 E8E100              <1> 	call .draw_black_bar
  1177                              <1> 
  1178 00001956 8B36[651A]          <1> 	mov word si, [.list_string]
  1179 0000195A E89A00              <1> 	call .draw_list
  1180                              <1> 
  1181                              <1> .another_key:
  1182 0000195D B400                <1> 	mov ah, 0x00
  1183 0000195F CD16                <1> 	int 0x16
  1184                              <1> 
  1185 00001961 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1186 00001964 740F                <1> 	je .go_up
  1187 00001966 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1188 00001969 741B                <1> 	je .go_down
  1189 0000196B 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1190 0000196D 7468                <1> 	je .option_selected
  1191 0000196F 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1192 00001971 747E                <1> 	je .esc_pressed
  1193 00001973 EBCD                <1> 	jmp .more_select		; If not, wait for another key
  1194                              <1> 
  1195                              <1> 
  1196                              <1> .go_up:
  1197 00001975 80FE07              <1> 	cmp dh, 7			; Already at top?
  1198 00001978 7E32                <1> 	jle .hit_top
  1199                              <1> 
  1200 0000197A E8CF00              <1> 	call .draw_white_bar
  1201                              <1> 
  1202 0000197D B219                <1> 	mov dl, 25
  1203 0000197F E8C7F8              <1> 	call move_cursor
  1204                              <1> 
  1205 00001982 FECE                <1> 	dec dh				; Row to select (increasing down)
  1206 00001984 EBBC                <1> 	jmp .more_select
  1207                              <1> 
  1208                              <1> 
  1209                              <1> .go_down:				; Already at bottom of list?
  1210 00001986 80FE14              <1> 	cmp dh, 20
  1211 00001989 7430                <1> 	je .hit_bottom
  1212                              <1> 
  1213 0000198B B90000              <1> 	mov cx, 0
  1214 0000198E 88F1                <1> 	mov byte cl, dh
  1215                              <1> 
  1216 00001990 80E907              <1> 	sub cl, 7
  1217 00001993 FEC1                <1> 	inc cl
  1218 00001995 020E[641A]          <1> 	add byte cl, [.skip_num]
  1219                              <1> 
  1220 00001999 A0[631A]            <1> 	mov byte al, [.num_of_entries]
  1221 0000199C 38C1                <1> 	cmp cl, al
  1222 0000199E 74BD                <1> 	je .another_key
  1223                              <1> 
  1224 000019A0 E8A900              <1> 	call .draw_white_bar
  1225                              <1> 
  1226 000019A3 B219                <1> 	mov dl, 25
  1227 000019A5 E8A1F8              <1> 	call move_cursor
  1228                              <1> 
  1229 000019A8 FEC6                <1> 	inc dh
  1230 000019AA EB96                <1> 	jmp .more_select
  1231                              <1> 
  1232                              <1> 
  1233                              <1> .hit_top:
  1234 000019AC 8A0E[641A]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1235 000019B0 80F900              <1> 	cmp cl, 0
  1236 000019B3 74A8                <1> 	je .another_key			; If not, wait for another key
  1237                              <1> 
  1238 000019B5 FE0E[641A]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1239 000019B9 EB87                <1> 	jmp .more_select
  1240                              <1> 
  1241                              <1> 
  1242                              <1> .hit_bottom:				; See if there's more to scroll
  1243 000019BB B90000              <1> 	mov cx, 0
  1244 000019BE 88F1                <1> 	mov byte cl, dh
  1245                              <1> 
  1246 000019C0 80E907              <1> 	sub cl, 7
  1247 000019C3 FEC1                <1> 	inc cl
  1248 000019C5 020E[641A]          <1> 	add byte cl, [.skip_num]
  1249                              <1> 
  1250 000019C9 A0[631A]            <1> 	mov byte al, [.num_of_entries]
  1251 000019CC 38C1                <1> 	cmp cl, al
  1252 000019CE 748D                <1> 	je .another_key
  1253                              <1> 
  1254 000019D0 FE06[641A]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1255 000019D4 E96BFF              <1> 	jmp .more_select
  1256                              <1> 
  1257                              <1> 
  1258                              <1> 
  1259                              <1> .option_selected:
  1260 000019D7 E84EF8              <1> 	call show_cursor
  1261                              <1> 
  1262 000019DA 80EE07              <1> 	sub dh, 7
  1263                              <1> 
  1264 000019DD B80000              <1> 	mov ax, 0
  1265 000019E0 88F0                <1> 	mov al, dh
  1266                              <1> 
  1267 000019E2 FEC0                <1> 	inc al				; Options start from 1
  1268 000019E4 0206[641A]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1269                              <1> 
  1270 000019E8 A3[611A]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1271                              <1> 
  1272 000019EB 61                  <1> 	popa
  1273                              <1> 
  1274 000019EC A1[611A]            <1> 	mov word ax, [.tmp]
  1275 000019EF F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1276 000019F0 C3                  <1> 	ret
  1277                              <1> 
  1278                              <1> 
  1279                              <1> 
  1280                              <1> .esc_pressed:
  1281 000019F1 E834F8              <1> 	call show_cursor
  1282 000019F4 61                  <1> 	popa
  1283 000019F5 F9                  <1> 	stc				; Set carry for Esc
  1284 000019F6 C3                  <1> 	ret
  1285                              <1> 
  1286                              <1> 
  1287                              <1> 
  1288                              <1> .draw_list:
  1289 000019F7 60                  <1> 	pusha
  1290                              <1> 
  1291 000019F8 B212                <1> 	mov dl, 18			; Get into position for option list text
  1292 000019FA B607                <1> 	mov dh, 7
  1293 000019FC E84AF8              <1> 	call move_cursor
  1294                              <1> 
  1295                              <1> 
  1296 000019FF B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  1297 00001A02 8A0E[641A]          <1> 	mov byte cl, [.skip_num]
  1298                              <1> 
  1299                              <1> .skip_loop:
  1300 00001A06 83F900              <1> 	cmp cx, 0
  1301 00001A09 7408                <1> 	je .skip_loop_finished
  1302                              <1> .more_lodsb:
  1303 00001A0B AC                  <1> 	lodsb
  1304 00001A0C 3C2C                <1> 	cmp al, ','
  1305 00001A0E 75FB                <1> 	jne .more_lodsb
  1306 00001A10 49                  <1> 	dec cx
  1307 00001A11 EBF3                <1> 	jmp .skip_loop
  1308                              <1> 
  1309                              <1> 
  1310                              <1> .skip_loop_finished:
  1311 00001A13 BB0000              <1> 	mov bx, 0			; Counter for total number of options
  1312                              <1> 
  1313                              <1> 
  1314                              <1> .more:
  1315 00001A16 AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  1316                              <1> 
  1317 00001A17 3C00                <1> 	cmp al, 0			; End of string?
  1318 00001A19 7417                <1> 	je .done_list
  1319                              <1> 
  1320 00001A1B 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1321 00001A1D 7406                <1> 	je .newline
  1322                              <1> 
  1323 00001A1F B40E                <1> 	mov ah, 0Eh
  1324 00001A21 CD10                <1> 	int 10h
  1325 00001A23 EBF1                <1> 	jmp .more
  1326                              <1> 
  1327                              <1> .newline:
  1328 00001A25 B212                <1> 	mov dl, 18			; Go back to starting X position
  1329 00001A27 FEC6                <1> 	inc dh				; But jump down a line
  1330 00001A29 E81DF8              <1> 	call move_cursor
  1331                              <1> 
  1332 00001A2C 43                  <1> 	inc bx				; Update the number-of-options counter
  1333 00001A2D 83FB0E              <1> 	cmp bx, 14			; Limit to one screen of options
  1334 00001A30 7CE4                <1> 	jl .more
  1335                              <1> 
  1336                              <1> .done_list:
  1337 00001A32 61                  <1> 	popa
  1338 00001A33 E813F8              <1> 	call move_cursor
  1339                              <1> 
  1340 00001A36 C3                  <1> 	ret
  1341                              <1> 
  1342                              <1> 
  1343                              <1> 
  1344                              <1> .draw_black_bar:
  1345 00001A37 60                  <1> 	pusha
  1346                              <1> 
  1347 00001A38 B211                <1> 	mov dl, 17
  1348 00001A3A E80CF8              <1> 	call move_cursor
  1349                              <1> 
  1350 00001A3D B409                <1> 	mov ah, 09h			; Draw white bar at top
  1351 00001A3F B700                <1> 	mov bh, 0
  1352 00001A41 B92E00              <1> 	mov cx, 46
  1353 00001A44 B30F                <1> 	mov bl, 00001111b		; White text on black background
  1354 00001A46 B020                <1> 	mov al, ' '
  1355 00001A48 CD10                <1> 	int 10h
  1356                              <1> 
  1357 00001A4A 61                  <1> 	popa
  1358 00001A4B C3                  <1> 	ret
  1359                              <1> 
  1360                              <1> 
  1361                              <1> 
  1362                              <1> .draw_white_bar:
  1363 00001A4C 60                  <1> 	pusha
  1364                              <1> 
  1365 00001A4D B211                <1> 	mov dl, 17
  1366 00001A4F E8F7F7              <1> 	call move_cursor
  1367                              <1> 
  1368 00001A52 B409                <1> 	mov ah, 09h			; Draw white bar at top
  1369 00001A54 B700                <1> 	mov bh, 0
  1370 00001A56 B92E00              <1> 	mov cx, 46
  1371 00001A59 B3F0                <1> 	mov bl, 11110000b		; Black text on white background
  1372 00001A5B B020                <1> 	mov al, ' '
  1373 00001A5D CD10                <1> 	int 10h
  1374                              <1> 
  1375 00001A5F 61                  <1> 	popa
  1376 00001A60 C3                  <1> 	ret
  1377                              <1> 
  1378                              <1> 
  1379 00001A61 0000                <1> 	.tmp			dw 0
  1380 00001A63 00                  <1> 	.num_of_entries		db 0
  1381 00001A64 00                  <1> 	.skip_num		db 0
  1382 00001A65 0000                <1> 	.list_string		dw 0
   373                                      %include "./includes/misc.asm"
     1                              <1> ; get_api_version -- Return current version of KronkOS API
     2                              <1> ; OUT: AL = API version number
     3                              <1> 
     4                              <1> get_api_version:
     5 00001A67 B004                <1> 	mov al, KRONKOS_API
     6 00001A69 C3                  <1> 	ret
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; clear_regs -- Clear all the registers
    10                              <1> 
    11                              <1> clear_regs:
    12 00001A6A 31C0                <1> 	xor ax, ax
    13 00001A6C 31DB                <1> 	xor bx, bx
    14 00001A6E 31C9                <1> 	xor cx, cx
    15 00001A70 31D2                <1> 	xor dx, dx
    16 00001A72 31F6                <1> 	xor si, si
    17 00001A74 31FF                <1> 	xor di, di
    18                              <1> 	
    19 00001A76 C3                  <1> 	ret
    20                              <1> 
    21                              <1> ; ------------------------------------------------------------------
    22                              <1> ; fatal_error -- Display error message and halt execution
    23                              <1> ; IN: AX = error message string location
    24                              <1> 
    25                              <1> fatal_error:
    26 00001A77 89C3                <1> 	mov bx, ax			; Store string location for now
    27                              <1> 
    28 00001A79 B600                <1> 	mov dh, 0
    29 00001A7B B200                <1> 	mov dl, 0
    30 00001A7D E8C9F7              <1> 	call move_cursor
    31                              <1> 
    32 00001A80 60                  <1> 	pusha
    33 00001A81 B409                <1> 	mov ah, 0x09		; Draw red bar at top
    34 00001A83 B700                <1> 	mov bh, 0
    35 00001A85 B9F000              <1> 	mov cx, 240
    36 00001A88 B34F                <1> 	mov bl, 01001111b
    37 00001A8A B020                <1> 	mov al, ' '
    38 00001A8C CD10                <1> 	int 10h
    39 00001A8E 61                  <1> 	popa
    40                              <1> 
    41 00001A8F B600                <1> 	mov dh, 0
    42 00001A91 B200                <1> 	mov dl, 0
    43 00001A93 E8B3F7              <1> 	call move_cursor
    44                              <1> 
    45 00001A96 BE[A31A]            <1> 	mov si, .msg_inform		; Inform of fatal error
    46 00001A99 E80501              <1> 	call print
    47                              <1> 
    48 00001A9C 89DE                <1> 	mov si, bx			; Program-supplied error message
    49 00001A9E E80001              <1> 	call print
    50                              <1> 
    51 00001AA1 EBFE                <1> 	jmp $				; Halt execution
    52                              <1> 
    53                              <1> 	
    54 00001AA3 464154414C204F5045- <1> 	.msg_inform		db 'FATAL OPERATING SYSTEM ERROR!', 0x0d, 0x0a, 0
    54 00001AAC 524154494E47205359- <1>
    54 00001AB5 5354454D204552524F- <1>
    54 00001ABE 52210D0A00          <1>
    55                              <1> 
    56                              <1> ; ------------------------------------------------------------------
    57                              <1> ; bios_wait -- Wait
    58                              <1> ; IN: CX:DX time
    59                              <1> 
    60                              <1> bios_wait:
    61 00001AC3 B80086              <1> 	mov ax, 0x8600
    62 00001AC6 CD15                <1>     int 0x15
    63 00001AC8 C3                  <1>     ret
   374                                      %include "./includes/input.asm"
     1                              <1> get_input:
     2 00001AC9 60                  <1>     pusha
     3 00001ACA B200                <1>     mov dl, 0
     4 00001ACC BE[B601]            <1>     mov si, in_buffer
     5                              <1> 
     6                              <1>     ; Clear the input buffer for use
     7                              <1>     .clear_loop:
     8 00001ACF C60400              <1>         mov byte [si], 0
     9                              <1> 
    10 00001AD2 46                  <1>         inc si
    11 00001AD3 FEC2                <1>         inc dl
    12                              <1> 
    13 00001AD5 80FA1E              <1>         cmp dl, 30
    14 00001AD8 75F5                <1>         jne .clear_loop
    15                              <1> 
    16 00001ADA BE[B601]            <1>     mov si, in_buffer
    17 00001ADD 30DB                <1>     xor bl, bl ; Used for checking the length of the buffer
    18                              <1> 
    19                              <1> ; The actual loop
    20                              <1> .input_loop:
    21 00001ADF B400                <1>     mov ah, 0x00
    22 00001AE1 CD16                <1>     int 0x16
    23                              <1> 
    24                              <1>     ; Check if the user pressed enter
    25 00001AE3 3C0D                <1>     cmp al, 0x0d
    26 00001AE5 7442                <1>     je .input_done
    27                              <1> 
    28                              <1>     ; Check if the user pressed backspace
    29 00001AE7 3C08                <1>     cmp al, 0x08
    30 00001AE9 7524                <1>     jne .not_back
    31                              <1> 
    32                              <1>     ; ******************************
    33                              <1>     ; The user pressed backspace!
    34                              <1> 
    35                              <1>     ; Get current cursor position
    36 00001AEB B403                <1>     mov ah, 0x03
    37 00001AED B700                <1>     mov bh, 0
    38 00001AEF CD10                <1>     int 0x10
    39                              <1> 
    40 00001AF1 80FA03              <1>     cmp dl, 3 ; 3 = backspace limit
    41 00001AF4 74E9                <1>     je .input_loop
    42                              <1> 
    43 00001AF6 FECA                <1>     dec dl
    44 00001AF8 FECB                <1>     dec bl
    45                              <1> 
    46                              <1>     ; Move one back
    47 00001AFA B402                <1>     mov ah, 0x02
    48 00001AFC CD10                <1>     int 0x10
    49                              <1> 
    50 00001AFE B40E                <1>     mov ah, 0x0e
    51 00001B00 B000                <1>     mov al, 0
    52 00001B02 CD10                <1>     int 0x10
    53                              <1> 
    54 00001B04 B402                <1>     mov ah, 0x02
    55 00001B06 CD10                <1>     int 0x10
    56                              <1> 
    57                              <1>     ; Remove the last character from the input buffer
    58 00001B08 4E                  <1>     dec si
    59 00001B09 B000                <1>     mov al, 0
    60 00001B0B 8804                <1>     mov [si], al
    61                              <1> 
    62 00001B0D EBD0                <1>     jmp .input_loop
    63                              <1>     
    64                              <1>     ; ******************************
    65                              <1> 
    66                              <1>     ; Show the pressed character and save it to the input buffer
    67                              <1>     .not_back:
    68 00001B0F 80FB28              <1>         cmp bl, 40
    69 00001B12 74CB                <1>         je .input_loop
    70 00001B14 FEC3                <1>         inc bl
    71                              <1> 
    72 00001B16 8804                <1>         mov [si], al
    73 00001B18 46                  <1>         inc si
    74                              <1> 
    75 00001B19 B40E                <1>         mov ah, 0x0e
    76 00001B1B 3C61                <1>         cmp al, 'a'
    77 00001B1D 7206                <1>         jb .noatoz
    78 00001B1F 3C7A                <1>         cmp al, 'z'
    79 00001B21 7702                <1>         ja .noatoz
    80                              <1>         
    81 00001B23 24DF                <1>         and al, 0xdf
    82                              <1>         .noatoz:
    83 00001B25 CD10                <1>         int 0x10
    84                              <1> 
    85 00001B27 EBB6                <1>         jmp .input_loop
    86                              <1> 
    87                              <1>     ; Return the cursor to the start and return
    88                              <1>     .input_done:
    89 00001B29 B8[B601]            <1>         mov ax, in_buffer
    90 00001B2C E838F3              <1>         call string_lowercase
    91                              <1> 
    92 00001B2F B40E                <1>         mov ah, 0x0e
    93 00001B31 B00D                <1>         mov al, 0x0d
    94 00001B33 CD10                <1>         int 0x10
    95                              <1> 
    96 00001B35 61                  <1>         popa
    97 00001B36 C3                  <1>         ret
   375                                      %include "./includes/math.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; KronkOS -- The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; MATH ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; seed_random -- Seed the random number generator based on clock
    10                              <1> 
    11                              <1> seed_random:
    12 00001B37 53                  <1> 	push bx
    13 00001B38 50                  <1> 	push ax
    14                              <1> 
    15 00001B39 BB0000              <1> 	mov bx, 0
    16 00001B3C B002                <1> 	mov al, 0x02
    17 00001B3E E670                <1> 	out 0x70, al
    18 00001B40 E471                <1> 	in al, 0x71
    19                              <1> 
    20 00001B42 88C3                <1> 	mov bl, al
    21 00001B44 C1E308              <1> 	shl bx, 8
    22 00001B47 B000                <1> 	mov al, 0
    23 00001B49 E670                <1> 	out 0x70, al
    24 00001B4B E471                <1> 	in al, 0x71
    25                              <1> 
    26 00001B4D 891E[541B]          <1> 	mov word [random_seed], bx
    27                              <1> 
    28 00001B51 58                  <1> 	pop ax
    29 00001B52 5B                  <1> 	pop bx
    30 00001B53 C3                  <1> 	ret
    31                              <1> 
    32 00001B54 0000                <1> 	random_seed dw 0
    33                              <1> 
    34                              <1> ; ------------------------------------------------------------------
    35                              <1> ; get_random -- Return a random integer between low and high (inclusive)
    36                              <1> ; IN: AX = low integer, BX = high integer
    37                              <1> ; OUT: CX = random integer
    38                              <1> 
    39                              <1> get_random:
    40 00001B56 52                  <1> 	push dx
    41 00001B57 53                  <1> 	push bx
    42 00001B58 50                  <1> 	push ax
    43                              <1> 
    44 00001B59 29C3                <1> 	sub bx, ax
    45 00001B5B E80F00              <1> 	call .generate_random
    46 00001B5E 89DA                <1> 	mov dx, bx
    47 00001B60 83C201              <1> 	add dx, 1
    48 00001B63 F7E2                <1> 	mul dx
    49 00001B65 89D1                <1> 	mov cx, dx
    50                              <1> 
    51 00001B67 58                  <1> 	pop ax
    52 00001B68 5B                  <1> 	pop bx
    53 00001B69 5A                  <1> 	pop dx
    54 00001B6A 01C1                <1> 	add cx, ax
    55 00001B6C C3                  <1> 	ret
    56                              <1> 
    57                              <1> 	.generate_random:
    58 00001B6D 52                  <1> 		push dx
    59 00001B6E 53                  <1> 		push bx
    60                              <1> 
    61 00001B6F A1[541B]            <1> 		mov ax, [random_seed]
    62 00001B72 BA8373              <1> 		mov dx, 0x7383
    63 00001B75 F7E2                <1> 		mul dx
    64 00001B77 A3[541B]            <1> 		mov [random_seed], ax
    65                              <1> 
    66 00001B7A 5B                  <1> 		pop bx
    67 00001B7B 5A                  <1> 		pop dx
    68                              <1> 		
    69 00001B7C C3                  <1> 		ret
    70                              <1> 
    71                              <1> ; ------------------------------------------------------------------
    72                              <1> ; bcd_to_int -- Converts binary coded decimal number to an integer
    73                              <1> ; IN: AL = BCD number
    74                              <1> ; OUT: AX = integer value
    75                              <1> 
    76                              <1> bcd_to_int:
    77 00001B7D 60                  <1> 	pusha
    78                              <1> 
    79 00001B7E 88C3                <1> 	mov bl, al
    80                              <1> 
    81 00001B80 83E00F              <1> 	and ax, 0x0F
    82 00001B83 89C1                <1> 	mov cx, ax
    83                              <1> 
    84 00001B85 C0EB04              <1> 	shr bl, 4
    85 00001B88 B00A                <1> 	mov al, 10
    86 00001B8A F6E3                <1> 	mul bl
    87                              <1> 
    88 00001B8C 01C8                <1> 	add ax, cx
    89 00001B8E A3[961B]            <1> 	mov [.tmp], ax
    90                              <1> 
    91 00001B91 61                  <1> 	popa
    92 00001B92 A1[961B]            <1> 	mov ax, [.tmp]
    93 00001B95 C3                  <1> 	ret
    94                              <1> 
    95 00001B96 0000                <1> 	.tmp	dw 0
    96                              <1> 	
    97                              <1> ; ------------------------------------------------------------------
    98                              <1> ; long_int_negate -- Multiply value in DX:AX by -1
    99                              <1> ; IN: DX:AX = long integer
   100                              <1> ; OUT: DX:AX = -(initial DX:AX)
   101                              <1> 
   102                              <1> long_int_negate:
   103 00001B98 F7D8                <1> 	neg ax
   104 00001B9A 83D200              <1> 	adc dx, 0
   105 00001B9D F7DA                <1> 	neg dx
   106 00001B9F C3                  <1> 	ret
   107                              <1> 
   108                              <1> ; ------------------------------------------------------------------
   109                              <1> ; hex_to_int -- Convert a hexadecimal to decimal
   110                              <1> ; IN: AX = number to be converted, BX = base
   111                              <1> 
   112                              <1> hex_to_int:
   113 00001BA0 C3                  <1> 	ret
   114                              <1> 
   115                              <1> ; ==================================================================
   376                                      %include "./includes/print.asm"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; print -- Print a string to the screen
     3                              <1> ; IN: SI = The location of the string
     4                              <1> 
     5                              <1> print:
     6 00001BA1 60                  <1>     pusha
     7 00001BA2 B40E                <1>     mov ah, 0x0e
     8                              <1> 
     9                              <1> .repeat:
    10 00001BA4 AC                  <1>     lodsb
    11 00001BA5 84C0                <1>     test al, al
    12 00001BA7 7404                <1>     jz .done
    13                              <1> 
    14 00001BA9 CD10                <1>     int 0x10
    15 00001BAB EBF7                <1>     jmp short .repeat
    16                              <1> 
    17                              <1> .done:
    18 00001BAD 61                  <1>     popa
    19 00001BAE C3                  <1>     ret
    20                              <1> 
    21                              <1> ; ------------------------------------------------------------------
    22                              <1> ; welcome_print -- Print the welcome message
    23                              <1> ; IN: SI = The location of the string
    24                              <1> 
    25                              <1> welcome_print:
    26 00001BAF B409                <1>     mov ah, 0x09
    27 00001BB1 B90100              <1>     mov cx, 1
    28 00001BB4 31DB                <1>     xor bx, bx
    29 00001BB6 B330                <1>     mov bl, mb_color
    30                              <1> 
    31                              <1>     .repeat:
    32 00001BB8 AC                  <1>         lodsb
    33 00001BB9 3C00                <1>         cmp al, 0
    34 00001BBB 741C                <1>         je .done
    35                              <1> 
    36 00001BBD 3C0A                <1>         cmp al, 0x0a
    37 00001BBF 7410                <1>         je .other_char
    38 00001BC1 3C0D                <1>         cmp al, 0x0d
    39 00001BC3 740C                <1>         je .other_char
    40                              <1> 
    41 00001BC5 E88AF6              <1>         call get_cursor_pos
    42 00001BC8 FEC2                <1>         inc dl
    43 00001BCA E87CF6              <1>         call move_cursor
    44                              <1> 
    45 00001BCD CD10                <1>         int 0x10
    46 00001BCF EBE7                <1>         jmp short .repeat
    47                              <1> 
    48                              <1>     .other_char:
    49 00001BD1 B40E                <1>         mov ah, 0x0e
    50 00001BD3 CD10                <1>         int 0x10
    51                              <1> 
    52 00001BD5 B409                <1>         mov ah, 0x09
    53 00001BD7 EBDF                <1>         jmp .repeat
    54                              <1> 
    55                              <1>     .done:
    56 00001BD9 C3                  <1>         ret
    57                              <1> 
    58                              <1> ; ------------------------------------------------------------------
    59                              <1> ; print_atr -- Print a string with attribute to the screen
    60                              <1> ; IN: SI = The location of the string
    61                              <1> ;     BH = Page number
    62                              <1> ;     BL = Attribute
    63                              <1> 
    64                              <1> print_atr:
    65 00001BDA 60                  <1>     pusha
    66 00001BDB 8816[071C]          <1>     mov [.start_x], dl
    67                              <1> 
    68 00001BDF B90100              <1>     mov cx, 1
    69 00001BE2 B409                <1>     mov ah, 0x09
    70                              <1> 
    71                              <1> .repeat:
    72 00001BE4 AC                  <1>     lodsb
    73 00001BE5 84C0                <1>     test al, al
    74 00001BE7 741C                <1>     jz .done
    75                              <1> 
    76 00001BE9 3C0A                <1>     cmp al, 0x0a
    77 00001BEB 7410                <1>     je .special_char
    78                              <1> 
    79 00001BED 3C0D                <1>     cmp al, 0x0d
    80 00001BEF 740C                <1>     je .special_char
    81                              <1> 
    82 00001BF1 CD10                <1>     int 0x10
    83                              <1> 
    84 00001BF3 E85CF6              <1>     call get_cursor_pos
    85 00001BF6 FEC2                <1>     inc dl
    86 00001BF8 E84EF6              <1>     call move_cursor
    87                              <1> 
    88 00001BFB EBE7                <1>     jmp short .repeat
    89                              <1> 
    90                              <1> .special_char:
    91 00001BFD B40E                <1>     mov ah, 0x0e
    92 00001BFF CD10                <1>     int 0x10
    93 00001C01 B409                <1>     mov ah, 0x09
    94 00001C03 EBDF                <1>     jmp short .repeat
    95                              <1> 
    96                              <1> .done:
    97 00001C05 61                  <1>     popa
    98 00001C06 C3                  <1>     ret
    99                              <1> 
   100 00001C07 0000                <1>     .start_x:   dw 0
   101                              <1> 
   102                              <1> ; ------------------------------------------------------------------
   103                              <1> ; print_word_hex -- Print a word as hex
   104                              <1> ; IN: AX = Hex number
   105                              <1> ;     BH = Page number
   106                              <1> ;     BL = Attribute
   107                              <1> 
   108                              <1> print_word_hex:
   109 00001C09 60                  <1>     pusha
   110 00001C0A 86C4                <1>     xchg al, ah
   111 00001C0C E80700              <1>     call print_byte_hex
   112 00001C0F 86C4                <1>     xchg al, ah
   113 00001C11 E80200              <1>     call print_byte_hex
   114 00001C14 61                  <1>     popa
   115 00001C15 C3                  <1>     ret
   116                              <1> 
   117                              <1> ; ------------------------------------------------------------------
   118                              <1> ; print_byte_hex -- Print a byte as hex
   119                              <1> ; IN: AX = Hex number
   120                              <1> 
   121                              <1> print_byte_hex:
   122 00001C16 50                  <1>     push ax
   123 00001C17 51                  <1>     push cx
   124 00001C18 53                  <1>     push bx
   125                              <1> 
   126 00001C19 8D1E[371C]          <1>     lea bx, [.table]
   127                              <1> 
   128 00001C1D 88C4                <1>     mov ah, al
   129 00001C1F 240F                <1>     and al, 0x0f
   130 00001C21 B104                <1>     mov cl, 4
   131 00001C23 D2EC                <1>     shr ah, cl
   132 00001C25 D7                  <1>     xlat
   133 00001C26 86E0                <1>     xchg ah, al
   134 00001C28 D7                  <1>     xlat
   135                              <1> 
   136 00001C29 5B                  <1>     pop bx
   137 00001C2A 88E5                <1>     mov ch, ah
   138 00001C2C B40E                <1>     mov ah, 0x0e
   139 00001C2E CD10                <1>     int 0x10
   140 00001C30 88E8                <1>     mov al, ch
   141 00001C32 CD10                <1>     int 0x10
   142                              <1> 
   143 00001C34 59                  <1>     pop cx
   144 00001C35 58                  <1>     pop ax
   145 00001C36 C3                  <1>     ret
   146                              <1> 
   147 00001C37 303132333435363738- <1>     .table: db "0123456789ABCDEF", 0
   147 00001C40 3941424344454600    <1>
   377                                      %include "./includes/mouse.asm"
     1                              <1> HW_EQUIP_PS2     equ 4          ; PS2 mouse installed?
     2                              <1> MOUSE_PKT_BYTES  equ 3          ; Number of bytes in mouse packet
     3                              <1> MOUSE_RESOLUTION equ 3          ; Mouse resolution 8 counts/mm
     4                              <1> ARG_OFFSETS      equ 6          ; Offset of args from BP
     5                              <1> 
     6                              <1> mouse_initialize:
     7 00001C48 06                  <1>     push es
     8 00001C49 53                  <1>     push bx
     9                              <1> 
    10 00001C4A CD11                <1>     int 0x11
    11 00001C4C A90400              <1>     test ax, HW_EQUIP_PS2
    12 00001C4F 7421                <1>     jz .no_mouse
    13                              <1> 
    14 00001C51 B805C2              <1>     mov ax, 0xC205
    15 00001C54 B703                <1>     mov bh, MOUSE_PKT_BYTES
    16 00001C56 CD15                <1>     int 0x15
    17 00001C58 7218                <1>     jc .no_mouse
    18                              <1> 
    19 00001C5A B803C2              <1>     mov ax, 0xC203
    20 00001C5D B703                <1>     mov bh, MOUSE_RESOLUTION
    21 00001C5F CD15                <1>     int 0x15
    22 00001C61 720F                <1>     jc .no_mouse
    23                              <1> 
    24 00001C63 0E                  <1>     push cs
    25 00001C64 07                  <1>     pop es
    26                              <1> 
    27 00001C65 BB[DD1C]            <1>     mov bx, mouse_callback_dummy
    28 00001C68 B807C2              <1>     mov ax, 0xC207
    29 00001C6B CD15                <1>     int 0x15
    30 00001C6D 7203                <1>     jc .no_mouse
    31                              <1> 
    32 00001C6F F8                  <1>     clc
    33 00001C70 EB01                <1>     jmp .finished
    34                              <1>     
    35                              <1>     .no_mouse:
    36 00001C72 F9                  <1>         stc
    37                              <1>     
    38                              <1>     .finished:
    39 00001C73 5B                  <1>         pop bx
    40 00001C74 07                  <1>         pop es
    41 00001C75 C3                  <1>         ret
    42                              <1> 
    43                              <1> 
    44                              <1> mouse_enable:
    45 00001C76 06                  <1>     push es
    46 00001C77 53                  <1>     push bx
    47                              <1> 
    48 00001C78 E81400              <1>     call mouse_disable
    49                              <1> 
    50 00001C7B 0E                  <1>     push cs
    51 00001C7C 07                  <1>     pop es
    52 00001C7D BB[A21C]            <1>     mov bx, mouse_callback
    53 00001C80 B807C2              <1>     mov ax, 0xC207
    54 00001C83 CD15                <1>     int 0x15
    55                              <1> 
    56 00001C85 B800C2              <1>     mov ax, 0xC200
    57 00001C88 B701                <1>     mov bh, 1
    58 00001C8A CD15                <1>     int 0x15
    59                              <1> 
    60 00001C8C 5B                  <1>     pop bx
    61 00001C8D 07                  <1>     pop es
    62 00001C8E C3                  <1>     ret
    63                              <1> 
    64                              <1> 
    65                              <1> mouse_disable:
    66 00001C8F 06                  <1>     push es
    67 00001C90 53                  <1>     push bx
    68                              <1> 
    69 00001C91 B800C2              <1>     mov ax, 0xC200
    70 00001C94 31DB                <1>     xor bx, bx
    71 00001C96 CD15                <1>     int 0x15
    72                              <1> 
    73 00001C98 8EC3                <1>     mov es, bx
    74 00001C9A B807C2              <1>     mov ax, 0xC207
    75 00001C9D CD15                <1>     int 0x15
    76                              <1> 
    77 00001C9F 5B                  <1>     pop bx
    78 00001CA0 07                  <1>     pop es
    79 00001CA1 C3                  <1>     ret
    80                              <1> 
    81                              <1> 
    82                              <1> mouse_callback:
    83 00001CA2 55                  <1>     push bp
    84 00001CA3 89E5                <1>     mov bp, sp
    85                              <1> 
    86 00001CA5 1E                  <1>     push ds
    87 00001CA6 50                  <1>     push ax
    88 00001CA7 53                  <1>     push bx
    89 00001CA8 51                  <1>     push cx
    90 00001CA9 52                  <1>     push dx
    91                              <1> 
    92 00001CAA 0E                  <1>     push cs
    93 00001CAB 1F                  <1>     pop ds
    94                              <1> 
    95 00001CAC 8A460C              <1>     mov al, [bp+ARG_OFFSETS+6]
    96 00001CAF 88C3                <1>     mov bl, al
    97 00001CB1 B103                <1>     mov cl, 3
    98 00001CB3 D2E0                <1>     shl al, cl
    99                              <1> 
   100 00001CB5 18F6                <1>     sbb dh, dh
   101 00001CB7 98                  <1>     cbw
   102 00001CB8 8A5608              <1>     mov dl, [bp+ARG_OFFSETS+2]
   103 00001CBB 8A460A              <1>     mov al, [bp+ARG_OFFSETS+4]
   104                              <1> 
   105 00001CBE F7DA                <1>     neg dx
   106 00001CC0 8B0E[901D]          <1>     mov cx, [mouseY]
   107 00001CC4 01CA                <1>     add dx, cx
   108 00001CC6 8B0E[8E1D]          <1>     mov cx, [mouseX]
   109 00001CCA 01C8                <1>     add ax, cx
   110                              <1> 
   111 00001CCC 881E[921D]          <1>     mov [curStatus], bl
   112 00001CD0 A3[8E1D]            <1>     mov [mouseX], ax
   113 00001CD3 8916[901D]          <1>     mov [mouseY], dx
   114                              <1> 
   115 00001CD7 5A                  <1>     pop dx
   116 00001CD8 59                  <1>     pop cx
   117 00001CD9 5B                  <1>     pop bx
   118 00001CDA 58                  <1>     pop ax
   119 00001CDB 1F                  <1>     pop ds
   120 00001CDC 5D                  <1>     pop bp
   121                              <1> 
   122                              <1> mouse_callback_dummy:
   123 00001CDD CB                  <1>     retf
   124                              <1> 
   125                              <1> poll_mouse:
   126 00001CDE 50                  <1>     push ax
   127 00001CDF 53                  <1>     push bx
   128 00001CE0 52                  <1>     push dx
   129                              <1>     
   130 00001CE1 BB0200              <1>     mov bx, 0x0002
   131                              <1> 
   132 00001CE4 FA                  <1>     cli
   133 00001CE5 A1[8E1D]            <1>     mov ax, [mouseX]
   134 00001CE8 8B16[901D]          <1>     mov dx, [mouseY]
   135 00001CEC FB                  <1>     sti
   136                              <1> 
   137 00001CED 5A                  <1>     pop dx
   138 00001CEE 5B                  <1>     pop bx
   139 00001CEF 58                  <1>     pop ax
   140 00001CF0 C3                  <1>     ret
   141                              <1> 
   142                              <1> clamp_mouse:
   143 00001CF1 A1[8E1D]            <1>     mov ax, [mouseX]
   144                              <1> 
   145 00001CF4 83F84E              <1>     cmp ax, screenmaxW
   146 00001CF7 7D17                <1>     jge .r_edge
   147                              <1> 
   148 00001CF9 BA0100              <1>     mov dx, screenminW
   149 00001CFC 39D0                <1>     cmp ax, dx
   150 00001CFE 7E22                <1>     jle .l_edge
   151                              <1> 
   152 00001D00 BA0100              <1>     mov dx, screenminH
   153 00001D03 A1[901D]            <1>     mov ax, [mouseY]
   154 00001D06 39D0                <1>     cmp ax, dx
   155 00001D08 7E2A                <1>     jle .t_edge
   156                              <1> 
   157 00001D0A 83F817              <1>     cmp ax, screenmaxH
   158 00001D0D 7D37                <1>     jge .b_edge
   159                              <1> 
   160 00001D0F C3                  <1>     ret
   161                              <1> 
   162                              <1> .r_edge:
   163 00001D10 C706[8E1D]4E00      <1>     mov word [mouseX], screenmaxW
   164 00001D16 8A16[8E1D]          <1>     mov dl, [mouseX]
   165 00001D1A 8A36[901D]          <1>     mov dh, [mouseY]
   166 00001D1E E828F5              <1>     call move_cursor
   167 00001D21 C3                  <1>     ret
   168                              <1> 
   169                              <1> .l_edge:
   170 00001D22 C706[8E1D]0100      <1>     mov word [mouseX], screenminW
   171 00001D28 8A16[8E1D]          <1>     mov dl, [mouseX]
   172 00001D2C 8A36[901D]          <1>     mov dh, [mouseY]
   173 00001D30 E816F5              <1>     call move_cursor
   174 00001D33 C3                  <1>     ret
   175                              <1> 
   176                              <1> .t_edge:
   177 00001D34 C706[901D]0100      <1>     mov word [mouseY], screenminH
   178 00001D3A 8A16[8E1D]          <1>     mov dl, [mouseX]
   179 00001D3E 8A36[901D]          <1>     mov dh, [mouseY]
   180 00001D42 E804F5              <1>     call move_cursor
   181 00001D45 C3                  <1>     ret
   182                              <1> 
   183                              <1> .b_edge:
   184 00001D46 C706[901D]1700      <1>     mov word [mouseY], screenmaxH
   185 00001D4C 8A16[8E1D]          <1>     mov dl, [mouseX]
   186 00001D50 8A36[901D]          <1>     mov dh, [mouseY]
   187 00001D54 E8F2F4              <1>     call move_cursor
   188 00001D57 C3                  <1>     ret
   189                              <1> 
   190                              <1> no_mouse:
   191 00001D58 B8[3002]            <1>     mov ax, mouse_yes
   192 00001D5B 31DB                <1>     xor bx, bx
   193 00001D5D 31C9                <1>     xor cx, cx
   194 00001D5F BA0000              <1>     mov dx, 0
   195 00001D62 E876F5              <1>     call dialog_box
   196                              <1> 
   197 00001D65 31C0                <1>     xor ax, ax
   198 00001D67 CD13                <1>     int 0x13
   199                              <1> 
   200 00001D69 B80010              <1>     mov ax, 0x1000
   201 00001D6C 8CD0                <1>     mov ax, ss
   202 00001D6E BC00F0              <1>     mov sp, 0xf000
   203 00001D71 B80753              <1>     mov ax, 0x5307
   204 00001D74 BB0100              <1>     mov bx, 0x0001
   205 00001D77 B90300              <1>     mov cx, 0x0003
   206 00001D7A CD15                <1>     int 0x15
   207                              <1> 
   208                              <1> mouse_loop:
   209 00001D7C E85FFF              <1>     call poll_mouse
   210                              <1> 
   211 00001D7F 8A16[8E1D]          <1>     mov dl, [mouseX]
   212 00001D83 8A36[901D]          <1>     mov dh, [mouseY]
   213                              <1> 
   214 00001D87 E8BFF4              <1>     call move_cursor
   215 00001D8A E864FF              <1>     call clamp_mouse
   216                              <1> 
   217 00001D8D C3                  <1>     ret
   218                              <1> 
   219 00001D8E 0000                <1> mouseX:         dw 0
   220 00001D90 0000                <1> mouseY:         dw 0
   221 00001D92 00                  <1> curStatus:      db 0
   222 00001D93 0D4572726F72207365- <1> noMouseMsg:     db 0x0d, "Error setting up and initializing mouse", 0x0a, 0x0d, 0
   222 00001D9C 7474696E6720757020- <1>
   222 00001DA5 616E6420696E697469- <1>
   222 00001DAE 616C697A696E67206D- <1>
   222 00001DB7 6F7573650A0D00      <1>
   378                                      %include "./includes/disk.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; FAT12 FLOPPY DISK ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
    10                              <1> ; IN/OUT: AX = location to store zero-terminated filename string
    11                              <1> 
    12                              <1> os_get_file_list:
    13 00001DBE 60                  <1> 	pusha
    14                              <1> 
    15 00001DBF A3[601E]            <1> 	mov word [.file_list_tmp], ax
    16                              <1> 
    17 00001DC2 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
    18                              <1> 
    19 00001DC8 E84007              <1> 	call disk_reset_floppy		; Just in case disk was changed
    20                              <1> 
    21 00001DCB B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
    22 00001DCE E88307              <1> 	call disk_convert_l2hts
    23                              <1> 
    24 00001DD1 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
    25 00001DD4 89F3                <1> 	mov bx, si
    26                              <1> 
    27 00001DD6 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
    28 00001DD8 B00E                <1> 	mov al, 14			; And read 14 of them
    29                              <1> 
    30 00001DDA 60                  <1> 	pusha				; Prepare to enter loop
    31                              <1> 
    32                              <1> 
    33                              <1> .read_root_dir:
    34 00001DDB 61                  <1> 	popa
    35 00001DDC 60                  <1> 	pusha
    36                              <1> 
    37 00001DDD F9                  <1> 	stc
    38 00001DDE CD13                <1> 	int 13h				; Read sectors
    39 00001DE0 E82807              <1> 	call disk_reset_floppy		; Check we've read them OK
    40 00001DE3 7307                <1> 	jnc .show_dir_init		; No errors, continue
    41                              <1> 
    42 00001DE5 E82307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
    43 00001DE8 73F1                <1> 	jnc .read_root_dir
    44 00001DEA EB6E                <1> 	jmp .done			; Double error, exit 'dir' routine
    45                              <1> 
    46                              <1> .show_dir_init:
    47 00001DEC 61                  <1> 	popa
    48                              <1> 
    49 00001DED B80000              <1> 	mov ax, 0
    50 00001DF0 BE0060              <1> 	mov si, disk_buffer		; Data reader from start of filenames
    51                              <1> 
    52 00001DF3 8B3E[601E]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
    53                              <1> 
    54                              <1> 
    55                              <1> .start_entry:
    56 00001DF7 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
    57 00001DFA 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
    58 00001DFC 7457                <1> 	je .skip
    59                              <1> 
    60 00001DFE A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
    61 00001E00 7553                <1> 	jnz .skip			; Yes, ignore it
    62                              <1> 
    63 00001E02 8A04                <1> 	mov al, [si]
    64 00001E04 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
    65 00001E06 744D                <1> 	je .skip
    66                              <1> 
    67 00001E08 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
    68 00001E0A 744E                <1> 	je .done
    69                              <1> 
    70                              <1> 
    71 00001E0C B90100              <1> 	mov cx, 1			; Set char counter
    72 00001E0F 89F2                <1> 	mov dx, si			; Beginning of possible entry
    73                              <1> 
    74                              <1> .testdirentry:
    75 00001E11 46                  <1> 	inc si
    76 00001E12 8A04                <1> 	mov al, [si]			; Test for most unusable characters
    77 00001E14 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
    78 00001E16 7C3B                <1> 	jl .nxtdirentry
    79 00001E18 3C7E                <1> 	cmp al, '~'
    80 00001E1A 7737                <1> 	ja .nxtdirentry
    81                              <1> 
    82 00001E1C 41                  <1> 	inc cx
    83 00001E1D 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
    84 00001E20 7402                <1> 	je .gotfilename
    85 00001E22 EBED                <1> 	jmp .testdirentry
    86                              <1> 
    87                              <1> 
    88                              <1> .gotfilename:				; Got a filename that passes testing
    89 00001E24 89D6                <1> 	mov si, dx			; DX = where getting string
    90                              <1> 
    91 00001E26 B90000              <1> 	mov cx, 0
    92                              <1> .loopy:
    93 00001E29 8A04                <1> 	mov byte al, [si]
    94 00001E2B 3C20                <1> 	cmp al, ' '
    95 00001E2D 7411                <1> 	je .ignore_space
    96 00001E2F 8805                <1> 	mov byte [di], al
    97 00001E31 46                  <1> 	inc si
    98 00001E32 47                  <1> 	inc di
    99 00001E33 41                  <1> 	inc cx
   100 00001E34 83F908              <1> 	cmp cx, 8
   101 00001E37 7410                <1> 	je .add_dot
   102 00001E39 83F90B              <1> 	cmp cx, 11
   103 00001E3C 7411                <1> 	je .done_copy
   104 00001E3E EBE9                <1> 	jmp .loopy
   105                              <1> 
   106                              <1> .ignore_space:
   107 00001E40 46                  <1> 	inc si
   108 00001E41 41                  <1> 	inc cx
   109 00001E42 83F908              <1> 	cmp cx, 8
   110 00001E45 7402                <1> 	je .add_dot
   111 00001E47 EBE0                <1> 	jmp .loopy
   112                              <1> 
   113                              <1> .add_dot:
   114 00001E49 C6052E              <1> 	mov byte [di], '.'
   115 00001E4C 47                  <1> 	inc di
   116 00001E4D EBDA                <1> 	jmp .loopy
   117                              <1> 
   118                              <1> .done_copy:
   119 00001E4F C6052C              <1> 	mov byte [di], ','
   120 00001E52 47                  <1> 	inc di
   121                              <1> 
   122                              <1> .nxtdirentry:
   123 00001E53 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
   124                              <1> 
   125                              <1> .skip:
   126 00001E55 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
   127 00001E58 EB9D                <1> 	jmp .start_entry
   128                              <1> 
   129                              <1> 
   130                              <1> .done:
   131 00001E5A 4F                  <1> 	dec di
   132 00001E5B C60500              <1> 	mov byte [di], 0		; Zero-terminate string (gets rid of final comma)
   133                              <1> 
   134 00001E5E 61                  <1> 	popa
   135 00001E5F C3                  <1> 	ret
   136                              <1> 
   137 00001E60 0000                <1> 	.file_list_tmp		dw 0
   138                              <1> 
   139                              <1> ; ------------------------------------------------------------------
   140                              <1> ; os_load_file -- Load file into RAM
   141                              <1> ; IN: AX = location of filename, CX = location in RAM to load file
   142                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
   143                              <1> 
   144                              <1> os_load_file:
   145 00001E62 E8E5EF              <1> 	call string_uppercase
   146 00001E65 E87205              <1> 	call int_filename_convert
   147                              <1> 
   148 00001E68 A3[6A1F]            <1> 	mov [.filename_loc], ax		; Store filename location
   149 00001E6B 890E[6C1F]          <1> 	mov [.load_position], cx	; And where to load the file!
   150                              <1> 
   151 00001E6F 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   152                              <1> 
   153 00001E75 E89306              <1> 	call disk_reset_floppy		; In case floppy has been changed
   154 00001E78 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
   155                              <1> 
   156 00001E7A B8[7C1F]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
   157 00001E7D E9F7FB              <1> 	jmp fatal_error
   158                              <1> 
   159                              <1> 
   160                              <1> .floppy_ok:				; Ready to read first block of data
   161 00001E80 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   162 00001E83 E8CE06              <1> 	call disk_convert_l2hts
   163                              <1> 
   164 00001E86 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   165 00001E89 89F3                <1> 	mov bx, si
   166                              <1> 
   167 00001E8B B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   168 00001E8D B00E                <1> 	mov al, 14			; 14 root directory sectors
   169                              <1> 
   170 00001E8F 60                  <1> 	pusha				; Prepare to enter loop
   171                              <1> 
   172                              <1> 
   173                              <1> .read_root_dir:
   174 00001E90 61                  <1> 	popa
   175 00001E91 60                  <1> 	pusha
   176                              <1> 
   177 00001E92 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
   178 00001E93 CD13                <1> 	int 13h				; Read sectors
   179 00001E95 7308                <1> 	jnc .search_root_dir		; No errors = continue
   180                              <1> 
   181 00001E97 E87106              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
   182 00001E9A 73F4                <1> 	jnc .read_root_dir
   183                              <1> 
   184 00001E9C 61                  <1> 	popa
   185 00001E9D EB38                <1> 	jmp .root_problem		; Double error = exit
   186                              <1> 
   187                              <1> .search_root_dir:
   188 00001E9F 61                  <1> 	popa
   189                              <1> 
   190 00001EA0 B9E000              <1> 	mov cx, word 224		; Search all entries in root dir
   191 00001EA3 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
   192                              <1> 
   193                              <1> .next_root_entry:
   194 00001EA6 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
   195 00001EA9 BF0060              <1> 	mov di, disk_buffer		; Point root dir at next entry
   196 00001EAC 01DF                <1> 	add di, bx
   197                              <1> 
   198 00001EAE 8A05                <1> 	mov al, [di]			; First character of name
   199                              <1> 
   200 00001EB0 3C00                <1> 	cmp al, 0			; Last file name already checked?
   201 00001EB2 7423                <1> 	je .root_problem
   202                              <1> 
   203 00001EB4 3CE5                <1> 	cmp al, 229			; Was this file deleted?
   204 00001EB6 74EE                <1> 	je .next_root_entry		; If yes, skip it
   205                              <1> 
   206 00001EB8 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
   207                              <1> 
   208 00001EBB 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
   209 00001EBD 74E7                <1> 	je .next_root_entry
   210                              <1> 
   211 00001EBF A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   212 00001EC1 75E3                <1> 	jnz .next_root_entry
   213                              <1> 
   214 00001EC3 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
   215                              <1> 
   216 00001EC7 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
   217 00001EC9 E87EEF              <1> 	call string_uppercase
   218                              <1> 
   219 00001ECC 8B36[6A1F]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
   220                              <1> 
   221 00001ED0 E832F0              <1> 	call string_compare		; Current entry same as requested?
   222 00001ED3 7207                <1> 	jc .found_file_to_load
   223                              <1> 
   224 00001ED5 E2CF                <1> 	loop .next_root_entry
   225                              <1> 
   226                              <1> .root_problem:
   227 00001ED7 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
   228 00001EDA F9                  <1> 	stc				; return with size = 0 and carry set
   229 00001EDB C3                  <1> 	ret
   230                              <1> 
   231                              <1> 
   232                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
   233 00001EDC 8B451C              <1> 	mov ax, [di+28]			; Store file size to return to calling routine
   234 00001EDF A3[6E1F]            <1> 	mov word [.file_size], ax
   235                              <1> 
   236 00001EE2 83F800              <1> 	cmp ax, 0			; If the file size is zero, don't bother trying
   237 00001EE5 7478                <1> 	je .end				; to read more clusters
   238                              <1> 
   239 00001EE7 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
   240 00001EEA A3[661F]            <1> 	mov word [.cluster], ax
   241                              <1> 
   242 00001EED B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
   243 00001EF0 E86106              <1> 	call disk_convert_l2hts
   244                              <1> 
   245 00001EF3 BF0060              <1> 	mov di, disk_buffer		; ES:BX points to our buffer
   246 00001EF6 89FB                <1> 	mov bx, di
   247                              <1> 
   248 00001EF8 B402                <1> 	mov ah, 2			; int 13h params: read sectors
   249 00001EFA B009                <1> 	mov al, 9			; And read 9 of them
   250                              <1> 
   251 00001EFC 60                  <1> 	pusha
   252                              <1> 
   253                              <1> .read_fat:
   254 00001EFD 61                  <1> 	popa				; In case registers altered by int 13h
   255 00001EFE 60                  <1> 	pusha
   256                              <1> 
   257 00001EFF F9                  <1> 	stc
   258 00001F00 CD13                <1> 	int 13h
   259 00001F02 7308                <1> 	jnc .read_fat_ok
   260                              <1> 
   261 00001F04 E80406              <1> 	call disk_reset_floppy
   262 00001F07 73F4                <1> 	jnc .read_fat
   263                              <1> 
   264 00001F09 61                  <1> 	popa
   265 00001F0A EBCB                <1> 	jmp .root_problem
   266                              <1> 
   267                              <1> 
   268                              <1> .read_fat_ok:
   269 00001F0C 61                  <1> 	popa
   270                              <1> 
   271                              <1> 
   272                              <1> .load_file_sector:
   273 00001F0D A1[661F]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
   274 00001F10 83C01F              <1> 	add ax, 31
   275                              <1> 
   276 00001F13 E83E06              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
   277                              <1> 
   278 00001F16 8B1E[6C1F]          <1> 	mov bx, [.load_position]
   279                              <1> 
   280                              <1> 
   281 00001F1A B402                <1> 	mov ah, 02			; AH = read sectors, AL = just read 1
   282 00001F1C B001                <1> 	mov al, 01
   283                              <1> 
   284 00001F1E F9                  <1> 	stc
   285 00001F1F CD13                <1> 	int 13h
   286 00001F21 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
   287                              <1> 
   288 00001F23 E8E505              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
   289 00001F26 73E5                <1> 	jnc .load_file_sector
   290                              <1> 
   291 00001F28 B8[7C1F]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
   292 00001F2B E949FB              <1> 	jmp fatal_error
   293                              <1> 
   294                              <1> 
   295                              <1> .calculate_next_cluster:
   296 00001F2E A1[661F]            <1> 	mov ax, [.cluster]
   297 00001F31 BB0300              <1> 	mov bx, 3
   298 00001F34 F7E3                <1> 	mul bx
   299 00001F36 BB0200              <1> 	mov bx, 2
   300 00001F39 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
   301 00001F3B BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   302 00001F3E 01C6                <1> 	add si, ax
   303 00001F40 3E8B04              <1> 	mov ax, word [ds:si]
   304                              <1> 
   305 00001F43 09D2                <1> 	or dx, dx			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
   306                              <1> 
   307 00001F45 7405                <1> 	jz .even			; If [CLUSTER] = even, drop last 4 bits of word
   308                              <1> 					; with next cluster; if odd, drop first 4 bits
   309                              <1> 
   310                              <1> .odd:
   311 00001F47 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
   312 00001F4A EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   313                              <1> 
   314                              <1> .even:
   315 00001F4C 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
   316                              <1> 
   317                              <1> .calculate_cluster_cont:
   318 00001F4F A3[661F]            <1> 	mov word [.cluster], ax		; Store cluster
   319                              <1> 
   320 00001F52 3DF80F              <1> 	cmp ax, 0FF8h
   321 00001F55 7308                <1> 	jae .end
   322                              <1> 
   323 00001F57 8106[6C1F]0002      <1> 	add word [.load_position], 512
   324 00001F5D EBAE                <1> 	jmp .load_file_sector		; Onto next sector!
   325                              <1> 
   326                              <1> 
   327                              <1> .end:
   328 00001F5F 8B1E[6E1F]          <1> 	mov bx, [.file_size]		; Get file size to pass back in BX
   329 00001F63 F8                  <1> 	clc				; Carry clear = good load
   330 00001F64 C3                  <1> 	ret
   331                              <1> 
   332                              <1> 
   333 00001F65 00                  <1> 	.bootd		db 0 		; Boot device number
   334 00001F66 0000                <1> 	.cluster	dw 0 		; Cluster of the file we want to load
   335 00001F68 0000                <1> 	.pointer	dw 0 		; Pointer into disk_buffer, for loading 'file2load'
   336                              <1> 
   337 00001F6A 0000                <1> 	.filename_loc	dw 0		; Temporary store of filename location
   338 00001F6C 0000                <1> 	.load_position	dw 0		; Where we'll load the file
   339 00001F6E 0000                <1> 	.file_size	dw 0		; Size of the file
   340                              <1> 
   341 00001F70 00<rept>            <1> 	.string_buff	times 12 db 0	; For size (integer) printing
   342                              <1> 
   343 00001F7C 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy failed to reset', 0
   343 00001F85 696C653A20466C6F70- <1>
   343 00001F8E 7079206661696C6564- <1>
   343 00001F97 20746F207265736574- <1>
   343 00001FA0 00                  <1>
   344                              <1> 
   345                              <1> 
   346                              <1> ; --------------------------------------------------------------------------
   347                              <1> ; os_write_file -- Save (max 64K) file to disk
   348                              <1> ; IN: AX = filename, BX = data location, CX = bytes to write
   349                              <1> ; OUT: Carry clear if OK, set if failure
   350                              <1> 
   351                              <1> os_write_file:
   352 00001FA1 60                  <1> 	pusha
   353                              <1> 
   354 00001FA2 89C6                <1> 	mov si, ax
   355 00001FA4 E854EE              <1> 	call string_length
   356 00001FA7 83F800              <1> 	cmp ax, 0
   357 00001FAA 0F849201            <1> 	je near .failure
   358 00001FAE 89F0                <1> 	mov ax, si
   359                              <1> 
   360 00001FB0 E897EE              <1> 	call string_uppercase
   361 00001FB3 E82404              <1> 	call int_filename_convert	; Make filename FAT12-style
   362 00001FB6 0F828601            <1> 	jc near .failure
   363                              <1> 
   364 00001FBA 890E[4321]          <1> 	mov word [.filesize], cx
   365 00001FBE 891E[4921]          <1> 	mov word [.location], bx
   366 00001FC2 A3[4D21]            <1> 	mov word [.filename], ax
   367                              <1> 
   368 00001FC5 E88702              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
   369 00001FC8 0F837401            <1> 	jnc near .failure
   370                              <1> 
   371                              <1> 
   372                              <1> 	; First, zero out the .free_clusters list from any previous execution
   373 00001FCC 60                  <1> 	pusha
   374                              <1> 
   375 00001FCD BF[4F21]            <1> 	mov di, .free_clusters
   376 00001FD0 B98000              <1> 	mov cx, 128
   377                              <1> .clean_free_loop:
   378 00001FD3 C7050000            <1> 	mov word [di], 0
   379 00001FD7 47                  <1> 	inc di
   380 00001FD8 47                  <1> 	inc di
   381 00001FD9 E2F8                <1> 	loop .clean_free_loop
   382                              <1> 
   383 00001FDB 61                  <1> 	popa
   384                              <1> 
   385                              <1> 
   386                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
   387                              <1> 
   388 00001FDC 89C8                <1> 	mov ax, cx
   389 00001FDE BA0000              <1> 	mov dx, 0
   390 00001FE1 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
   391 00001FE4 F7F3                <1> 	div bx
   392 00001FE6 83FA00              <1> 	cmp dx, 0
   393 00001FE9 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
   394 00001FEB EB03                <1> 	jmp .carry_on
   395                              <1> 
   396                              <1> .add_a_bit:
   397 00001FED 83C001              <1> 	add ax, 1
   398                              <1> .carry_on:
   399                              <1> 
   400 00001FF0 A3[4B21]            <1> 	mov word [.clusters_needed], ax
   401                              <1> 
   402 00001FF3 A1[4D21]            <1> 	mov word ax, [.filename]	; Get filename back
   403                              <1> 
   404 00001FF6 E87502              <1> 	call os_create_file		; Create empty root dir entry for this file
   405 00001FF9 0F824301            <1> 	jc near .failure		; If we can't write to the media, jump out
   406                              <1> 
   407 00001FFD 8B1E[4321]          <1> 	mov word bx, [.filesize]
   408 00002001 83FB00              <1> 	cmp bx, 0
   409 00002004 0F843501            <1> 	je near .finished
   410                              <1> 
   411 00002008 E86B04              <1> 	call disk_read_fat		; Get FAT copy into RAM
   412 0000200B BE0360              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
   413                              <1> 
   414 0000200E BB0200              <1> 	mov bx, 2			; Current cluster counter
   415 00002011 8B0E[4B21]          <1> 	mov word cx, [.clusters_needed]
   416 00002015 BA0000              <1> 	mov dx, 0			; Offset in .free_clusters list
   417                              <1> 
   418                              <1> .find_free_cluster:
   419 00002018 AD                  <1> 	lodsw				; Get a word
   420 00002019 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
   421 0000201C 740D                <1> 	jz .found_free_even		; Free entry?
   422                              <1> 
   423                              <1> .more_odd:
   424 0000201E 43                  <1> 	inc bx				; If not, bump our counter
   425 0000201F 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
   426                              <1> 
   427 00002020 AD                  <1> 	lodsw				; Get word
   428 00002021 C1E804              <1> 	shr ax, 4			; Shift for odd
   429 00002024 09C0                <1> 	or ax, ax			; Free entry?
   430 00002026 7416                <1> 	jz .found_free_odd
   431                              <1> 
   432                              <1> .more_even:
   433 00002028 43                  <1> 	inc bx				; If not, keep going
   434 00002029 EBED                <1> 	jmp .find_free_cluster
   435                              <1> 
   436                              <1> 
   437                              <1> .found_free_even:
   438 0000202B 56                  <1> 	push si
   439 0000202C BE[4F21]            <1> 	mov si, .free_clusters		; Store cluster
   440 0000202F 01D6                <1> 	add si, dx
   441 00002031 891C                <1> 	mov word [si], bx
   442 00002033 5E                  <1> 	pop si
   443                              <1> 
   444 00002034 49                  <1> 	dec cx				; Got all the clusters we need?
   445 00002035 83F900              <1> 	cmp cx, 0
   446 00002038 7417                <1> 	je .finished_list
   447                              <1> 
   448 0000203A 42                  <1> 	inc dx				; Next word in our list
   449 0000203B 42                  <1> 	inc dx
   450 0000203C EBE0                <1> 	jmp .more_odd
   451                              <1> 
   452                              <1> .found_free_odd:
   453 0000203E 56                  <1> 	push si
   454 0000203F BE[4F21]            <1> 	mov si, .free_clusters		; Store cluster
   455 00002042 01D6                <1> 	add si, dx
   456 00002044 891C                <1> 	mov word [si], bx
   457 00002046 5E                  <1> 	pop si
   458                              <1> 
   459 00002047 49                  <1> 	dec cx
   460 00002048 83F900              <1> 	cmp cx, 0
   461 0000204B 7404                <1> 	je .finished_list
   462                              <1> 
   463 0000204D 42                  <1> 	inc dx				; Next word in our list
   464 0000204E 42                  <1> 	inc dx
   465 0000204F EBD7                <1> 	jmp .more_even
   466                              <1> 
   467                              <1> 
   468                              <1> 
   469                              <1> .finished_list:
   470                              <1> 
   471                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
   472                              <1> 	; that correspond to free clusters on the disk; the next job is to
   473                              <1> 	; create a cluster chain in the FAT for our file
   474                              <1> 
   475 00002051 B90000              <1> 	mov cx, 0			; .free_clusters offset counter
   476 00002054 C706[4721]0100      <1> 	mov word [.count], 1		; General cluster counter
   477                              <1> 
   478                              <1> .chain_loop:
   479 0000205A A1[4721]            <1> 	mov word ax, [.count]		; Is this the last cluster?
   480 0000205D 3B06[4B21]          <1> 	cmp word ax, [.clusters_needed]
   481 00002061 7455                <1> 	je .last_cluster
   482                              <1> 
   483 00002063 BF[4F21]            <1> 	mov di, .free_clusters
   484                              <1> 
   485 00002066 01CF                <1> 	add di, cx
   486 00002068 8B1D                <1> 	mov word bx, [di]		; Get cluster
   487                              <1> 
   488 0000206A 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
   489 0000206C BA0000              <1> 	mov dx, 0
   490 0000206F BB0300              <1> 	mov bx, 3
   491 00002072 F7E3                <1> 	mul bx
   492 00002074 BB0200              <1> 	mov bx, 2
   493 00002077 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   494 00002079 BE0060              <1> 	mov si, disk_buffer
   495 0000207C 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   496 0000207E 3E8B04              <1> 	mov ax, word [ds:si]
   497                              <1> 
   498 00002081 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   499 00002083 741B                <1> 	jz .even
   500                              <1> 
   501                              <1> .odd:
   502 00002085 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
   503 00002088 BF[4F21]            <1> 	mov di, .free_clusters
   504 0000208B 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   505 0000208D 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
   506 00002090 C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
   507 00002093 01D8                <1> 	add ax, bx
   508                              <1> 
   509 00002095 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   510                              <1> 
   511 00002098 FF06[4721]          <1> 	inc word [.count]
   512 0000209C 41                  <1> 	inc cx				; Move on a word in .free_clusters
   513 0000209D 41                  <1> 	inc cx
   514                              <1> 
   515 0000209E EBBA                <1> 	jmp .chain_loop
   516                              <1> 
   517                              <1> .even:
   518 000020A0 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
   519 000020A3 BF[4F21]            <1> 	mov di, .free_clusters
   520 000020A6 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   521 000020A8 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
   522                              <1> 
   523 000020AB 01D8                <1> 	add ax, bx
   524                              <1> 
   525 000020AD 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   526                              <1> 
   527 000020B0 FF06[4721]          <1> 	inc word [.count]
   528 000020B4 41                  <1> 	inc cx				; Move on a word in .free_clusters
   529 000020B5 41                  <1> 	inc cx
   530                              <1> 
   531 000020B6 EBA2                <1> 	jmp .chain_loop
   532                              <1> 
   533                              <1> 
   534                              <1> 
   535                              <1> .last_cluster:
   536 000020B8 BF[4F21]            <1> 	mov di, .free_clusters
   537 000020BB 01CF                <1> 	add di, cx
   538 000020BD 8B1D                <1> 	mov word bx, [di]		; Get cluster
   539                              <1> 
   540 000020BF 89D8                <1> 	mov ax, bx
   541                              <1> 
   542 000020C1 BA0000              <1> 	mov dx, 0
   543 000020C4 BB0300              <1> 	mov bx, 3
   544 000020C7 F7E3                <1> 	mul bx
   545 000020C9 BB0200              <1> 	mov bx, 2
   546 000020CC F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   547 000020CE BE0060              <1> 	mov si, disk_buffer
   548 000020D1 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   549 000020D3 3E8B04              <1> 	mov ax, word [ds:si]
   550                              <1> 
   551 000020D6 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   552 000020D8 7408                <1> 	jz .even_last
   553                              <1> 
   554                              <1> .odd_last:
   555 000020DA 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
   556 000020DD 83C080              <1> 	add ax, 0FF80h
   557 000020E0 EB06                <1> 	jmp .finito
   558                              <1> 
   559                              <1> .even_last:
   560 000020E2 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
   561 000020E5 05F80F              <1> 	add ax, 0FF8h
   562                              <1> 
   563                              <1> 
   564                              <1> .finito:
   565 000020E8 3E8904              <1> 	mov word [ds:si], ax
   566                              <1> 
   567 000020EB E8B403              <1> 	call disk_write_fat		; Save our FAT back to disk
   568                              <1> 
   569                              <1> 
   570                              <1> 	; Now it's time to save the sectors to disk!
   571                              <1> 
   572 000020EE B90000              <1> 	mov cx, 0
   573                              <1> 
   574                              <1> .save_loop:
   575 000020F1 BF[4F21]            <1> 	mov di, .free_clusters
   576 000020F4 01CF                <1> 	add di, cx
   577 000020F6 8B05                <1> 	mov word ax, [di]
   578                              <1> 
   579 000020F8 83F800              <1> 	cmp ax, 0
   580 000020FB 0F841D00            <1> 	je near .write_root_entry
   581                              <1> 
   582 000020FF 60                  <1> 	pusha
   583                              <1> 
   584 00002100 83C01F              <1> 	add ax, 31
   585                              <1> 
   586 00002103 E84E04              <1> 	call disk_convert_l2hts
   587                              <1> 
   588 00002106 8B1E[4921]          <1> 	mov word bx, [.location]
   589                              <1> 
   590 0000210A B403                <1> 	mov ah, 3
   591 0000210C B001                <1> 	mov al, 1
   592 0000210E F9                  <1> 	stc
   593 0000210F CD13                <1> 	int 13h
   594                              <1> 
   595 00002111 61                  <1> 	popa
   596                              <1> 
   597 00002112 8106[4921]0002      <1> 	add word [.location], 512
   598 00002118 41                  <1> 	inc cx
   599 00002119 41                  <1> 	inc cx
   600 0000211A EBD5                <1> 	jmp .save_loop
   601                              <1> 
   602                              <1> 
   603                              <1> .write_root_entry:
   604                              <1> 
   605                              <1> 	; Now it's time to head back to the root directory, find our
   606                              <1> 	; entry and update it with the cluster in use and file size
   607                              <1> 
   608 0000211C E8A203              <1> 	call disk_read_root_dir
   609                              <1> 
   610 0000211F A1[4D21]            <1> 	mov word ax, [.filename]
   611 00002122 E81903              <1> 	call disk_get_root_entry
   612                              <1> 
   613 00002125 A1[4F21]            <1> 	mov word ax, [.free_clusters]	; Get first free cluster
   614                              <1> 
   615 00002128 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
   616                              <1> 
   617 0000212B 8B0E[4321]          <1> 	mov word cx, [.filesize]
   618 0000212F 894D1C              <1> 	mov word [di+28], cx
   619                              <1> 
   620 00002132 C6451E00            <1> 	mov byte [di+30], 0		; File size
   621 00002136 C6451F00            <1> 	mov byte [di+31], 0
   622                              <1> 
   623 0000213A E8AF03              <1> 	call disk_write_root_dir
   624                              <1> 
   625                              <1> .finished:
   626 0000213D 61                  <1> 	popa
   627 0000213E F8                  <1> 	clc
   628 0000213F C3                  <1> 	ret
   629                              <1> 
   630                              <1> .failure:
   631 00002140 61                  <1> 	popa
   632 00002141 F9                  <1> 	stc				; Couldn't write!
   633 00002142 C3                  <1> 	ret
   634                              <1> 
   635                              <1> 
   636 00002143 0000                <1> 	.filesize	dw 0
   637 00002145 0000                <1> 	.cluster	dw 0
   638 00002147 0000                <1> 	.count		dw 0
   639 00002149 0000                <1> 	.location	dw 0
   640                              <1> 
   641 0000214B 0000                <1> 	.clusters_needed	dw 0
   642                              <1> 
   643 0000214D 0000                <1> 	.filename	dw 0
   644                              <1> 
   645 0000214F 0000<rept>          <1> 	.free_clusters	times 128 dw 0
   646                              <1> 
   647                              <1> 
   648                              <1> ; --------------------------------------------------------------------------
   649                              <1> ; os_file_exists -- Check for presence of file on the floppy
   650                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
   651                              <1> 
   652                              <1> os_file_exists:
   653 0000224F E8F8EB              <1> 	call string_uppercase
   654 00002252 E88501              <1> 	call int_filename_convert	; Make FAT12-style filename
   655                              <1> 
   656 00002255 50                  <1> 	push ax
   657 00002256 E8A2EB              <1> 	call string_length
   658 00002259 83F800              <1> 	cmp ax, 0
   659 0000225C 740D                <1> 	je .failure
   660 0000225E 58                  <1> 	pop ax
   661                              <1> 
   662 0000225F 50                  <1> 	push ax
   663 00002260 E85E02              <1> 	call disk_read_root_dir
   664                              <1> 
   665 00002263 58                  <1> 	pop ax				; Restore filename
   666 00002264 BF0060              <1> 	mov di, disk_buffer
   667 00002267 E8D401              <1> 	call disk_get_root_entry	; Set or clear carry flag
   668                              <1> 	
   669 0000226A C3                  <1> 	ret
   670                              <1> 
   671                              <1> .failure:
   672 0000226B 58                  <1> 	pop ax
   673 0000226C F9                  <1> 	stc
   674 0000226D C3                  <1> 	ret
   675                              <1> 
   676                              <1> 
   677                              <1> ; --------------------------------------------------------------------------
   678                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
   679                              <1> ; IN: AX = location of filename
   680                              <1> 
   681                              <1> os_create_file:
   682 0000226E F8                  <1> 	clc
   683                              <1> 
   684 0000226F E8D8EB              <1> 	call string_uppercase
   685 00002272 E86501              <1> 	call int_filename_convert	; Make FAT12-style filename
   686 00002275 60                  <1> 	pusha
   687                              <1> 
   688 00002276 50                  <1> 	push ax				; Save filename for now
   689                              <1> 
   690 00002277 E8D5FF              <1> 	call os_file_exists		; Does the file already exist?
   691 0000227A 7315                <1> 	jnc .exists_error
   692                              <1> 
   693                              <1> 
   694                              <1> 	; Root dir already read into disk_buffer by os_file_exists
   695                              <1> 
   696 0000227C BF0060              <1> 	mov di, disk_buffer		; So point DI at it!
   697                              <1> 
   698                              <1> 
   699 0000227F B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
   700                              <1> .next_entry:
   701 00002282 8A05                <1> 	mov byte al, [di]
   702 00002284 3C00                <1> 	cmp al, 0			; Is this a free entry?
   703 00002286 740D                <1> 	je .found_free_entry
   704 00002288 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
   705 0000228A 7409                <1> 	je .found_free_entry
   706 0000228C 83C720              <1> 	add di, 32			; If not, go onto next entry
   707 0000228F E2F1                <1> 	loop .next_entry
   708                              <1> 
   709                              <1> .exists_error:				; We also get here if above loop finds nothing
   710 00002291 58                  <1> 	pop ax				; Get filename back
   711                              <1> 
   712 00002292 61                  <1> 	popa
   713 00002293 F9                  <1> 	stc				; Set carry for failure
   714 00002294 C3                  <1> 	ret
   715                              <1> 
   716                              <1> 
   717                              <1> .found_free_entry:
   718 00002295 5E                  <1> 	pop si				; Get filename back
   719 00002296 B90B00              <1> 	mov cx, 11
   720 00002299 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
   721                              <1> 
   722                              <1> 
   723 0000229B 83EF0B              <1> 	sub di, 11			; Back to start of root dir entry, for clarity
   724                              <1> 
   725                              <1> 
   726 0000229E C6450B00            <1> 	mov byte [di+11], 0		; Attributes
   727 000022A2 C6450C00            <1> 	mov byte [di+12], 0		; Reserved
   728 000022A6 C6450D00            <1> 	mov byte [di+13], 0		; Reserved
   729 000022AA C6450EC6            <1> 	mov byte [di+14], 0C6h		; Creation time
   730 000022AE C6450F7E            <1> 	mov byte [di+15], 07Eh		; Creation time
   731 000022B2 C6451000            <1> 	mov byte [di+16], 0		; Creation date
   732 000022B6 C6451100            <1> 	mov byte [di+17], 0		; Creation date
   733 000022BA C6451200            <1> 	mov byte [di+18], 0		; Last access date
   734 000022BE C6451300            <1> 	mov byte [di+19], 0		; Last access date
   735 000022C2 C6451400            <1> 	mov byte [di+20], 0		; Ignore in FAT12
   736 000022C6 C6451500            <1> 	mov byte [di+21], 0		; Ignore in FAT12
   737 000022CA C64516C6            <1> 	mov byte [di+22], 0C6h		; Last write time
   738 000022CE C645177E            <1> 	mov byte [di+23], 07Eh		; Last write time
   739 000022D2 C6451800            <1> 	mov byte [di+24], 0		; Last write date
   740 000022D6 C6451900            <1> 	mov byte [di+25], 0		; Last write date
   741 000022DA C6451A00            <1> 	mov byte [di+26], 0		; First logical cluster
   742 000022DE C6451B00            <1> 	mov byte [di+27], 0		; First logical cluster
   743 000022E2 C6451C00            <1> 	mov byte [di+28], 0		; File size
   744 000022E6 C6451D00            <1> 	mov byte [di+29], 0		; File size
   745 000022EA C6451E00            <1> 	mov byte [di+30], 0		; File size
   746 000022EE C6451F00            <1> 	mov byte [di+31], 0		; File size
   747                              <1> 
   748 000022F2 E8F701              <1> 	call disk_write_root_dir
   749 000022F5 7203                <1> 	jc .failure
   750                              <1> 
   751 000022F7 61                  <1> 	popa
   752 000022F8 F8                  <1> 	clc				; Clear carry for success
   753 000022F9 C3                  <1> 	ret
   754                              <1> 
   755                              <1> .failure:
   756 000022FA 61                  <1> 	popa
   757 000022FB F9                  <1> 	stc
   758 000022FC C3                  <1> 	ret
   759                              <1> 
   760                              <1> 
   761                              <1> ; --------------------------------------------------------------------------
   762                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
   763                              <1> ; IN: AX = location of filename to remove
   764                              <1> 
   765                              <1> os_remove_file:
   766 000022FD 60                  <1> 	pusha
   767 000022FE E849EB              <1> 	call string_uppercase
   768 00002301 E8D600              <1> 	call int_filename_convert	; Make filename FAT12-style
   769 00002304 50                  <1> 	push ax				; Save filename
   770                              <1> 
   771 00002305 F8                  <1> 	clc
   772                              <1> 
   773 00002306 E8B801              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
   774                              <1> 
   775 00002309 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
   776                              <1> 
   777 0000230C 58                  <1> 	pop ax				; Get chosen filename back
   778                              <1> 
   779 0000230D E82E01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
   780 00002310 7269                <1> 	jc .failure			; If entry can't be found
   781                              <1> 
   782                              <1> 
   783 00002312 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
   784 00002316 A3[7E23]            <1> 	mov word [.cluster], ax		; And save it
   785                              <1> 
   786 00002319 C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
   787                              <1> 
   788 0000231C 47                  <1> 	inc di
   789                              <1> 
   790 0000231D B90000              <1> 	mov cx, 0			; Set rest of data in root dir entry to zeros
   791                              <1> .clean_loop:
   792 00002320 C60500              <1> 	mov byte [di], 0
   793 00002323 47                  <1> 	inc di
   794 00002324 41                  <1> 	inc cx
   795 00002325 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
   796 00002328 7CF6                <1> 	jl .clean_loop
   797                              <1> 
   798 0000232A E8BF01              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
   799                              <1> 
   800                              <1> 
   801 0000232D E84601              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
   802 00002330 BF0060              <1> 	mov di, disk_buffer		; And DI points to it
   803                              <1> 
   804                              <1> 
   805                              <1> .more_clusters:
   806 00002333 A1[7E23]            <1> 	mov word ax, [.cluster]		; Get cluster contents
   807                              <1> 
   808 00002336 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
   809 00002339 743D                <1> 	je .nothing_to_do
   810                              <1> 
   811 0000233B BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
   812 0000233E F7E3                <1> 	mul bx
   813 00002340 BB0200              <1> 	mov bx, 2
   814 00002343 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
   815 00002345 BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   816 00002348 01C6                <1> 	add si, ax
   817 0000234A 3E8B04              <1> 	mov ax, word [ds:si]
   818                              <1> 
   819 0000234D 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
   820                              <1> 
   821 0000234F 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
   822                              <1> 					; with next cluster; if odd, drop first 4 bits
   823                              <1> .odd:
   824 00002351 50                  <1> 	push ax
   825 00002352 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
   826 00002355 3E8904              <1> 	mov word [ds:si], ax
   827 00002358 58                  <1> 	pop ax
   828                              <1> 
   829 00002359 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
   830 0000235C EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   831                              <1> 
   832                              <1> .even:
   833 0000235E 50                  <1> 	push ax
   834 0000235F 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
   835 00002362 3E8904              <1> 	mov word [ds:si], ax
   836 00002365 58                  <1> 	pop ax
   837                              <1> 
   838 00002366 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
   839                              <1> 
   840                              <1> .calculate_cluster_cont:
   841 00002369 A3[7E23]            <1> 	mov word [.cluster], ax		; Store cluster
   842                              <1> 
   843 0000236C 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
   844 0000236F 7302                <1> 	jae .end
   845                              <1> 
   846 00002371 EBC0                <1> 	jmp .more_clusters		; If not, grab more
   847                              <1> 
   848                              <1> .end:
   849 00002373 E82C01              <1> 	call disk_write_fat
   850 00002376 7203                <1> 	jc .failure
   851                              <1> 
   852                              <1> .nothing_to_do:
   853 00002378 61                  <1> 	popa
   854 00002379 F8                  <1> 	clc
   855 0000237A C3                  <1> 	ret
   856                              <1> 
   857                              <1> .failure:
   858 0000237B 61                  <1> 	popa
   859 0000237C F9                  <1> 	stc
   860 0000237D C3                  <1> 	ret
   861                              <1> 
   862                              <1> 
   863 0000237E 0000                <1> 	.cluster dw 0
   864                              <1> 
   865                              <1> 
   866                              <1> ; --------------------------------------------------------------------------
   867                              <1> ; os_rename_file -- Change the name of a file on the disk
   868                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
   869                              <1> ; OUT: carry set on error
   870                              <1> 
   871                              <1> os_rename_file:
   872 00002380 53                  <1> 	push bx
   873 00002381 50                  <1> 	push ax
   874                              <1> 
   875 00002382 F8                  <1> 	clc
   876                              <1> 
   877 00002383 E83B01              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
   878                              <1> 
   879 00002386 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
   880                              <1> 
   881 00002389 58                  <1> 	pop ax				; Get chosen filename back
   882                              <1> 
   883 0000238A E8BDEA              <1> 	call string_uppercase
   884 0000238D E84A00              <1> 	call int_filename_convert
   885                              <1> 
   886 00002390 E8AB00              <1> 	call disk_get_root_entry	; Entry will be returned in DI
   887 00002393 7217                <1> 	jc .fail_read			; Quit out if file not found
   888                              <1> 
   889 00002395 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
   890                              <1> 
   891 00002396 89D8                <1> 	mov ax, bx
   892                              <1> 
   893 00002398 E8AFEA              <1> 	call string_uppercase
   894 0000239B E83C00              <1> 	call int_filename_convert
   895                              <1> 
   896 0000239E 89C6                <1> 	mov si, ax
   897                              <1> 
   898 000023A0 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
   899 000023A3 F3A4                <1> 	rep movsb
   900                              <1> 
   901 000023A5 E84401              <1> 	call disk_write_root_dir	; Save root dir to disk
   902 000023A8 7205                <1> 	jc .fail_write
   903                              <1> 
   904 000023AA F8                  <1> 	clc
   905 000023AB C3                  <1> 	ret
   906                              <1> 
   907                              <1> .fail_read:
   908 000023AC 58                  <1> 	pop ax
   909 000023AD F9                  <1> 	stc
   910 000023AE C3                  <1> 	ret
   911                              <1> 
   912                              <1> .fail_write:
   913 000023AF F9                  <1> 	stc
   914 000023B0 C3                  <1> 	ret
   915                              <1> 
   916                              <1> 
   917                              <1> ; --------------------------------------------------------------------------
   918                              <1> ; os_get_file_size -- Get file size information for specified file
   919                              <1> ; IN: AX = filename; OUT: BX = file size in bytes (up to 64K)
   920                              <1> ; or carry set if file not found
   921                              <1> 
   922                              <1> os_get_file_size:
   923 000023B1 60                  <1> 	pusha
   924                              <1> 
   925 000023B2 E895EA              <1> 	call string_uppercase
   926 000023B5 E82200              <1> 	call int_filename_convert
   927                              <1> 
   928 000023B8 F8                  <1> 	clc
   929                              <1> 
   930 000023B9 50                  <1> 	push ax
   931                              <1> 
   932 000023BA E80401              <1> 	call disk_read_root_dir
   933 000023BD 7216                <1> 	jc .failure
   934                              <1> 
   935 000023BF 58                  <1> 	pop ax
   936                              <1> 
   937 000023C0 BF0060              <1> 	mov di, disk_buffer
   938                              <1> 
   939 000023C3 E87800              <1> 	call disk_get_root_entry
   940 000023C6 720D                <1> 	jc .failure
   941                              <1> 
   942 000023C8 8B5D1C              <1> 	mov word bx, [di+28]
   943                              <1> 
   944 000023CB 891E[D823]          <1> 	mov word [.tmp], bx
   945                              <1> 
   946 000023CF 61                  <1> 	popa
   947                              <1> 
   948 000023D0 8B1E[D823]          <1> 	mov word bx, [.tmp]
   949                              <1> 
   950 000023D4 C3                  <1> 	ret
   951                              <1> 
   952                              <1> .failure:
   953 000023D5 61                  <1> 	popa
   954 000023D6 F9                  <1> 	stc
   955 000023D7 C3                  <1> 	ret
   956                              <1> 
   957                              <1> 
   958 000023D8 0000                <1> 	.tmp	dw 0
   959                              <1> 
   960                              <1> 
   961                              <1> ; ==================================================================
   962                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
   963                              <1> 
   964                              <1> ; ------------------------------------------------------------------
   965                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
   966                              <1> ; IN: AX = filename string
   967                              <1> ; OUT: AX = location of converted string (carry set if invalid)
   968                              <1> 
   969                              <1> int_filename_convert:
   970 000023DA 60                  <1> 	pusha
   971                              <1> 
   972 000023DB 89C6                <1> 	mov si, ax
   973                              <1> 
   974 000023DD E81BEA              <1> 	call string_length
   975 000023E0 83F80E              <1> 	cmp ax, 14			; Filename too long?
   976 000023E3 7F49                <1> 	jg .failure			; Fail if so
   977                              <1> 
   978 000023E5 83F800              <1> 	cmp ax, 0
   979 000023E8 7444                <1> 	je .failure			; Similarly, fail if zero-char string
   980                              <1> 
   981 000023EA 89C2                <1> 	mov dx, ax			; Store string length for now
   982                              <1> 
   983 000023EC BF[3124]            <1> 	mov di, .dest_string
   984                              <1> 
   985 000023EF B90000              <1> 	mov cx, 0
   986                              <1> .copy_loop:
   987 000023F2 AC                  <1> 	lodsb
   988 000023F3 3C2E                <1> 	cmp al, '.'
   989 000023F5 7408                <1> 	je .extension_found
   990 000023F7 AA                  <1> 	stosb
   991 000023F8 41                  <1> 	inc cx
   992 000023F9 39D1                <1> 	cmp cx, dx
   993 000023FB 7F31                <1> 	jg .failure			; No extension found = wrong
   994 000023FD EBF3                <1> 	jmp .copy_loop
   995                              <1> 
   996                              <1> .extension_found:
   997 000023FF 83F900              <1> 	cmp cx, 0
   998 00002402 742A                <1> 	je .failure			; Fail if extension dot is first char
   999                              <1> 
  1000 00002404 83F908              <1> 	cmp cx, 8
  1001 00002407 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  1002                              <1> 
  1003                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  1004                              <1> 	; with spaces, if necessary
  1005                              <1> 
  1006                              <1> .add_spaces:
  1007 00002409 C60520              <1> 	mov byte [di], ' '
  1008 0000240C 47                  <1> 	inc di
  1009 0000240D 41                  <1> 	inc cx
  1010 0000240E 83F908              <1> 	cmp cx, 8
  1011 00002411 7CF6                <1> 	jl .add_spaces
  1012                              <1> 
  1013                              <1> 	; Finally, copy over the extension
  1014                              <1> .do_extension:
  1015 00002413 AC                  <1> 	lodsb				; 3 characters
  1016 00002414 3C00                <1> 	cmp al, 0
  1017 00002416 7416                <1> 	je .failure
  1018 00002418 AA                  <1> 	stosb
  1019 00002419 AC                  <1> 	lodsb
  1020 0000241A 3C00                <1> 	cmp al, 0
  1021 0000241C 7410                <1> 	je .failure
  1022 0000241E AA                  <1> 	stosb
  1023 0000241F AC                  <1> 	lodsb
  1024 00002420 3C00                <1> 	cmp al, 0
  1025 00002422 740A                <1> 	je .failure
  1026 00002424 AA                  <1> 	stosb
  1027                              <1> 
  1028 00002425 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  1029                              <1> 
  1030 00002428 61                  <1> 	popa
  1031 00002429 B8[3124]            <1> 	mov ax, .dest_string
  1032 0000242C F8                  <1> 	clc				; Clear carry for success
  1033 0000242D C3                  <1> 	ret
  1034                              <1> 
  1035                              <1> 
  1036                              <1> .failure:
  1037 0000242E 61                  <1> 	popa
  1038 0000242F F9                  <1> 	stc				; Set carry for failure
  1039 00002430 C3                  <1> 	ret
  1040                              <1> 
  1041                              <1> 
  1042 00002431 00<rept>            <1> 	.dest_string	times 13 db 0
  1043                              <1> 
  1044                              <1> 
  1045                              <1> ; --------------------------------------------------------------------------
  1046                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  1047                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  1048                              <1> ; or carry set if file not found
  1049                              <1> 
  1050                              <1> disk_get_root_entry:
  1051 0000243E 60                  <1> 	pusha
  1052                              <1> 
  1053 0000243F A3[7224]            <1> 	mov word [.filename], ax
  1054                              <1> 
  1055 00002442 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  1056 00002445 B80000              <1> 	mov ax, 0			; Searching at offset 0
  1057                              <1> 
  1058                              <1> .to_next_root_entry:
  1059 00002448 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  1060                              <1> 
  1061 0000244A 8B36[7224]          <1> 	mov word si, [.filename]	; Start searching for filename
  1062 0000244E B90B00              <1> 	mov cx, 11
  1063 00002451 F3A6                <1> 	rep cmpsb
  1064 00002453 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  1065                              <1> 
  1066 00002455 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  1067                              <1> 
  1068 00002458 BF0060              <1> 	mov di, disk_buffer		; Point to next root dir entry
  1069 0000245B 01C7                <1> 	add di, ax
  1070                              <1> 
  1071 0000245D 87D1                <1> 	xchg dx, cx			; Get the original CX back
  1072 0000245F E2E7                <1> 	loop .to_next_root_entry
  1073                              <1> 
  1074 00002461 61                  <1> 	popa
  1075                              <1> 
  1076 00002462 F9                  <1> 	stc				; Set carry if entry not found
  1077 00002463 C3                  <1> 	ret
  1078                              <1> 
  1079                              <1> 
  1080                              <1> .found_file:
  1081 00002464 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  1082                              <1> 
  1083 00002467 893E[7424]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  1084                              <1> 
  1085 0000246B 61                  <1> 	popa
  1086                              <1> 
  1087 0000246C 8B3E[7424]          <1> 	mov word di, [.tmp]
  1088                              <1> 
  1089 00002470 F8                  <1> 	clc
  1090 00002471 C3                  <1> 	ret
  1091                              <1> 
  1092                              <1> 
  1093 00002472 0000                <1> 	.filename	dw 0
  1094 00002474 0000                <1> 	.tmp		dw 0
  1095                              <1> 
  1096                              <1> 
  1097                              <1> ; --------------------------------------------------------------------------
  1098                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  1099                              <1> ; IN: Nothing; OUT: carry set if failure
  1100                              <1> 
  1101                              <1> disk_read_fat:
  1102 00002476 60                  <1> 	pusha
  1103                              <1> 
  1104 00002477 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1105 0000247A E8D700              <1> 	call disk_convert_l2hts
  1106                              <1> 
  1107 0000247D BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1108 00002480 BB0020              <1> 	mov bx, 2000h
  1109 00002483 8EC3                <1> 	mov es, bx
  1110 00002485 89F3                <1> 	mov bx, si
  1111                              <1> 
  1112 00002487 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1113 00002489 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  1114                              <1> 
  1115 0000248B 60                  <1> 	pusha				; Prepare to enter loop
  1116                              <1> 
  1117                              <1> 
  1118                              <1> .read_fat_loop:
  1119 0000248C 61                  <1> 	popa
  1120 0000248D 60                  <1> 	pusha
  1121                              <1> 
  1122 0000248E F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1123 0000248F CD13                <1> 	int 13h				; Read sectors
  1124                              <1> 
  1125 00002491 7308                <1> 	jnc .fat_done
  1126 00002493 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  1127 00002496 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  1128                              <1> 
  1129 00002498 61                  <1> 	popa
  1130 00002499 EB04                <1> 	jmp .read_failure		; Fatal double error
  1131                              <1> 
  1132                              <1> .fat_done:
  1133 0000249B 61                  <1> 	popa				; Restore registers from main loop
  1134                              <1> 
  1135 0000249C 61                  <1> 	popa				; And restore registers from start of system call
  1136 0000249D F8                  <1> 	clc
  1137 0000249E C3                  <1> 	ret
  1138                              <1> 
  1139                              <1> .read_failure:
  1140 0000249F 61                  <1> 	popa
  1141 000024A0 F9                  <1> 	stc				; Set carry flag (for failure)
  1142 000024A1 C3                  <1> 	ret
  1143                              <1> 
  1144                              <1> 
  1145                              <1> ; --------------------------------------------------------------------------
  1146                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  1147                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  1148                              <1> 
  1149                              <1> disk_write_fat:
  1150 000024A2 60                  <1> 	pusha
  1151                              <1> 
  1152 000024A3 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1153 000024A6 E8AB00              <1> 	call disk_convert_l2hts
  1154                              <1> 
  1155 000024A9 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1156 000024AC 8CDB                <1> 	mov bx, ds
  1157 000024AE 8EC3                <1> 	mov es, bx
  1158 000024B0 89F3                <1> 	mov bx, si
  1159                              <1> 
  1160 000024B2 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1161 000024B4 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  1162                              <1> 
  1163 000024B6 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1164 000024B7 CD13                <1> 	int 13h				; Write sectors
  1165                              <1> 
  1166 000024B9 7203                <1> 	jc .write_failure		; Fatal double error
  1167                              <1> 
  1168 000024BB 61                  <1> 	popa				; And restore from start of system call
  1169 000024BC F8                  <1> 	clc
  1170 000024BD C3                  <1> 	ret
  1171                              <1> 
  1172                              <1> .write_failure:
  1173 000024BE 61                  <1> 	popa
  1174 000024BF F9                  <1> 	stc				; Set carry flag (for failure)
  1175 000024C0 C3                  <1> 	ret
  1176                              <1> 
  1177                              <1> 
  1178                              <1> ; --------------------------------------------------------------------------
  1179                              <1> ; disk_read_root_dir -- Get the root directory contents
  1180                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  1181                              <1> 
  1182                              <1> disk_read_root_dir:
  1183 000024C1 60                  <1> 	pusha
  1184                              <1> 
  1185 000024C2 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1186 000024C5 E88C00              <1> 	call disk_convert_l2hts
  1187                              <1> 
  1188 000024C8 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1189 000024CB 8CDB                <1> 	mov bx, ds
  1190 000024CD 8EC3                <1> 	mov es, bx
  1191 000024CF 89F3                <1> 	mov bx, si
  1192                              <1> 
  1193 000024D1 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1194 000024D3 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  1195                              <1> 
  1196 000024D5 60                  <1> 	pusha				; Prepare to enter loop
  1197                              <1> 
  1198                              <1> 
  1199                              <1> .read_root_dir_loop:
  1200 000024D6 61                  <1> 	popa
  1201 000024D7 60                  <1> 	pusha
  1202                              <1> 
  1203 000024D8 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1204 000024D9 CD13                <1> 	int 13h				; Read sectors
  1205                              <1> 
  1206 000024DB 7308                <1> 	jnc .root_dir_finished
  1207 000024DD E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  1208 000024E0 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  1209                              <1> 
  1210 000024E2 61                  <1> 	popa
  1211 000024E3 EB04                <1> 	jmp .read_failure		; Fatal double error
  1212                              <1> 
  1213                              <1> 
  1214                              <1> .root_dir_finished:
  1215 000024E5 61                  <1> 	popa				; Restore registers from main loop
  1216                              <1> 
  1217 000024E6 61                  <1> 	popa				; And restore from start of this system call
  1218 000024E7 F8                  <1> 	clc				; Clear carry (for success)
  1219 000024E8 C3                  <1> 	ret
  1220                              <1> 
  1221                              <1> .read_failure:
  1222 000024E9 61                  <1> 	popa
  1223 000024EA F9                  <1> 	stc				; Set carry flag (for failure)
  1224 000024EB C3                  <1> 	ret
  1225                              <1> 
  1226                              <1> 
  1227                              <1> ; --------------------------------------------------------------------------
  1228                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  1229                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  1230                              <1> 
  1231                              <1> disk_write_root_dir:
  1232 000024EC 60                  <1> 	pusha
  1233                              <1> 
  1234 000024ED B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1235 000024F0 E86100              <1> 	call disk_convert_l2hts
  1236                              <1> 
  1237 000024F3 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1238 000024F6 8CDB                <1> 	mov bx, ds
  1239 000024F8 8EC3                <1> 	mov es, bx
  1240 000024FA 89F3                <1> 	mov bx, si
  1241                              <1> 
  1242 000024FC B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1243 000024FE B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  1244                              <1> 
  1245 00002500 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1246 00002501 CD13                <1> 	int 13h				; Write sectors
  1247 00002503 7203                <1> 	jc .write_failure
  1248                              <1> 
  1249 00002505 61                  <1> 	popa				; And restore from start of this system call
  1250 00002506 F8                  <1> 	clc
  1251 00002507 C3                  <1> 	ret
  1252                              <1> 
  1253                              <1> .write_failure:
  1254 00002508 61                  <1> 	popa
  1255 00002509 F9                  <1> 	stc				; Set carry flag (for failure)
  1256 0000250A C3                  <1> 	ret
  1257                              <1> 
  1258                              <1> 
  1259                              <1> ; --------------------------------------------------------------------------
  1260                              <1> ; Reset floppy disk
  1261                              <1> 
  1262                              <1> disk_reset_floppy:
  1263 0000250B 50                  <1> 	push ax
  1264 0000250C 52                  <1> 	push dx
  1265 0000250D B80000              <1> 	mov ax, 0
  1266                              <1> ; ******************************************************************
  1267 00002510 8A16[8325]          <1> 	mov dl, [bootdev]
  1268                              <1> ; ******************************************************************
  1269 00002514 F9                  <1> 	stc
  1270 00002515 CD13                <1> 	int 13h
  1271 00002517 5A                  <1> 	pop dx
  1272 00002518 58                  <1> 	pop ax
  1273 00002519 C3                  <1> 	ret
  1274                              <1> 
  1275                              <1> 
  1276                              <1> ; --------------------------------------------------------------------------
  1277                              <1> ; chk_string_ext -- Check if a file has a 3 letter extension, if not add it
  1278                              <1> ; IN: SI = String
  1279                              <1> ;     AX = Truncate length
  1280                              <1> ; OUT SI = String with extension
  1281                              <1> 
  1282                              <1> chk_string_ext:
  1283 0000251A 50                  <1> 	push ax
  1284 0000251B 53                  <1> 	push bx
  1285                              <1> 
  1286 0000251C E86EE9              <1> 	call string_truncate
  1287                              <1> 
  1288 0000251F 50                  <1> 	push ax
  1289 00002520 56                  <1> 	push si
  1290 00002521 89F0                <1> 	mov ax, si
  1291 00002523 E8D5E8              <1> 	call string_length
  1292 00002526 01C6                <1> 	add si, ax
  1293                              <1> 
  1294 00002528 83EE04              <1> 	sub si, 4
  1295 0000252B 8A04                <1> 	mov al, [si]
  1296 0000252D 3C2E                <1> 	cmp al, '.'
  1297 0000252F 7504                <1> 	jne .ext_not_found
  1298                              <1> 
  1299 00002531 5E                  <1> 	pop si
  1300 00002532 58                  <1> 	pop ax
  1301 00002533 EB17                <1> 	jmp .ext_found
  1302                              <1> 
  1303                              <1> 	.ext_not_found:
  1304 00002535 5E                  <1> 		pop si
  1305 00002536 58                  <1> 		pop ax
  1306 00002537 83F808              <1> 		cmp ax, 8
  1307 0000253A 7C06                <1> 		jl .skip_trun
  1308                              <1> 
  1309 0000253C B80800              <1> 	mov ax, 8
  1310 0000253F E84BE9              <1> 	call string_truncate
  1311                              <1> 
  1312                              <1> 	.skip_trun:
  1313 00002542 89F0                <1> 		mov ax, si
  1314 00002544 BB[4F25]            <1> 		mov bx, .tmp_ext
  1315 00002547 E852E9              <1> 		call string_join
  1316 0000254A 89CE                <1> 		mov si, cx
  1317                              <1> 
  1318                              <1> 	.ext_found:
  1319 0000254C 58                  <1> 		pop ax
  1320 0000254D 5B                  <1> 		pop bx
  1321 0000254E C3                  <1> 		ret
  1322                              <1> 
  1323 0000254F 2E74787400          <1> 	.tmp_ext:	db ".txt", 0
  1324                              <1> 
  1325                              <1> 
  1326                              <1> ; --------------------------------------------------------------------------
  1327                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  1328                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  1329                              <1> 
  1330                              <1> disk_convert_l2hts:
  1331 00002554 53                  <1> 	push bx
  1332 00002555 50                  <1> 	push ax
  1333                              <1> 
  1334 00002556 89C3                <1> 	mov bx, ax			; Save logical sector
  1335                              <1> 
  1336 00002558 BA0000              <1> 	mov dx, 0			; First the sector
  1337 0000255B F736[8125]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1338 0000255F 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  1339 00002562 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  1340 00002564 89D8                <1> 	mov ax, bx
  1341                              <1> 
  1342 00002566 BA0000              <1> 	mov dx, 0			; Now calculate the head
  1343 00002569 F736[8125]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1344 0000256D BA0000              <1> 	mov dx, 0
  1345 00002570 F736[7F25]          <1> 	div word [Sides]		; Floppy sides
  1346 00002574 88D6                <1> 	mov dh, dl			; Head/side
  1347 00002576 88C5                <1> 	mov ch, al			; Track
  1348                              <1> 
  1349 00002578 58                  <1> 	pop ax
  1350 00002579 5B                  <1> 	pop bx
  1351                              <1> 
  1352                              <1> ; ******************************************************************
  1353 0000257A 8A16[8325]          <1> 	mov dl, [bootdev]		; Set correct device
  1354                              <1> ; ******************************************************************
  1355                              <1> 
  1356 0000257E C3                  <1> 	ret
  1357                              <1> 
  1358                              <1> 
  1359 0000257F 0200                <1> 	Sides dw 2
  1360 00002581 1200                <1> 	SecsPerTrack dw 18
  1361                              <1> ; ******************************************************************
  1362 00002583 00                  <1> 	bootdev db 0			; Boot device number
  1363                              <1> ; ******************************************************************
  1364                              <1> ; ==================================================================
   379                                      %include "./includes/checkin.asm"
     1                              <1> check_com:      ; AX = command
     2 00002584 BE[B601]            <1>     mov si, in_buffer
     3 00002587 89C7                <1>     mov di, ax
     4                              <1> 
     5                              <1> .check_loop:
     6 00002589 AC                  <1>     lodsb
     7 0000258A 3A05                <1>     cmp al, [di]
     8 0000258C 7509                <1>     jne .not_equal
     9                              <1>     
    10 0000258E B000                <1>     mov al, 0
    11 00002590 3805                <1>     cmp [di], al
    12 00002592 7405                <1>     je .done
    13                              <1> 
    14 00002594 47                  <1>     inc di
    15 00002595 EBF2                <1>     jmp .check_loop
    16                              <1> 
    17                              <1> .not_equal:
    18 00002597 F9                  <1>     stc
    19 00002598 C3                  <1>     ret
    20                              <1> 
    21                              <1> .done:
    22 00002599 F8                  <1>     clc
    23 0000259A C3                  <1>     ret
   380                                  
   381                                  ; ==================================================================
   382                                  ; END OF KERNEL
   383                                  ; ==================================================================
