     1                                  ; ==================================================================
     2                                  ; The Kronk Operating System kernel
     3                                  ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                                  ;
     5                                  ; This is loaded from the drive by BOOTLOAD.BIN, as KERNEL.BIN
     6                                  ; ==================================================================
     7                                  
     8                                      ORG 0x0000
     9                                      BITS 16
    10                                      
    11                                      %define KRONKOS_VER '0.3.2'
    12                                      %define KRONKOS_API 4
    13                                      
    14                                      ; RAM locations
    15                                      disk_buffer     equ 24576
    16                                      prg_load_loc    equ 32768
    17                                      set_load_loc    equ 36864
    18                                  
    19                                      ; Screen mouse clamps
    20                                      screenmaxW      equ 0x004E
    21                                      screenminW      equ 0x0001
    22                                      screenmaxH      equ 0x0017
    23                                      screenminH      equ 0x0001
    24                                      
    25                                      ; Mouse buttons
    26                                      leftMButton     equ 0x09
    27                                      rightMButton    equ 0x0A
    28                                  
    29                                      ; Screen modes
    30                                      vidRes          equ 0x13
    31                                      cliRes          equ 0x03
    32                                  
    33                                  ; ******************************************************************
    34                                  ; Start the kernel
    35                                  kernel_start:
    36 00000000 E8E91A                      call seed_random
    37                                  
    38 00000003 FA                          cli                         ; Clear interrupts
    39 00000004 B80020                      mov ax, 0x2000              ; The bootloader loads us at 0x2000
    40 00000007 8ED8                        mov ds, ax                  ; Set DS and ES to 0x2000
    41 00000009 8EC0                        mov es, ax
    42                                  
    43                                      ; Stack just below 0x2000:0x0000 starting at 0x1000:0x0000.
    44                                      ; First push will set SS:SP to 0x1000:0xfffe because SP will wrap.
    45 0000000B B80010                      mov ax, 0x1000
    46 0000000E 8ED0                        mov ss, ax
    47 00000010 31E4                        xor sp, sp
    48                                  
    49 00000012 FC                          cld                         ; Clear Direction Flag (DF=0 is for forward string movement)
    50                                  ; ******************************************************************
    51                                  
    52                                  
    53                                  ; ==================================================================
    54                                  ; START OF KERNEL
    55                                  ; ==================================================================
    56                                  
    57                                  RESET:
    58 00000013 31C0                    	xor ax, ax
    59 00000015 31DB                    	xor bx, bx
    60 00000017 31C9                    	xor cx, cx
    61 00000019 31D2                    	xor dx, dx
    62 0000001B 31F6                    	xor si, si
    63 0000001D 31FF                    	xor di, di
    64                                  
    65                                      ; Change the cursor to a solid block
    66 0000001F B500                        mov ch, 0x00
    67 00000021 E8C711                      call change_cursor
    68                                  
    69                                      ; Check if SETTINGS.KSF exists
    70 00000024 B8[1D03]                    mov ax, settings_filename
    71 00000027 E89521                      call os_file_exists
    72 0000002A 7311                        jnc .skip_setup     ; If it does... skip the setup
    73                                  
    74 0000002C E8E50A                      call setup_init
    75                                  
    76                                      ; Save the settings
    77 0000002F B8[1D03]                    mov ax, settings_filename
    78 00000032 BB0090                      mov bx, set_load_loc
    79 00000035 B9[7E01]                    mov cx, usrNam
    80 00000038 E8D61E                      call os_write_file
    81                                  
    82 0000003B EBD6                        jmp RESET
    83                                  
    84                                  .skip_setup:
    85                                      ; Load the settings file
    86 0000003D B8[1D03]                    mov ax, settings_filename
    87 00000040 B90090                      mov cx, set_load_loc
    88 00000043 31DB                        xor bx, bx
    89 00000045 E88A1D                      call os_load_file
    90                                  
    91 00000048 89DE                        mov si, bx
    92 0000004A BF[7E01]                    mov di, usrNam
    93 0000004D E8EA0D                      call string_copy
    94                                  
    95 00000050 8A26[9301]                  mov ah, [vidMode]
    96 00000054 80FC00                      cmp ah, 0
    97 00000057 7405                        je .startCli
    98 00000059 80FC01                      cmp ah, 1
    99 0000005C 7404                        je .startVideo
   100                                  
   101                                  .startCli:
   102 0000005E E81505                      call kronk_cli
   103 00000061 F4                          hlt
   104                                  
   105                                  .startVideo:
   106 00000062 E88C0A                      call kronk_vid
   107 00000065 F4                          hlt
   108                                  
   109                                  
   110                                  ; ==================================================================
   111                                  ; JUMP VECTORS
   112                                  ; ==================================================================
   113                                  
   114                                  JUMP_VECTORS:
   115 00000066 EB98                        jmp kernel_start        ; 0x0066
   116 00000068 E9EB1A                      jmp print               ; 0x0068
   117 0000006B E92D0D                      jmp cls                 ; 0x006B
   118 0000006E E94E21                      jmp os_file_exists      ; 0x006E
   119 00000071 E95E1D                      jmp os_load_file        ; 0x0071
   120 00000074 E96721                      jmp os_create_file      ; 0x0074
   121 00000077 E9F321                      jmp os_remove_file      ; 0x0077
   122 0000007A E9941E                      jmp os_write_file       ; 0x007A
   123 0000007D E99D0D                      jmp string_lowercase    ; 0x007D
   124 00000080 E97D0D                      jmp string_uppercase    ; 0x0080
   125 00000083 E9BD0D                      jmp string_truncate     ; 0x0083
   126 00000086 E9280D                      jmp string_length       ; 0x0086
   127 00000089 E97311                      jmp move_cursor         ; 0x0089
   128 0000008C E97911                      jmp get_cursor_pos      ; 0x008C
   129 0000008F E98911                      jmp print_horiz_line    ; 0x008F
   130 00000092 E9A311                      jmp input_dialog        ; 0x0092
   131 00000095 E90D18                      jmp list_dialog         ; 0x0095
   132 00000098 E9F711                      jmp dialog_box          ; 0x0098
   133 0000009B E94D11                      jmp change_cursor       ; 0x009B
   134 0000009E E92F11                      jmp string_clear        ; 0x009E
   135 000000A1 E98A1C                      jmp os_get_file_list    ; 0x00A1
   136 000000A4 E97819                      jmp clear_regs          ; 0x00A4
   137 000000A7 E9700E                      jmp int_to_string       ; 0x00A7
   138                                  
   139                                  
   140                                  ; ==================================================================
   141                                  ; KERNEL SUBROUTINES
   142                                  ; ==================================================================
   143                                  
   144                                      error_ext:
   145 000000AA 5E                              pop si
   146                                  
   147 000000AB B8[6403]                        mov ax, err1_ext
   148 000000AE BB[7603]                        mov bx, err2_ext
   149 000000B1 31C9                            xor cx, cx
   150 000000B3 31D2                            xor dx, dx
   151 000000B5 E8DA11                          call dialog_box
   152                                  
   153 000000B8 B70F                            mov bh, cli_color
   154 000000BA E8DE0C                          call cls
   155                                  
   156 000000BD C3                              ret
   157                                  
   158                                      try_run_file:
   159 000000BE E83F0D                          call string_uppercase
   160 000000C1 89C6                            mov si, ax
   161 000000C3 BF[1203]                        mov di, kern_filename
   162 000000C6 E8F20D                          call string_compare
   163 000000C9 7230                            jc load_kern_err
   164                                  
   165 000000CB E8F120                          call os_file_exists
   166 000000CE 7229                            jc .not_found
   167 000000D0 F8                              clc
   168                                  
   169 000000D1 89C6                            mov si, ax
   170 000000D3 56                              push si 
   171                                  
   172 000000D4 89F3                            mov bx, si
   173 000000D6 89F0                            mov ax, si
   174 000000D8 E8D60C                          call string_length
   175                                  
   176 000000DB 89DE                            mov si, bx
   177 000000DD 01C6                            add si, ax
   178                                  
   179 000000DF 83EE03                          sub si, 3
   180                                  
   181 000000E2 BF[5E03]                        mov di, bin_ext
   182 000000E5 B90300                          mov cx, 3
   183 000000E8 F3A6                            rep cmpsb
   184 000000EA 7523                            jne execute_bas_program
   185 000000EC 5E                              pop si
   186                                  
   187 000000ED 89F0                            mov ax, si
   188 000000EF B90080                          mov cx, prg_load_loc
   189 000000F2 E8DD1C                          call os_load_file
   190                                  
   191 000000F5 E85000                          call execute_bin_program
   192 000000F8 C3                              ret
   193                                  
   194                                          .not_found:
   195 000000F9 F9                                  stc
   196 000000FA C3                                  ret
   197                                  
   198                                          load_kern_err:
   199 000000FB 5E                                  pop si
   200                                  
   201 000000FC B8[9403]                            mov ax, err3_ext
   202 000000FF BB[A703]                            mov bx, err4_ext
   203 00000102 31C9                                xor cx, cx
   204 00000104 31D2                                xor dx, dx
   205 00000106 E88911                              call dialog_box
   206                                  
   207 00000109 B70F                                mov bh, cli_color
   208 0000010B E88D0C                              call cls
   209                                  
   210 0000010E C3                                  ret
   211                                  
   212                                      execute_bas_program:
   213 0000010F 5E                              pop si
   214 00000110 56                              push si
   215                                          
   216 00000111 89F3                            mov bx, si
   217 00000113 89F0                            mov ax, si
   218 00000115 E8990C                          call string_length
   219                                  
   220 00000118 89DE                            mov si, bx
   221 0000011A 01C6                            add si, ax
   222                                  
   223 0000011C 83EE03                          sub si, 3
   224                                  
   225 0000011F BF[6103]                        mov di, bas_ext
   226 00000122 B90300                          mov cx, 3
   227 00000125 F3A6                            rep cmpsb
   228 00000127 7581                            jne error_ext
   229                                  
   230 00000129 5E                              pop si
   231                                          
   232 0000012A 89F0                            mov ax, si
   233 0000012C B90080                          mov cx, prg_load_loc
   234 0000012F E8A01C                          call os_load_file
   235                                  
   236 00000132 B70F                            mov bh, 0x0F
   237 00000134 E8640C                          call cls
   238                                  
   239 00000137 B80080                          mov ax, prg_load_loc
   240 0000013A 31F6                            xor si, si
   241                                          ;call os_run_basic
   242                                  
   243 0000013C BE[F403]                        mov si, new_line
   244 0000013F E8141A                          call print
   245                                  
   246 00000142 B70F                            mov bh, cli_color
   247 00000144 E8540C                          call cls
   248                                  
   249 00000147 C3                              ret
   250                                  
   251                                      execute_bin_program:
   252 00000148 BE[F403]                        mov si, new_line
   253 0000014B E8081A                          call print
   254                                  
   255 0000014E 31C0                    		xor ax, ax
   256 00000150 31DB                    		xor bx, bx
   257 00000152 31C9                    		xor cx, cx
   258 00000154 31D2                    		xor dx, dx
   259 00000156 31F6                    		xor si, si
   260 00000158 31FF                    		xor di, di
   261                                  
   262 0000015A E8(0080)                        call prg_load_loc
   263 0000015D B70F                            mov bh, 0x0F
   264 0000015F E8390C                          call cls
   265                                  
   266 00000162 BE[2A03]                        mov si, prg_done_msg
   267 00000165 E8EE19                          call print
   268 00000168 30E4                            xor ah, ah
   269 0000016A CD16                            int 0x16
   270                                          
   271 0000016C B70F                            mov bh, 0x0F
   272 0000016E E82A0C                          call cls
   273                                  
   274 00000171 C3                              ret
   275                                  
   276                                  
   277                                  ; ------------------------------------------------------------------
   278                                  ; STRINGS AND OTHER VARIABLES
   279                                  
   280                                      ; DEBUG VARIABLES START
   281 00000172 4D653F20476F6E6761-         tmp:                db "Me? Gongaga", 0
   281 0000017B 676100             
   282                                      ; END
   283                                  
   284                                      ; USER RELATED VARIABLES START
   285 0000017E 00<rep 15h>                 usrNam:             times 21 db 0
   286                                  
   287 00000193 0000                        vidMode:            dw 0x00
   288                                      cli_color:          equ 0x0f
   289                                      vid_backcolor:      equ 0x01
   290                                      vid_forecolor:      equ 0x0f
   291                                      ; END
   292                                  
   293                                      ; TMP VARIABLES START
   294 00000195 4D4F555345204C4546-         mouse_left:         db "MOUSE LEFT", 0
   294 0000019E 5400               
   295 000001A0 4D4F55534520524947-         mouse_right:        db "MOUSE RIGHT", 0
   295 000001A9 485400             
   296                                      ; END
   297                                  
   298                                      ; CLI SPECIFIC VARIABLES START
   299 000001AC 3A3E2000                	in_msg:				db ":> ", 0
   300 000001B0 00<rep 29h>             	in_buffer: 			times 41 db 0
   301 000001D9 206973206E6F74206B-         not_com:            db " is not known command", 0x0a, 0x0d, 0
   301 000001E2 6E6F776E20636F6D6D-
   301 000001EB 616E640A0D00       
   302                                      ; END
   303                                  
   304                                      ; CLI COMMANDS START
   305 000001F1 7265737461727400            restart_com:        db "restart", 0
   306 000001F9 73687574646F776E00          shutdown_com:       db "shutdown", 0
   307 00000202 73657474696E677300          settings_com:       db "settings", 0
   308 0000020B 636C65617200                clear_com:          db "clear", 0
   309 00000211 64697200                    dir_com:            db "dir", 0
   310 00000215 68656C7000                  help_com:           db "help", 0
   311 0000021A 6564697400                  edit_com:           db "edit", 0
   312 0000021F 6C6F616400                  load_com:           db "load", 0
   313 00000224 6D6B00                      mk_com:             db "mk", 0
   314 00000227 726D00                      rm_com:             db "rm", 0
   315                                      ; END
   316                                  
   317                                      ; MOUSE VARIABLES START
   318 0000022A 4D4F55534520495320-         mouse_yes:          db "MOUSE IS CONNECTED!", 0
   318 00000233 434F4E4E4543544544-
   318 0000023C 2100               
   319 0000023E 4D4F55534520495320-         mouse_no:           db "MOUSE IS NOT CONNECTED!", 0
   319 00000247 4E4F5420434F4E4E45-
   319 00000250 435445442100       
   320                                      ; END
   321                                  
   322                                      ; WELCOME SCREEN VARIABLES START
   323 00000256 0A0D204B726F6E6B4F-     	welcome_msg1:		db 0x0a, 0x0d, " KronkOS ver. ", KRONKOS_VER
   323 0000025F 53207665722E20302E-
   323 00000268 332E32             
   324 0000026B 20<rep 1Ah>             						times 44-18 db " "
   325 00000285 0A0D2000                						db 0x0a, 0x0d, " ", 0
   326 00000289 204B696C6F20427974-     	welcome_msg2:		db " Kilo Bytes of total memory available. ", 0x0a, 0x0d, 0
   326 00000292 6573206F6620746F74-
   326 0000029B 616C206D656D6F7279-
   326 000002A4 20617661696C61626C-
   326 000002AD 652E200A0D00       
   327 000002B3 20<rep 2Dh>             	welcome_msg3:		times 45 db " "
   328 000002E0 0A0D20547970652027-     						db 0x0a, 0x0d, " Type 'help' and press enter to start off.   ", 0x0a, 0x0d, 0
   328 000002E9 68656C702720616E64-
   328 000002F2 20707265737320656E-
   328 000002FB 74657220746F207374-
   328 00000304 617274206F66662E20-
   328 0000030D 20200A0D00         
   329                                  	; END
   330                                  
   331                                      ; FILE RELATED VARIABLES START
   332 00000312 4B45524E454C2E4249-     	kern_filename:		db 'KERNEL.BIN', 0
   332 0000031B 4E00               
   333 0000031D 53455454494E47532E-         settings_filename:  db 'SETTINGS.KSF', 0
   333 00000326 4B534600           
   334 0000032A 3E3E3E2050726F6772-     	prg_done_msg:	    db '>>> Program finished --- press a key to continue...', 0
   334 00000333 616D2066696E697368-
   334 0000033C 6564202D2D2D207072-
   334 00000345 6573732061206B6579-
   334 0000034E 20746F20636F6E7469-
   334 00000357 6E75652E2E2E00     
   335                                  
   336 0000035E 424B46                  	bin_ext:			db 'BKF'
   337 00000361 424153                  	bas_ext:			db 'BAS'
   338 00000364 556E6B6E6F776E2065-     	err1_ext:			db "Unknown extension", 0
   338 0000036D 7874656E73696F6E00 
   339 00000376 4F6E6C79202E424B46-     	err2_ext:			db "Only .BKF and .BAS is allowed", 0
   339 0000037F 20616E64202E424153-
   339 00000388 20697320616C6C6F77-
   339 00000391 656400             
   340 00000394 4572726F72206C6F61-     	err3_ext:			db "Error loading file", 0
   340 0000039D 64696E672066696C65-
   340 000003A6 00                 
   341 000003A7 596F752063616E2774-     	err4_ext:			db "You can't load KERNEL.BIN", 0
   341 000003B0 206C6F6164204B4552-
   341 000003B9 4E454C2E42494E00   
   342 000003C1 596F752063616E2774-         err5_ext:           db "You can't load SETTINGS.KSF", 0
   342 000003CA 206C6F616420534554-
   342 000003D3 54494E47532E4B5346-
   342 000003DC 00                 
   343 000003DD 0A0D46696C65206E6F-         notfound_msg:	    db 0x0a, 0x0d, "File not found", 0x0a, 0x0a, 0x0d, 0
   343 000003E6 7420666F756E640A0A-
   343 000003EF 0D00               
   344                                      ; END
   345                                  
   346                                      ; OTHER VARIABLES START
   347 000003F1 00                      	fmt_12_24:			db 0 		; (Non-zero = 24 hour format)
   348 000003F2 012F                    	fmt_date:			db 1, '/'	; 0, 1, 2 = M/D/Y, D/M/Y or Y/M/D
   349                                  									; Bit 7 = use name for months
   350                                  									; If bit 7 = 0, second byte = separator character
   351                                  
   352 000003F4 0A0D00                  	new_line:			db 0x0a, 0x0d, 0
   353 000003F7 202D2D2000              	file_size_sep:		db " -- ", 0
   354 000003FC 2042797465730A0D00      	file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   355                                      ; END
   356                                  
   357                                      ; MENUBAR VARIABLES START
   358                                      mb_color:           equ 0x30
   359 00000405 20<rep 4Fh>                 mb_fill:            times 79 db " "
   360 00000454 00                                              db 0
   361                                      ; END
   362                                  
   363                                  ; ------------------------------------------------------------------
   364                                  ; INCLUDED FILES
   365                                  
   366                                      %include "./includes/settings_menu.asm"
   367                              <1> show_settings:
   368 00000455 60                  <1>     pusha
   369                              <1> 
   370                              <1> .main_menu:
   371 00000456 B8[C404]            <1>     mov ax, .main_options
   372 00000459 BB[DF04]            <1>     mov bx, .main_header
   373 0000045C B9[E804]            <1>     mov cx, .main_string
   374 0000045F E84314              <1>     call list_dialog
   375                              <1> 
   376 00000462 83F801              <1>     cmp ax, 1
   377 00000465 7402                <1>     je .display_menu
   378                              <1> 
   379 00000467 EB54                <1>     jmp .end
   380                              <1> 
   381                              <1> .display_menu:
   382 00000469 B8[0705]            <1>     mov ax, .display_options
   383 0000046C BB[2005]            <1>     mov bx, .display_header
   384 0000046F B9[2F05]            <1>     mov cx, .display_string
   385 00000472 E83014              <1>     call list_dialog
   386                              <1> 
   387 00000475 83F801              <1>     cmp ax, 1
   388 00000478 7407                <1>     je .change_cli
   389                              <1> 
   390 0000047A 83F802              <1>     cmp ax, 2
   391 0000047D 7420                <1>     je .change_vid
   392                              <1> 
   393 0000047F EBD5                <1>     jmp .main_menu
   394                              <1> 
   395                              <1> .change_cli:
   396 00000481 B8[4505]            <1>     mov ax, .display_restart1
   397 00000484 BB[5F05]            <1>     mov bx, .display_restart2
   398 00000487 31C9                <1>     xor cx, cx
   399 00000489 BA0100              <1>     mov dx, 1
   400 0000048C E8030E              <1>     call dialog_box
   401                              <1> 
   402 0000048F 85C0                <1>     test ax, ax
   403 00000491 75D6                <1>     jnz .display_menu
   404                              <1> 
   405                              <1> 
   406 00000493 C606[9301]00        <1>     mov byte [vidMode], 0
   407 00000498 31C0                <1>     xor ax, ax
   408 0000049A CD13                <1>     int 0x13
   409 0000049C E974FB              <1>     jmp RESET
   410                              <1> 
   411                              <1> .change_vid:
   412 0000049F B8[4505]            <1>     mov ax, .display_restart1
   413 000004A2 BB[5F05]            <1>     mov bx, .display_restart2
   414 000004A5 31C9                <1>     xor cx, cx
   415 000004A7 BA0100              <1>     mov dx, 1
   416 000004AA E8E50D              <1>     call dialog_box
   417                              <1> 
   418 000004AD 85C0                <1>     test ax, ax
   419 000004AF 75B8                <1>     jnz .display_menu
   420                              <1> 
   421 000004B1 C606[9301]01        <1>     mov byte [vidMode], 1
   422 000004B6 31C0                <1>     xor ax, ax
   423 000004B8 CD13                <1>     int 0x13
   424 000004BA E956FB              <1>     jmp RESET
   425                              <1> 
   426                              <1> .end:
   427 000004BD B70F                <1>     mov bh, cli_color
   428 000004BF E8D908              <1>     call cls
   429                              <1> 
   430 000004C2 61                  <1>     popa
   431 000004C3 C3                  <1>     ret
   432                              <1> 
   433                              <1> 
   434 000004C4 444953504C41592C    <1> .main_options:      db "DISPLAY,"
   435 000004CC 555345522C          <1>                     db "USER,"
   436 000004D1 455849542053455454- <1>                     db "EXIT SETTINGS", 0
   436 000004DA 494E475300          <1>
   437 000004DF 53455454494E475300  <1> .main_header:       db "SETTINGS", 0
   438 000004E8 4368616E6765207468- <1> .main_string:       db "Change the settings of KronkOS", 0
   438 000004F1 652073657474696E67- <1>
   438 000004FA 73206F66204B726F6E- <1>
   438 00000503 6B4F5300            <1>
   439                              <1> 
   440 00000507 434C49204D4F44452C  <1> .display_options:   db "CLI MODE,"
   441 00000510 564944454F204D4F44- <1>                     db "VIDEO MODE,"
   441 00000519 452C                <1>
   442 0000051B 4241434B00          <1>                     db "BACK", 0
   443 00000520 564944454F20534554- <1> .display_header:    db "VIDEO SETTINGS", 0
   443 00000529 54494E475300        <1>
   444 0000052F 4368616E6765207468- <1> .display_string:    db "Change the video mode", 0
   444 00000538 6520766964656F206D- <1>
   444 00000541 6F646500            <1>
   445 00000545 546869732077696C6C- <1> .display_restart1:  db "This will restart KronkOS", 0
   445 0000054E 207265737461727420- <1>
   445 00000557 4B726F6E6B4F5300    <1>
   446 0000055F 507265737320274F4B- <1> .display_restart2:  db "Press 'OK' to continue", 0
   446 00000568 2720746F20636F6E74- <1>
   446 00000571 696E756500          <1>
   367                                      %include "./includes/cli.asm"
   368                              <1> kronk_cli:
   369 00000576 B80000              <1>     mov ax, 0
   370 00000579 B70F                <1>     mov bh, cli_color
   371 0000057B E8F10E              <1>     call switch_mode
   372                              <1>     
   373                              <1>     ; Disable color blinking
   374 0000057E B80310              <1>     mov ax, 0x1003
   375 00000581 BB0000              <1>     mov bx, 0x0000
   376 00000584 CD10                <1>     int 0x10
   377                              <1> 
   378                              <1> 	; Let's see if there's a file called AUTORUN.BIN and execute
   379                              <1> 	; it if so, before going to the terminal
   380                              <1> 
   381 00000586 B8[3E0A]            <1>     mov ax, .autobin_filename
   382 00000589 E8331C              <1>     call os_file_exists
   383 0000058C 7209                <1>     jc .no_autorun_bin
   384                              <1> 
   385 0000058E B90080              <1>     mov cx, prg_load_loc
   386 00000591 E83E18              <1>     call os_load_file
   387 00000594 E8B1FB              <1>     call execute_bin_program
   388                              <1> 
   389                              <1> .no_autorun_bin:
   390 00000597 B8[4A0A]            <1>     mov ax, .autobas_filename
   391 0000059A E8221C              <1>     call os_file_exists
   392 0000059D 7209                <1>     jc .no_autorun_bas
   393                              <1> 
   394 0000059F B90080              <1>     mov cx, prg_load_loc
   395 000005A2 E82D18              <1>     call os_load_file
   396 000005A5 E867FB              <1>     call execute_bas_program
   397                              <1> 
   398                              <1> .no_autorun_bas:
   399                              <1>     ; Draw welcome menu
   400 000005A8 BE[5602]            <1>     mov si, welcome_msg1
   401 000005AB E8B615              <1>     call welcome_print
   402                              <1> 
   403 000005AE B488                <1>     mov ah, 0x88
   404 000005B0 CD15                <1>     int 0x15
   405 000005B2 E86509              <1>     call int_to_string
   406 000005B5 89C6                <1>     mov si, ax
   407 000005B7 E8AA15              <1>     call welcome_print
   408                              <1> 
   409 000005BA BE[8902]            <1>     mov si, welcome_msg2
   410 000005BD E8A415              <1>     call welcome_print
   411 000005C0 BE[B302]            <1>     mov si, welcome_msg3
   412 000005C3 E89E15              <1>     call welcome_print
   413                              <1> 
   414 000005C6 B80A0E              <1>     mov ax, 0x0e0a
   415 000005C9 CD10                <1>     int 0x10
   416                              <1> 
   417                              <1> ; The loop that gets the input
   418                              <1> .input_loop:
   419                              <1>     ; Change the cursor to a solid block
   420 000005CB B500                <1>     mov ch, 0x00
   421 000005CD E81B0C              <1>     call change_cursor
   422                              <1> 
   423 000005D0 E88304              <1>     call check_pos
   424 000005D3 E8A604              <1>     call draw_menu_bar
   425                              <1> 
   426                              <1>     ; Print the username and the input msg
   427                              <1>     ;mov si, usrNam
   428                              <1>     ;call print
   429 000005D6 BE[AC01]            <1>     mov si, in_msg
   430 000005D9 E87A15              <1>     call print
   431                              <1> 
   432                              <1>     ; Get the input and save it in in_buffer 
   433 000005DC E89F14              <1>     call get_input
   434                              <1> 
   435                              <1>     ; Check the input
   436 000005DF B8[0202]            <1>     mov ax, settings_com
   437 000005E2 E8D51E              <1>     call check_com
   438 000005E5 0F83C400            <1>     jnc .settings
   439                              <1> 
   440 000005E9 B8[0B02]            <1>     mov ax, clear_com
   441 000005EC E8CB1E              <1>     call check_com
   442 000005EF 0F83C000            <1>     jnc .clear
   443                              <1> 
   444 000005F3 B8[1102]            <1>     mov ax, dir_com
   445 000005F6 E8C11E              <1>     call check_com
   446 000005F9 0F83BE00            <1>     jnc .dir
   447                              <1> 
   448 000005FD B8[1502]            <1>     mov ax, help_com
   449 00000600 E8B71E              <1>     call check_com
   450 00000603 0F836301            <1>     jnc .show_help
   451                              <1>     
   452                              <1>     ; ----------------------------------
   453                              <1>     ; MK AND RM
   454                              <1> 
   455 00000607 60                  <1>     pusha
   456                              <1> 
   457 00000608 BE[B301]            <1>     mov si, in_buffer+3
   458 0000060B BF[CF09]            <1>     mov di, .tmp_filename
   459 0000060E E82908              <1>     call string_copy
   460                              <1> 
   461 00000611 BE[B001]            <1>     mov si, in_buffer
   462 00000614 BF[E309]            <1>     mov di, .tmp_inbuffer
   463 00000617 E82008              <1>     call string_copy
   464                              <1> 
   465 0000061A BE[B001]            <1>     mov si, in_buffer
   466 0000061D B80200              <1>     mov ax, 2
   467 00000620 E82008              <1>     call string_truncate
   468                              <1>     
   469 00000623 B8[2402]            <1>     mov ax, mk_com
   470 00000626 E8911E              <1>     call check_com
   471 00000629 0F831003            <1>     jnc .make_file
   472                              <1> 
   473 0000062D B8[2702]            <1>     mov ax, rm_com
   474 00000630 E8871E              <1>     call check_com
   475 00000633 0F833103            <1>     jnc .remove_file
   476                              <1> 
   477 00000637 BE[E309]            <1>     mov si, .tmp_inbuffer
   478 0000063A BF[B001]            <1>     mov di, in_buffer
   479 0000063D E8FA07              <1>     call string_copy
   480                              <1> 
   481 00000640 61                  <1>     popa
   482                              <1> 
   483                              <1>     ; ----------------------------------
   484                              <1>     ; LOAD AND EDIT
   485                              <1> 
   486 00000641 60                  <1>     pusha
   487                              <1> 
   488 00000642 BE[B501]            <1>     mov si, in_buffer+5
   489 00000645 BF[CF09]            <1>     mov di, .tmp_filename
   490 00000648 E8EF07              <1>     call string_copy
   491                              <1> 
   492 0000064B BE[B001]            <1>     mov si, in_buffer
   493 0000064E BF[E309]            <1>     mov di, .tmp_inbuffer
   494 00000651 E8E607              <1>     call string_copy
   495                              <1> 
   496 00000654 BE[B001]            <1>     mov si, in_buffer
   497 00000657 B80400              <1>     mov ax, 4
   498 0000065A E8E607              <1>     call string_truncate
   499                              <1> 
   500 0000065D B8[1F02]            <1>     mov ax, load_com
   501 00000660 E8571E              <1>     call check_com
   502 00000663 0F832C03            <1>     jnc .load_file
   503                              <1> 
   504 00000667 BE[E309]            <1>     mov si, .tmp_inbuffer
   505 0000066A BF[B001]            <1>     mov di, in_buffer
   506 0000066D E8CA07              <1>     call string_copy
   507                              <1> 
   508 00000670 61                  <1>     popa
   509                              <1> 
   510 00000671 B8[F101]            <1>     mov ax, restart_com
   511 00000674 E8431E              <1>     call check_com
   512 00000677 0F833403            <1>     jnc .restart
   513                              <1> 
   514 0000067B B8[F901]            <1>     mov ax, shutdown_com
   515 0000067E E8391E              <1>     call check_com
   516 00000681 0F833203            <1>     jnc .shutdown
   517 00000685 7200                <1>     jc .not_equal
   518                              <1> 
   519                              <1> .not_equal:
   520 00000687 B40E                <1>     mov ah, 0x0e
   521 00000689 B00A                <1>     mov al, 0x0a
   522 0000068B CD10                <1>     int 0x10
   523                              <1> 
   524 0000068D B40E                <1>     mov ah, 0x0e
   525 0000068F B022                <1>     mov al, '"'
   526 00000691 CD10                <1>     int 0x10
   527                              <1> 
   528 00000693 BE[B001]            <1>     mov si, in_buffer
   529 00000696 E8BD14              <1>     call print
   530                              <1> 
   531 00000699 B40E                <1>     mov ah, 0x0e
   532 0000069B B022                <1>     mov al, '"'
   533 0000069D CD10                <1>     int 0x10
   534                              <1>     
   535 0000069F BE[D901]            <1>     mov si, not_com
   536 000006A2 E8B114              <1>     call print
   537                              <1>     
   538                              <1>     ; Create a new line
   539 000006A5 B80A0E              <1>     mov ax, 0x0e0a
   540 000006A8 CD10                <1>     int 0x10
   541                              <1> 
   542 000006AA E91EFF              <1>     jmp .input_loop
   543                              <1> 
   544                              <1> ; ----------------------------------
   545                              <1> ; SETTINGS
   546                              <1> 
   547                              <1> .settings:
   548 000006AD E8A5FD              <1>     call show_settings
   549 000006B0 E918FF              <1>     jmp .input_loop
   550                              <1> 
   551                              <1> ; ----------------------------------
   552                              <1> ; CLEAR
   553                              <1> 
   554                              <1> .clear:
   555 000006B3 B70F                <1>     mov bh, cli_color
   556 000006B5 E8E306              <1>     call cls
   557 000006B8 E910FF              <1>     jmp .input_loop
   558                              <1> 
   559                              <1> ; ----------------------------------
   560                              <1> ; DIR
   561                              <1> 
   562                              <1> .dir:
   563 000006BB 31C0                <1>     xor ax, ax
   564 000006BD E86E16              <1>     call os_get_file_list
   565                              <1> 
   566 000006C0 50                  <1>     push ax
   567 000006C1 B80A0E              <1>     mov ax, 0x0e0a
   568 000006C4 CD10                <1>     int 0x10
   569 000006C6 CD10                <1>     int 0x10
   570 000006C8 B00D                <1>     mov al, 0x0d
   571 000006CA CD10                <1>     int 0x10
   572 000006CC 58                  <1>     pop ax
   573                              <1> 
   574 000006CD 89C6                <1>     mov si, ax
   575 000006CF BF[CF09]            <1>     mov di, .tmp_filename
   576 000006D2 BA0000              <1>     mov dx, 0
   577                              <1> 
   578 000006D5 B40E                <1>     mov ah, 0x0e
   579 000006D7 B020                <1>     mov al, ' '
   580 000006D9 CD10                <1>     int 0x10
   581                              <1> 
   582                              <1>     .loop:
   583 000006DB AC                  <1>         lodsb
   584 000006DC 3C2C                <1>         cmp al, ','
   585 000006DE 740C                <1>         je .add_size
   586 000006E0 3C00                <1>         cmp al, 0
   587 000006E2 744C                <1>         je .done
   588                              <1> 
   589 000006E4 AA                  <1>         stosb
   590 000006E5 42                  <1>         inc dx
   591                              <1> 
   592 000006E6 B40E                <1>         mov ah, 0x0e
   593 000006E8 CD10                <1>         int 0x10
   594                              <1> 
   595 000006EA EBEF                <1>         jmp .loop
   596                              <1> 
   597                              <1>     .add_size:
   598 000006EC 60                  <1>         pusha
   599 000006ED 83FA0C              <1>         cmp dx, 12
   600 000006F0 7D03                <1>         jge .continue
   601                              <1> 
   602 000006F2 E82F00              <1>         call .add_spaces
   603                              <1> 
   604                              <1>         .continue:
   605 000006F5 BE[0C0A]            <1>         mov si, .file_size_sep
   606 000006F8 E85B14              <1>         call print
   607                              <1> 
   608 000006FB 89D0                <1>         mov ax, dx
   609 000006FD E84307              <1>         call string_truncate
   610                              <1> 
   611 00000700 B8[CF09]            <1>         mov ax, .tmp_filename
   612 00000703 E81B1C              <1>         call os_get_file_size
   613                              <1> 
   614 00000706 89D8                <1>         mov ax, bx
   615 00000708 E80F08              <1>         call int_to_string
   616 0000070B 89C6                <1>         mov si, ax
   617 0000070D E84614              <1>         call print
   618                              <1> 
   619 00000710 BE[FC03]            <1>         mov si, file_size_typ
   620 00000713 E84014              <1>         call print
   621                              <1> 
   622 00000716 B8200E              <1>         mov ax, 0x0e20
   623 00000719 CD10                <1>         int 0x10
   624                              <1> 
   625 0000071B 61                  <1>         popa
   626                              <1> 
   627 0000071C BF[CF09]            <1>         mov di, .tmp_filename
   628 0000071F BA0000              <1>         mov dx, 0
   629 00000722 EBB7                <1>         jmp .loop
   630                              <1> 
   631                              <1>     .add_spaces:
   632 00000724 B8200E              <1>         mov ax, 0x0e20
   633 00000727 CD10                <1>         int 0x10
   634 00000729 42                  <1>         inc dx
   635 0000072A 83FA0C              <1>         cmp dx, 12
   636 0000072D 75F5                <1>         jne .add_spaces
   637 0000072F C3                  <1>         ret
   638                              <1> 
   639                              <1>     .done:
   640 00000730 83FA0C              <1>         cmp dx, 12
   641 00000733 7D03                <1>         jge .done_c
   642                              <1> 
   643 00000735 E8ECFF              <1>         call .add_spaces
   644                              <1> 
   645                              <1>         .done_c:
   646 00000738 BE[0C0A]            <1>         mov si, .file_size_sep
   647 0000073B E81814              <1>         call print
   648                              <1> 
   649 0000073E BE[CF09]            <1>         mov si, .tmp_filename
   650 00000741 89D0                <1>         mov ax, dx
   651 00000743 E8FD06              <1>         call string_truncate
   652                              <1> 
   653 00000746 B8[CF09]            <1>         mov ax, .tmp_filename
   654 00000749 E8D51B              <1>         call os_get_file_size
   655                              <1> 
   656 0000074C 89D8                <1>         mov ax, bx
   657 0000074E E8C907              <1>         call int_to_string
   658 00000751 89C6                <1>         mov si, ax
   659 00000753 E80014              <1>         call print
   660                              <1> 
   661 00000756 BE[110A]            <1>         mov si, .file_size_typ
   662 00000759 E8FA13              <1>         call print
   663                              <1> 
   664 0000075C 50                  <1>     push ax
   665                              <1> 
   666 0000075D B80A0E              <1>     mov ax, 0x0e0a
   667 00000760 CD10                <1>     int 0x10
   668 00000762 B00D                <1>     mov al, 0x0d
   669 00000764 CD10                <1>     int 0x10
   670                              <1> 
   671 00000766 58                  <1>     pop ax
   672                              <1> 
   673 00000767 E961FE              <1>     jmp .input_loop
   674                              <1> 
   675                              <1> ; ----------------------------------
   676                              <1> ; HELP
   677                              <1> 
   678                              <1> .show_help:
   679 0000076A B8[9A07]            <1>     mov ax, .help_commands
   680 0000076D BB[0C09]            <1>     mov bx, .help_header
   681 00000770 B9[1609]            <1>     mov cx, .help_string
   682 00000773 E82F11              <1>     call list_dialog
   683                              <1> 
   684 00000776 83F804              <1>     cmp ax, 4
   685 00000779 0F8430FF            <1>     je .settings
   686                              <1>     
   687 0000077D B70F                <1>     mov bh, cli_color
   688 0000077F E81906              <1>     call cls
   689                              <1> 
   690 00000782 83F802              <1>     cmp ax, 2
   691 00000785 0F8432FF            <1>     je .dir
   692 00000789 83F809              <1>     cmp ax, 9
   693 0000078C 0F841F02            <1>     je .restart
   694 00000790 83F80A              <1>     cmp ax, 10
   695 00000793 0F842002            <1>     je .shutdown
   696                              <1> 
   697 00000797 E931FE              <1>     jmp .input_loop
   698                              <1> 
   699 0000079A 48454C502020202020- <1>     .help_commands:     db "HELP       --  What you're looking at,"
   699 000007A3 20202D2D2020576861- <1>
   699 000007AC 7420796F7527726520- <1>
   699 000007B5 6C6F6F6B696E672061- <1>
   699 000007BE 742C                <1>
   700 000007C0 444952202020202020- <1>                         db "DIR        --  Show a list of all files,"
   700 000007C9 20202D2D202053686F- <1>
   700 000007D2 772061206C69737420- <1>
   700 000007DB 6F6620616C6C206669- <1>
   700 000007E4 6C65732C            <1>
   701 000007E8 434C45415220202020- <1>                         db "CLEAR      --  Clear the terminal,"
   701 000007F1 20202D2D2020436C65- <1>
   701 000007FA 617220746865207465- <1>
   701 00000803 726D696E616C2C      <1>
   702 0000080A 53455454494E475320- <1>                         db "SETTINGS   --  Show the settings menu,"
   702 00000813 20202D2D202053686F- <1>
   702 0000081C 772074686520736574- <1>
   702 00000825 74696E6773206D656E- <1>
   702 0000082E 752C                <1>
   703 00000830 4D4B2046494C452020- <1>                         db "MK FILE    --  Create a file,"
   703 00000839 20202D2D2020437265- <1>
   703 00000842 61746520612066696C- <1>
   703 0000084B 652C                <1>
   704 0000084D 524D2046494C452020- <1>                         db "RM FILE    --  Delete a file,"
   704 00000856 20202D2D202044656C- <1>
   704 0000085F 65746520612066696C- <1>
   704 00000868 652C                <1>
   705 0000086A 4C4F41442046494C45- <1>                         db "LOAD FILE  --  Load/run a file,"
   705 00000873 20202D2D20204C6F61- <1>
   705 0000087C 642F72756E20612066- <1>
   705 00000885 696C652C            <1>
   706 00000889 454449542046494C45- <1>                         db "EDIT FILE  --  Load and edit a file,"
   706 00000892 20202D2D20204C6F61- <1>
   706 0000089B 6420616E6420656469- <1>
   706 000008A4 7420612066696C652C  <1>
   707 000008AD 524553544152542020- <1>                         db "RESTART    --  Restart KronkOS,"
   707 000008B6 20202D2D2020526573- <1>
   707 000008BF 74617274204B726F6E- <1>
   707 000008C8 6B4F532C            <1>
   708 000008CC 53485554444F574E20- <1>                         db "SHUTDOWN   --  Shutdown KronkOS,,"
   708 000008D5 20202D2D2020536875- <1>
   708 000008DE 74646F776E204B726F- <1>
   708 000008E7 6E6B4F532C2C        <1>
   709 000008ED 43414E43454C202020- <1>                         db "CANCEL     --  Leave this menu", 0
   709 000008F6 20202D2D20204C6561- <1>
   709 000008FF 76652074686973206D- <1>
   709 00000908 656E7500            <1>
   710 0000090C 48454C50204D454E55- <1>     .help_header:       db "HELP MENU", 0
   710 00000915 00                  <1>
   711 00000916 507265737320454E54- <1>     .help_string:       db "Press ENTER to run any of the commands", 0
   711 0000091F 455220746F2072756E- <1>
   711 00000928 20616E79206F662074- <1>
   711 00000931 686520636F6D6D616E- <1>
   711 0000093A 647300              <1>
   712                              <1> 
   713                              <1> ; ----------------------------------
   714                              <1> ; MAKE FILE
   715                              <1> 
   716                              <1> .make_file:
   717 0000093D 60                  <1>     pusha
   718 0000093E B8[CF09]            <1>     mov ax, .tmp_filename
   719 00000941 E89A18              <1>     call os_create_file
   720                              <1>     
   721 00000944 B80A0E              <1>     mov ax, 0x0e0a
   722 00000947 CD10                <1>     int 0x10
   723 00000949 B00D                <1>     mov al, 0x0d
   724 0000094B CD10                <1>     int 0x10
   725                              <1> 
   726 0000094D BE[CF09]            <1>     mov si, .tmp_filename
   727 00000950 E80312              <1>     call print
   728 00000953 BE[2C0A]            <1>     mov si, .tmp_filemk
   729 00000956 E8FD11              <1>     call print
   730                              <1> 
   731 00000959 B80A0E              <1>     mov ax, 0x0e0a
   732 0000095C CD10                <1>     int 0x10
   733 0000095E CD10                <1>     int 0x10
   734 00000960 B00D                <1>     mov al, 0x0d
   735 00000962 CD10                <1>     int 0x10
   736                              <1> 
   737 00000964 61                  <1>     popa
   738                              <1> 
   739 00000965 E963FC              <1>     jmp .input_loop
   740                              <1> 
   741                              <1> ; ----------------------------------
   742                              <1> ; REMOVE FILE
   743                              <1> 
   744                              <1> .remove_file:
   745 00000968 60                  <1>     pusha
   746 00000969 B8[CF09]            <1>     mov ax, .tmp_filename
   747 0000096C E8FE18              <1>     call os_remove_file
   748                              <1>     
   749 0000096F B80A0E              <1>     mov ax, 0x0e0a
   750 00000972 CD10                <1>     int 0x10
   751 00000974 B00D                <1>     mov al, 0x0d
   752 00000976 CD10                <1>     int 0x10
   753                              <1> 
   754 00000978 BE[CF09]            <1>     mov si, .tmp_filename
   755 0000097B E8D811              <1>     call print
   756 0000097E BE[1A0A]            <1>     mov si, .tmp_filerm
   757 00000981 E8D211              <1>     call print
   758                              <1> 
   759 00000984 B80A0E              <1>     mov ax, 0x0e0a
   760 00000987 CD10                <1>     int 0x10
   761 00000989 CD10                <1>     int 0x10
   762 0000098B B00D                <1>     mov al, 0x0d
   763 0000098D CD10                <1>     int 0x10
   764                              <1> 
   765 0000098F 61                  <1>     popa
   766                              <1> 
   767 00000990 E938FC              <1>     jmp .input_loop
   768                              <1> 
   769                              <1> ; ----------------------------------
   770                              <1> ; LOAD FILE
   771                              <1> 
   772                              <1> .load_file:
   773 00000993 60                  <1>     pusha
   774 00000994 31C0                <1>     xor ax, ax
   775                              <1> 
   776 00000996 B8[CF09]            <1>     mov ax, .tmp_filename
   777 00000999 E822F7              <1>     call try_run_file
   778 0000099C 7204                <1>     jc .not_found
   779                              <1> 
   780 0000099E 61                  <1>     popa
   781 0000099F E929FC              <1>     jmp .input_loop
   782                              <1> 
   783                              <1>     .not_found:
   784 000009A2 BE[DD03]            <1>         mov si, notfound_msg
   785 000009A5 E8AE11              <1>         call print
   786                              <1> 
   787 000009A8 61                  <1>         popa
   788 000009A9 E91FFC              <1>         jmp .input_loop
   789                              <1> 
   790                              <1> ; ----------------------------------
   791                              <1> ; EDIT FILE
   792                              <1> 
   793                              <1> .edit_file:
   794 000009AC E91CFC              <1>     jmp .input_loop
   795                              <1> 
   796                              <1> ; ----------------------------------
   797                              <1> ; RESTART
   798                              <1> 
   799                              <1> .restart:
   800 000009AF B80000              <1>     mov ax, 0x00
   801 000009B2 CD13                <1>     int 0x13
   802 000009B4 CD19                <1>     int 0x19
   803                              <1> 
   804                              <1>     ; Halt cpu if restart fails
   805 000009B6 F4                  <1>     hlt
   806                              <1> 
   807                              <1> ; ----------------------------------
   808                              <1> ; SHUTDOWN
   809                              <1> 
   810                              <1> .shutdown:
   811 000009B7 31C0                <1>     xor ax, ax
   812 000009B9 CD13                <1>     int 0x13
   813                              <1> 
   814 000009BB B80010              <1>     mov ax, 0x1000
   815 000009BE 8CD0                <1>     mov ax, ss
   816 000009C0 BC00F0              <1>     mov sp, 0xf000
   817 000009C3 B80753              <1>     mov ax, 0x5307
   818 000009C6 BB0100              <1>     mov bx, 0x0001
   819 000009C9 B90300              <1>     mov cx, 0x0003
   820 000009CC CD15                <1>     int 0x15
   821                              <1> 
   822                              <1>     ; Halt cpu if shutdown fails
   823 000009CE F4                  <1>     hlt
   824                              <1> 
   825                              <1> 
   826 000009CF 00<rep 14h>         <1> .tmp_filename:      times 20 db 0
   827 000009E3 00<rep 29h>         <1> .tmp_inbuffer:      times 41 db 0
   828 00000A0C 202D2D2000          <1> .file_size_sep:		db " -- ", 0
   829 00000A11 2042797465730A0D00  <1> .file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   830 00000A1A 20686173206265656E- <1> .tmp_filerm:        db " has been deleted", 0
   830 00000A23 2064656C6574656400  <1>
   831 00000A2C 20686173206265656E- <1> .tmp_filemk:        db " has been created", 0
   831 00000A35 206372656174656400  <1>
   832 00000A3E 4155544F52554E2E42- <1> .autobin_filename:  db "AUTORUN.BKF", 0
   832 00000A47 4B4600              <1>
   833 00000A4A 4155544F52554E2E42- <1> .autobas_filename:  db "AUTORUN.BAS", 0
   833 00000A53 415300              <1>
   368                                      %include "./includes/menubar.asm"
   369                              <1> check_pos:
   370 00000A56 60                  <1>     pusha
   371                              <1> 
   372 00000A57 B403                <1>     mov ah, 0x03
   373 00000A59 30FF                <1>     xor bh, bh
   374 00000A5B CD10                <1>     int 0x10
   375                              <1> 
   376 00000A5D 80FE18              <1>     cmp dh, 24
   377 00000A60 7402                <1>     je .at_end
   378                              <1> 
   379 00000A62 61                  <1>     popa
   380 00000A63 C3                  <1>     ret
   381                              <1> 
   382                              <1> .at_end:
   383 00000A64 B80306              <1>     mov ax, 0x0603
   384 00000A67 B70F                <1>     mov bh, cli_color
   385 00000A69 BA4F18              <1> 	mov dx, 0x184f
   386 00000A6C 31C9                <1> 	xor cx, cx
   387 00000A6E CD10                <1>     int 0x10
   388                              <1> 
   389 00000A70 B402                <1>     mov ah, 0x02
   390 00000A72 30FF                <1>     xor bh, bh
   391 00000A74 30D2                <1>     xor dl, dl
   392 00000A76 B615                <1>     mov dh, 21
   393 00000A78 CD10                <1>     int 0x10
   394                              <1> 
   395 00000A7A 61                  <1>     popa
   396 00000A7B C3                  <1>     ret
   397                              <1> 
   398                              <1> draw_menu_bar:
   399 00000A7C 60                  <1>     pusha
   400                              <1> 
   401 00000A7D B403                <1>     mov ah, 0x03
   402 00000A7F 30FF                <1>     xor bh, bh
   403 00000A81 CD10                <1>     int 0x10
   404                              <1> 
   405 00000A83 52                  <1>     push dx
   406                              <1> 
   407 00000A84 B80407              <1>     mov ax, 0x0704
   408 00000A87 B70F                <1>     mov bh, cli_color
   409 00000A89 BA4F18              <1> 	mov dx, 0x184f
   410 00000A8C 31C9                <1> 	xor cx, cx
   411 00000A8E CD10                <1>     int 0x10
   412 00000A90 B80406              <1>     mov ax, 0x0604
   413 00000A93 CD10                <1>     int 0x10
   414                              <1>     
   415 00000A95 B402                <1>     mov ah, 0x02
   416 00000A97 B618                <1>     mov dh, 24
   417 00000A99 30FF                <1>     xor bh, bh
   418 00000A9B 30D2                <1>     xor dl, dl
   419 00000A9D CD10                <1>     int 0x10
   420                              <1> 
   421 00000A9F BE[0504]            <1>     mov si, mb_fill
   422 00000AA2 B330                <1>     mov bl, mb_color
   423 00000AA4 E8E810              <1>     call print_atr
   424                              <1> 
   425 00000AA7 B402                <1>     mov ah, 0x02
   426 00000AA9 B618                <1>     mov dh, 24
   427 00000AAB B201                <1>     mov dl, 1
   428 00000AAD 30FF                <1>     xor bh, bh
   429 00000AAF CD10                <1>     int 0x10
   430                              <1> 
   431 00000AB1 E82505              <1>     call get_time_string
   432 00000AB4 89DE                <1>     mov si, bx
   433 00000AB6 B330                <1>     mov bl, mb_color
   434 00000AB8 E8D410              <1>     call print_atr
   435                              <1> 
   436 00000ABB B402                <1>     mov ah, 0x02
   437 00000ABD B618                <1>     mov dh, 24
   438 00000ABF B21C                <1>     mov dl, 28
   439 00000AC1 30FF                <1>     xor bh, bh
   440 00000AC3 CD10                <1>     int 0x10
   441                              <1> 
   442 00000AC5 B8[7E01]            <1>     mov ax, usrNam
   443 00000AC8 E83503              <1>     call string_uppercase
   444 00000ACB 89C6                <1>     mov si, ax
   445 00000ACD B330                <1>     mov bl, mb_color
   446 00000ACF E8BD10              <1>     call print_atr
   447                              <1> 
   448 00000AD2 B402                <1>     mov ah, 0x02
   449 00000AD4 B618                <1>     mov dh, 24
   450 00000AD6 B245                <1>     mov dl, 69
   451 00000AD8 30FF                <1>     xor bh, bh
   452 00000ADA CD10                <1>     int 0x10
   453                              <1> 
   454 00000ADC E8B105              <1>     call get_date_string
   455 00000ADF 89DE                <1>     mov si, bx
   456 00000AE1 B330                <1>     mov bl, mb_color
   457 00000AE3 E8A910              <1>     call print_atr
   458                              <1> 
   459 00000AE6 B402                <1>     mov ah, 0x02
   460 00000AE8 30FF                <1>     xor bh, bh
   461 00000AEA 30D2                <1>     xor dl, dl
   462 00000AEC 5A                  <1>     pop dx
   463 00000AED CD10                <1>     int 0x10
   464                              <1> 
   465 00000AEF 61                  <1>     popa
   466 00000AF0 C3                  <1>     ret
   369                                      %include "./includes/video.asm"
   370                              <1> kronk_vid:
   371 00000AF1 B80100              <1>     mov ax, 1
   372 00000AF4 B701                <1>     mov bh, vid_backcolor
   373 00000AF6 E87609              <1>     call switch_mode
   374                              <1>     
   375                              <1>     ; Disable color blinking
   376 00000AF9 B80310              <1>     mov ax, 0x1003
   377 00000AFC BB0000              <1>     mov bx, 0x0000
   378 00000AFF CD10                <1>     int 0x10
   379                              <1> 
   380                              <1>     ; Initalize and enable the mouse if possible
   381 00000B01 E8B410              <1>     call mouse_initialize
   382 00000B04 720A                <1>     jc vid_input
   383 00000B06 B001                <1>     mov al, 1
   384 00000B08 A2[110B]            <1>     mov [mouse_working], al
   385 00000B0B E8D810              <1>     call mouse_enable
   386 00000B0E EB00                <1>     jmp vid_input
   387                              <1> 
   388                              <1> vid_input:
   389                              <1>     ;mov si, mb_string
   390                              <1>     ;xor bh, bh
   391                              <1>     ;mov bl, vid_forecolor
   392                              <1>     ;call print_atr
   393                              <1> 
   394                              <1>     ;mov bh, vid_backcolor
   395                              <1>     ;call cls
   396                              <1> 
   397                              <1>     ;mov al, [mouse_working]
   398                              <1>     ;cmp al, 0
   399                              <1>     ;call mouse_loop
   400                              <1>     ;call move_cursor
   401                              <1> 
   402                              <1>     ;mov si, sejt
   403                              <1>     ;xor bh, bh
   404                              <1>     ;mov bl, vid_forecolor
   405                              <1>     ;call print_atr
   406                              <1> 
   407 00000B10 F4                  <1>     hlt
   408                              <1> 
   409                              <1> ; ------------------------------------------------------------------
   410                              <1> ; STRINGS AND OTHER VARIABLES
   411                              <1> 
   412 00000B11 00                  <1>     mouse_working:      db 0
   413 00000B12 2000                <1>     sejt:               db " ", 0
   370                                      %include "./includes/setup.asm"
   371                              <1> ; ==================================================================
   372                              <1> ; The Kronk Operating System setup file
   373                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   374                              <1> ;
   375                              <1> ; This is loaded from the drive by KERNEL.BIN, at first boot
   376                              <1> ; ==================================================================
   377                              <1> setup_init:
   378                              <1> 
   379                              <1>     ; Color variables
   380                              <1>     basic_colors    equ 0x1F
   381                              <1>     marked_colors   equ 0x1E
   382                              <1> 
   383                              <1>     ; Setup text box variables
   384                              <1>     edge_width      equ 14
   385                              <1>     border_length   equ 50
   386                              <1>     
   387                              <1>     ; Disable color blinking
   388 00000B14 B80310              <1>     mov ax, 0x1003
   389 00000B17 BB0000              <1>     mov bx, 0x0000
   390 00000B1A CD10                <1>     int 0x10
   391                              <1> 
   392 00000B1C EB00                <1>     jmp setup_start
   393                              <1> 
   394                              <1> ; ******************************************************************
   395                              <1> ; Start the setup
   396                              <1> setup_start:
   397 00000B1E 60                  <1>     pusha
   398 00000B1F B71F                <1>     mov bh, basic_colors
   399 00000B21 E87702              <1>     call cls
   400                              <1> 
   401 00000B24 BE[860D]            <1>     mov si, setup_string
   402 00000B27 E86C09              <1>     call setup_bottom_string
   403                              <1> 
   404 00000B2A BE[AB0B]            <1>     mov si, usr_set
   405 00000B2D E8290C              <1>     call draw_setup_box
   406                              <1> 
   407 00000B30 B8[970B]            <1>     mov ax, usr_save
   408 00000B33 E87809              <1>     call setup_input
   409                              <1> 
   410 00000B36 B71F                <1>     mov bh, basic_colors
   411 00000B38 E86002              <1>     call cls
   412                              <1> 
   413 00000B3B BE[DA0B]            <1>     mov si, vid_set
   414 00000B3E E8180C              <1>     call draw_setup_box
   415                              <1> 
   416 00000B41 B8[510D]            <1>     mov ax, vid_opt1
   417 00000B44 BB[5A0D]            <1>     mov bx, vid_opt2
   418 00000B47 B9[650D]            <1>     mov cx, vid_opt3
   419 00000B4A BAE11F              <1>     mov dx, 0x1fe1
   420 00000B4D E8560A              <1>     call setup_choose
   421                              <1> 
   422 00000B50 83F802              <1>     cmp ax, 2
   423 00000B53 7517                <1>     jne .setup_done
   424                              <1> 
   425                              <1>     ; User has choosen "cancel" and KronkOS will therefore shutdown
   426 00000B55 31C0                <1>     xor ax, ax
   427 00000B57 CD13                <1>     int 0x13
   428                              <1> 
   429 00000B59 B80010              <1>     mov ax, 0x1000
   430 00000B5C 8CD0                <1>     mov ax, ss
   431 00000B5E BC00F0              <1>     mov sp, 0xf000
   432 00000B61 B80753              <1>     mov ax, 0x5307
   433 00000B64 BB0100              <1>     mov bx, 0x0001
   434 00000B67 B90300              <1>     mov cx, 0x0003
   435 00000B6A CD15                <1>     int 0x15
   436                              <1> 
   437                              <1> .setup_done:
   438 00000B6C A3[9301]            <1>     mov [vidMode], ax
   439                              <1> 
   440 00000B6F BE[970B]            <1>     mov si, usr_save
   441 00000B72 BF[7E01]            <1>     mov di, usrNam
   442 00000B75 E8C202              <1>     call string_copy
   443                              <1> 
   444 00000B78 61                  <1>     popa
   445 00000B79 C3                  <1>     ret
   446                              <1> 
   447                              <1> ; ******************************************************************
   448                              <1> 
   449                              <1> ; ------------------------------------------------------------------
   450                              <1> ; VARIABLES
   451 00000B7A 766964656F6D6F6465- <1>     vidmode_save:   db "videomode,", 0
   451 00000B83 2C00                <1>
   452 00000B85 300A0D00            <1>     cli_save:       db "0", 0x0a, 0x0d, 0
   453 00000B89 310A0D00            <1>     vid_save:       db "1", 0x0a, 0x0d, 0
   454 00000B8D 757365726E616D652C- <1>     usrname_save:   db "username,", 0
   454 00000B96 00                  <1>
   455 00000B97 00<rep 14h>         <1>     usr_save:       times 20 db 0
   456                              <1> 
   457 00000BAB 506C6561736520656E- <1>     usr_set:    db "Please enter your username, and press enter...", 0
   457 00000BB4 74657220796F757220- <1>
   457 00000BBD 757365726E616D652C- <1>
   457 00000BC6 20616E642070726573- <1>
   457 00000BCF 7320656E7465722E2E- <1>
   457 00000BD8 2E00                <1>
   458                              <1> 
   459 00000BDA 506C65617365206368- <1>     vid_set:    db "Please choose a standard view mode...", 0x0a, 0x0a
   459 00000BE3 6F6F73652061207374- <1>
   459 00000BEC 616E64617264207669- <1>
   459 00000BF5 6577206D6F64652E2E- <1>
   459 00000BFE 2E0A0A              <1>
   460 00000C01 564944454F204D4F44- <1>                 db "VIDEO MODE is for the more casual user, that", 0x0a, "just want to be able to use KronkOS with ease by using a nice graphical interface.", 0x0a, 0x0a
   460 00000C0A 4520697320666F7220- <1>
   460 00000C13 746865206D6F726520- <1>
   460 00000C1C 63617375616C207573- <1>
   460 00000C25 65722C20746861740A- <1>
   460 00000C2E 6A7573742077616E74- <1>
   460 00000C37 20746F206265206162- <1>
   460 00000C40 6C6520746F20757365- <1>
   460 00000C49 204B726F6E6B4F5320- <1>
   460 00000C52 776974682065617365- <1>
   460 00000C5B 206279207573696E67- <1>
   460 00000C64 2061206E6963652067- <1>
   460 00000C6D 726170686963616C20- <1>
   460 00000C76 696E74657266616365- <1>
   460 00000C7F 2E0A0A              <1>
   461 00000C82 434C49204D4F444520- <1>                 db "CLI MODE is for the more advanced user, where", 0x0a, "instead of pressing buttons, you use commands to", 0x0a, "execute the various actions you desire.", 0x0a, 0x0a
   461 00000C8B 697320666F72207468- <1>
   461 00000C94 65206D6F7265206164- <1>
   461 00000C9D 76616E636564207573- <1>
   461 00000CA6 65722C207768657265- <1>
   461 00000CAF 0A696E737465616420- <1>
   461 00000CB8 6F6620707265737369- <1>
   461 00000CC1 6E6720627574746F6E- <1>
   461 00000CCA 732C20796F75207573- <1>
   461 00000CD3 6520636F6D6D616E64- <1>
   461 00000CDC 7320746F0A65786563- <1>
   461 00000CE5 757465207468652076- <1>
   461 00000CEE 6172696F7573206163- <1>
   461 00000CF7 74696F6E7320796F75- <1>
   461 00000D00 206465736972652E0A- <1>
   461 00000D09 0A                  <1>
   462 00000D0A 557365207468652061- <1>                 db "Use the arrow keys and 'ENTER' to select between the different options", 0
   462 00000D13 72726F77206B657973- <1>
   462 00000D1C 20616E642027454E54- <1>
   462 00000D25 45522720746F207365- <1>
   462 00000D2E 6C6563742062657477- <1>
   462 00000D37 65656E207468652064- <1>
   462 00000D40 6966666572656E7420- <1>
   462 00000D49 6F7074696F6E7300    <1>
   463                              <1> 
   464 00000D51 434C49204D4F444500  <1>     vid_opt1:   db "CLI MODE", 0
   465 00000D5A 564944454F204D4F44- <1>     vid_opt2:   db "VIDEO MODE", 0
   465 00000D63 4500                <1>
   466 00000D65 43616E63656C202857- <1>     vid_opt3:   db "Cancel (Will shutdown KronkOS)", 0
   466 00000D6E 696C6C207368757464- <1>
   466 00000D77 6F776E204B726F6E6B- <1>
   466 00000D80 4F532900            <1>
   467                              <1> 
   468 00000D84 0000                <1>     vid_chosen: dw 0
   469                              <1> 
   470 00000D86 204B726F6E6B4F5320- <1>     setup_string: db " KronkOS ", KRONKOS_VER, " setup", 0
   470 00000D8F 302E332E3220736574- <1>
   470 00000D98 757000              <1>
   371                                      %include "./includes/cls.asm"
   372                              <1> cls:
   373 00000D9B 60                  <1>     pusha
   374                              <1>     
   375 00000D9C B406                <1>     mov ah, 0x06
   376 00000D9E BA4F18              <1>     mov dx, 0x184f
   377                              <1> 
   378 00000DA1 30C0                <1>     xor al, al
   379 00000DA3 31C9                <1>     xor cx, cx
   380                              <1> 
   381 00000DA5 CD10                <1>     int 0x10
   382                              <1>     
   383 00000DA7 B402                <1>     mov ah, 0x2
   384 00000DA9 31D2                <1>     xor dx, dx
   385 00000DAB 30FF                <1>     xor bh, bh
   386                              <1> 
   387 00000DAD CD10                <1>     int 0x10
   388                              <1>     
   389 00000DAF 61                  <1>     popa
   390 00000DB0 C3                  <1>     ret
   372                                      %include "./includes/string.asm"
   373                              <1> ; ==================================================================
   374                              <1> ; KronkOS -- The Kronk Operating System kernel
   375                              <1> ; Copyright (C) 2019-2020 Alexander Wiencken
   376                              <1> ;
   377                              <1> ; STRING MANIPULATION ROUTINES
   378                              <1> ; ==================================================================
   379                              <1> 
   380                              <1> ; ------------------------------------------------------------------
   381                              <1> ; string_length -- Return length of a string
   382                              <1> ; IN: AX = string location
   383                              <1> ; OUT AX = length (other regs preserved)
   384                              <1> 
   385                              <1> string_length:
   386 00000DB1 60                  <1>     pusha
   387 00000DB2 89C3                <1>     mov bx, ax
   388 00000DB4 B90000              <1>     mov cx, 0
   389                              <1> 
   390                              <1>     .more:
   391 00000DB7 803F00              <1>         cmp byte [bx], 0
   392 00000DBA 7404                <1>         je .done
   393 00000DBC 43                  <1>         inc bx
   394 00000DBD 41                  <1>         inc cx
   395 00000DBE EBF7                <1>         jmp .more
   396                              <1> 
   397                              <1>     .done:
   398 00000DC0 890E[C90D]          <1>         mov word [.tmp_counter], cx
   399 00000DC4 61                  <1>         popa
   400                              <1> 
   401 00000DC5 A1[C90D]            <1>         mov ax, [.tmp_counter]
   402 00000DC8 C3                  <1>         ret
   403                              <1> 
   404 00000DC9 0000                <1>         .tmp_counter dw 0
   405                              <1> 
   406                              <1> ; ------------------------------------------------------------------
   407                              <1> ; find_char_in_string -- Find location of character in a string
   408                              <1> ; IN: SI = string location, AL = character to find
   409                              <1> ; OUT AX = location in string, or 0 if not present
   410                              <1> 
   411                              <1> find_char_in_string:
   412 00000DCB 60                  <1>     pusha
   413 00000DCC B90100              <1>     mov cx, 1
   414                              <1> 
   415                              <1>     .more:
   416 00000DCF 3804                <1>         cmp byte [si], al
   417 00000DD1 7409                <1>         je .done
   418 00000DD3 803C00              <1>         cmp byte [si], 0
   419 00000DD6 740D                <1>         je .notfound
   420                              <1>         
   421 00000DD8 46                  <1>         inc si
   422 00000DD9 41                  <1>         inc cx
   423                              <1> 
   424 00000DDA EBF3                <1>         jmp .more
   425                              <1>     
   426                              <1>     .done:
   427 00000DDC 890E[EA0D]          <1>         mov [.tmp], cx
   428 00000DE0 61                  <1>         popa
   429 00000DE1 A1[EA0D]            <1>         mov ax, [.tmp]
   430                              <1> 
   431 00000DE4 C3                  <1>         ret
   432                              <1>     
   433                              <1>     .notfound:
   434 00000DE5 61                  <1>         popa
   435 00000DE6 B80000              <1>         mov ax, 0
   436                              <1> 
   437 00000DE9 C3                  <1>         ret
   438                              <1> 
   439 00000DEA 0000                <1>     .tmp dw 0
   440                              <1> 
   441                              <1> ; ------------------------------------------------------------------
   442                              <1> ; string_charchange -- Change a character in a string
   443                              <1> ; IN: SI = string location, AL = char to find, BL = char to replace with
   444                              <1> 
   445                              <1> string_charchange:
   446 00000DEC 60                  <1>     pusha
   447 00000DED 88C1                <1>     mov cl, al
   448                              <1> 
   449                              <1>     .loop:
   450 00000DEF 8A04                <1>         mov byte al, [si]
   451 00000DF1 3C00                <1>         cmp al, 0
   452 00000DF3 7409                <1>         je .finish
   453 00000DF5 38C8                <1>         cmp al, cl
   454 00000DF7 7502                <1>         jne .nochange
   455                              <1> 
   456 00000DF9 881C                <1>         mov byte [si], bl
   457                              <1> 
   458                              <1>     .nochange:
   459 00000DFB 46                  <1>         inc si
   460 00000DFC EBF1                <1>         jmp .loop
   461                              <1>     
   462                              <1>     .finish:
   463 00000DFE 61                  <1>         popa
   464 00000DFF C3                  <1>         ret
   465                              <1> 
   466                              <1> ; ------------------------------------------------------------------
   467                              <1> ; string_uppercase -- Convert string to upper case
   468                              <1> ; IN/OUT: AX = string location
   469                              <1> 
   470                              <1> string_uppercase:
   471 00000E00 60                  <1>     pusha
   472 00000E01 89C6                <1>     mov si, ax
   473                              <1> 
   474                              <1>     .more:
   475 00000E03 803C00              <1>         cmp byte [si], 0
   476 00000E06 7413                <1>         je .done
   477                              <1> 
   478 00000E08 803C61              <1>         cmp byte [si], 'a'
   479 00000E0B 720B                <1>         jb .noatoz
   480 00000E0D 803C7A              <1>         cmp byte [si], 'z'
   481 00000E10 7706                <1>         ja .noatoz
   482                              <1> 
   483 00000E12 802C20              <1>         sub byte [si], 0x20
   484                              <1> 
   485 00000E15 46                  <1>         inc si
   486 00000E16 EBEB                <1>         jmp .more
   487                              <1> 
   488                              <1>     .noatoz:
   489 00000E18 46                  <1>         inc si
   490 00000E19 EBE8                <1>         jmp .more
   491                              <1> 
   492                              <1>     .done:
   493 00000E1B 61                  <1>         popa
   494 00000E1C C3                  <1>         ret
   495                              <1> 
   496                              <1> ; ------------------------------------------------------------------
   497                              <1> ; string_lowercase -- Convert string to lower case
   498                              <1> ; IN/OUT: AX = string location
   499                              <1> 
   500                              <1> string_lowercase:
   501 00000E1D 60                  <1>     pusha
   502 00000E1E 89C6                <1>     mov si, ax
   503                              <1> 
   504                              <1>     .more:
   505 00000E20 803C00              <1>         cmp byte [si], 0
   506 00000E23 7413                <1>         je .done
   507                              <1> 
   508 00000E25 803C41              <1>         cmp byte [si], 'A'
   509 00000E28 720B                <1>         jb .noatoz
   510 00000E2A 803C5A              <1>         cmp byte [si], 'Z'
   511 00000E2D 7706                <1>         ja .noatoz
   512                              <1> 
   513 00000E2F 800420              <1>         add byte [si], 0x20
   514                              <1> 
   515 00000E32 46                  <1>         inc si
   516 00000E33 EBEB                <1>         jmp .more
   517                              <1>     
   518                              <1>     .noatoz:
   519 00000E35 46                  <1>         inc si
   520 00000E36 EBE8                <1>         jmp .more
   521                              <1> 
   522                              <1>     .done:
   523 00000E38 61                  <1>         popa
   524 00000E39 C3                  <1>         ret
   525                              <1>         
   526                              <1> ; ------------------------------------------------------------------
   527                              <1> ; string_copy -- Copy one string on to another
   528                              <1> ; IN: SI = source
   529                              <1> ; OUT: DI = destination
   530                              <1> 
   531                              <1> string_copy:
   532 00000E3A 60                  <1>     pusha
   533                              <1> 
   534                              <1>     .more:
   535 00000E3B AC                  <1>         lodsb
   536 00000E3C AA                  <1>         stosb
   537                              <1> 
   538 00000E3D 84C0                <1>         test al, al
   539 00000E3F 75FA                <1>         jnz .more
   540                              <1> 
   541                              <1>     .done:
   542 00000E41 61                  <1>         popa
   543 00000E42 C3                  <1>         ret
   544                              <1> 
   545                              <1> ; ------------------------------------------------------------------
   546                              <1> ; string_truncate -- Chop string down to specified number of characters
   547                              <1> ; IN: SI = string location, AX = number of characters
   548                              <1> ; OUT: Modified string
   549                              <1> 
   550                              <1> string_truncate:
   551 00000E43 60                  <1>     pusha
   552                              <1> 
   553 00000E44 01C6                <1>     add si, ax
   554 00000E46 C60400              <1>     mov byte [si], 0
   555                              <1> 
   556 00000E49 61                  <1>     popa
   557 00000E4A C3                  <1>     ret
   558                              <1> 
   559                              <1> ; ------------------------------------------------------------------
   560                              <1> ; string_add
   561                              <1> ; IN: AX = string one; BX = string two
   562                              <1> ; OUT AX = product
   563                              <1> 
   564                              <1> string_add:
   565                              <1>     .add_loop:
   566 00000E4B AC                  <1>         lodsb
   567 00000E4C AA                  <1>         stosb
   568                              <1> 
   569 00000E4D 3C00                <1>         cmp al, 0
   570 00000E4F 75FA                <1>         jne .add_loop
   571                              <1> 
   572 00000E51 C3                  <1>         ret
   573                              <1> 
   574                              <1> ; ------------------------------------------------------------------
   575                              <1> ; string_join -- Join two strings into a third seperate string
   576                              <1> ; IN/OUT: AX = string one, BX = string two, CX = product destination
   577                              <1> 
   578                              <1> string_join:
   579 00000E52 60                  <1>     pusha
   580                              <1>     
   581 00000E53 89C6                <1>     mov si, ax
   582 00000E55 89CF                <1>     mov di, cx
   583                              <1> 
   584 00000E57 E8E0FF              <1>     call string_copy
   585 00000E5A E854FF              <1>     call string_length
   586                              <1> 
   587 00000E5D 01C1                <1>     add cx, ax
   588                              <1> 
   589 00000E5F 89DE                <1>     mov si, bx
   590 00000E61 89CF                <1>     mov di, cx
   591 00000E63 E8D4FF              <1>     call string_copy
   592                              <1> 
   593 00000E66 61                  <1>     popa
   594 00000E67 C3                  <1>     ret
   595                              <1> 
   596                              <1> ; ------------------------------------------------------------------
   597                              <1> ; string_chomp -- Strip away extra spaces from a string
   598                              <1> ; IN: AX = string location
   599                              <1> 
   600                              <1> string_chomp:
   601 00000E68 60                  <1>     pusha
   602                              <1> 
   603 00000E69 89C2                <1>     mov dx, ax
   604                              <1> 
   605 00000E6B 89C7                <1>     mov di, ax
   606 00000E6D B90000              <1>     mov cx, 0
   607                              <1> 
   608                              <1>     .keepcounting:
   609 00000E70 803D20              <1>         cmp byte [di], ' '
   610 00000E73 7504                <1>         jne .counted
   611 00000E75 41                  <1>         inc cx
   612 00000E76 47                  <1>         inc di
   613 00000E77 EBF7                <1>         jmp .keepcounting
   614                              <1> 
   615                              <1>     .counted:
   616 00000E79 83F900              <1>         cmp cx, 0
   617 00000E7C 740E                <1>         je .finished_copy
   618                              <1> 
   619 00000E7E 89FE                <1>         mov si, di
   620 00000E80 89D7                <1>         mov di, dx
   621                              <1>     
   622                              <1>     .keep_copying:
   623 00000E82 AC                  <1>         lodsb
   624 00000E83 8805                <1>         mov [di], al
   625 00000E85 3C00                <1>         cmp al, 0
   626 00000E87 7403                <1>         je .finished_copy
   627 00000E89 47                  <1>         inc di
   628                              <1> 
   629 00000E8A EBF6                <1>         jmp .keep_copying
   630                              <1> 
   631                              <1>     .finished_copy:
   632 00000E8C 89D0                <1>         mov ax, dx
   633                              <1> 
   634 00000E8E E820FF              <1>         call string_length
   635 00000E91 83F800              <1>         cmp ax, 0
   636 00000E94 740F                <1>         je .done
   637                              <1> 
   638 00000E96 89D6                <1>         mov si, dx
   639 00000E98 01C6                <1>         add si, ax
   640                              <1>     
   641                              <1>     .more:
   642 00000E9A 4E                  <1>         dec si
   643 00000E9B 803C20              <1>         cmp byte [si], ' '
   644 00000E9E 7505                <1>         jne .done
   645 00000EA0 C60400              <1>         mov byte [si], 0
   646 00000EA3 EBF5                <1>         jmp .more
   647                              <1>     
   648                              <1>     .done:
   649 00000EA5 61                  <1>         popa
   650 00000EA6 C3                  <1>         ret
   651                              <1> 
   652                              <1> ; ------------------------------------------------------------------
   653                              <1> ; string_strip -- Remove a character from a string (max 255 chars)
   654                              <1> ; IN: SI = string location, AL = character to remove
   655                              <1> ; OUT: SI = modified string
   656                              <1> 
   657                              <1> string_strip:
   658 00000EA7 60                  <1>     pusha
   659                              <1> 
   660 00000EA8 89F7                <1>     mov di, si
   661 00000EAA 88C3                <1>     mov bl, al
   662                              <1> 
   663                              <1>     .nextchar:
   664 00000EAC AC                  <1>         lodsb
   665 00000EAD AA                  <1>         stosb
   666 00000EAE 3C00                <1>         cmp al, 0
   667 00000EB0 7407                <1>         je .finish
   668 00000EB2 38D8                <1>         cmp al, bl
   669 00000EB4 75F6                <1>         jne .nextchar
   670                              <1> 
   671                              <1>     .skip:
   672 00000EB6 4F                  <1>         dec di
   673 00000EB7 EBF3                <1>         jmp .nextchar
   674                              <1> 
   675                              <1>     .finish:
   676 00000EB9 61                  <1>         popa
   677 00000EBA C3                  <1>         ret
   678                              <1> 
   679                              <1> ; ------------------------------------------------------------------
   680                              <1> ; string_compare -- Check if two strings match
   681                              <1> ; IN: SI = string one, DI = string two
   682                              <1> ; OUT: carry set if same, clear if different
   683                              <1> 
   684                              <1> string_compare:
   685 00000EBB 60                  <1>     pusha
   686                              <1> 
   687                              <1>     .more:
   688 00000EBC 8A04                <1>         mov al, [si]
   689 00000EBE 8A1D                <1>         mov bl, [di]
   690                              <1> 
   691 00000EC0 80FB00              <1>         cmp bl, 0
   692 00000EC3 740B                <1>         je .terminated
   693                              <1> 
   694 00000EC5 38D8                <1>         cmp al, bl
   695 00000EC7 7504                <1>         jne .not_same
   696                              <1> 
   697 00000EC9 46                  <1>         inc si
   698 00000ECA 47                  <1>         inc di
   699 00000ECB EBEF                <1>         jmp .more
   700                              <1>     
   701                              <1>     .not_same:
   702 00000ECD 61                  <1>         popa
   703 00000ECE F8                  <1>         clc
   704 00000ECF C3                  <1>         ret
   705                              <1>     
   706                              <1>     .terminated:
   707 00000ED0 61                  <1>         popa
   708 00000ED1 F9                  <1>         stc
   709 00000ED2 C3                  <1>         ret
   710                              <1> 
   711                              <1> ; ------------------------------------------------------------------
   712                              <1> ; string_to_int -- Convert string to an integer
   713                              <1> ; IN: SI = string (max 5 chars, up to '65536')
   714                              <1> ; OUT: AX = number
   715                              <1> 
   716                              <1> string_to_int:
   717 00000ED3 60                  <1>     pusha
   718                              <1> 
   719 00000ED4 89F0                <1>     mov ax, si
   720 00000ED6 E8D8FE              <1>     call string_length
   721                              <1> 
   722 00000ED9 01C6                <1>     add si, ax
   723 00000EDB 4E                  <1>     dec si
   724                              <1> 
   725 00000EDC 89C1                <1>     mov cx, ax
   726                              <1> 
   727 00000EDE BB0000              <1>     mov bx, 0
   728 00000EE1 B80000              <1>     mov ax, 0
   729                              <1> 
   730 00000EE4 C706[160F]0100      <1>     mov word [.multiplier], 1
   731                              <1> 
   732                              <1>     .loop:
   733 00000EEA B80000              <1>         mov ax, 0
   734 00000EED 8A04                <1>         mov byte al, [si]
   735 00000EEF 2C30                <1>         sub al, 48
   736                              <1> 
   737 00000EF1 F726[160F]          <1>         mul word [.multiplier]
   738 00000EF5 01C3                <1>         add bx, ax
   739                              <1> 
   740 00000EF7 50                  <1>         push ax
   741 00000EF8 A1[160F]            <1>         mov word ax, [.multiplier]
   742 00000EFB BA0A00              <1>         mov dx, 10
   743 00000EFE F7E2                <1>         mul dx
   744 00000F00 A3[160F]            <1>         mov word [.multiplier], ax
   745 00000F03 58                  <1>         pop ax
   746                              <1> 
   747 00000F04 49                  <1>         dec cx
   748 00000F05 83F900              <1>         cmp cx, 0
   749 00000F08 7403                <1>         je .finish
   750 00000F0A 4E                  <1>         dec si
   751 00000F0B EBDD                <1>         jmp .loop
   752                              <1>     
   753                              <1>     .finish:
   754 00000F0D 891E[180F]          <1>         mov word [.tmp], bx
   755 00000F11 61                  <1>         popa
   756 00000F12 A1[180F]            <1>         mov word ax, [.tmp]
   757                              <1> 
   758 00000F15 C3                  <1>         ret
   759                              <1> 
   760 00000F16 0000                <1>     .multiplier dw 0
   761 00000F18 0000                <1>     .tmp        dw 0
   762                              <1> 
   763                              <1> ; ------------------------------------------------------------------
   764                              <1> ; int_to_string -- Convert unsigned integer to a string
   765                              <1> ; IN: AX = unsigned int
   766                              <1> ; OUT: AX = string
   767                              <1> 
   768                              <1> int_to_string:
   769 00000F1A 60                  <1>     pusha
   770                              <1> 
   771 00000F1B B90000              <1>     mov cx, 0
   772 00000F1E BB0A00              <1>     mov bx, 10
   773 00000F21 BF[410F]            <1>     mov di, .t
   774                              <1> 
   775                              <1>     .push:
   776 00000F24 BA0000              <1>         mov dx, 0
   777 00000F27 F7F3                <1>         div bx
   778 00000F29 41                  <1>         inc cx
   779 00000F2A 52                  <1>         push dx
   780 00000F2B 85C0                <1>         test ax, ax
   781 00000F2D 75F5                <1>         jnz .push
   782                              <1> 
   783                              <1>     .pop:
   784 00000F2F 5A                  <1>         pop dx
   785 00000F30 80C230              <1>         add dl, '0'
   786 00000F33 8815                <1>         mov [di], dl
   787 00000F35 47                  <1>         inc di
   788 00000F36 49                  <1>         dec cx
   789 00000F37 75F6                <1>         jnz .pop
   790                              <1> 
   791 00000F39 C60500              <1>         mov byte [di], 0
   792                              <1> 
   793 00000F3C 61                  <1>         popa
   794 00000F3D B8[410F]            <1>         mov ax, .t
   795 00000F40 C3                  <1>         ret
   796                              <1> 
   797 00000F41 00<rep 7h>          <1>         .t times 7 db 0
   798                              <1> 
   799                              <1> ; ------------------------------------------------------------------
   800                              <1> ; sint_to_string -- Convert signed integer to string
   801                              <1> ; IN: AX = signed int
   802                              <1> ; OUT: AX = string location
   803                              <1> 
   804                              <1> sint_to_string:
   805 00000F48 60                  <1>     pusha
   806                              <1> 
   807 00000F49 B90000              <1>     mov cx, 0
   808 00000F4C BB0A00              <1>     mov bx, 10
   809 00000F4F BF[7D0F]            <1>     mov di, .t
   810                              <1> 
   811 00000F52 85C0                <1>     test ax, ax
   812 00000F54 7802                <1>     js .neg
   813 00000F56 EB08                <1>     jmp .push
   814                              <1> 
   815                              <1>     .neg:
   816 00000F58 F7D8                <1>         neg ax
   817 00000F5A C606[7D0F]2D        <1>         mov byte [.t], '-'
   818 00000F5F 47                  <1>         inc di
   819                              <1>     
   820                              <1>     .push:
   821 00000F60 BA0000              <1>         mov dx, 0
   822 00000F63 F7F3                <1>         div bx
   823 00000F65 41                  <1>         inc cx
   824 00000F66 52                  <1>         push dx
   825 00000F67 85C0                <1>         test ax, ax
   826 00000F69 75F5                <1>         jnz .push
   827                              <1> 
   828                              <1>     .pop:
   829 00000F6B 5A                  <1>         pop dx
   830 00000F6C 80C230              <1>         add dl, '0'
   831 00000F6F 8815                <1>         mov [di], dl
   832 00000F71 47                  <1>         inc di
   833 00000F72 49                  <1>         dec cx
   834 00000F73 75F6                <1>         jnz .pop
   835                              <1> 
   836 00000F75 C60500              <1>         mov byte [di], 0
   837                              <1> 
   838 00000F78 61                  <1>         popa
   839 00000F79 B8[7D0F]            <1>         mov ax, .t
   840 00000F7C C3                  <1>         ret
   841                              <1> 
   842 00000F7D 00<rep 7h>          <1>         .t times 7 db 0
   843                              <1>         
   844                              <1> ; ------------------------------------------------------------------
   845                              <1> ; lint_to_string -- Convert long integer to string
   846                              <1> ; IN: DX:AX = long unsigned int, BX = number base, DI = string location
   847                              <1> ; OUT: DI = location of converted string
   848                              <1> 
   849                              <1> lint_to_string:
   850 00000F84 60                  <1>     pusha
   851                              <1> 
   852 00000F85 89FE                <1>     mov si, di
   853 00000F87 C7050000            <1>     mov word [di], 0
   854                              <1> 
   855 00000F8B 83FB25              <1>     cmp bx, 37
   856 00000F8E 773B                <1>     ja .done
   857                              <1> 
   858 00000F90 83FB00              <1>     cmp bx, 0
   859 00000F93 7436                <1>     je .done
   860                              <1> 
   861                              <1>     .conversion_loop:
   862 00000F95 B90000              <1>         mov cx, 0
   863                              <1> 
   864 00000F98 91                  <1>         xchg ax, cx
   865 00000F99 92                  <1>         xchg ax, dx
   866 00000F9A F7F3                <1>         div bx
   867                              <1> 
   868 00000F9C 91                  <1>         xchg ax, cx
   869 00000F9D F7F3                <1>         div bx
   870 00000F9F 87CA                <1>         xchg cx, dx
   871                              <1>     
   872                              <1>     .save_digit:
   873 00000FA1 83F909              <1>         cmp cx, 9
   874 00000FA4 7E03                <1>         jle .convert_digit
   875                              <1> 
   876 00000FA6 83C107              <1>         add cx, 'A'-'9'-1
   877                              <1> 
   878                              <1>     .convert_digit:
   879 00000FA9 83C130              <1>         add cx, '0'
   880                              <1> 
   881 00000FAC 50                  <1>         push ax
   882 00000FAD 53                  <1>         push bx
   883 00000FAE 89F0                <1>         mov ax, si
   884 00000FB0 E8FEFD              <1>         call string_length
   885                              <1> 
   886 00000FB3 89F7                <1>         mov di, si
   887 00000FB5 01C7                <1>         add di, ax
   888 00000FB7 40                  <1>         inc ax
   889                              <1>     
   890                              <1>     .move_string_up:
   891 00000FB8 8A1D                <1>         mov bl, [di]
   892 00000FBA 885D01              <1>         mov [di+1], bl
   893 00000FBD 4F                  <1>         dec di
   894 00000FBE 48                  <1>         dec ax
   895 00000FBF 75F7                <1>         jnz .move_string_up
   896                              <1> 
   897 00000FC1 5B                  <1>         pop bx
   898 00000FC2 58                  <1>         pop ax
   899 00000FC3 880C                <1>         mov [si], cl
   900                              <1>     
   901                              <1>     .test_end:
   902 00000FC5 89D1                <1>         mov cx, dx
   903 00000FC7 09C1                <1>         or cx, ax
   904 00000FC9 75CA                <1>         jnz .conversion_loop
   905                              <1>     
   906                              <1>     .done:
   907 00000FCB 61                  <1>         popa
   908 00000FCC C3                  <1>         ret
   909                              <1>         
   910                              <1> ; ------------------------------------------------------------------
   911                              <1> ; set_time_fmt -- Set time reporting format (eg '10:25 AM' or '2300 hours')
   912                              <1> ; IN: AL = format flag, 0 = 12-hr format
   913                              <1> 
   914                              <1> set_time_fmt:
   915 00000FCD 60                  <1> 	pusha
   916 00000FCE 3C00                <1> 	cmp al, 0
   917 00000FD0 7402                <1> 	je .store
   918 00000FD2 B0FF                <1> 	mov al, 0x0FF
   919                              <1> .store:
   920 00000FD4 A2[F103]            <1> 	mov [fmt_12_24], al
   921 00000FD7 61                  <1> 	popa
   922 00000FD8 C3                  <1> 	ret
   923                              <1> 
   924                              <1> 
   925                              <1> ; ------------------------------------------------------------------
   926                              <1> ; get_time_string -- Get current time in a string (eg '10:25')
   927                              <1> ; OUT: BX = string location
   928                              <1> 
   929                              <1> get_time_string:
   930 00000FD9 60                  <1> 	pusha
   931                              <1> 
   932 00000FDA 89DF                <1> 	mov di, bx
   933                              <1> 
   934 00000FDC F8                  <1> 	clc
   935 00000FDD B402                <1> 	mov ah, 2
   936 00000FDF CD1A                <1> 	int 0x1A
   937 00000FE1 7305                <1> 	jnc .read
   938                              <1> 
   939 00000FE3 F8                  <1> 	clc
   940 00000FE4 B402                <1> 	mov ah, 2
   941 00000FE6 CD1A                <1> 	int 0x1A
   942                              <1> 
   943                              <1> .read:
   944 00000FE8 88E8                <1> 	mov al, ch
   945 00000FEA E8450B              <1> 	call bcd_to_int
   946 00000FED 89C2                <1> 	mov dx, ax
   947                              <1> 
   948 00000FEF 88E8                <1> 	mov al,	ch
   949 00000FF1 C0E804              <1> 	shr al, 4
   950 00000FF4 80E50F              <1> 	and ch, 0x0F
   951 00000FF7 F606[F103]FF        <1> 	test byte [fmt_12_24], 0x0FF
   952 00000FFC 740A                <1> 	jz .twelve_hr
   953                              <1> 
   954 00000FFE E86900              <1> 	call .add_digit
   955 00001001 88E8                <1> 	mov al, ch
   956 00001003 E86400              <1> 	call .add_digit
   957 00001006 EB2F                <1> 	jmp short .minutes
   958                              <1> 
   959                              <1> .twelve_hr:
   960 00001008 83FA00              <1> 	cmp dx, 0
   961 0000100B 741B                <1> 	je .midnight
   962                              <1> 
   963 0000100D 83FA0A              <1> 	cmp dx, 10
   964 00001010 7C1D                <1> 	jl .twelve_st1
   965                              <1> 
   966 00001012 83FA0C              <1> 	cmp dx, 12
   967 00001015 7E15                <1> 	jle .twelve_st2
   968                              <1> 
   969 00001017 89D0                <1> 	mov ax, dx
   970 00001019 83E80C              <1> 	sub ax, 12
   971 0000101C B30A                <1> 	mov bl, 10
   972 0000101E F6F3                <1> 	div bl
   973 00001020 88E5                <1> 	mov ch, ah
   974                              <1> 
   975 00001022 3C00                <1> 	cmp al, 0
   976 00001024 7409                <1> 	je .twelve_st1
   977                              <1> 
   978 00001026 EB04                <1> 	jmp short .twelve_st2
   979                              <1> 
   980                              <1> .midnight:
   981 00001028 B001                <1> 	mov al, 1
   982 0000102A B502                <1> 	mov ch, 2
   983                              <1> 
   984                              <1> .twelve_st2:
   985 0000102C E83B00              <1> 	call .add_digit
   986                              <1> .twelve_st1:
   987 0000102F 88E8                <1> 	mov al, ch
   988 00001031 E83600              <1> 	call .add_digit
   989                              <1> 
   990 00001034 B03A                <1> 	mov al, ':'
   991 00001036 AA                  <1> 	stosb
   992                              <1> 
   993                              <1> .minutes:
   994 00001037 88C8                <1> 	mov al, cl
   995 00001039 C0E804              <1> 	shr al, 4
   996 0000103C 80E10F              <1> 	and cl, 0x0F
   997 0000103F E82800              <1> 	call .add_digit
   998 00001042 88C8                <1> 	mov al, cl
   999 00001044 E82300              <1> 	call .add_digit
  1000                              <1> 
  1001 00001047 B020                <1> 	mov al, ' '
  1002 00001049 AA                  <1> 	stosb
  1003                              <1> 
  1004 0000104A BE[6E10]            <1> 	mov si, .hours_string
  1005 0000104D F606[F103]FF        <1> 	test byte [fmt_12_24], 0x0FF
  1006 00001052 750B                <1> 	jnz .copy
  1007                              <1> 
  1008 00001054 BE[7710]            <1> 	mov si, .pm_string
  1009 00001057 83FA0C              <1> 	cmp dx, 12
  1010 0000105A 7F03                <1> 	jg .copy
  1011                              <1> 
  1012 0000105C BE[7410]            <1> 	mov si, .am_string
  1013                              <1> 
  1014                              <1> .copy:
  1015 0000105F 80C301              <1>     add bl, 1
  1016 00001062 AC                  <1> 	lodsb
  1017 00001063 AA                  <1> 	stosb
  1018 00001064 3C00                <1> 	cmp al, 0
  1019 00001066 75F7                <1> 	jne .copy
  1020                              <1> 
  1021 00001068 61                  <1> 	popa
  1022 00001069 C3                  <1> 	ret
  1023                              <1> 
  1024                              <1> .add_digit:
  1025 0000106A 0430                <1> 	add al, '0'
  1026 0000106C AA                  <1> 	stosb
  1027 0000106D C3                  <1> 	ret
  1028                              <1> 
  1029                              <1> 
  1030 0000106E 686F75727300        <1> 	.hours_string	db 'hours', 0
  1031 00001074 414D00              <1> 	.am_string 	db 'AM', 0
  1032 00001077 504D00              <1> 	.pm_string 	db 'PM', 0
  1033                              <1> 
  1034                              <1> 
  1035                              <1> ; ------------------------------------------------------------------
  1036                              <1> ; set_date_fmt -- Set date reporting format (M/D/Y, D/M/Y or Y/M/D - 0, 1, 2)
  1037                              <1> ; IN: AX = format flag, 0-2
  1038                              <1> ; If AX bit 7 = 1 = use name for months
  1039                              <1> ; If AX bit 7 = 0, high byte = separator character
  1040                              <1> 
  1041                              <1> set_date_fmt:
  1042 0000107A 60                  <1> 	pusha
  1043 0000107B A880                <1> 	test al, 0x80
  1044 0000107D 7505                <1> 	jnz .fmt_clear
  1045                              <1> 
  1046 0000107F 25037F              <1> 	and ax, 0x7F03
  1047 00001082 EB03                <1> 	jmp short .fmt_test
  1048                              <1> 
  1049                              <1> .fmt_clear:
  1050 00001084 83E003              <1> 	and ax, 0003
  1051                              <1> 
  1052                              <1> .fmt_test:
  1053 00001087 3C03                <1> 	cmp al, 3
  1054 00001089 7303                <1> 	jae .leave
  1055 0000108B A3[F203]            <1> 	mov [fmt_date], ax
  1056                              <1> 
  1057                              <1> .leave:
  1058 0000108E 61                  <1> 	popa
  1059 0000108F C3                  <1> 	ret
  1060                              <1> 
  1061                              <1> 
  1062                              <1> ; ------------------------------------------------------------------
  1063                              <1> ; get_date_string -- Get current date in a string (eg '12/31/2007')
  1064                              <1> ; OUT: BX = string location
  1065                              <1> 
  1066                              <1> get_date_string:
  1067 00001090 60                  <1> 	pusha
  1068                              <1> 
  1069 00001091 89DF                <1> 	mov di, bx
  1070 00001093 8B1E[F203]          <1> 	mov bx, [fmt_date]
  1071 00001097 81E3037F            <1> 	and bx, 0x7F03
  1072                              <1> 
  1073 0000109B F8                  <1> 	clc
  1074 0000109C B404                <1> 	mov ah, 4
  1075 0000109E CD1A                <1> 	int 0x1A
  1076 000010A0 7305                <1> 	jnc .read
  1077                              <1> 
  1078 000010A2 F8                  <1> 	clc
  1079 000010A3 B404                <1> 	mov ah, 4
  1080 000010A5 CD1A                <1> 	int 0x1A
  1081                              <1> 
  1082                              <1> .read:
  1083 000010A7 80FB02              <1> 	cmp bl, 2
  1084 000010AA 751C                <1> 	jne .try_fmt1
  1085                              <1> 
  1086 000010AC 88EC                <1> 	mov ah, ch
  1087 000010AE E8A000              <1> 	call .add_2digits
  1088 000010B1 88CC                <1> 	mov ah, cl
  1089 000010B3 E89B00              <1> 	call .add_2digits
  1090 000010B6 B02F                <1> 	mov al, '/'
  1091 000010B8 AA                  <1> 	stosb
  1092                              <1> 
  1093 000010B9 88F4                <1> 	mov ah, dh
  1094 000010BB E89300              <1> 	call .add_2digits
  1095 000010BE B02F                <1> 	mov al, '/'
  1096 000010C0 AA                  <1> 	stosb
  1097                              <1> 
  1098 000010C1 88D4                <1> 	mov ah, dl
  1099 000010C3 E88B00              <1> 	call .add_2digits
  1100 000010C6 EB71                <1> 	jmp .done
  1101                              <1> 
  1102                              <1> .try_fmt1:
  1103 000010C8 80FB01              <1> 	cmp bl, 1
  1104 000010CB 7536                <1> 	jne .do_fmt0
  1105                              <1> 
  1106 000010CD 88D4                <1> 	mov ah, dl
  1107 000010CF E86D00              <1> 	call .add_1or2digits
  1108                              <1> 
  1109 000010D2 88F8                <1> 	mov al, bh
  1110 000010D4 80FF00              <1> 	cmp bh, 0
  1111 000010D7 7502                <1> 	jne .fmt1_day
  1112                              <1> 
  1113 000010D9 B020                <1> 	mov al, ' '
  1114                              <1> 
  1115                              <1> .fmt1_day:
  1116 000010DB AA                  <1> 	stosb
  1117                              <1> 
  1118 000010DC 88F4                <1> 	mov ah,	dh
  1119 000010DE 80FF00              <1> 	cmp bh, 0
  1120 000010E1 7509                <1> 	jne .fmt1_month
  1121                              <1> 
  1122 000010E3 E87F00              <1> 	call .add_month
  1123 000010E6 B82C20              <1> 	mov ax, ', '
  1124 000010E9 AB                  <1> 	stosw
  1125 000010EA EB06                <1> 	jmp short .fmt1_century
  1126                              <1> 
  1127                              <1> .fmt1_month:
  1128 000010EC E85000              <1> 	call .add_1or2digits
  1129 000010EF 88F8                <1> 	mov al, bh
  1130 000010F1 AA                  <1> 	stosb
  1131                              <1> 
  1132                              <1> .fmt1_century:
  1133 000010F2 88EC                <1> 	mov ah,	ch
  1134 000010F4 80FC00              <1> 	cmp ah, 0
  1135 000010F7 7403                <1> 	je .fmt1_year
  1136                              <1> 
  1137 000010F9 E84300              <1> 	call .add_1or2digits
  1138                              <1> 
  1139                              <1> .fmt1_year:
  1140 000010FC 88CC                <1> 	mov ah, cl
  1141 000010FE E85000              <1> 	call .add_2digits
  1142                              <1> 
  1143 00001101 EB36                <1> 	jmp .done
  1144                              <1> 
  1145                              <1> .do_fmt0:
  1146 00001103 88F4                <1> 	mov ah,	dh
  1147 00001105 80FF00              <1> 	cmp bh, 0
  1148 00001108 7508                <1> 	jne .fmt0_month
  1149                              <1> 
  1150 0000110A E85800              <1> 	call .add_month
  1151 0000110D B020                <1> 	mov al, ' '
  1152 0000110F AA                  <1> 	stosb
  1153 00001110 EB06                <1> 	jmp short .fmt0_day
  1154                              <1> 
  1155                              <1> .fmt0_month:
  1156 00001112 E82A00              <1> 	call .add_1or2digits
  1157 00001115 88F8                <1> 	mov al, bh
  1158 00001117 AA                  <1> 	stosb
  1159                              <1> 
  1160                              <1> .fmt0_day:
  1161 00001118 88D4                <1> 	mov ah, dl
  1162 0000111A E82200              <1> 	call .add_1or2digits
  1163                              <1> 
  1164 0000111D 88F8                <1> 	mov al, bh
  1165 0000111F 80FF00              <1> 	cmp bh, 0
  1166 00001122 7505                <1> 	jne .fmt0_day2
  1167                              <1> 
  1168 00001124 B02C                <1> 	mov al, ','
  1169 00001126 AA                  <1> 	stosb
  1170 00001127 B020                <1> 	mov al, ' '
  1171                              <1> 
  1172                              <1> .fmt0_day2:
  1173 00001129 AA                  <1> 	stosb
  1174                              <1> 
  1175                              <1> .fmt0_century:
  1176 0000112A 88EC                <1> 	mov ah,	ch
  1177 0000112C 80FC00              <1> 	cmp ah, 0
  1178 0000112F 7403                <1> 	je .fmt0_year
  1179                              <1> 
  1180 00001131 E80B00              <1> 	call .add_1or2digits
  1181                              <1> 
  1182                              <1> .fmt0_year:
  1183 00001134 88CC                <1> 	mov ah, cl
  1184 00001136 E81800              <1> 	call .add_2digits
  1185                              <1> 
  1186                              <1> 
  1187                              <1> .done:
  1188 00001139 B80000              <1> 	mov ax, 0
  1189 0000113C AB                  <1> 	stosw
  1190                              <1> 
  1191 0000113D 61                  <1> 	popa
  1192 0000113E C3                  <1> 	ret
  1193                              <1> 
  1194                              <1> 
  1195                              <1> .add_1or2digits:
  1196 0000113F F6C4F0              <1> 	test ah, 0x0F0
  1197 00001142 7405                <1> 	jz .only_one
  1198 00001144 E80A00              <1> 	call .add_2digits
  1199 00001147 EB07                <1> 	jmp short .two_done
  1200                              <1> .only_one:
  1201 00001149 88E0                <1> 	mov al, ah
  1202 0000114B 240F                <1> 	and al, 0x0F
  1203 0000114D E81100              <1> 	call .add_digit
  1204                              <1> .two_done:
  1205 00001150 C3                  <1> 	ret
  1206                              <1> 
  1207                              <1> .add_2digits:
  1208 00001151 88E0                <1> 	mov al, ah
  1209 00001153 C0E804              <1> 	shr al, 4
  1210 00001156 E80800              <1> 	call .add_digit
  1211 00001159 88E0                <1> 	mov al, ah
  1212 0000115B 240F                <1> 	and al, 0x0F
  1213 0000115D E80100              <1> 	call .add_digit
  1214 00001160 C3                  <1> 	ret
  1215                              <1> 
  1216                              <1> .add_digit:
  1217 00001161 0430                <1> 	add al, '0'
  1218 00001163 AA                  <1> 	stosb
  1219 00001164 C3                  <1> 	ret
  1220                              <1> 
  1221                              <1> .add_month:
  1222 00001165 53                  <1> 	push bx
  1223 00001166 51                  <1> 	push cx
  1224 00001167 88E0                <1> 	mov al, ah
  1225 00001169 E8C609              <1> 	call bcd_to_int
  1226 0000116C FEC8                <1> 	dec al
  1227 0000116E B304                <1> 	mov bl, 4
  1228 00001170 F6E3                <1> 	mul bl
  1229 00001172 BE[8611]            <1> 	mov si, .months
  1230 00001175 01C6                <1> 	add si, ax
  1231 00001177 B90400              <1> 	mov cx, 4
  1232 0000117A F3A4                <1> 	rep movsb
  1233 0000117C 807DFF20            <1> 	cmp byte [di-1], ' '
  1234 00001180 7501                <1> 	jne .done_month
  1235 00001182 4F                  <1> 	dec di
  1236                              <1> .done_month:
  1237 00001183 59                  <1> 	pop cx
  1238 00001184 5B                  <1> 	pop bx
  1239 00001185 C3                  <1> 	ret
  1240                              <1> 
  1241 00001186 4A616E2E4665622E4D- <1> 	.months db 'Jan.Feb.Mar.Apr.May JuneJulyAug.SeptOct.Nov.Dec.'
  1241 0000118F 61722E4170722E4D61- <1>
  1241 00001198 79204A756E654A756C- <1>
  1241 000011A1 794175672E53657074- <1>
  1241 000011AA 4F63742E4E6F762E44- <1>
  1241 000011B3 65632E              <1>
  1242                              <1> 
  1243                              <1> ; ------------------------------------------------------------------
  1244                              <1> ; string_tokenize -- Reads tokens separated by specified char from
  1245                              <1> ; a string. Returns pointer to next token, or 0 if none left
  1246                              <1> ; IN: AL = separator char, SI = beginning
  1247                              <1> ; OUT: DI = next token or 0 if none
  1248                              <1> 
  1249                              <1> string_tokenize:
  1250 000011B6 56                  <1> 	push si
  1251                              <1> 
  1252                              <1>     .next_char:
  1253 000011B7 3804                <1> 	    cmp byte [si], al
  1254 000011B9 7408                <1> 	    je .return_token
  1255 000011BB 803C00              <1> 	    cmp byte [si], 0
  1256 000011BE 740B                <1> 	    jz .no_more
  1257 000011C0 46                  <1> 	    inc si
  1258 000011C1 EBF4                <1> 	    jmp .next_char
  1259                              <1> 
  1260                              <1>     .return_token:
  1261 000011C3 C60400              <1> 	    mov byte [si], 0
  1262 000011C6 46                  <1> 	    inc si
  1263 000011C7 89F7                <1> 	    mov di, si
  1264 000011C9 5E                  <1> 	    pop si
  1265 000011CA C3                  <1> 	    ret
  1266                              <1> 
  1267                              <1>     .no_more:
  1268 000011CB BF0000              <1> 	    mov di, 0
  1269 000011CE 5E                  <1> 	    pop si
  1270 000011CF C3                  <1> 	    ret
  1271                              <1> 
  1272                              <1> ; ------------------------------------------------------------------
  1273                              <1> ; string_clear -- Clears a variable
  1274                              <1> ; IN: DI  = variable, AX = length
  1275                              <1> ; OUT: empty variable
  1276                              <1> 
  1277                              <1> string_clear:
  1278 000011D0 60                  <1>     pusha
  1279 000011D1 BBFFFF              <1>     mov bx, -1
  1280                              <1>     
  1281                              <1>     .loop:
  1282 000011D4 30C0                <1>         xor al, al
  1283 000011D6 AA                  <1>         stosb
  1284                              <1>         
  1285 000011D7 43                  <1>         inc bx
  1286                              <1> 
  1287 000011D8 39D8                <1>         cmp ax, bx
  1288 000011DA 75F8                <1>         jne .loop
  1289 000011DC 61                  <1>         popa
  1290 000011DD C3                  <1>         ret
  1291                              <1> 
  1292                              <1> ; ==================================================================
   373                                      %include "./includes/screen.asm"
   374                              <1> ; ------------------------------------------------------------------
   375                              <1> ; show_cursor -- Turns on cursor in text mode
   376                              <1> ; IN/OUT: Nothing
   377                              <1> 
   378                              <1> show_cursor:
   379 000011DE 60                  <1> 	pusha
   380                              <1> 
   381 000011DF B506                <1> 	mov ch, 6
   382 000011E1 B107                <1> 	mov cl, 7
   383 000011E3 B401                <1> 	mov ah, 1
   384 000011E5 B003                <1> 	mov al, 3
   385 000011E7 CD10                <1> 	int 10h
   386                              <1> 
   387 000011E9 61                  <1> 	popa
   388 000011EA C3                  <1> 	ret
   389                              <1> 
   390                              <1> ; ------------------------------------------------------------------
   391                              <1> ; change_cursor -- Change the cursors look
   392                              <1> ; IN: CH = 0x00/0x06
   393                              <1> 
   394                              <1> change_cursor:
   395 000011EB 60                  <1> 	pusha
   396                              <1> 
   397 000011EC B401                <1> 	mov ah, 0x01
   398 000011EE B107                <1> 	mov cl, 0x07
   399 000011F0 CD10                <1> 	int 10h
   400                              <1> 
   401 000011F2 61                  <1> 	popa
   402 000011F3 C3                  <1> 	ret
   403                              <1> 
   404                              <1> ; ------------------------------------------------------------------
   405                              <1> ; hide_cursor -- Turns off cursor in text mode
   406                              <1> ; IN/OUT: Nothing
   407                              <1> 
   408                              <1> hide_cursor:
   409 000011F4 60                  <1> 	pusha
   410                              <1> 
   411 000011F5 B520                <1> 	mov ch, 32
   412 000011F7 B401                <1> 	mov ah, 1
   413 000011F9 B003                <1> 	mov al, 3
   414 000011FB CD10                <1> 	int 10h
   415                              <1> 
   416 000011FD 61                  <1> 	popa
   417 000011FE C3                  <1> 	ret
   418                              <1> 
   419                              <1> ; ------------------------------------------------------------------
   420                              <1> ; move_cursor -- Moves cursor in text mode
   421                              <1> ; IN: DH, DL = row, column
   422                              <1> 
   423                              <1> move_cursor:
   424 000011FF 60                  <1> 	pusha
   425                              <1> 
   426 00001200 B700                <1> 	mov bh, 0
   427 00001202 B402                <1> 	mov ah, 2
   428 00001204 CD10                <1> 	int 0x10
   429                              <1> 
   430 00001206 61                  <1> 	popa
   431 00001207 C3                  <1> 	ret
   432                              <1> 
   433                              <1> ; ------------------------------------------------------------------
   434                              <1> ; get_cursor_pos -- Return position of text cursor
   435                              <1> ; OUT: DH, DL = row, column
   436                              <1> 
   437                              <1> get_cursor_pos:
   438 00001208 60                  <1> 	pusha
   439                              <1> 
   440 00001209 B700                <1> 	mov bh, 0
   441 0000120B B403                <1> 	mov ah, 3
   442 0000120D CD10                <1> 	int 0x10
   443                              <1> 
   444 0000120F 8916[1912]          <1> 	mov [.tmp], dx
   445 00001213 61                  <1> 	popa
   446 00001214 8B16[1912]          <1> 	mov dx, [.tmp]
   447 00001218 C3                  <1> 	ret
   448                              <1> 
   449 00001219 0000                <1> 	.tmp dw 0
   450                              <1> 
   451                              <1> ; ------------------------------------------------------------------
   452                              <1> ; print_horiz_line -- Draw a horizontal line on the screen
   453                              <1> ; IN: AX = line type (1 for double (=), otherwise single (-))
   454                              <1> 
   455                              <1> print_horiz_line:
   456 0000121B 60                  <1> 	pusha
   457                              <1> 
   458 0000121C 89C1                <1> 	mov cx, ax
   459 0000121E B0C4                <1> 	mov al, 196
   460                              <1> 
   461 00001220 83F901              <1> 	cmp cx, 1
   462 00001223 7502                <1> 	jne .ready
   463 00001225 B0CD                <1> 	mov al, 205
   464                              <1> 
   465                              <1> 	.ready:
   466 00001227 B90000              <1> 		mov cx, 0
   467 0000122A B40E                <1> 		mov ah, 0Eh
   468                              <1> 
   469                              <1> 	.restart:
   470 0000122C CD10                <1> 		int 0x10
   471 0000122E 41                  <1> 		inc cx
   472 0000122F 83F950              <1> 		cmp cx, 80
   473 00001232 7402                <1> 		je .done
   474 00001234 EBF6                <1> 		jmp .restart
   475                              <1> 
   476                              <1> 	.done:
   477 00001236 61                  <1> 		popa
   478 00001237 C3                  <1> 		ret
   479                              <1> 
   480                              <1> ; ------------------------------------------------------------------
   481                              <1> ; input_dialog -- Get text string from user via a dialog box
   482                              <1> ; IN: AX = string location, BX = message to show
   483                              <1> ; OUT: AX = string location
   484                              <1> 
   485                              <1> input_dialog:
   486 00001238 60                  <1> 	pusha
   487                              <1> 
   488 00001239 50                  <1> 	push ax
   489 0000123A 53                  <1> 	push bx
   490                              <1> 
   491                              <1> 
   492 0000123B B60A                <1> 	mov dh, 10
   493 0000123D B20C                <1> 	mov dl, 12
   494                              <1> 
   495                              <1> .redbox:
   496 0000123F E8BDFF              <1> 	call move_cursor
   497                              <1> 
   498 00001242 60                  <1> 	pusha
   499 00001243 B409                <1> 	mov ah, 09h
   500 00001245 B700                <1> 	mov bh, 0
   501 00001247 B93700              <1> 	mov cx, 55
   502 0000124A B31F                <1> 	mov bl, 0x1F
   503 0000124C B020                <1> 	mov al, ' '
   504 0000124E CD10                <1> 	int 0x10
   505 00001250 61                  <1> 	popa
   506                              <1> 
   507 00001251 FEC6                <1> 	inc dh
   508 00001253 80FE10              <1> 	cmp dh, 16
   509 00001256 7402                <1> 	je .boxdone
   510 00001258 EBE5                <1> 	jmp .redbox
   511                              <1> 
   512                              <1> 
   513                              <1> .boxdone:
   514 0000125A B20E                <1> 	mov dl, 14
   515 0000125C B60B                <1> 	mov dh, 11
   516 0000125E E89EFF              <1> 	call move_cursor
   517                              <1> 
   518                              <1> 
   519 00001261 5B                  <1> 	pop bx
   520 00001262 89DE                <1> 	mov si, bx
   521 00001264 E8EF08              <1> 	call print
   522                              <1> 
   523 00001267 B20E                <1> 	mov dl, 14
   524 00001269 B60D                <1> 	mov dh, 13
   525 0000126B E891FF              <1> 	call move_cursor
   526                              <1> 
   527                              <1> 
   528 0000126E 58                  <1> 	pop ax
   529 0000126F BB3200              <1> 	mov bx, 50
   530 00001272 E89B01              <1> 	call input_string
   531                              <1> 
   532 00001275 61                  <1> 	popa
   533 00001276 C3                  <1> 	ret
   534                              <1> 
   535                              <1> ; ------------------------------------------------------------------
   536                              <1> ; draw_block -- Render block of specified colour
   537                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   538                              <1> 
   539                              <1> draw_block:
   540 00001277 60                  <1> 	pusha
   541                              <1> 
   542                              <1> .more:
   543 00001278 E884FF              <1> 	call move_cursor		; Move to block starting position
   544                              <1> 
   545 0000127B B409                <1> 	mov ah, 09h			; Draw colour section
   546 0000127D B700                <1> 	mov bh, 0
   547 0000127F 89F1                <1> 	mov cx, si
   548 00001281 B020                <1> 	mov al, ' '
   549 00001283 CD10                <1> 	int 10h
   550                              <1> 
   551 00001285 FEC6                <1> 	inc dh				; Get ready for next line
   552                              <1> 
   553 00001287 B80000              <1> 	mov ax, 0
   554 0000128A 88F0                <1> 	mov al, dh			; Get current Y position into DL
   555 0000128C 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
   556 0000128E 75E8                <1> 	jne .more			; If not, keep drawing
   557                              <1> 
   558 00001290 61                  <1> 	popa
   559 00001291 C3                  <1> 	ret
   560                              <1> 
   561                              <1> ; ------------------------------------------------------------------
   562                              <1> ; dialog_box -- Print dialog box in middle of screen, with button(s)
   563                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display)
   564                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
   565                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   566                              <1> ; NOTE: Each string is limited to 40 characters
   567                              <1> 
   568                              <1> dialog_box:
   569 00001292 60                  <1> 	pusha
   570                              <1> 
   571 00001293 8916[0E14]          <1> 	mov [.tmp], dx
   572                              <1> 
   573 00001297 E85AFF              <1> 	call hide_cursor
   574                              <1> 
   575 0000129A B609                <1> 	mov dh, 9			; First, draw blue background box
   576 0000129C B213                <1> 	mov dl, 19
   577                              <1> 
   578                              <1> .redbox:				; Loop to draw all lines of box
   579 0000129E E85EFF              <1> 	call move_cursor
   580                              <1> 
   581 000012A1 60                  <1> 	pusha
   582 000012A2 B409                <1> 	mov ah, 0x09
   583 000012A4 B700                <1> 	mov bh, 0
   584 000012A6 B92A00              <1> 	mov cx, 42
   585 000012A9 B31F                <1> 	mov bl, 0x1F		; White on blue
   586 000012AB B020                <1> 	mov al, ' '
   587 000012AD CD10                <1> 	int 10h
   588 000012AF 61                  <1> 	popa
   589                              <1> 
   590 000012B0 FEC6                <1> 	inc dh
   591 000012B2 80FE10              <1> 	cmp dh, 16
   592 000012B5 7402                <1> 	je .boxdone
   593 000012B7 EBE5                <1> 	jmp .redbox
   594                              <1> 
   595                              <1> 
   596                              <1> .boxdone:
   597 000012B9 83F800              <1> 	cmp ax, 0			; Skip string params if zero
   598 000012BC 740C                <1> 	je .no_first_string
   599 000012BE B214                <1> 	mov dl, 20
   600 000012C0 B60A                <1> 	mov dh, 10
   601 000012C2 E83AFF              <1> 	call move_cursor
   602                              <1> 
   603 000012C5 89C6                <1> 	mov si, ax			; First string
   604 000012C7 E88C08              <1> 	call print
   605                              <1> 
   606                              <1> .no_first_string:
   607 000012CA 83FB00              <1> 	cmp bx, 0
   608 000012CD 740C                <1> 	je .no_second_string
   609 000012CF B214                <1> 	mov dl, 20
   610 000012D1 B60B                <1> 	mov dh, 11
   611 000012D3 E829FF              <1> 	call move_cursor
   612                              <1> 
   613 000012D6 89DE                <1> 	mov si, bx			; Second string
   614 000012D8 E87B08              <1> 	call print
   615                              <1> 
   616                              <1> .no_second_string:
   617 000012DB 83F900              <1> 	cmp cx, 0
   618 000012DE 740C                <1> 	je .no_third_string
   619 000012E0 B214                <1> 	mov dl, 20
   620 000012E2 B60C                <1> 	mov dh, 12
   621 000012E4 E818FF              <1> 	call move_cursor
   622                              <1> 
   623 000012E7 89CE                <1> 	mov si, cx			; Third string
   624 000012E9 E86A08              <1> 	call print
   625                              <1> 
   626                              <1> .no_third_string:
   627 000012EC 8B16[0E14]          <1> 	mov dx, [.tmp]
   628 000012F0 83FA00              <1> 	cmp dx, 0
   629 000012F3 7405                <1> 	je .one_button
   630 000012F5 83FA01              <1> 	cmp dx, 1
   631 000012F8 741E                <1> 	je .two_button
   632                              <1> 
   633                              <1> 
   634                              <1> .one_button:
   635 000012FA B3F0                <1> 	mov bl, 11110000b		; Black on white
   636 000012FC B60E                <1> 	mov dh, 14
   637 000012FE B223                <1> 	mov dl, 35
   638 00001300 BE0800              <1> 	mov si, 8
   639 00001303 BF0F00              <1> 	mov di, 15
   640 00001306 E86EFF              <1> 	call draw_block
   641                              <1> 
   642 00001309 B226                <1> 	mov dl, 38			; OK button, centred at bottom of box
   643 0000130B B60E                <1> 	mov dh, 14
   644 0000130D E8EFFE              <1> 	call move_cursor
   645 00001310 BE[EE13]            <1> 	mov si, .ok_button_string
   646 00001313 E84008              <1> 	call print
   647                              <1> 
   648 00001316 EB2E                <1> 	jmp .one_button_wait
   649                              <1> 
   650                              <1> 
   651                              <1> .two_button:
   652 00001318 B3F0                <1> 	mov bl, 11110000b		; Black on white
   653 0000131A B60E                <1> 	mov dh, 14
   654 0000131C B21B                <1> 	mov dl, 27
   655 0000131E BE0800              <1> 	mov si, 8
   656 00001321 BF0F00              <1> 	mov di, 15
   657 00001324 E850FF              <1> 	call draw_block
   658                              <1> 
   659 00001327 B21E                <1> 	mov dl, 30			; OK button
   660 00001329 B60E                <1> 	mov dh, 14
   661 0000132B E8D1FE              <1> 	call move_cursor
   662 0000132E BE[EE13]            <1> 	mov si, .ok_button_string
   663 00001331 E82208              <1> 	call print
   664                              <1> 
   665 00001334 B22C                <1> 	mov dl, 44			; Cancel button
   666 00001336 B60E                <1> 	mov dh, 14
   667 00001338 E8C4FE              <1> 	call move_cursor
   668 0000133B BE[F113]            <1> 	mov si, .cancel_button_string
   669 0000133E E81508              <1> 	call print
   670                              <1> 
   671 00001341 B90000              <1> 	mov cx, 0			; Default button = 0
   672 00001344 EB0D                <1> 	jmp .two_button_wait
   673                              <1> 
   674                              <1> 
   675                              <1> 
   676                              <1> .one_button_wait:
   677 00001346 B400                <1> 	mov ah, 0x00
   678 00001348 CD16                <1> 	int 0x16
   679                              <1> 
   680 0000134A 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
   681 0000134C 75F8                <1> 	jne .one_button_wait
   682                              <1> 
   683 0000134E E88DFE              <1> 	call show_cursor
   684                              <1> 
   685 00001351 61                  <1> 	popa
   686 00001352 C3                  <1> 	ret
   687                              <1> 
   688                              <1> 
   689                              <1> .two_button_wait:
   690 00001353 B400                <1> 	mov ah, 0x00
   691 00001355 CD16                <1> 	int 0x16
   692                              <1> 	
   693 00001357 80FC4B              <1> 	cmp ah, 0x4B			; Left cursor key pressed?
   694 0000135A 753D                <1> 	jne .noleft
   695                              <1> 
   696 0000135C B3F0                <1> 	mov bl, 11110000b		; Black on white
   697 0000135E B60E                <1> 	mov dh, 14
   698 00001360 B21B                <1> 	mov dl, 27
   699 00001362 BE0800              <1> 	mov si, 8
   700 00001365 BF0F00              <1> 	mov di, 15
   701 00001368 E80CFF              <1> 	call draw_block
   702                              <1> 
   703 0000136B B21E                <1> 	mov dl, 30				; OK button
   704 0000136D B60E                <1> 	mov dh, 14
   705 0000136F E88DFE              <1> 	call move_cursor
   706 00001372 BE[EE13]            <1> 	mov si, .ok_button_string
   707 00001375 E8DE07              <1> 	call print
   708                              <1> 
   709 00001378 B31F                <1> 	mov bl, 0x1F		; White on blue for cancel button
   710 0000137A B60E                <1> 	mov dh, 14
   711 0000137C B22A                <1> 	mov dl, 42
   712 0000137E BE0900              <1> 	mov si, 9
   713 00001381 BF0F00              <1> 	mov di, 15
   714 00001384 E8F0FE              <1> 	call draw_block
   715                              <1> 
   716 00001387 B22C                <1> 	mov dl, 44				; Cancel button
   717 00001389 B60E                <1> 	mov dh, 14
   718 0000138B E871FE              <1> 	call move_cursor
   719 0000138E BE[F113]            <1> 	mov si, .cancel_button_string
   720 00001391 E8C207              <1> 	call print
   721                              <1> 
   722 00001394 B90000              <1> 	mov cx, 0				; And update result we'll return
   723 00001397 EBBA                <1> 	jmp .two_button_wait
   724                              <1> 
   725                              <1> 
   726                              <1> .noleft:
   727 00001399 80FC4D              <1> 	cmp ah, 0x4D			; Right cursor key pressed?
   728 0000139C 753E                <1> 	jne .noright
   729                              <1> 
   730                              <1> 
   731 0000139E B31F                <1> 	mov bl, 0x1F		; Black on white
   732 000013A0 B60E                <1> 	mov dh, 14
   733 000013A2 B21B                <1> 	mov dl, 27
   734 000013A4 BE0800              <1> 	mov si, 8
   735 000013A7 BF0F00              <1> 	mov di, 15
   736 000013AA E8CAFE              <1> 	call draw_block
   737                              <1> 
   738 000013AD B21E                <1> 	mov dl, 30				; OK button
   739 000013AF B60E                <1> 	mov dh, 14
   740 000013B1 E84BFE              <1> 	call move_cursor
   741 000013B4 BE[EE13]            <1> 	mov si, .ok_button_string
   742 000013B7 E89C07              <1> 	call print
   743                              <1> 
   744 000013BA B3F0                <1> 	mov bl, 11110000b		; White on blue for cancel button
   745 000013BC B60E                <1> 	mov dh, 14
   746 000013BE B22B                <1> 	mov dl, 43
   747 000013C0 BE0800              <1> 	mov si, 8
   748 000013C3 BF0F00              <1> 	mov di, 15
   749 000013C6 E8AEFE              <1> 	call draw_block
   750                              <1> 
   751 000013C9 B22C                <1> 	mov dl, 44				; Cancel button
   752 000013CB B60E                <1> 	mov dh, 14
   753 000013CD E82FFE              <1> 	call move_cursor
   754 000013D0 BE[F113]            <1> 	mov si, .cancel_button_string
   755 000013D3 E88007              <1> 	call print
   756                              <1> 
   757 000013D6 B90100              <1> 	mov cx, 1				; And update result we'll return
   758 000013D9 E977FF              <1> 	jmp .two_button_wait
   759                              <1> 
   760                              <1> 
   761                              <1> .noright:
   762 000013DC 3C0D                <1> 	cmp al, 13				; Wait for enter key (13) to be pressed
   763 000013DE 0F8571FF            <1> 	jne .two_button_wait
   764                              <1> 
   765 000013E2 E8F9FD              <1> 	call show_cursor
   766                              <1> 
   767 000013E5 890E[0E14]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
   768 000013E9 61                  <1> 	popa
   769 000013EA A1[0E14]            <1> 	mov ax, [.tmp]
   770                              <1> 
   771 000013ED C3                  <1> 	ret
   772                              <1> 
   773                              <1> 
   774 000013EE 4F4B00              <1> 	.ok_button_string	db 'OK', 0
   775 000013F1 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
   776 000013F8 2020204F4B20202000  <1> 	.ok_button_noselect	db '   OK   ', 0
   777 00001401 20202043616E63656C- <1> 	.cancel_button_noselect	db '   Cancel   ', 0
   777 0000140A 20202000            <1>
   778                              <1> 
   779 0000140E 0000                <1> 	.tmp dw 0
   780                              <1> 
   781                              <1> ; ------------------------------------------------------------------
   782                              <1> ; input_string --- Get a string from keyboard input
   783                              <1> ; IN: AX = output address, BX = maximum bytes of output string
   784                              <1> ; OUT: nothing
   785                              <1> 
   786                              <1> input_string:
   787 00001410 60                  <1> 	pusha
   788                              <1> 
   789                              <1> 	; If the character count is zero, don't do anything.
   790 00001411 83FB00              <1> 	cmp bx, 0
   791 00001414 7424                <1> 	je .done
   792                              <1> 
   793 00001416 89C7                <1> 	mov di, ax			; DI = Current position in buffer
   794                              <1> 	
   795 00001418 4B                  <1> 	dec bx				; BX = Maximum characters in string
   796 00001419 89D9                <1> 	mov cx, bx			; CX = Remaining character count
   797                              <1> 
   798                              <1> .get_char:
   799 0000141B B400                <1> 	mov ah, 0x00
   800 0000141D CD16                <1> 	int 0x16
   801                              <1> 
   802 0000141F 3C08                <1> 	cmp al, 8
   803 00001421 7419                <1> 	je .backspace
   804                              <1> 
   805 00001423 3C0D                <1> 	cmp al, 13			; The ENTER key ends the prompt
   806 00001425 7410                <1> 	je .end_string
   807                              <1> 
   808                              <1> 	; Do not add any characters if the maximum size has been reached.
   809 00001427 E3F2                <1> 	jcxz .get_char
   810                              <1> 
   811                              <1> 	; Only add printable characters (ASCII Values 32-126)
   812 00001429 3C20                <1> 	cmp al, ' '
   813 0000142B 72EE                <1> 	jb .get_char
   814                              <1> 
   815 0000142D 3C7E                <1> 	cmp al, 126
   816 0000142F 77EA                <1> 	ja .get_char
   817                              <1> 
   818 00001431 E83100              <1> 	call .add_char
   819                              <1> 
   820 00001434 49                  <1> 	dec cx
   821 00001435 EBE4                <1> 	jmp .get_char
   822                              <1> 
   823                              <1> .end_string:
   824 00001437 B000                <1> 	mov al, 0
   825 00001439 AA                  <1> 	stosb
   826                              <1> 
   827                              <1> .done:
   828 0000143A 61                  <1> 	popa
   829 0000143B C3                  <1> 	ret
   830                              <1> 
   831                              <1> .backspace:
   832                              <1> 	; Check if there are any characters to backspace
   833 0000143C 39D9                <1> 	cmp cx, bx 
   834 0000143E 73DB                <1> 	jae .get_char
   835                              <1> 
   836 00001440 41                  <1> 	inc cx				; Increase characters remaining
   837                              <1> 
   838 00001441 E80A00              <1> 	call .reverse_cursor		; Move back to the previous character
   839 00001444 B020                <1> 	mov al, ' '			; Print a space on the character
   840 00001446 E81C00              <1> 	call .add_char
   841 00001449 E80200              <1> 	call .reverse_cursor		; Now move the cursor back again
   842                              <1> 
   843 0000144C EBCD                <1> 	jmp .get_char
   844                              <1> 
   845                              <1> .reverse_cursor:
   846 0000144E 4F                  <1> 	dec di				; Move the output pointer backwards
   847                              <1> 	
   848 0000144F E8B6FD              <1> 	call get_cursor_pos
   849 00001452 80FA00              <1> 	cmp dl, 0			; Is the cursor at the start of line?
   850 00001455 7406                <1> 	je .back_line
   851                              <1> 
   852 00001457 FECA                <1> 	dec dl				; If not, just decrease the column
   853 00001459 E8A3FD              <1> 	call move_cursor
   854 0000145C C3                  <1> 	ret
   855                              <1> 
   856                              <1> .back_line:
   857 0000145D FECE                <1> 	dec dh				; Otherwise, move the cursor to the end
   858 0000145F B24F                <1> 	mov dl, 79			; of the previous line.
   859 00001461 E89BFD              <1> 	call move_cursor
   860 00001464 C3                  <1> 	ret
   861                              <1> 
   862                              <1> 
   863                              <1> .add_char:
   864 00001465 AA                  <1> 	stosb
   865 00001466 B40E                <1> 	mov ah, 0x0E			; Teletype Function
   866 00001468 B700                <1> 	mov bh, 0			; Video Page 0
   867 0000146A 55                  <1> 	push bp				; Some BIOS's may mess up BP
   868 0000146B CD10                <1> 	int 0x10
   869 0000146D 5D                  <1> 	pop bp
   870 0000146E C3                  <1> 	ret
   871                              <1> 
   872                              <1> ; ------------------------------------------------------------------
   873                              <1> ; switch_mode -- Switch between VIDEO and CLI mode
   874                              <1> ; IN: AX = mode (0 for CLI and 1 for video)
   875                              <1> ;	  BH = color scheme (only background for video)
   876                              <1> ; OUT: Switches mode
   877                              <1> 
   878                              <1> switch_mode:
   879 0000146F 60                  <1> 	pusha
   880 00001470 30DB                <1> 	xor bl, bl
   881                              <1> 
   882 00001472 85C0                <1> 	test ax, ax
   883 00001474 7405                <1> 	je .switch_cli
   884                              <1> 
   885 00001476 83F801              <1> 	cmp ax, 1
   886 00001479 740F                <1> 	je .switch_vid
   887                              <1> 
   888                              <1> .switch_cli:
   889                              <1> 	; Switch to text mode
   890 0000147B B80300              <1> 	mov ax, cliRes
   891 0000147E CD10                <1> 	int 0x10
   892                              <1> 
   893                              <1> 	; Change the cursor
   894 00001480 31C9                <1> 	xor cx, cx
   895 00001482 E866FD              <1> 	call change_cursor
   896                              <1> 
   897                              <1> 	; Clear the screen and change color scheme
   898 00001485 E813F9              <1> 	call cls
   899                              <1> 
   900 00001488 EB0A                <1> 	jmp .done
   901                              <1> 
   902                              <1> .switch_vid:
   903                              <1> 	; Switch to video mode
   904 0000148A B81300              <1> 	mov ax, vidRes
   905 0000148D CD10                <1> 	int 0x10
   906                              <1> 
   907                              <1> 	; Clear the screen and change the background color
   908 0000148F E809F9              <1> 	call cls
   909                              <1> 
   910 00001492 EB00                <1> 	jmp .done
   911                              <1> 
   912                              <1> .done:
   913 00001494 61                  <1> 	popa
   914 00001495 C3                  <1> 	ret
   915                              <1> 
   916                              <1> ; ------------------------------------------------------------------
   917                              <1> ; setup_bottom_string -- Draw a string in the bottom of the setup screen
   918                              <1> ; IN: SI = String location
   919                              <1> 
   920                              <1> setup_bottom_string:
   921 00001496 56                  <1> 	push si
   922 00001497 B617                <1>     mov dh, 23
   923 00001499 30D2                <1>     xor dl, dl
   924 0000149B E861FD              <1>     call move_cursor
   925                              <1> 
   926 0000149E B80100              <1>     mov ax, 1
   927 000014A1 E877FD              <1>     call print_horiz_line
   928                              <1> 	
   929 000014A4 5E                  <1> 	pop si
   930 000014A5 E8AE06              <1>     call print
   931                              <1> 
   932 000014A8 31D2                <1>     xor dx, dx
   933 000014AA E852FD              <1>     call move_cursor
   934                              <1> 
   935 000014AD C3                  <1> 	ret
   936                              <1> 
   937                              <1> ; ------------------------------------------------------------------
   938                              <1> ; setup_input -- Get keyboard input for the setup
   939                              <1> ; IN: AX = string location
   940                              <1> ; OUT: AX = string location
   941                              <1> 
   942                              <1> setup_input:
   943 000014AE 60                  <1> 	pusha
   944 000014AF 89C7                <1> 	mov di, ax
   945 000014B1 50                  <1> 	push ax
   946                              <1> 
   947                              <1> 	; Position the mouse
   948 000014B2 B403                <1> 	mov ah, 0x03
   949 000014B4 B700                <1> 	mov bh, 0
   950 000014B6 CD10                <1> 	int 0x10
   951                              <1> 
   952 000014B8 B402                <1> 	mov ah, 0x02
   953 000014BA B21B                <1> 	mov dl, 27
   954 000014BC FEC6                <1> 	inc dh
   955 000014BE CD10                <1> 	int 0x10
   956                              <1> 
   957                              <1> 	; And draw the top/sides
   958 000014C0 BE[6B15]            <1> 	mov si, .top_bar
   959 000014C3 E89006              <1> 	call print
   960                              <1> 
   961 000014C6 B402                <1> 	mov ah, 0x02
   962 000014C8 B21B                <1> 	mov dl, 27
   963 000014CA FEC6                <1> 	inc dh
   964 000014CC CD10                <1> 	int 0x10
   965                              <1> 	
   966 000014CE 8836[A515]          <1> 	mov [.mouse_pos], dh
   967 000014D2 BE[8415]            <1> 	mov si, .sidl_bar
   968 000014D5 E87E06              <1> 	call print
   969                              <1> 	
   970 000014D8 B402                <1> 	mov ah, 0x02
   971 000014DA B21B                <1> 	mov dl, 27
   972 000014DC FEC6                <1> 	inc dh
   973 000014DE CD10                <1> 	int 0x10
   974                              <1> 
   975 000014E0 BE[8B15]            <1> 	mov si, .bot_bar
   976 000014E3 E87006              <1> 	call print
   977                              <1> 
   978 000014E6 B402                <1> 	mov ah, 0x02
   979 000014E8 B21B                <1> 	mov dl, 27
   980 000014EA 8A36[A515]          <1> 	mov dh, [.mouse_pos]
   981 000014EE CD10                <1> 	int 0x10
   982                              <1> 
   983 000014F0 30DB                <1> 	xor bl, bl
   984                              <1> 
   985                              <1> 	; Clear the string location
   986                              <1> .clear_loop:
   987 000014F2 B000                <1> 	mov al, 0
   988 000014F4 AA                  <1> 	stosb
   989 000014F5 FEC3                <1> 	inc bl
   990                              <1> 
   991 000014F7 80FB14              <1> 	cmp bl, 20
   992 000014FA 75F6                <1> 	jne .clear_loop
   993                              <1> 
   994 000014FC B403                <1> 	mov ah, 0x03
   995 000014FE B700                <1> 	mov bh, 0
   996 00001500 CD10                <1> 	int 0x10
   997                              <1> 
   998 00001502 B402                <1> 	mov ah, 0x02
   999 00001504 B21D                <1> 	mov dl, 29
  1000 00001506 CD10                <1> 	int 0x10
  1001                              <1> 
  1002 00001508 58                  <1> 	pop ax
  1003 00001509 89C7                <1> 	mov di, ax
  1004 0000150B 30DB                <1> 	xor bl, bl
  1005                              <1> 
  1006                              <1> .input_loop:
  1007 0000150D B403                <1> 	mov ah, 0x03
  1008 0000150F B700                <1> 	mov bh, 0
  1009 00001511 CD10                <1> 	int 0x10
  1010                              <1> 
  1011 00001513 8816[A515]          <1> 	mov [.mouse_pos], dl
  1012                              <1> 
  1013 00001517 B402                <1> 	mov ah, 0x02
  1014 00001519 B230                <1> 	mov dl, 48
  1015 0000151B CD10                <1> 	int 0x10
  1016                              <1> 
  1017 0000151D BE[8715]            <1> 	mov si, .sidr_bar
  1018 00001520 E83306              <1> 	call print
  1019                              <1> 
  1020 00001523 B402                <1> 	mov ah, 0x02
  1021 00001525 8A16[A515]          <1> 	mov dl, [.mouse_pos]
  1022 00001529 CD10                <1> 	int 0x10
  1023                              <1> 
  1024 0000152B B400                <1> 	mov ah, 0x00
  1025 0000152D CD16                <1> 	int 0x16
  1026                              <1> 
  1027 0000152F 3C0D                <1> 	cmp al, 0x0d
  1028 00001531 7436                <1> 	je .input_done
  1029                              <1> 
  1030 00001533 3C08                <1> 	cmp al, 0x08
  1031 00001535 7524                <1> 	jne .not_back
  1032                              <1> 
  1033                              <1> 	; Pressed backspace
  1034 00001537 B403                <1> 	mov ah, 0x03
  1035 00001539 B700                <1> 	mov bh, 0
  1036 0000153B CD10                <1> 	int 0x10
  1037                              <1> 
  1038 0000153D 80FA1D              <1> 	cmp dl, 29
  1039 00001540 74CB                <1> 	je .input_loop
  1040                              <1> 
  1041 00001542 FECA                <1> 	dec dl
  1042 00001544 FECB                <1> 	dec bl
  1043                              <1> 
  1044 00001546 B402                <1> 	mov ah, 0x02
  1045 00001548 CD10                <1> 	int 0x10
  1046                              <1> 
  1047 0000154A B40E                <1> 	mov ah, 0x0e
  1048 0000154C B000                <1> 	mov al, 0
  1049 0000154E CD10                <1> 	int 0x10
  1050                              <1> 	
  1051 00001550 B402                <1> 	mov ah, 0x02
  1052 00001552 CD10                <1> 	int 0x10
  1053                              <1> 
  1054 00001554 4F                  <1> 	dec di
  1055 00001555 B000                <1> 	mov al, 0
  1056 00001557 AA                  <1> 	stosb
  1057 00001558 4F                  <1> 	dec di
  1058                              <1> 
  1059 00001559 EBB2                <1> 	jmp .input_loop
  1060                              <1> 
  1061                              <1> .not_back:
  1062 0000155B 80FB13              <1> 	cmp bl, 19
  1063 0000155E 74AD                <1> 	je .input_loop
  1064 00001560 FEC3                <1> 	inc bl
  1065                              <1> 
  1066 00001562 AA                  <1> 	stosb
  1067                              <1> 
  1068 00001563 B40E                <1> 	mov ah, 0x0e
  1069 00001565 CD10                <1> 	int 0x10
  1070                              <1> 
  1071 00001567 EBA4                <1> 	jmp .input_loop 
  1072                              <1> 
  1073                              <1> .input_done:
  1074 00001569 61                  <1> 	popa
  1075 0000156A C3                  <1> 	ret
  1076                              <1> 
  1077 0000156B DA                  <1> .top_bar:	db 0xda
  1078 0000156C C4<rep 15h>         <1> 			times 21 db 0xc4
  1079 00001581 BF0A00              <1> 			db 0xbf, 0x0a, 0
  1080 00001584 B32000              <1> .sidl_bar:	db 0xb3, 0x20, 0
  1081 00001587 20B30A00            <1> .sidr_bar:	db 0x20, 0xb3, 0x0a, 0
  1082 0000158B C0                  <1> .bot_bar:	db 0xc0
  1083 0000158C C4<rep 15h>         <1> 			times 21 db 0xc4
  1084 000015A1 D90A0D00            <1> 			db 0xd9, 0x0a, 0x0d, 0
  1085                              <1> 
  1086 000015A5 1D                  <1> .mouse_pos:	db 29
  1087                              <1> 
  1088                              <1> ; ------------------------------------------------------------------
  1089                              <1> ; setup_choose -- Draw text and use the cursors to choose between them
  1090                              <1> ; IN: AX, BX, CX = options
  1091                              <1> ;	  DH = not focused color
  1092                              <1> ;	  DL = focused color
  1093                              <1> ; OUT: AX = options choosen (starting at 0)
  1094                              <1> 
  1095                              <1> setup_choose:
  1096 000015A6 E84BFC              <1> 	call hide_cursor
  1097 000015A9 60                  <1> 	pusha
  1098 000015AA 52                  <1> 	push dx
  1099                              <1> 
  1100 000015AB 8A16[DE16]          <1> 	mov dl, [.start_x]
  1101 000015AF 8A36[DF16]          <1> 	mov dh, [.start_y]
  1102 000015B3 E849FC              <1> 	call move_cursor
  1103 000015B6 5A                  <1> 	pop dx
  1104                              <1> 	
  1105 000015B7 89C6                <1> 	mov si, ax
  1106 000015B9 BF[E016]            <1> 	mov di, .option1
  1107 000015BC E87BF8              <1> 	call string_copy
  1108                              <1> 	
  1109 000015BF 89DE                <1> 	mov si, bx
  1110 000015C1 BF[0817]            <1> 	mov di, .option2
  1111 000015C4 E873F8              <1> 	call string_copy
  1112                              <1> 
  1113 000015C7 89CE                <1> 	mov si, cx
  1114 000015C9 BF[3017]            <1> 	mov di, .option3
  1115 000015CC E86BF8              <1> 	call string_copy
  1116                              <1> 
  1117 000015CF 31C9                <1> 	xor cx, cx
  1118 000015D1 EB03                <1> 	jmp .choose_loop
  1119                              <1> 
  1120 000015D3 E9F700              <1> 	jmp .done
  1121                              <1> 
  1122                              <1> .choose_loop:
  1123 000015D6 E84100              <1> 	call .print_options
  1124 000015D9 E80B00              <1> 	call .check_arrows
  1125 000015DC E8C800              <1> 	call .clear_bottom
  1126                              <1> 
  1127 000015DF 83F803              <1> 	cmp ax, 3
  1128 000015E2 75F2                <1> 	jne .choose_loop
  1129 000015E4 E9E600              <1> 	jmp .done
  1130                              <1> 
  1131                              <1> .check_arrows:
  1132 000015E7 60                  <1> 	pusha
  1133 000015E8 BE[860D]            <1>     mov si, setup_string
  1134 000015EB E8A8FE              <1>     call setup_bottom_string
  1135 000015EE 61                  <1> 	popa
  1136                              <1> 
  1137 000015EF 31C0                <1> 	xor ax, ax
  1138 000015F1 CD16                <1> 	int 0x16
  1139                              <1> 
  1140 000015F3 80FC48              <1> 	cmp ah, 0x48	; UP
  1141 000015F6 740A                <1> 	je .up
  1142 000015F8 80FC50              <1> 	cmp ah, 0x50	; DOWN
  1143 000015FB 740F                <1> 	je .down
  1144                              <1> 
  1145 000015FD 3C0D                <1> 	cmp al, 0x0D	; ENTER
  1146 000015FF 7415                <1> 	je .enter
  1147                              <1> 
  1148 00001601 C3                  <1> 	ret				; Failsafe return
  1149                              <1> 
  1150                              <1> 	.up:
  1151 00001602 85C9                <1> 		test cx, cx
  1152 00001604 7402                <1> 		jz .at_top
  1153                              <1> 
  1154 00001606 49                  <1> 		dec cx
  1155 00001607 C3                  <1> 		ret
  1156                              <1> 	
  1157                              <1> 		.at_top:
  1158 00001608 B90200              <1> 			mov cx, 2
  1159 0000160B C3                  <1> 			ret
  1160                              <1> 	
  1161                              <1> 	.down:
  1162 0000160C 83F902              <1> 		cmp cx, 2
  1163 0000160F 7402                <1> 		je .at_bottom
  1164                              <1> 
  1165 00001611 41                  <1> 		inc cx
  1166 00001612 C3                  <1> 		ret
  1167                              <1> 
  1168                              <1> 		.at_bottom:
  1169 00001613 31C9                <1> 			xor cx, cx
  1170 00001615 C3                  <1> 			ret
  1171                              <1> 
  1172                              <1> 	.enter:
  1173 00001616 B80300              <1> 		mov ax, 3
  1174 00001619 C3                  <1> 		ret
  1175                              <1> 
  1176                              <1> .print_options:
  1177 0000161A 83F900              <1> 	cmp cx, 0
  1178 0000161D 740A                <1> 	je .mark_1
  1179                              <1> 
  1180 0000161F 83F901              <1> 	cmp cx, 1
  1181 00001622 7419                <1> 	je .mark_2
  1182                              <1> 
  1183 00001624 83F902              <1> 	cmp cx, 2
  1184 00001627 7428                <1> 	je .mark_3
  1185                              <1> 
  1186                              <1> 	.mark_1:
  1187 00001629 BE[E016]            <1> 		mov si, .option1
  1188 0000162C E83F00              <1> 		call .print_marked
  1189                              <1> 
  1190 0000162F BE[0817]            <1> 		mov si, .option2
  1191 00001632 E82F00              <1> 		call .print_normal
  1192                              <1> 
  1193 00001635 BE[3017]            <1> 		mov si, .option3
  1194 00001638 E82900              <1> 		call .print_normal
  1195                              <1> 
  1196 0000163B EB26                <1> 		jmp .mark_done
  1197                              <1> 	
  1198                              <1> 	.mark_2:
  1199 0000163D BE[E016]            <1> 		mov si, .option1
  1200 00001640 E82100              <1> 		call .print_normal
  1201                              <1> 
  1202 00001643 BE[0817]            <1> 		mov si, .option2
  1203 00001646 E82500              <1> 		call .print_marked
  1204                              <1> 
  1205 00001649 BE[3017]            <1> 		mov si, .option3
  1206 0000164C E81500              <1> 		call .print_normal
  1207                              <1> 
  1208 0000164F EB12                <1> 		jmp .mark_done
  1209                              <1> 	
  1210                              <1> 	.mark_3:
  1211 00001651 BE[E016]            <1> 		mov si, .option1
  1212 00001654 E80D00              <1> 		call .print_normal
  1213                              <1> 
  1214 00001657 BE[0817]            <1> 		mov si, .option2
  1215 0000165A E80700              <1> 		call .print_normal
  1216                              <1> 
  1217 0000165D BE[3017]            <1> 		mov si, .option3
  1218 00001660 E80B00              <1> 		call .print_marked
  1219                              <1> 
  1220                              <1> 	.mark_done:
  1221 00001663 C3                  <1> 		ret
  1222                              <1> 
  1223                              <1> .print_normal:
  1224 00001664 E81700              <1> 	call .print_space
  1225 00001667 E8EC04              <1> 	call print
  1226 0000166A E82D00              <1> 	call .new_line
  1227                              <1> 
  1228 0000166D C3                  <1> 	ret
  1229                              <1> 
  1230                              <1> .print_marked:
  1231 0000166E 53                  <1> 	push bx
  1232                              <1> 
  1233 0000166F E80C00              <1> 	call .print_space
  1234 00001672 31DB                <1> 	xor bx, bx
  1235 00001674 88D3                <1> 	mov bl, dl
  1236 00001676 E81605              <1> 	call print_atr
  1237 00001679 E81E00              <1> 	call .new_line
  1238                              <1> 
  1239 0000167C 5B                  <1> 	pop bx
  1240 0000167D C3                  <1> 	ret
  1241                              <1> 
  1242                              <1> .print_space:
  1243 0000167E 53                  <1> 	push bx
  1244                              <1> 
  1245 0000167F 31DB                <1> 	xor bx, bx
  1246 00001681 BB2800              <1> 	mov bx, .screen_mid
  1247                              <1> 	
  1248 00001684 89F0                <1> 	mov ax, si
  1249 00001686 E828F7              <1> 	call string_length
  1250 00001689 D1F8                <1> 	sar ax, 1
  1251                              <1> 
  1252 0000168B 29C3                <1> 	sub bx, ax
  1253                              <1> 
  1254                              <1> 	.space_loop:
  1255 0000168D B40E                <1> 		mov ah, 0x0e
  1256 0000168F B020                <1> 		mov al, ' '
  1257 00001691 CD10                <1> 		int 0x10
  1258                              <1> 
  1259 00001693 4B                  <1> 		dec bx
  1260 00001694 85DB                <1> 		test bx, bx
  1261 00001696 75F5                <1> 		jnz .space_loop
  1262                              <1> 
  1263 00001698 5B                  <1> 	pop bx
  1264 00001699 C3                  <1> 	ret
  1265                              <1> 
  1266                              <1> .new_line:
  1267 0000169A 50                  <1> 	push ax
  1268                              <1> 
  1269 0000169B B80A0E              <1> 	mov ax, 0x0E0A
  1270 0000169E CD10                <1> 	int 0x10
  1271 000016A0 B80D0E              <1> 	mov ax, 0x0E0D
  1272 000016A3 CD10                <1> 	int 0x10
  1273                              <1> 
  1274 000016A5 58                  <1> 	pop ax
  1275 000016A6 C3                  <1> 	ret
  1276                              <1> 
  1277                              <1> .clear_bottom:
  1278 000016A7 60                  <1> 	pusha
  1279                              <1> 
  1280 000016A8 8A36[DF16]          <1> 	mov dh, [.start_y]
  1281 000016AC 8A16[DE16]          <1> 	mov dl, [.start_x]
  1282 000016B0 E84CFB              <1> 	call move_cursor
  1283                              <1> 
  1284 000016B3 B80A07              <1> 	mov ax, 0x070A
  1285 000016B6 B71F                <1> 	mov bh, 0x1F
  1286 000016B8 31C9                <1> 	xor cx, cx
  1287 000016BA BA4F18              <1> 	mov dx, 0x184f
  1288 000016BD CD10                <1> 	int 0x10
  1289                              <1> 	
  1290 000016BF B80A06              <1> 	mov ax, 0x060A
  1291 000016C2 B71F                <1> 	mov bh, 0x1F
  1292 000016C4 31C9                <1> 	xor cx, cx
  1293 000016C6 BA4F18              <1> 	mov dx, 0x184f
  1294 000016C9 CD10                <1> 	int 0x10
  1295                              <1> 
  1296 000016CB 61                  <1> 	popa
  1297 000016CC C3                  <1> 	ret
  1298                              <1> 
  1299                              <1> .done:
  1300 000016CD E8D7FF              <1> 	call .clear_bottom
  1301 000016D0 890E[5817]          <1> 	mov [.option_picked], cx
  1302                              <1> 
  1303 000016D4 61                  <1> 	popa
  1304 000016D5 E806FB              <1> 	call show_cursor
  1305                              <1> 
  1306 000016D8 0FB606[5817]        <1> 	movzx ax, [.option_picked]
  1307 000016DD C3                  <1> 	ret
  1308                              <1> 
  1309                              <1> .screen_mid		equ 40
  1310 000016DE 00                  <1> .start_x:		db 0
  1311 000016DF 12                  <1> .start_y:		db 18
  1312                              <1> 
  1313 000016E0 00<rep 28h>         <1> .option1:		times 40 db 0
  1314 00001708 00<rep 28h>         <1> .option2:		times 40 db 0
  1315 00001730 00<rep 28h>         <1> .option3:		times 40 db 0
  1316                              <1> 
  1317 00001758 00                  <1> .option_picked:	db 0
  1318                              <1> 
  1319                              <1> ; ------------------------------------------------------------------
  1320                              <1> ; draw_setup_box -- Draw a text box for the setup
  1321                              <1> ; IN: SI = location of the string
  1322                              <1> ; OUT: prints a box that's meant for the setup
  1323                              <1> 
  1324                              <1> draw_setup_box:
  1325 00001759 60                  <1> 	pusha
  1326 0000175A 30DB                <1> 	xor bl, bl
  1327                              <1> 
  1328 0000175C 31D2                <1> 	xor dx, dx
  1329 0000175E E89EFA              <1> 	call move_cursor
  1330                              <1> 
  1331 00001761 56                  <1> 	push si
  1332 00001762 BE[C517]            <1> 	mov si, .setbox_top
  1333 00001765 E8EE03              <1> 	call print
  1334                              <1> 
  1335 00001768 BE[5018]            <1> 	mov si, .setbox_nwl
  1336 0000176B E8E803              <1> 	call print
  1337                              <1> 
  1338 0000176E 5E                  <1> 	pop si
  1339                              <1> 
  1340                              <1> .print_loop:
  1341 0000176F AC                  <1> 	lodsb
  1342 00001770 84C0                <1> 	test al, al
  1343 00001772 7446                <1> 	je .done
  1344                              <1> 
  1345 00001774 3C0A                <1> 	cmp al, 0x0a
  1346 00001776 740D                <1> 	je .new_line
  1347                              <1> 
  1348 00001778 80FB30              <1> 	cmp bl, 48
  1349 0000177B 7408                <1> 	je .new_line
  1350                              <1> 
  1351 0000177D B40E                <1> 	mov ah, 0x0e
  1352 0000177F CD10                <1> 	int 0x10
  1353                              <1> 	
  1354 00001781 FEC3                <1> 	inc bl
  1355                              <1> 
  1356 00001783 EBEA                <1> 	jmp .print_loop
  1357                              <1> 
  1358                              <1> .new_line:
  1359 00001785 E80A00              <1> 	call .finish_line
  1360                              <1> 
  1361 00001788 56                  <1> 	push si
  1362 00001789 BE[5018]            <1> 	mov si, .setbox_nwl
  1363 0000178C E8C703              <1> 	call print
  1364 0000178F 5E                  <1> 	pop si
  1365                              <1> 
  1366 00001790 EBDD                <1> 	jmp .print_loop
  1367                              <1> 
  1368                              <1> .finish_line:
  1369 00001792 B730                <1> 	mov bh, border_length-2
  1370 00001794 28DF                <1> 	sub bh, bl
  1371                              <1> 
  1372                              <1> .finish_loop:
  1373 00001796 80FF00              <1> 	cmp bh, 0
  1374 00001799 760A                <1> 	jbe .loop_done
  1375                              <1> 
  1376 0000179B B40E                <1> 	mov ah, 0x0e
  1377 0000179D B020                <1> 	mov al, " "
  1378 0000179F CD10                <1> 	int 0x10
  1379 000017A1 FECF                <1> 	dec bh
  1380                              <1> 
  1381 000017A3 EBF1                <1> 	jmp .finish_loop
  1382                              <1> 
  1383                              <1> .loop_done:
  1384 000017A5 56                  <1> 	push si
  1385 000017A6 BE[6118]            <1> 	mov si, .setbox_fnl
  1386 000017A9 E8AA03              <1> 	call print
  1387 000017AC 5E                  <1> 	pop si
  1388 000017AD 31DB                <1> 	xor bx, bx
  1389                              <1> 
  1390 000017AF B80A0E              <1> 	mov ax, 0x0e0a
  1391 000017B2 CD10                <1> 	int 0x10
  1392                              <1> 
  1393 000017B4 B80D0E              <1> 	mov ax, 0x0e0d
  1394 000017B7 CD10                <1> 	int 0x10
  1395                              <1> 	
  1396 000017B9 C3                  <1> 	ret
  1397                              <1> 
  1398                              <1> .done:
  1399 000017BA E8D5FF              <1> 	call .finish_line
  1400                              <1> 
  1401 000017BD BE[0B18]            <1> 	mov si, .setbox_bot
  1402 000017C0 E89303              <1> 	call print
  1403                              <1> 
  1404 000017C3 61                  <1> 	popa
  1405 000017C4 C3                  <1> 	ret
  1406                              <1> 	
  1407                              <1> 
  1408 000017C5 0A                  <1> .setbox_top:	db 0x0a
  1409 000017C6 20<rep Eh>          <1>         		times edge_width db " "
  1410 000017D4 DA                  <1>                 db 0xDA
  1411 000017D5 C4<rep 32h>         <1>                 times border_length db 0xC4
  1412 00001807 BF0A0D00            <1>                 db 0xBF, 0x0a, 0x0d, 0
  1413                              <1> 
  1414 0000180B 20<rep Eh>          <1> .setbox_bot:	times edge_width db " "
  1415 00001819 C0                  <1>                 db 0xC0
  1416 0000181A C4<rep 32h>         <1>                 times border_length db 0xC4
  1417 0000184C D90A0D00            <1>                 db 0xD9, 0x0a, 0x0d, 0
  1418                              <1> 
  1419 00001850 20<rep Eh>          <1> .setbox_nwl:	times edge_width db " "
  1420 0000185E B32000              <1> 				db 0xB3, " ", 0
  1421                              <1> 
  1422 00001861 20B300              <1> .setbox_fnl:	db " ", 0xB3, 0
  1423                              <1> 
  1424                              <1> ; ------------------------------------------------------------------
  1425                              <1> ; draw_box -- Draw a box
  1426                              <1> ; IN: AL = color
  1427                              <1> ;	  BX = end x position
  1428                              <1> ;	  CX = end y position
  1429                              <1> ;	  DH = start x position
  1430                              <1> ;	  DL = start y position
  1431                              <1> ; OUT: Draws box
  1432                              <1> 
  1433                              <1> draw_box:
  1434 00001864 60                  <1> 	pusha
  1435                              <1> 
  1436 00001865 8836[9D18]          <1> 	mov [.startx], dh
  1437 00001869 8816[9F18]          <1> 	mov [.starty], dl
  1438 0000186D 891E[A118]          <1> 	mov [.endx], bx
  1439 00001871 890E[A318]          <1> 	mov [.endy], cx
  1440                              <1> 
  1441 00001875 8B0E[9D18]          <1> 	mov cx, [.startx]
  1442 00001879 8B16[9F18]          <1> 	mov dx, [.starty]
  1443 0000187D B40C                <1> 	mov ah, 0x0C
  1444                              <1> 
  1445                              <1> 	.x_loop:
  1446 0000187F 3B0E[A118]          <1> 		cmp cx, [.endx]
  1447 00001883 7405                <1> 		je .y_loop
  1448                              <1> 
  1449 00001885 CD10                <1> 		int 0x10
  1450                              <1> 
  1451 00001887 41                  <1> 		inc cx
  1452 00001888 EBF5                <1> 		jmp .x_loop
  1453                              <1> 
  1454                              <1> 	.y_loop:
  1455 0000188A CD10                <1> 		int 0x10
  1456                              <1> 
  1457 0000188C 3B16[A318]          <1> 		cmp dx, [.endy]
  1458 00001890 7407                <1> 		je .done
  1459                              <1> 
  1460 00001892 8B0E[9D18]          <1> 		mov cx, [.startx]
  1461 00001896 42                  <1> 		inc dx
  1462 00001897 EBE6                <1> 		jmp .x_loop
  1463                              <1> 	
  1464                              <1> 	.done:
  1465 00001899 61                  <1> 		popa
  1466 0000189A C3                  <1> 		ret
  1467                              <1> 
  1468 0000189B 0000                <1> 	.tmp:    dw 0
  1469 0000189D 0000                <1> 	.startx: dw 0
  1470 0000189F 0000                <1> 	.starty: dw 0
  1471 000018A1 0000                <1> 	.endx:   dw 0
  1472 000018A3 0000                <1> 	.endy:	 dw 0
  1473                              <1> 
  1474                              <1> ; ------------------------------------------------------------------
  1475                              <1> ; list_dialog -- Show a dialog with a list of options
  1476                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1477                              <1> ;     BX = first help string, CX = second help string
  1478                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1479                              <1> 
  1480                              <1> list_dialog:
  1481 000018A5 60                  <1> 	pusha
  1482                              <1> 
  1483 000018A6 50                  <1> 	push ax				; Store string list for now
  1484                              <1> 
  1485 000018A7 51                  <1> 	push cx				; And help strings
  1486 000018A8 53                  <1> 	push bx
  1487                              <1> 
  1488 000018A9 E848F9              <1> 	call hide_cursor
  1489                              <1> 
  1490                              <1> 
  1491 000018AC B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1492 000018AE 89C6                <1> 	mov si, ax
  1493                              <1> .count_loop:
  1494 000018B0 AC                  <1> 	lodsb
  1495 000018B1 3C00                <1> 	cmp al, 0
  1496 000018B3 7408                <1> 	je .done_count
  1497 000018B5 3C2C                <1> 	cmp al, ','
  1498 000018B7 75F7                <1> 	jne .count_loop
  1499 000018B9 FEC1                <1> 	inc cl
  1500 000018BB EBF3                <1> 	jmp .count_loop
  1501                              <1> 
  1502                              <1> .done_count:
  1503 000018BD FEC1                <1> 	inc cl
  1504 000018BF 880E[181A]          <1> 	mov byte [.num_of_entries], cl
  1505                              <1> 
  1506 000018C3 B39F                <1> 	mov bl, 0x9F		; White on light blue
  1507 000018C5 B20F                <1> 	mov dl, 15			; Start X position
  1508 000018C7 B602                <1> 	mov dh, 2			; Start Y position
  1509 000018C9 BE3200              <1> 	mov si, 50			; Width
  1510 000018CC BF1700              <1> 	mov di, 23			; Finish Y position
  1511 000018CF E8A5F9              <1> 	call draw_block		; Draw option selector window
  1512                              <1> 
  1513 000018D2 B210                <1> 	mov dl, 16			; Show first line of help text...
  1514 000018D4 B603                <1> 	mov dh, 3
  1515 000018D6 E826F9              <1> 	call move_cursor
  1516                              <1> 
  1517 000018D9 5E                  <1> 	pop si				; Get back first string
  1518 000018DA E87902              <1> 	call print
  1519                              <1> 
  1520 000018DD FEC6                <1> 	inc dh				; ...and the second
  1521 000018DF E81DF9              <1> 	call move_cursor
  1522                              <1> 
  1523 000018E2 5E                  <1> 	pop si
  1524 000018E3 E87002              <1> 	call print
  1525                              <1> 
  1526                              <1> 
  1527 000018E6 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1528 000018E7 8936[1A1A]          <1> 	mov word [.list_string], si
  1529                              <1> 
  1530                              <1> 
  1531                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1532                              <1> 	; entry and let the user move up and down using the cursor keys
  1533                              <1> 
  1534 000018EB C606[191A]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1535                              <1> 
  1536 000018F0 B214                <1> 	mov dl, 20			; Set up starting position for selector
  1537 000018F2 B607                <1> 	mov dh, 7
  1538                              <1> 
  1539 000018F4 E808F9              <1> 	call move_cursor
  1540                              <1> 
  1541                              <1> .more_select:
  1542 000018F7 60                  <1> 	pusha
  1543 000018F8 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1544 000018FA B210                <1> 	mov dl, 16
  1545 000018FC B606                <1> 	mov dh, 6
  1546 000018FE BE3000              <1> 	mov si, 48
  1547 00001901 BF1600              <1> 	mov di, 22
  1548 00001904 E870F9              <1> 	call draw_block
  1549 00001907 61                  <1> 	popa
  1550                              <1> 
  1551 00001908 E8E100              <1> 	call .draw_black_bar
  1552                              <1> 
  1553 0000190B 8B36[1A1A]          <1> 	mov word si, [.list_string]
  1554 0000190F E89A00              <1> 	call .draw_list
  1555                              <1> 
  1556                              <1> .another_key:
  1557 00001912 B400                <1> 	mov ah, 0x00
  1558 00001914 CD16                <1> 	int 0x16
  1559                              <1> 
  1560 00001916 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1561 00001919 740F                <1> 	je .go_up
  1562 0000191B 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1563 0000191E 741B                <1> 	je .go_down
  1564 00001920 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1565 00001922 7468                <1> 	je .option_selected
  1566 00001924 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1567 00001926 747E                <1> 	je .esc_pressed
  1568 00001928 EBCD                <1> 	jmp .more_select		; If not, wait for another key
  1569                              <1> 
  1570                              <1> 
  1571                              <1> .go_up:
  1572 0000192A 80FE07              <1> 	cmp dh, 7			; Already at top?
  1573 0000192D 7E32                <1> 	jle .hit_top
  1574                              <1> 
  1575 0000192F E8CF00              <1> 	call .draw_white_bar
  1576                              <1> 
  1577 00001932 B219                <1> 	mov dl, 25
  1578 00001934 E8C8F8              <1> 	call move_cursor
  1579                              <1> 
  1580 00001937 FECE                <1> 	dec dh				; Row to select (increasing down)
  1581 00001939 EBBC                <1> 	jmp .more_select
  1582                              <1> 
  1583                              <1> 
  1584                              <1> .go_down:				; Already at bottom of list?
  1585 0000193B 80FE14              <1> 	cmp dh, 20
  1586 0000193E 7430                <1> 	je .hit_bottom
  1587                              <1> 
  1588 00001940 B90000              <1> 	mov cx, 0
  1589 00001943 88F1                <1> 	mov byte cl, dh
  1590                              <1> 
  1591 00001945 80E907              <1> 	sub cl, 7
  1592 00001948 FEC1                <1> 	inc cl
  1593 0000194A 020E[191A]          <1> 	add byte cl, [.skip_num]
  1594                              <1> 
  1595 0000194E A0[181A]            <1> 	mov byte al, [.num_of_entries]
  1596 00001951 38C1                <1> 	cmp cl, al
  1597 00001953 74BD                <1> 	je .another_key
  1598                              <1> 
  1599 00001955 E8A900              <1> 	call .draw_white_bar
  1600                              <1> 
  1601 00001958 B219                <1> 	mov dl, 25
  1602 0000195A E8A2F8              <1> 	call move_cursor
  1603                              <1> 
  1604 0000195D FEC6                <1> 	inc dh
  1605 0000195F EB96                <1> 	jmp .more_select
  1606                              <1> 
  1607                              <1> 
  1608                              <1> .hit_top:
  1609 00001961 8A0E[191A]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1610 00001965 80F900              <1> 	cmp cl, 0
  1611 00001968 74A8                <1> 	je .another_key			; If not, wait for another key
  1612                              <1> 
  1613 0000196A FE0E[191A]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1614 0000196E EB87                <1> 	jmp .more_select
  1615                              <1> 
  1616                              <1> 
  1617                              <1> .hit_bottom:				; See if there's more to scroll
  1618 00001970 B90000              <1> 	mov cx, 0
  1619 00001973 88F1                <1> 	mov byte cl, dh
  1620                              <1> 
  1621 00001975 80E907              <1> 	sub cl, 7
  1622 00001978 FEC1                <1> 	inc cl
  1623 0000197A 020E[191A]          <1> 	add byte cl, [.skip_num]
  1624                              <1> 
  1625 0000197E A0[181A]            <1> 	mov byte al, [.num_of_entries]
  1626 00001981 38C1                <1> 	cmp cl, al
  1627 00001983 748D                <1> 	je .another_key
  1628                              <1> 
  1629 00001985 FE06[191A]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1630 00001989 E96BFF              <1> 	jmp .more_select
  1631                              <1> 
  1632                              <1> 
  1633                              <1> 
  1634                              <1> .option_selected:
  1635 0000198C E84FF8              <1> 	call show_cursor
  1636                              <1> 
  1637 0000198F 80EE07              <1> 	sub dh, 7
  1638                              <1> 
  1639 00001992 B80000              <1> 	mov ax, 0
  1640 00001995 88F0                <1> 	mov al, dh
  1641                              <1> 
  1642 00001997 FEC0                <1> 	inc al				; Options start from 1
  1643 00001999 0206[191A]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1644                              <1> 
  1645 0000199D A3[161A]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1646                              <1> 
  1647 000019A0 61                  <1> 	popa
  1648                              <1> 
  1649 000019A1 A1[161A]            <1> 	mov word ax, [.tmp]
  1650 000019A4 F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1651 000019A5 C3                  <1> 	ret
  1652                              <1> 
  1653                              <1> 
  1654                              <1> 
  1655                              <1> .esc_pressed:
  1656 000019A6 E835F8              <1> 	call show_cursor
  1657 000019A9 61                  <1> 	popa
  1658 000019AA F9                  <1> 	stc				; Set carry for Esc
  1659 000019AB C3                  <1> 	ret
  1660                              <1> 
  1661                              <1> 
  1662                              <1> 
  1663                              <1> .draw_list:
  1664 000019AC 60                  <1> 	pusha
  1665                              <1> 
  1666 000019AD B212                <1> 	mov dl, 18			; Get into position for option list text
  1667 000019AF B607                <1> 	mov dh, 7
  1668 000019B1 E84BF8              <1> 	call move_cursor
  1669                              <1> 
  1670                              <1> 
  1671 000019B4 B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  1672 000019B7 8A0E[191A]          <1> 	mov byte cl, [.skip_num]
  1673                              <1> 
  1674                              <1> .skip_loop:
  1675 000019BB 83F900              <1> 	cmp cx, 0
  1676 000019BE 7408                <1> 	je .skip_loop_finished
  1677                              <1> .more_lodsb:
  1678 000019C0 AC                  <1> 	lodsb
  1679 000019C1 3C2C                <1> 	cmp al, ','
  1680 000019C3 75FB                <1> 	jne .more_lodsb
  1681 000019C5 49                  <1> 	dec cx
  1682 000019C6 EBF3                <1> 	jmp .skip_loop
  1683                              <1> 
  1684                              <1> 
  1685                              <1> .skip_loop_finished:
  1686 000019C8 BB0000              <1> 	mov bx, 0			; Counter for total number of options
  1687                              <1> 
  1688                              <1> 
  1689                              <1> .more:
  1690 000019CB AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  1691                              <1> 
  1692 000019CC 3C00                <1> 	cmp al, 0			; End of string?
  1693 000019CE 7417                <1> 	je .done_list
  1694                              <1> 
  1695 000019D0 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1696 000019D2 7406                <1> 	je .newline
  1697                              <1> 
  1698 000019D4 B40E                <1> 	mov ah, 0Eh
  1699 000019D6 CD10                <1> 	int 10h
  1700 000019D8 EBF1                <1> 	jmp .more
  1701                              <1> 
  1702                              <1> .newline:
  1703 000019DA B212                <1> 	mov dl, 18			; Go back to starting X position
  1704 000019DC FEC6                <1> 	inc dh				; But jump down a line
  1705 000019DE E81EF8              <1> 	call move_cursor
  1706                              <1> 
  1707 000019E1 43                  <1> 	inc bx				; Update the number-of-options counter
  1708 000019E2 83FB0E              <1> 	cmp bx, 14			; Limit to one screen of options
  1709 000019E5 7CE4                <1> 	jl .more
  1710                              <1> 
  1711                              <1> .done_list:
  1712 000019E7 61                  <1> 	popa
  1713 000019E8 E814F8              <1> 	call move_cursor
  1714                              <1> 
  1715 000019EB C3                  <1> 	ret
  1716                              <1> 
  1717                              <1> 
  1718                              <1> 
  1719                              <1> .draw_black_bar:
  1720 000019EC 60                  <1> 	pusha
  1721                              <1> 
  1722 000019ED B211                <1> 	mov dl, 17
  1723 000019EF E80DF8              <1> 	call move_cursor
  1724                              <1> 
  1725 000019F2 B409                <1> 	mov ah, 09h			; Draw white bar at top
  1726 000019F4 B700                <1> 	mov bh, 0
  1727 000019F6 B92E00              <1> 	mov cx, 46
  1728 000019F9 B30F                <1> 	mov bl, 00001111b		; White text on black background
  1729 000019FB B020                <1> 	mov al, ' '
  1730 000019FD CD10                <1> 	int 10h
  1731                              <1> 
  1732 000019FF 61                  <1> 	popa
  1733 00001A00 C3                  <1> 	ret
  1734                              <1> 
  1735                              <1> 
  1736                              <1> 
  1737                              <1> .draw_white_bar:
  1738 00001A01 60                  <1> 	pusha
  1739                              <1> 
  1740 00001A02 B211                <1> 	mov dl, 17
  1741 00001A04 E8F8F7              <1> 	call move_cursor
  1742                              <1> 
  1743 00001A07 B409                <1> 	mov ah, 09h			; Draw white bar at top
  1744 00001A09 B700                <1> 	mov bh, 0
  1745 00001A0B B92E00              <1> 	mov cx, 46
  1746 00001A0E B3F0                <1> 	mov bl, 11110000b		; Black text on white background
  1747 00001A10 B020                <1> 	mov al, ' '
  1748 00001A12 CD10                <1> 	int 10h
  1749                              <1> 
  1750 00001A14 61                  <1> 	popa
  1751 00001A15 C3                  <1> 	ret
  1752                              <1> 
  1753                              <1> 
  1754 00001A16 0000                <1> 	.tmp			dw 0
  1755 00001A18 00                  <1> 	.num_of_entries		db 0
  1756 00001A19 00                  <1> 	.skip_num		db 0
  1757 00001A1A 0000                <1> 	.list_string		dw 0
   374                                      %include "./includes/misc.asm"
   375                              <1> ; get_api_version -- Return current version of KronkOS API
   376                              <1> ; OUT: AL = API version number
   377                              <1> 
   378                              <1> get_api_version:
   379 00001A1C B004                <1> 	mov al, KRONKOS_API
   380 00001A1E C3                  <1> 	ret
   381                              <1> 
   382                              <1> ; ------------------------------------------------------------------
   383                              <1> ; clear_regs -- Clear all the registers
   384                              <1> 
   385                              <1> clear_regs:
   386 00001A1F 31C0                <1> 	xor ax, ax
   387 00001A21 31DB                <1> 	xor bx, bx
   388 00001A23 31C9                <1> 	xor cx, cx
   389 00001A25 31D2                <1> 	xor dx, dx
   390 00001A27 31F6                <1> 	xor si, si
   391 00001A29 31FF                <1> 	xor di, di
   392                              <1> 	
   393 00001A2B C3                  <1> 	ret
   394                              <1> 
   395                              <1> ; ------------------------------------------------------------------
   396                              <1> ; fatal_error -- Display error message and halt execution
   397                              <1> ; IN: AX = error message string location
   398                              <1> 
   399                              <1> fatal_error:
   400 00001A2C 89C3                <1> 	mov bx, ax			; Store string location for now
   401                              <1> 
   402 00001A2E B600                <1> 	mov dh, 0
   403 00001A30 B200                <1> 	mov dl, 0
   404 00001A32 E8CAF7              <1> 	call move_cursor
   405                              <1> 
   406 00001A35 60                  <1> 	pusha
   407 00001A36 B409                <1> 	mov ah, 0x09		; Draw red bar at top
   408 00001A38 B700                <1> 	mov bh, 0
   409 00001A3A B9F000              <1> 	mov cx, 240
   410 00001A3D B34F                <1> 	mov bl, 01001111b
   411 00001A3F B020                <1> 	mov al, ' '
   412 00001A41 CD10                <1> 	int 10h
   413 00001A43 61                  <1> 	popa
   414                              <1> 
   415 00001A44 B600                <1> 	mov dh, 0
   416 00001A46 B200                <1> 	mov dl, 0
   417 00001A48 E8B4F7              <1> 	call move_cursor
   418                              <1> 
   419 00001A4B BE[581A]            <1> 	mov si, .msg_inform		; Inform of fatal error
   420 00001A4E E80501              <1> 	call print
   421                              <1> 
   422 00001A51 89DE                <1> 	mov si, bx			; Program-supplied error message
   423 00001A53 E80001              <1> 	call print
   424                              <1> 
   425 00001A56 EBFE                <1> 	jmp $				; Halt execution
   426                              <1> 
   427                              <1> 	
   428 00001A58 464154414C204F5045- <1> 	.msg_inform		db 'FATAL OPERATING SYSTEM ERROR!', 0x0d, 0x0a, 0
   428 00001A61 524154494E47205359- <1>
   428 00001A6A 5354454D204552524F- <1>
   428 00001A73 52210D0A00          <1>
   429                              <1> 
   430                              <1> ; ------------------------------------------------------------------
   431                              <1> ; bios_wait -- Wait
   432                              <1> ; IN: CX:DX time
   433                              <1> 
   434                              <1> bios_wait:
   435 00001A78 B80086              <1> 	mov ax, 0x8600
   436 00001A7B CD15                <1>     int 0x15
   437 00001A7D C3                  <1>     ret
   375                                      %include "./includes/input.asm"
   376                              <1> get_input:
   377 00001A7E 60                  <1>     pusha
   378 00001A7F B200                <1>     mov dl, 0
   379 00001A81 BE[B001]            <1>     mov si, in_buffer
   380                              <1> 
   381                              <1>     ; Clear the input buffer for use
   382                              <1>     .clear_loop:
   383 00001A84 C60400              <1>         mov byte [si], 0
   384                              <1> 
   385 00001A87 46                  <1>         inc si
   386 00001A88 FEC2                <1>         inc dl
   387                              <1> 
   388 00001A8A 80FA1E              <1>         cmp dl, 30
   389 00001A8D 75F5                <1>         jne .clear_loop
   390                              <1> 
   391 00001A8F BE[B001]            <1>     mov si, in_buffer
   392 00001A92 30DB                <1>     xor bl, bl ; Used for checking the length of the buffer
   393                              <1> 
   394                              <1> ; The actual loop
   395                              <1> .input_loop:
   396 00001A94 B400                <1>     mov ah, 0x00
   397 00001A96 CD16                <1>     int 0x16
   398                              <1> 
   399                              <1>     ; Check if the user pressed enter
   400 00001A98 3C0D                <1>     cmp al, 0x0d
   401 00001A9A 7442                <1>     je .input_done
   402                              <1> 
   403                              <1>     ; Check if the user pressed backspace
   404 00001A9C 3C08                <1>     cmp al, 0x08
   405 00001A9E 7524                <1>     jne .not_back
   406                              <1> 
   407                              <1>     ; ******************************
   408                              <1>     ; The user pressed backspace!
   409                              <1> 
   410                              <1>     ; Get current cursor position
   411 00001AA0 B403                <1>     mov ah, 0x03
   412 00001AA2 B700                <1>     mov bh, 0
   413 00001AA4 CD10                <1>     int 0x10
   414                              <1> 
   415 00001AA6 80FA03              <1>     cmp dl, 3 ; 3 = backspace limit
   416 00001AA9 74E9                <1>     je .input_loop
   417                              <1> 
   418 00001AAB FECA                <1>     dec dl
   419 00001AAD FECB                <1>     dec bl
   420                              <1> 
   421                              <1>     ; Move one back
   422 00001AAF B402                <1>     mov ah, 0x02
   423 00001AB1 CD10                <1>     int 0x10
   424                              <1> 
   425 00001AB3 B40E                <1>     mov ah, 0x0e
   426 00001AB5 B000                <1>     mov al, 0
   427 00001AB7 CD10                <1>     int 0x10
   428                              <1> 
   429 00001AB9 B402                <1>     mov ah, 0x02
   430 00001ABB CD10                <1>     int 0x10
   431                              <1> 
   432                              <1>     ; Remove the last character from the input buffer
   433 00001ABD 4E                  <1>     dec si
   434 00001ABE B000                <1>     mov al, 0
   435 00001AC0 8804                <1>     mov [si], al
   436                              <1> 
   437 00001AC2 EBD0                <1>     jmp .input_loop
   438                              <1>     
   439                              <1>     ; ******************************
   440                              <1> 
   441                              <1>     ; Show the pressed character and save it to the input buffer
   442                              <1>     .not_back:
   443 00001AC4 80FB28              <1>         cmp bl, 40
   444 00001AC7 74CB                <1>         je .input_loop
   445 00001AC9 FEC3                <1>         inc bl
   446                              <1> 
   447 00001ACB 8804                <1>         mov [si], al
   448 00001ACD 46                  <1>         inc si
   449                              <1> 
   450 00001ACE B40E                <1>         mov ah, 0x0e
   451 00001AD0 3C61                <1>         cmp al, 'a'
   452 00001AD2 7206                <1>         jb .noatoz
   453 00001AD4 3C7A                <1>         cmp al, 'z'
   454 00001AD6 7702                <1>         ja .noatoz
   455                              <1>         
   456 00001AD8 24DF                <1>         and al, 0xdf
   457                              <1>         .noatoz:
   458 00001ADA CD10                <1>         int 0x10
   459                              <1> 
   460 00001ADC EBB6                <1>         jmp .input_loop
   461                              <1> 
   462                              <1>     ; Return the cursor to the start and return
   463                              <1>     .input_done:
   464 00001ADE B8[B001]            <1>         mov ax, in_buffer
   465 00001AE1 E839F3              <1>         call string_lowercase
   466                              <1> 
   467 00001AE4 B40E                <1>         mov ah, 0x0e
   468 00001AE6 B00D                <1>         mov al, 0x0d
   469 00001AE8 CD10                <1>         int 0x10
   470                              <1> 
   471 00001AEA 61                  <1>         popa
   472 00001AEB C3                  <1>         ret
   376                                      %include "./includes/math.asm"
   377                              <1> ; ==================================================================
   378                              <1> ; KronkOS -- The Kronk Operating System kernel
   379                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   380                              <1> ;
   381                              <1> ; MATH ROUTINES
   382                              <1> ; ==================================================================
   383                              <1> 
   384                              <1> ; ------------------------------------------------------------------
   385                              <1> ; seed_random -- Seed the random number generator based on clock
   386                              <1> 
   387                              <1> seed_random:
   388 00001AEC 53                  <1> 	push bx
   389 00001AED 50                  <1> 	push ax
   390                              <1> 
   391 00001AEE BB0000              <1> 	mov bx, 0
   392 00001AF1 B002                <1> 	mov al, 0x02
   393 00001AF3 E670                <1> 	out 0x70, al
   394 00001AF5 E471                <1> 	in al, 0x71
   395                              <1> 
   396 00001AF7 88C3                <1> 	mov bl, al
   397 00001AF9 C1E308              <1> 	shl bx, 8
   398 00001AFC B000                <1> 	mov al, 0
   399 00001AFE E670                <1> 	out 0x70, al
   400 00001B00 E471                <1> 	in al, 0x71
   401                              <1> 
   402 00001B02 891E[091B]          <1> 	mov word [random_seed], bx
   403                              <1> 
   404 00001B06 58                  <1> 	pop ax
   405 00001B07 5B                  <1> 	pop bx
   406 00001B08 C3                  <1> 	ret
   407                              <1> 
   408 00001B09 0000                <1> 	random_seed dw 0
   409                              <1> 
   410                              <1> ; ------------------------------------------------------------------
   411                              <1> ; get_random -- Return a random integer between low and high (inclusive)
   412                              <1> ; IN: AX = low integer, BX = high integer
   413                              <1> ; OUT: CX = random integer
   414                              <1> 
   415                              <1> get_random:
   416 00001B0B 52                  <1> 	push dx
   417 00001B0C 53                  <1> 	push bx
   418 00001B0D 50                  <1> 	push ax
   419                              <1> 
   420 00001B0E 29C3                <1> 	sub bx, ax
   421 00001B10 E80F00              <1> 	call .generate_random
   422 00001B13 89DA                <1> 	mov dx, bx
   423 00001B15 83C201              <1> 	add dx, 1
   424 00001B18 F7E2                <1> 	mul dx
   425 00001B1A 89D1                <1> 	mov cx, dx
   426                              <1> 
   427 00001B1C 58                  <1> 	pop ax
   428 00001B1D 5B                  <1> 	pop bx
   429 00001B1E 5A                  <1> 	pop dx
   430 00001B1F 01C1                <1> 	add cx, ax
   431 00001B21 C3                  <1> 	ret
   432                              <1> 
   433                              <1> 	.generate_random:
   434 00001B22 52                  <1> 		push dx
   435 00001B23 53                  <1> 		push bx
   436                              <1> 
   437 00001B24 A1[091B]            <1> 		mov ax, [random_seed]
   438 00001B27 BA8373              <1> 		mov dx, 0x7383
   439 00001B2A F7E2                <1> 		mul dx
   440 00001B2C A3[091B]            <1> 		mov [random_seed], ax
   441                              <1> 
   442 00001B2F 5B                  <1> 		pop bx
   443 00001B30 5A                  <1> 		pop dx
   444                              <1> 		
   445 00001B31 C3                  <1> 		ret
   446                              <1> 
   447                              <1> ; ------------------------------------------------------------------
   448                              <1> ; bcd_to_int -- Converts binary coded decimal number to an integer
   449                              <1> ; IN: AL = BCD number
   450                              <1> ; OUT: AX = integer value
   451                              <1> 
   452                              <1> bcd_to_int:
   453 00001B32 60                  <1> 	pusha
   454                              <1> 
   455 00001B33 88C3                <1> 	mov bl, al
   456                              <1> 
   457 00001B35 83E00F              <1> 	and ax, 0x0F
   458 00001B38 89C1                <1> 	mov cx, ax
   459                              <1> 
   460 00001B3A C0EB04              <1> 	shr bl, 4
   461 00001B3D B00A                <1> 	mov al, 10
   462 00001B3F F6E3                <1> 	mul bl
   463                              <1> 
   464 00001B41 01C8                <1> 	add ax, cx
   465 00001B43 A3[4B1B]            <1> 	mov [.tmp], ax
   466                              <1> 
   467 00001B46 61                  <1> 	popa
   468 00001B47 A1[4B1B]            <1> 	mov ax, [.tmp]
   469 00001B4A C3                  <1> 	ret
   470                              <1> 
   471 00001B4B 0000                <1> 	.tmp	dw 0
   472                              <1> 	
   473                              <1> ; ------------------------------------------------------------------
   474                              <1> ; long_int_negate -- Multiply value in DX:AX by -1
   475                              <1> ; IN: DX:AX = long integer
   476                              <1> ; OUT: DX:AX = -(initial DX:AX)
   477                              <1> 
   478                              <1> long_int_negate:
   479 00001B4D F7D8                <1> 	neg ax
   480 00001B4F 83D200              <1> 	adc dx, 0
   481 00001B52 F7DA                <1> 	neg dx
   482 00001B54 C3                  <1> 	ret
   483                              <1> 
   484                              <1> ; ------------------------------------------------------------------
   485                              <1> ; hex_to_int -- Convert a hexadecimal to decimal
   486                              <1> ; IN: AX = number to be converted, BX = base
   487                              <1> 
   488                              <1> hex_to_int:
   489 00001B55 C3                  <1> 	ret
   490                              <1> 
   491                              <1> ; ==================================================================
   377                                      %include "./includes/print.asm"
   378                              <1> ; ------------------------------------------------------------------
   379                              <1> ; print -- Print a string to the screen
   380                              <1> ; IN: SI = The location of the string
   381                              <1> 
   382                              <1> print:
   383 00001B56 60                  <1>     pusha
   384 00001B57 B40E                <1>     mov ah, 0x0e
   385                              <1> 
   386                              <1> .repeat:
   387 00001B59 AC                  <1>     lodsb
   388 00001B5A 84C0                <1>     test al, al
   389 00001B5C 7404                <1>     jz .done
   390                              <1> 
   391 00001B5E CD10                <1>     int 0x10
   392 00001B60 EBF7                <1>     jmp short .repeat
   393                              <1> 
   394                              <1> .done:
   395 00001B62 61                  <1>     popa
   396 00001B63 C3                  <1>     ret
   397                              <1> 
   398                              <1> ; ------------------------------------------------------------------
   399                              <1> ; welcome_print -- Print the welcome message
   400                              <1> ; IN: SI = The location of the string
   401                              <1> 
   402                              <1> welcome_print:
   403 00001B64 B409                <1>     mov ah, 0x09
   404 00001B66 B90100              <1>     mov cx, 1
   405 00001B69 31DB                <1>     xor bx, bx
   406 00001B6B B330                <1>     mov bl, mb_color
   407                              <1> 
   408                              <1>     .repeat:
   409 00001B6D AC                  <1>         lodsb
   410 00001B6E 3C00                <1>         cmp al, 0
   411 00001B70 741C                <1>         je .done
   412                              <1> 
   413 00001B72 3C0A                <1>         cmp al, 0x0a
   414 00001B74 7410                <1>         je .other_char
   415 00001B76 3C0D                <1>         cmp al, 0x0d
   416 00001B78 740C                <1>         je .other_char
   417                              <1> 
   418 00001B7A E88BF6              <1>         call get_cursor_pos
   419 00001B7D FEC2                <1>         inc dl
   420 00001B7F E87DF6              <1>         call move_cursor
   421                              <1> 
   422 00001B82 CD10                <1>         int 0x10
   423 00001B84 EBE7                <1>         jmp short .repeat
   424                              <1> 
   425                              <1>     .other_char:
   426 00001B86 B40E                <1>         mov ah, 0x0e
   427 00001B88 CD10                <1>         int 0x10
   428                              <1> 
   429 00001B8A B409                <1>         mov ah, 0x09
   430 00001B8C EBDF                <1>         jmp .repeat
   431                              <1> 
   432                              <1>     .done:
   433 00001B8E C3                  <1>         ret
   434                              <1> 
   435                              <1> ; ------------------------------------------------------------------
   436                              <1> ; print_atr -- Print a string with attribute to the screen
   437                              <1> ; IN: SI = The location of the string
   438                              <1> ;     BH = Page number
   439                              <1> ;     BL = Attribute
   440                              <1> 
   441                              <1> print_atr:
   442 00001B8F 60                  <1>     pusha
   443 00001B90 B90100              <1>     mov cx, 1
   444 00001B93 B409                <1>     mov ah, 0x09
   445                              <1> 
   446                              <1> .repeat:
   447 00001B95 AC                  <1>     lodsb
   448 00001B96 84C0                <1>     test al, al
   449 00001B98 741C                <1>     jz .done
   450                              <1> 
   451 00001B9A 3C0A                <1>     cmp al, 0x0a
   452 00001B9C 7410                <1>     je .special_char
   453                              <1> 
   454 00001B9E 3C0D                <1>     cmp al, 0x0d
   455 00001BA0 740C                <1>     je .special_char
   456                              <1> 
   457 00001BA2 CD10                <1>     int 0x10
   458                              <1> 
   459 00001BA4 E861F6              <1>     call get_cursor_pos
   460 00001BA7 FEC2                <1>     inc dl
   461 00001BA9 E853F6              <1>     call move_cursor
   462                              <1> 
   463 00001BAC EBE7                <1>     jmp short .repeat
   464                              <1> 
   465                              <1> .special_char:
   466 00001BAE B40E                <1>     mov ah, 0x0e
   467 00001BB0 CD10                <1>     int 0x10
   468 00001BB2 B409                <1>     mov ah, 0x09
   469                              <1> 
   470 00001BB4 EBDF                <1>     jmp short .repeat
   471                              <1> 
   472                              <1> .done:
   473 00001BB6 61                  <1>     popa
   474 00001BB7 C3                  <1>     ret
   378                                      %include "./includes/mouse.asm"
   379                              <1> HW_EQUIP_PS2     equ 4          ; PS2 mouse installed?
   380                              <1> MOUSE_PKT_BYTES  equ 3          ; Number of bytes in mouse packet
   381                              <1> MOUSE_RESOLUTION equ 3          ; Mouse resolution 8 counts/mm
   382                              <1> ARG_OFFSETS      equ 6          ; Offset of args from BP
   383                              <1> 
   384                              <1> mouse_initialize:
   385 00001BB8 06                  <1>     push es
   386 00001BB9 53                  <1>     push bx
   387                              <1> 
   388 00001BBA CD11                <1>     int 0x11
   389 00001BBC A90400              <1>     test ax, HW_EQUIP_PS2
   390 00001BBF 7421                <1>     jz .no_mouse
   391                              <1> 
   392 00001BC1 B805C2              <1>     mov ax, 0xC205
   393 00001BC4 B703                <1>     mov bh, MOUSE_PKT_BYTES
   394 00001BC6 CD15                <1>     int 0x15
   395 00001BC8 7218                <1>     jc .no_mouse
   396                              <1> 
   397 00001BCA B803C2              <1>     mov ax, 0xC203
   398 00001BCD B703                <1>     mov bh, MOUSE_RESOLUTION
   399 00001BCF CD15                <1>     int 0x15
   400 00001BD1 720F                <1>     jc .no_mouse
   401                              <1> 
   402 00001BD3 0E                  <1>     push cs
   403 00001BD4 07                  <1>     pop es
   404                              <1> 
   405 00001BD5 BB[4D1C]            <1>     mov bx, mouse_callback_dummy
   406 00001BD8 B807C2              <1>     mov ax, 0xC207
   407 00001BDB CD15                <1>     int 0x15
   408 00001BDD 7203                <1>     jc .no_mouse
   409                              <1> 
   410 00001BDF F8                  <1>     clc
   411 00001BE0 EB01                <1>     jmp .finished
   412                              <1>     
   413                              <1>     .no_mouse:
   414 00001BE2 F9                  <1>         stc
   415                              <1>     
   416                              <1>     .finished:
   417 00001BE3 5B                  <1>         pop bx
   418 00001BE4 07                  <1>         pop es
   419 00001BE5 C3                  <1>         ret
   420                              <1> 
   421                              <1> 
   422                              <1> mouse_enable:
   423 00001BE6 06                  <1>     push es
   424 00001BE7 53                  <1>     push bx
   425                              <1> 
   426 00001BE8 E81400              <1>     call mouse_disable
   427                              <1> 
   428 00001BEB 0E                  <1>     push cs
   429 00001BEC 07                  <1>     pop es
   430 00001BED BB[121C]            <1>     mov bx, mouse_callback
   431 00001BF0 B807C2              <1>     mov ax, 0xC207
   432 00001BF3 CD15                <1>     int 0x15
   433                              <1> 
   434 00001BF5 B800C2              <1>     mov ax, 0xC200
   435 00001BF8 B701                <1>     mov bh, 1
   436 00001BFA CD15                <1>     int 0x15
   437                              <1> 
   438 00001BFC 5B                  <1>     pop bx
   439 00001BFD 07                  <1>     pop es
   440 00001BFE C3                  <1>     ret
   441                              <1> 
   442                              <1> 
   443                              <1> mouse_disable:
   444 00001BFF 06                  <1>     push es
   445 00001C00 53                  <1>     push bx
   446                              <1> 
   447 00001C01 B800C2              <1>     mov ax, 0xC200
   448 00001C04 31DB                <1>     xor bx, bx
   449 00001C06 CD15                <1>     int 0x15
   450                              <1> 
   451 00001C08 8EC3                <1>     mov es, bx
   452 00001C0A B807C2              <1>     mov ax, 0xC207
   453 00001C0D CD15                <1>     int 0x15
   454                              <1> 
   455 00001C0F 5B                  <1>     pop bx
   456 00001C10 07                  <1>     pop es
   457 00001C11 C3                  <1>     ret
   458                              <1> 
   459                              <1> 
   460                              <1> mouse_callback:
   461 00001C12 55                  <1>     push bp
   462 00001C13 89E5                <1>     mov bp, sp
   463                              <1> 
   464 00001C15 1E                  <1>     push ds
   465 00001C16 50                  <1>     push ax
   466 00001C17 53                  <1>     push bx
   467 00001C18 51                  <1>     push cx
   468 00001C19 52                  <1>     push dx
   469                              <1> 
   470 00001C1A 0E                  <1>     push cs
   471 00001C1B 1F                  <1>     pop ds
   472                              <1> 
   473 00001C1C 8A460C              <1>     mov al, [bp+ARG_OFFSETS+6]
   474 00001C1F 88C3                <1>     mov bl, al
   475 00001C21 B103                <1>     mov cl, 3
   476 00001C23 D2E0                <1>     shl al, cl
   477                              <1> 
   478 00001C25 18F6                <1>     sbb dh, dh
   479 00001C27 98                  <1>     cbw
   480 00001C28 8A5608              <1>     mov dl, [bp+ARG_OFFSETS+2]
   481 00001C2B 8A460A              <1>     mov al, [bp+ARG_OFFSETS+4]
   482                              <1> 
   483 00001C2E F7DA                <1>     neg dx
   484 00001C30 8B0E[001D]          <1>     mov cx, [mouseY]
   485 00001C34 01CA                <1>     add dx, cx
   486 00001C36 8B0E[FE1C]          <1>     mov cx, [mouseX]
   487 00001C3A 01C8                <1>     add ax, cx
   488                              <1> 
   489 00001C3C 881E[021D]          <1>     mov [curStatus], bl
   490 00001C40 A3[FE1C]            <1>     mov [mouseX], ax
   491 00001C43 8916[001D]          <1>     mov [mouseY], dx
   492                              <1> 
   493 00001C47 5A                  <1>     pop dx
   494 00001C48 59                  <1>     pop cx
   495 00001C49 5B                  <1>     pop bx
   496 00001C4A 58                  <1>     pop ax
   497 00001C4B 1F                  <1>     pop ds
   498 00001C4C 5D                  <1>     pop bp
   499                              <1> 
   500                              <1> mouse_callback_dummy:
   501 00001C4D CB                  <1>     retf
   502                              <1> 
   503                              <1> poll_mouse:
   504 00001C4E 50                  <1>     push ax
   505 00001C4F 53                  <1>     push bx
   506 00001C50 52                  <1>     push dx
   507                              <1>     
   508 00001C51 BB0200              <1>     mov bx, 0x0002
   509                              <1> 
   510 00001C54 FA                  <1>     cli
   511 00001C55 A1[FE1C]            <1>     mov ax, [mouseX]
   512 00001C58 8B16[001D]          <1>     mov dx, [mouseY]
   513 00001C5C FB                  <1>     sti
   514                              <1> 
   515 00001C5D 5A                  <1>     pop dx
   516 00001C5E 5B                  <1>     pop bx
   517 00001C5F 58                  <1>     pop ax
   518 00001C60 C3                  <1>     ret
   519                              <1> 
   520                              <1> clamp_mouse:
   521 00001C61 A1[FE1C]            <1>     mov ax, [mouseX]
   522                              <1> 
   523 00001C64 83F84E              <1>     cmp ax, screenmaxW
   524 00001C67 7D17                <1>     jge .r_edge
   525                              <1> 
   526 00001C69 BA0100              <1>     mov dx, screenminW
   527 00001C6C 39D0                <1>     cmp ax, dx
   528 00001C6E 7E22                <1>     jle .l_edge
   529                              <1> 
   530 00001C70 BA0100              <1>     mov dx, screenminH
   531 00001C73 A1[001D]            <1>     mov ax, [mouseY]
   532 00001C76 39D0                <1>     cmp ax, dx
   533 00001C78 7E2A                <1>     jle .t_edge
   534                              <1> 
   535 00001C7A 83F817              <1>     cmp ax, screenmaxH
   536 00001C7D 7D37                <1>     jge .b_edge
   537                              <1> 
   538 00001C7F C3                  <1>     ret
   539                              <1> 
   540                              <1> .r_edge:
   541 00001C80 C706[FE1C]4E00      <1>     mov word [mouseX], screenmaxW
   542 00001C86 8A16[FE1C]          <1>     mov dl, [mouseX]
   543 00001C8A 8A36[001D]          <1>     mov dh, [mouseY]
   544 00001C8E E86EF5              <1>     call move_cursor
   545 00001C91 C3                  <1>     ret
   546                              <1> 
   547                              <1> .l_edge:
   548 00001C92 C706[FE1C]0100      <1>     mov word [mouseX], screenminW
   549 00001C98 8A16[FE1C]          <1>     mov dl, [mouseX]
   550 00001C9C 8A36[001D]          <1>     mov dh, [mouseY]
   551 00001CA0 E85CF5              <1>     call move_cursor
   552 00001CA3 C3                  <1>     ret
   553                              <1> 
   554                              <1> .t_edge:
   555 00001CA4 C706[001D]0100      <1>     mov word [mouseY], screenminH
   556 00001CAA 8A16[FE1C]          <1>     mov dl, [mouseX]
   557 00001CAE 8A36[001D]          <1>     mov dh, [mouseY]
   558 00001CB2 E84AF5              <1>     call move_cursor
   559 00001CB5 C3                  <1>     ret
   560                              <1> 
   561                              <1> .b_edge:
   562 00001CB6 C706[001D]1700      <1>     mov word [mouseY], screenmaxH
   563 00001CBC 8A16[FE1C]          <1>     mov dl, [mouseX]
   564 00001CC0 8A36[001D]          <1>     mov dh, [mouseY]
   565 00001CC4 E838F5              <1>     call move_cursor
   566 00001CC7 C3                  <1>     ret
   567                              <1> 
   568                              <1> no_mouse:
   569 00001CC8 B8[2A02]            <1>     mov ax, mouse_yes
   570 00001CCB 31DB                <1>     xor bx, bx
   571 00001CCD 31C9                <1>     xor cx, cx
   572 00001CCF BA0000              <1>     mov dx, 0
   573 00001CD2 E8BDF5              <1>     call dialog_box
   574                              <1> 
   575 00001CD5 31C0                <1>     xor ax, ax
   576 00001CD7 CD13                <1>     int 0x13
   577                              <1> 
   578 00001CD9 B80010              <1>     mov ax, 0x1000
   579 00001CDC 8CD0                <1>     mov ax, ss
   580 00001CDE BC00F0              <1>     mov sp, 0xf000
   581 00001CE1 B80753              <1>     mov ax, 0x5307
   582 00001CE4 BB0100              <1>     mov bx, 0x0001
   583 00001CE7 B90300              <1>     mov cx, 0x0003
   584 00001CEA CD15                <1>     int 0x15
   585                              <1> 
   586                              <1> mouse_loop:
   587 00001CEC E85FFF              <1>     call poll_mouse
   588 00001CEF 8A16[FE1C]          <1>     mov dl, [mouseX]
   589 00001CF3 8A36[001D]          <1>     mov dh, [mouseY]
   590                              <1>     
   591 00001CF7 E805F5              <1>     call move_cursor
   592 00001CFA E864FF              <1>     call clamp_mouse
   593                              <1> 
   594 00001CFD C3                  <1>     ret
   595                              <1> 
   596 00001CFE 0000                <1> mouseX:         dw 0
   597 00001D00 0000                <1> mouseY:         dw 0
   598 00001D02 00                  <1> curStatus:      db 0
   599 00001D03 0D4572726F72207365- <1> noMouseMsg:     db 0x0d, "Error setting up and initializing mouse", 0x0a, 0x0d, 0
   599 00001D0C 7474696E6720757020- <1>
   599 00001D15 616E6420696E697469- <1>
   599 00001D1E 616C697A696E67206D- <1>
   599 00001D27 6F7573650A0D00      <1>
   379                                      %include "./includes/disk.asm"
   380                              <1> ; ==================================================================
   381                              <1> ; The Kronk Operating System kernel
   382                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   383                              <1> ;
   384                              <1> ; FAT12 FLOPPY DISK ROUTINES
   385                              <1> ; ==================================================================
   386                              <1> 
   387                              <1> ; ------------------------------------------------------------------
   388                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
   389                              <1> ; IN/OUT: AX = location to store zero-terminated filename string
   390                              <1> 
   391                              <1> os_get_file_list:
   392 00001D2E 60                  <1> 	pusha
   393                              <1> 
   394 00001D2F A3[D01D]            <1> 	mov word [.file_list_tmp], ax
   395                              <1> 
   396 00001D32 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   397                              <1> 
   398 00001D38 E84007              <1> 	call disk_reset_floppy		; Just in case disk was changed
   399                              <1> 
   400 00001D3B B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   401 00001D3E E84907              <1> 	call disk_convert_l2hts
   402                              <1> 
   403 00001D41 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   404 00001D44 89F3                <1> 	mov bx, si
   405                              <1> 
   406 00001D46 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   407 00001D48 B00E                <1> 	mov al, 14			; And read 14 of them
   408                              <1> 
   409 00001D4A 60                  <1> 	pusha				; Prepare to enter loop
   410                              <1> 
   411                              <1> 
   412                              <1> .read_root_dir:
   413 00001D4B 61                  <1> 	popa
   414 00001D4C 60                  <1> 	pusha
   415                              <1> 
   416 00001D4D F9                  <1> 	stc
   417 00001D4E CD13                <1> 	int 13h				; Read sectors
   418 00001D50 E82807              <1> 	call disk_reset_floppy		; Check we've read them OK
   419 00001D53 7307                <1> 	jnc .show_dir_init		; No errors, continue
   420                              <1> 
   421 00001D55 E82307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
   422 00001D58 73F1                <1> 	jnc .read_root_dir
   423 00001D5A EB6E                <1> 	jmp .done			; Double error, exit 'dir' routine
   424                              <1> 
   425                              <1> .show_dir_init:
   426 00001D5C 61                  <1> 	popa
   427                              <1> 
   428 00001D5D B80000              <1> 	mov ax, 0
   429 00001D60 BE0060              <1> 	mov si, disk_buffer		; Data reader from start of filenames
   430                              <1> 
   431 00001D63 8B3E[D01D]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
   432                              <1> 
   433                              <1> 
   434                              <1> .start_entry:
   435 00001D67 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   436 00001D6A 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   437 00001D6C 7457                <1> 	je .skip
   438                              <1> 
   439 00001D6E A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   440 00001D70 7553                <1> 	jnz .skip			; Yes, ignore it
   441                              <1> 
   442 00001D72 8A04                <1> 	mov al, [si]
   443 00001D74 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   444 00001D76 744D                <1> 	je .skip
   445                              <1> 
   446 00001D78 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
   447 00001D7A 744E                <1> 	je .done
   448                              <1> 
   449                              <1> 
   450 00001D7C B90100              <1> 	mov cx, 1			; Set char counter
   451 00001D7F 89F2                <1> 	mov dx, si			; Beginning of possible entry
   452                              <1> 
   453                              <1> .testdirentry:
   454 00001D81 46                  <1> 	inc si
   455 00001D82 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   456 00001D84 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   457 00001D86 7C3B                <1> 	jl .nxtdirentry
   458 00001D88 3C7E                <1> 	cmp al, '~'
   459 00001D8A 7737                <1> 	ja .nxtdirentry
   460                              <1> 
   461 00001D8C 41                  <1> 	inc cx
   462 00001D8D 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
   463 00001D90 7402                <1> 	je .gotfilename
   464 00001D92 EBED                <1> 	jmp .testdirentry
   465                              <1> 
   466                              <1> 
   467                              <1> .gotfilename:				; Got a filename that passes testing
   468 00001D94 89D6                <1> 	mov si, dx			; DX = where getting string
   469                              <1> 
   470 00001D96 B90000              <1> 	mov cx, 0
   471                              <1> .loopy:
   472 00001D99 8A04                <1> 	mov byte al, [si]
   473 00001D9B 3C20                <1> 	cmp al, ' '
   474 00001D9D 7411                <1> 	je .ignore_space
   475 00001D9F 8805                <1> 	mov byte [di], al
   476 00001DA1 46                  <1> 	inc si
   477 00001DA2 47                  <1> 	inc di
   478 00001DA3 41                  <1> 	inc cx
   479 00001DA4 83F908              <1> 	cmp cx, 8
   480 00001DA7 7410                <1> 	je .add_dot
   481 00001DA9 83F90B              <1> 	cmp cx, 11
   482 00001DAC 7411                <1> 	je .done_copy
   483 00001DAE EBE9                <1> 	jmp .loopy
   484                              <1> 
   485                              <1> .ignore_space:
   486 00001DB0 46                  <1> 	inc si
   487 00001DB1 41                  <1> 	inc cx
   488 00001DB2 83F908              <1> 	cmp cx, 8
   489 00001DB5 7402                <1> 	je .add_dot
   490 00001DB7 EBE0                <1> 	jmp .loopy
   491                              <1> 
   492                              <1> .add_dot:
   493 00001DB9 C6052E              <1> 	mov byte [di], '.'
   494 00001DBC 47                  <1> 	inc di
   495 00001DBD EBDA                <1> 	jmp .loopy
   496                              <1> 
   497                              <1> .done_copy:
   498 00001DBF C6052C              <1> 	mov byte [di], ','
   499 00001DC2 47                  <1> 	inc di
   500                              <1> 
   501                              <1> .nxtdirentry:
   502 00001DC3 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
   503                              <1> 
   504                              <1> .skip:
   505 00001DC5 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
   506 00001DC8 EB9D                <1> 	jmp .start_entry
   507                              <1> 
   508                              <1> 
   509                              <1> .done:
   510 00001DCA 4F                  <1> 	dec di
   511 00001DCB C60500              <1> 	mov byte [di], 0		; Zero-terminate string (gets rid of final comma)
   512                              <1> 
   513 00001DCE 61                  <1> 	popa
   514 00001DCF C3                  <1> 	ret
   515                              <1> 
   516 00001DD0 0000                <1> 	.file_list_tmp		dw 0
   517                              <1> 
   518                              <1> ; ------------------------------------------------------------------
   519                              <1> ; os_load_file -- Load file into RAM
   520                              <1> ; IN: AX = location of filename, CX = location in RAM to load file
   521                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
   522                              <1> 
   523                              <1> os_load_file:
   524 00001DD2 E82BF0              <1> 	call string_uppercase
   525 00001DD5 E87205              <1> 	call int_filename_convert
   526                              <1> 
   527 00001DD8 A3[DA1E]            <1> 	mov [.filename_loc], ax		; Store filename location
   528 00001DDB 890E[DC1E]          <1> 	mov [.load_position], cx	; And where to load the file!
   529                              <1> 
   530 00001DDF 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   531                              <1> 
   532 00001DE5 E89306              <1> 	call disk_reset_floppy		; In case floppy has been changed
   533 00001DE8 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
   534                              <1> 
   535 00001DEA B8[EC1E]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
   536 00001DED E93CFC              <1> 	jmp fatal_error
   537                              <1> 
   538                              <1> 
   539                              <1> .floppy_ok:				; Ready to read first block of data
   540 00001DF0 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   541 00001DF3 E89406              <1> 	call disk_convert_l2hts
   542                              <1> 
   543 00001DF6 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   544 00001DF9 89F3                <1> 	mov bx, si
   545                              <1> 
   546 00001DFB B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   547 00001DFD B00E                <1> 	mov al, 14			; 14 root directory sectors
   548                              <1> 
   549 00001DFF 60                  <1> 	pusha				; Prepare to enter loop
   550                              <1> 
   551                              <1> 
   552                              <1> .read_root_dir:
   553 00001E00 61                  <1> 	popa
   554 00001E01 60                  <1> 	pusha
   555                              <1> 
   556 00001E02 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
   557 00001E03 CD13                <1> 	int 13h				; Read sectors
   558 00001E05 7308                <1> 	jnc .search_root_dir		; No errors = continue
   559                              <1> 
   560 00001E07 E87106              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
   561 00001E0A 73F4                <1> 	jnc .read_root_dir
   562                              <1> 
   563 00001E0C 61                  <1> 	popa
   564 00001E0D EB38                <1> 	jmp .root_problem		; Double error = exit
   565                              <1> 
   566                              <1> .search_root_dir:
   567 00001E0F 61                  <1> 	popa
   568                              <1> 
   569 00001E10 B9E000              <1> 	mov cx, word 224		; Search all entries in root dir
   570 00001E13 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
   571                              <1> 
   572                              <1> .next_root_entry:
   573 00001E16 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
   574 00001E19 BF0060              <1> 	mov di, disk_buffer		; Point root dir at next entry
   575 00001E1C 01DF                <1> 	add di, bx
   576                              <1> 
   577 00001E1E 8A05                <1> 	mov al, [di]			; First character of name
   578                              <1> 
   579 00001E20 3C00                <1> 	cmp al, 0			; Last file name already checked?
   580 00001E22 7423                <1> 	je .root_problem
   581                              <1> 
   582 00001E24 3CE5                <1> 	cmp al, 229			; Was this file deleted?
   583 00001E26 74EE                <1> 	je .next_root_entry		; If yes, skip it
   584                              <1> 
   585 00001E28 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
   586                              <1> 
   587 00001E2B 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
   588 00001E2D 74E7                <1> 	je .next_root_entry
   589                              <1> 
   590 00001E2F A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   591 00001E31 75E3                <1> 	jnz .next_root_entry
   592                              <1> 
   593 00001E33 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
   594                              <1> 
   595 00001E37 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
   596 00001E39 E8C4EF              <1> 	call string_uppercase
   597                              <1> 
   598 00001E3C 8B36[DA1E]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
   599                              <1> 
   600 00001E40 E878F0              <1> 	call string_compare		; Current entry same as requested?
   601 00001E43 7207                <1> 	jc .found_file_to_load
   602                              <1> 
   603 00001E45 E2CF                <1> 	loop .next_root_entry
   604                              <1> 
   605                              <1> .root_problem:
   606 00001E47 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
   607 00001E4A F9                  <1> 	stc				; return with size = 0 and carry set
   608 00001E4B C3                  <1> 	ret
   609                              <1> 
   610                              <1> 
   611                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
   612 00001E4C 8B451C              <1> 	mov ax, [di+28]			; Store file size to return to calling routine
   613 00001E4F A3[DE1E]            <1> 	mov word [.file_size], ax
   614                              <1> 
   615 00001E52 83F800              <1> 	cmp ax, 0			; If the file size is zero, don't bother trying
   616 00001E55 7478                <1> 	je .end				; to read more clusters
   617                              <1> 
   618 00001E57 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
   619 00001E5A A3[D61E]            <1> 	mov word [.cluster], ax
   620                              <1> 
   621 00001E5D B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
   622 00001E60 E82706              <1> 	call disk_convert_l2hts
   623                              <1> 
   624 00001E63 BF0060              <1> 	mov di, disk_buffer		; ES:BX points to our buffer
   625 00001E66 89FB                <1> 	mov bx, di
   626                              <1> 
   627 00001E68 B402                <1> 	mov ah, 2			; int 13h params: read sectors
   628 00001E6A B009                <1> 	mov al, 9			; And read 9 of them
   629                              <1> 
   630 00001E6C 60                  <1> 	pusha
   631                              <1> 
   632                              <1> .read_fat:
   633 00001E6D 61                  <1> 	popa				; In case registers altered by int 13h
   634 00001E6E 60                  <1> 	pusha
   635                              <1> 
   636 00001E6F F9                  <1> 	stc
   637 00001E70 CD13                <1> 	int 13h
   638 00001E72 7308                <1> 	jnc .read_fat_ok
   639                              <1> 
   640 00001E74 E80406              <1> 	call disk_reset_floppy
   641 00001E77 73F4                <1> 	jnc .read_fat
   642                              <1> 
   643 00001E79 61                  <1> 	popa
   644 00001E7A EBCB                <1> 	jmp .root_problem
   645                              <1> 
   646                              <1> 
   647                              <1> .read_fat_ok:
   648 00001E7C 61                  <1> 	popa
   649                              <1> 
   650                              <1> 
   651                              <1> .load_file_sector:
   652 00001E7D A1[D61E]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
   653 00001E80 83C01F              <1> 	add ax, 31
   654                              <1> 
   655 00001E83 E80406              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
   656                              <1> 
   657 00001E86 8B1E[DC1E]          <1> 	mov bx, [.load_position]
   658                              <1> 
   659                              <1> 
   660 00001E8A B402                <1> 	mov ah, 02			; AH = read sectors, AL = just read 1
   661 00001E8C B001                <1> 	mov al, 01
   662                              <1> 
   663 00001E8E F9                  <1> 	stc
   664 00001E8F CD13                <1> 	int 13h
   665 00001E91 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
   666                              <1> 
   667 00001E93 E8E505              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
   668 00001E96 73E5                <1> 	jnc .load_file_sector
   669                              <1> 
   670 00001E98 B8[EC1E]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
   671 00001E9B E98EFB              <1> 	jmp fatal_error
   672                              <1> 
   673                              <1> 
   674                              <1> .calculate_next_cluster:
   675 00001E9E A1[D61E]            <1> 	mov ax, [.cluster]
   676 00001EA1 BB0300              <1> 	mov bx, 3
   677 00001EA4 F7E3                <1> 	mul bx
   678 00001EA6 BB0200              <1> 	mov bx, 2
   679 00001EA9 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
   680 00001EAB BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   681 00001EAE 01C6                <1> 	add si, ax
   682 00001EB0 3E8B04              <1> 	mov ax, word [ds:si]
   683                              <1> 
   684 00001EB3 09D2                <1> 	or dx, dx			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
   685                              <1> 
   686 00001EB5 7405                <1> 	jz .even			; If [CLUSTER] = even, drop last 4 bits of word
   687                              <1> 					; with next cluster; if odd, drop first 4 bits
   688                              <1> 
   689                              <1> .odd:
   690 00001EB7 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
   691 00001EBA EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   692                              <1> 
   693                              <1> .even:
   694 00001EBC 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
   695                              <1> 
   696                              <1> .calculate_cluster_cont:
   697 00001EBF A3[D61E]            <1> 	mov word [.cluster], ax		; Store cluster
   698                              <1> 
   699 00001EC2 3DF80F              <1> 	cmp ax, 0FF8h
   700 00001EC5 7308                <1> 	jae .end
   701                              <1> 
   702 00001EC7 8106[DC1E]0002      <1> 	add word [.load_position], 512
   703 00001ECD EBAE                <1> 	jmp .load_file_sector		; Onto next sector!
   704                              <1> 
   705                              <1> 
   706                              <1> .end:
   707 00001ECF 8B1E[DE1E]          <1> 	mov bx, [.file_size]		; Get file size to pass back in BX
   708 00001ED3 F8                  <1> 	clc				; Carry clear = good load
   709 00001ED4 C3                  <1> 	ret
   710                              <1> 
   711                              <1> 
   712 00001ED5 00                  <1> 	.bootd		db 0 		; Boot device number
   713 00001ED6 0000                <1> 	.cluster	dw 0 		; Cluster of the file we want to load
   714 00001ED8 0000                <1> 	.pointer	dw 0 		; Pointer into disk_buffer, for loading 'file2load'
   715                              <1> 
   716 00001EDA 0000                <1> 	.filename_loc	dw 0		; Temporary store of filename location
   717 00001EDC 0000                <1> 	.load_position	dw 0		; Where we'll load the file
   718 00001EDE 0000                <1> 	.file_size	dw 0		; Size of the file
   719                              <1> 
   720 00001EE0 00<rep Ch>          <1> 	.string_buff	times 12 db 0	; For size (integer) printing
   721                              <1> 
   722 00001EEC 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy failed to reset', 0
   722 00001EF5 696C653A20466C6F70- <1>
   722 00001EFE 7079206661696C6564- <1>
   722 00001F07 20746F207265736574- <1>
   722 00001F10 00                  <1>
   723                              <1> 
   724                              <1> 
   725                              <1> ; --------------------------------------------------------------------------
   726                              <1> ; os_write_file -- Save (max 64K) file to disk
   727                              <1> ; IN: AX = filename, BX = data location, CX = bytes to write
   728                              <1> ; OUT: Carry clear if OK, set if failure
   729                              <1> 
   730                              <1> os_write_file:
   731 00001F11 60                  <1> 	pusha
   732                              <1> 
   733 00001F12 89C6                <1> 	mov si, ax
   734 00001F14 E89AEE              <1> 	call string_length
   735 00001F17 83F800              <1> 	cmp ax, 0
   736 00001F1A 0F849201            <1> 	je near .failure
   737 00001F1E 89F0                <1> 	mov ax, si
   738                              <1> 
   739 00001F20 E8DDEE              <1> 	call string_uppercase
   740 00001F23 E82404              <1> 	call int_filename_convert	; Make filename FAT12-style
   741 00001F26 0F828601            <1> 	jc near .failure
   742                              <1> 
   743 00001F2A 890E[B320]          <1> 	mov word [.filesize], cx
   744 00001F2E 891E[B920]          <1> 	mov word [.location], bx
   745 00001F32 A3[BD20]            <1> 	mov word [.filename], ax
   746                              <1> 
   747 00001F35 E88702              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
   748 00001F38 0F837401            <1> 	jnc near .failure
   749                              <1> 
   750                              <1> 
   751                              <1> 	; First, zero out the .free_clusters list from any previous execution
   752 00001F3C 60                  <1> 	pusha
   753                              <1> 
   754 00001F3D BF[BF20]            <1> 	mov di, .free_clusters
   755 00001F40 B98000              <1> 	mov cx, 128
   756                              <1> .clean_free_loop:
   757 00001F43 C7050000            <1> 	mov word [di], 0
   758 00001F47 47                  <1> 	inc di
   759 00001F48 47                  <1> 	inc di
   760 00001F49 E2F8                <1> 	loop .clean_free_loop
   761                              <1> 
   762 00001F4B 61                  <1> 	popa
   763                              <1> 
   764                              <1> 
   765                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
   766                              <1> 
   767 00001F4C 89C8                <1> 	mov ax, cx
   768 00001F4E BA0000              <1> 	mov dx, 0
   769 00001F51 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
   770 00001F54 F7F3                <1> 	div bx
   771 00001F56 83FA00              <1> 	cmp dx, 0
   772 00001F59 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
   773 00001F5B EB03                <1> 	jmp .carry_on
   774                              <1> 
   775                              <1> .add_a_bit:
   776 00001F5D 83C001              <1> 	add ax, 1
   777                              <1> .carry_on:
   778                              <1> 
   779 00001F60 A3[BB20]            <1> 	mov word [.clusters_needed], ax
   780                              <1> 
   781 00001F63 A1[BD20]            <1> 	mov word ax, [.filename]	; Get filename back
   782                              <1> 
   783 00001F66 E87502              <1> 	call os_create_file		; Create empty root dir entry for this file
   784 00001F69 0F824301            <1> 	jc near .failure		; If we can't write to the media, jump out
   785                              <1> 
   786 00001F6D 8B1E[B320]          <1> 	mov word bx, [.filesize]
   787 00001F71 83FB00              <1> 	cmp bx, 0
   788 00001F74 0F843501            <1> 	je near .finished
   789                              <1> 
   790 00001F78 E86B04              <1> 	call disk_read_fat		; Get FAT copy into RAM
   791 00001F7B BE0360              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
   792                              <1> 
   793 00001F7E BB0200              <1> 	mov bx, 2			; Current cluster counter
   794 00001F81 8B0E[BB20]          <1> 	mov word cx, [.clusters_needed]
   795 00001F85 BA0000              <1> 	mov dx, 0			; Offset in .free_clusters list
   796                              <1> 
   797                              <1> .find_free_cluster:
   798 00001F88 AD                  <1> 	lodsw				; Get a word
   799 00001F89 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
   800 00001F8C 740D                <1> 	jz .found_free_even		; Free entry?
   801                              <1> 
   802                              <1> .more_odd:
   803 00001F8E 43                  <1> 	inc bx				; If not, bump our counter
   804 00001F8F 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
   805                              <1> 
   806 00001F90 AD                  <1> 	lodsw				; Get word
   807 00001F91 C1E804              <1> 	shr ax, 4			; Shift for odd
   808 00001F94 09C0                <1> 	or ax, ax			; Free entry?
   809 00001F96 7416                <1> 	jz .found_free_odd
   810                              <1> 
   811                              <1> .more_even:
   812 00001F98 43                  <1> 	inc bx				; If not, keep going
   813 00001F99 EBED                <1> 	jmp .find_free_cluster
   814                              <1> 
   815                              <1> 
   816                              <1> .found_free_even:
   817 00001F9B 56                  <1> 	push si
   818 00001F9C BE[BF20]            <1> 	mov si, .free_clusters		; Store cluster
   819 00001F9F 01D6                <1> 	add si, dx
   820 00001FA1 891C                <1> 	mov word [si], bx
   821 00001FA3 5E                  <1> 	pop si
   822                              <1> 
   823 00001FA4 49                  <1> 	dec cx				; Got all the clusters we need?
   824 00001FA5 83F900              <1> 	cmp cx, 0
   825 00001FA8 7417                <1> 	je .finished_list
   826                              <1> 
   827 00001FAA 42                  <1> 	inc dx				; Next word in our list
   828 00001FAB 42                  <1> 	inc dx
   829 00001FAC EBE0                <1> 	jmp .more_odd
   830                              <1> 
   831                              <1> .found_free_odd:
   832 00001FAE 56                  <1> 	push si
   833 00001FAF BE[BF20]            <1> 	mov si, .free_clusters		; Store cluster
   834 00001FB2 01D6                <1> 	add si, dx
   835 00001FB4 891C                <1> 	mov word [si], bx
   836 00001FB6 5E                  <1> 	pop si
   837                              <1> 
   838 00001FB7 49                  <1> 	dec cx
   839 00001FB8 83F900              <1> 	cmp cx, 0
   840 00001FBB 7404                <1> 	je .finished_list
   841                              <1> 
   842 00001FBD 42                  <1> 	inc dx				; Next word in our list
   843 00001FBE 42                  <1> 	inc dx
   844 00001FBF EBD7                <1> 	jmp .more_even
   845                              <1> 
   846                              <1> 
   847                              <1> 
   848                              <1> .finished_list:
   849                              <1> 
   850                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
   851                              <1> 	; that correspond to free clusters on the disk; the next job is to
   852                              <1> 	; create a cluster chain in the FAT for our file
   853                              <1> 
   854 00001FC1 B90000              <1> 	mov cx, 0			; .free_clusters offset counter
   855 00001FC4 C706[B720]0100      <1> 	mov word [.count], 1		; General cluster counter
   856                              <1> 
   857                              <1> .chain_loop:
   858 00001FCA A1[B720]            <1> 	mov word ax, [.count]		; Is this the last cluster?
   859 00001FCD 3B06[BB20]          <1> 	cmp word ax, [.clusters_needed]
   860 00001FD1 7455                <1> 	je .last_cluster
   861                              <1> 
   862 00001FD3 BF[BF20]            <1> 	mov di, .free_clusters
   863                              <1> 
   864 00001FD6 01CF                <1> 	add di, cx
   865 00001FD8 8B1D                <1> 	mov word bx, [di]		; Get cluster
   866                              <1> 
   867 00001FDA 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
   868 00001FDC BA0000              <1> 	mov dx, 0
   869 00001FDF BB0300              <1> 	mov bx, 3
   870 00001FE2 F7E3                <1> 	mul bx
   871 00001FE4 BB0200              <1> 	mov bx, 2
   872 00001FE7 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   873 00001FE9 BE0060              <1> 	mov si, disk_buffer
   874 00001FEC 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   875 00001FEE 3E8B04              <1> 	mov ax, word [ds:si]
   876                              <1> 
   877 00001FF1 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   878 00001FF3 741B                <1> 	jz .even
   879                              <1> 
   880                              <1> .odd:
   881 00001FF5 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
   882 00001FF8 BF[BF20]            <1> 	mov di, .free_clusters
   883 00001FFB 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   884 00001FFD 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
   885 00002000 C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
   886 00002003 01D8                <1> 	add ax, bx
   887                              <1> 
   888 00002005 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   889                              <1> 
   890 00002008 FF06[B720]          <1> 	inc word [.count]
   891 0000200C 41                  <1> 	inc cx				; Move on a word in .free_clusters
   892 0000200D 41                  <1> 	inc cx
   893                              <1> 
   894 0000200E EBBA                <1> 	jmp .chain_loop
   895                              <1> 
   896                              <1> .even:
   897 00002010 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
   898 00002013 BF[BF20]            <1> 	mov di, .free_clusters
   899 00002016 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   900 00002018 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
   901                              <1> 
   902 0000201B 01D8                <1> 	add ax, bx
   903                              <1> 
   904 0000201D 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   905                              <1> 
   906 00002020 FF06[B720]          <1> 	inc word [.count]
   907 00002024 41                  <1> 	inc cx				; Move on a word in .free_clusters
   908 00002025 41                  <1> 	inc cx
   909                              <1> 
   910 00002026 EBA2                <1> 	jmp .chain_loop
   911                              <1> 
   912                              <1> 
   913                              <1> 
   914                              <1> .last_cluster:
   915 00002028 BF[BF20]            <1> 	mov di, .free_clusters
   916 0000202B 01CF                <1> 	add di, cx
   917 0000202D 8B1D                <1> 	mov word bx, [di]		; Get cluster
   918                              <1> 
   919 0000202F 89D8                <1> 	mov ax, bx
   920                              <1> 
   921 00002031 BA0000              <1> 	mov dx, 0
   922 00002034 BB0300              <1> 	mov bx, 3
   923 00002037 F7E3                <1> 	mul bx
   924 00002039 BB0200              <1> 	mov bx, 2
   925 0000203C F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   926 0000203E BE0060              <1> 	mov si, disk_buffer
   927 00002041 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   928 00002043 3E8B04              <1> 	mov ax, word [ds:si]
   929                              <1> 
   930 00002046 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   931 00002048 7408                <1> 	jz .even_last
   932                              <1> 
   933                              <1> .odd_last:
   934 0000204A 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
   935 0000204D 83C080              <1> 	add ax, 0FF80h
   936 00002050 EB06                <1> 	jmp .finito
   937                              <1> 
   938                              <1> .even_last:
   939 00002052 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
   940 00002055 05F80F              <1> 	add ax, 0FF8h
   941                              <1> 
   942                              <1> 
   943                              <1> .finito:
   944 00002058 3E8904              <1> 	mov word [ds:si], ax
   945                              <1> 
   946 0000205B E8B403              <1> 	call disk_write_fat		; Save our FAT back to disk
   947                              <1> 
   948                              <1> 
   949                              <1> 	; Now it's time to save the sectors to disk!
   950                              <1> 
   951 0000205E B90000              <1> 	mov cx, 0
   952                              <1> 
   953                              <1> .save_loop:
   954 00002061 BF[BF20]            <1> 	mov di, .free_clusters
   955 00002064 01CF                <1> 	add di, cx
   956 00002066 8B05                <1> 	mov word ax, [di]
   957                              <1> 
   958 00002068 83F800              <1> 	cmp ax, 0
   959 0000206B 0F841D00            <1> 	je near .write_root_entry
   960                              <1> 
   961 0000206F 60                  <1> 	pusha
   962                              <1> 
   963 00002070 83C01F              <1> 	add ax, 31
   964                              <1> 
   965 00002073 E81404              <1> 	call disk_convert_l2hts
   966                              <1> 
   967 00002076 8B1E[B920]          <1> 	mov word bx, [.location]
   968                              <1> 
   969 0000207A B403                <1> 	mov ah, 3
   970 0000207C B001                <1> 	mov al, 1
   971 0000207E F9                  <1> 	stc
   972 0000207F CD13                <1> 	int 13h
   973                              <1> 
   974 00002081 61                  <1> 	popa
   975                              <1> 
   976 00002082 8106[B920]0002      <1> 	add word [.location], 512
   977 00002088 41                  <1> 	inc cx
   978 00002089 41                  <1> 	inc cx
   979 0000208A EBD5                <1> 	jmp .save_loop
   980                              <1> 
   981                              <1> 
   982                              <1> .write_root_entry:
   983                              <1> 
   984                              <1> 	; Now it's time to head back to the root directory, find our
   985                              <1> 	; entry and update it with the cluster in use and file size
   986                              <1> 
   987 0000208C E8A203              <1> 	call disk_read_root_dir
   988                              <1> 
   989 0000208F A1[BD20]            <1> 	mov word ax, [.filename]
   990 00002092 E81903              <1> 	call disk_get_root_entry
   991                              <1> 
   992 00002095 A1[BF20]            <1> 	mov word ax, [.free_clusters]	; Get first free cluster
   993                              <1> 
   994 00002098 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
   995                              <1> 
   996 0000209B 8B0E[B320]          <1> 	mov word cx, [.filesize]
   997 0000209F 894D1C              <1> 	mov word [di+28], cx
   998                              <1> 
   999 000020A2 C6451E00            <1> 	mov byte [di+30], 0		; File size
  1000 000020A6 C6451F00            <1> 	mov byte [di+31], 0
  1001                              <1> 
  1002 000020AA E8AF03              <1> 	call disk_write_root_dir
  1003                              <1> 
  1004                              <1> .finished:
  1005 000020AD 61                  <1> 	popa
  1006 000020AE F8                  <1> 	clc
  1007 000020AF C3                  <1> 	ret
  1008                              <1> 
  1009                              <1> .failure:
  1010 000020B0 61                  <1> 	popa
  1011 000020B1 F9                  <1> 	stc				; Couldn't write!
  1012 000020B2 C3                  <1> 	ret
  1013                              <1> 
  1014                              <1> 
  1015 000020B3 0000                <1> 	.filesize	dw 0
  1016 000020B5 0000                <1> 	.cluster	dw 0
  1017 000020B7 0000                <1> 	.count		dw 0
  1018 000020B9 0000                <1> 	.location	dw 0
  1019                              <1> 
  1020 000020BB 0000                <1> 	.clusters_needed	dw 0
  1021                              <1> 
  1022 000020BD 0000                <1> 	.filename	dw 0
  1023                              <1> 
  1024 000020BF 0000<rep 80h>       <1> 	.free_clusters	times 128 dw 0
  1025                              <1> 
  1026                              <1> 
  1027                              <1> ; --------------------------------------------------------------------------
  1028                              <1> ; os_file_exists -- Check for presence of file on the floppy
  1029                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
  1030                              <1> 
  1031                              <1> os_file_exists:
  1032 000021BF E83EEC              <1> 	call string_uppercase
  1033 000021C2 E88501              <1> 	call int_filename_convert	; Make FAT12-style filename
  1034                              <1> 
  1035 000021C5 50                  <1> 	push ax
  1036 000021C6 E8E8EB              <1> 	call string_length
  1037 000021C9 83F800              <1> 	cmp ax, 0
  1038 000021CC 740D                <1> 	je .failure
  1039 000021CE 58                  <1> 	pop ax
  1040                              <1> 
  1041 000021CF 50                  <1> 	push ax
  1042 000021D0 E85E02              <1> 	call disk_read_root_dir
  1043                              <1> 
  1044 000021D3 58                  <1> 	pop ax				; Restore filename
  1045 000021D4 BF0060              <1> 	mov di, disk_buffer
  1046 000021D7 E8D401              <1> 	call disk_get_root_entry	; Set or clear carry flag
  1047                              <1> 	
  1048 000021DA C3                  <1> 	ret
  1049                              <1> 
  1050                              <1> .failure:
  1051 000021DB 58                  <1> 	pop ax
  1052 000021DC F9                  <1> 	stc
  1053 000021DD C3                  <1> 	ret
  1054                              <1> 
  1055                              <1> 
  1056                              <1> ; --------------------------------------------------------------------------
  1057                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
  1058                              <1> ; IN: AX = location of filename
  1059                              <1> 
  1060                              <1> os_create_file:
  1061 000021DE F8                  <1> 	clc
  1062                              <1> 
  1063 000021DF E81EEC              <1> 	call string_uppercase
  1064 000021E2 E86501              <1> 	call int_filename_convert	; Make FAT12-style filename
  1065 000021E5 60                  <1> 	pusha
  1066                              <1> 
  1067 000021E6 50                  <1> 	push ax				; Save filename for now
  1068                              <1> 
  1069 000021E7 E8D5FF              <1> 	call os_file_exists		; Does the file already exist?
  1070 000021EA 7315                <1> 	jnc .exists_error
  1071                              <1> 
  1072                              <1> 
  1073                              <1> 	; Root dir already read into disk_buffer by os_file_exists
  1074                              <1> 
  1075 000021EC BF0060              <1> 	mov di, disk_buffer		; So point DI at it!
  1076                              <1> 
  1077                              <1> 
  1078 000021EF B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
  1079                              <1> .next_entry:
  1080 000021F2 8A05                <1> 	mov byte al, [di]
  1081 000021F4 3C00                <1> 	cmp al, 0			; Is this a free entry?
  1082 000021F6 740D                <1> 	je .found_free_entry
  1083 000021F8 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
  1084 000021FA 7409                <1> 	je .found_free_entry
  1085 000021FC 83C720              <1> 	add di, 32			; If not, go onto next entry
  1086 000021FF E2F1                <1> 	loop .next_entry
  1087                              <1> 
  1088                              <1> .exists_error:				; We also get here if above loop finds nothing
  1089 00002201 58                  <1> 	pop ax				; Get filename back
  1090                              <1> 
  1091 00002202 61                  <1> 	popa
  1092 00002203 F9                  <1> 	stc				; Set carry for failure
  1093 00002204 C3                  <1> 	ret
  1094                              <1> 
  1095                              <1> 
  1096                              <1> .found_free_entry:
  1097 00002205 5E                  <1> 	pop si				; Get filename back
  1098 00002206 B90B00              <1> 	mov cx, 11
  1099 00002209 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
  1100                              <1> 
  1101                              <1> 
  1102 0000220B 83EF0B              <1> 	sub di, 11			; Back to start of root dir entry, for clarity
  1103                              <1> 
  1104                              <1> 
  1105 0000220E C6450B00            <1> 	mov byte [di+11], 0		; Attributes
  1106 00002212 C6450C00            <1> 	mov byte [di+12], 0		; Reserved
  1107 00002216 C6450D00            <1> 	mov byte [di+13], 0		; Reserved
  1108 0000221A C6450EC6            <1> 	mov byte [di+14], 0C6h		; Creation time
  1109 0000221E C6450F7E            <1> 	mov byte [di+15], 07Eh		; Creation time
  1110 00002222 C6451000            <1> 	mov byte [di+16], 0		; Creation date
  1111 00002226 C6451100            <1> 	mov byte [di+17], 0		; Creation date
  1112 0000222A C6451200            <1> 	mov byte [di+18], 0		; Last access date
  1113 0000222E C6451300            <1> 	mov byte [di+19], 0		; Last access date
  1114 00002232 C6451400            <1> 	mov byte [di+20], 0		; Ignore in FAT12
  1115 00002236 C6451500            <1> 	mov byte [di+21], 0		; Ignore in FAT12
  1116 0000223A C64516C6            <1> 	mov byte [di+22], 0C6h		; Last write time
  1117 0000223E C645177E            <1> 	mov byte [di+23], 07Eh		; Last write time
  1118 00002242 C6451800            <1> 	mov byte [di+24], 0		; Last write date
  1119 00002246 C6451900            <1> 	mov byte [di+25], 0		; Last write date
  1120 0000224A C6451A00            <1> 	mov byte [di+26], 0		; First logical cluster
  1121 0000224E C6451B00            <1> 	mov byte [di+27], 0		; First logical cluster
  1122 00002252 C6451C00            <1> 	mov byte [di+28], 0		; File size
  1123 00002256 C6451D00            <1> 	mov byte [di+29], 0		; File size
  1124 0000225A C6451E00            <1> 	mov byte [di+30], 0		; File size
  1125 0000225E C6451F00            <1> 	mov byte [di+31], 0		; File size
  1126                              <1> 
  1127 00002262 E8F701              <1> 	call disk_write_root_dir
  1128 00002265 7203                <1> 	jc .failure
  1129                              <1> 
  1130 00002267 61                  <1> 	popa
  1131 00002268 F8                  <1> 	clc				; Clear carry for success
  1132 00002269 C3                  <1> 	ret
  1133                              <1> 
  1134                              <1> .failure:
  1135 0000226A 61                  <1> 	popa
  1136 0000226B F9                  <1> 	stc
  1137 0000226C C3                  <1> 	ret
  1138                              <1> 
  1139                              <1> 
  1140                              <1> ; --------------------------------------------------------------------------
  1141                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
  1142                              <1> ; IN: AX = location of filename to remove
  1143                              <1> 
  1144                              <1> os_remove_file:
  1145 0000226D 60                  <1> 	pusha
  1146 0000226E E88FEB              <1> 	call string_uppercase
  1147 00002271 E8D600              <1> 	call int_filename_convert	; Make filename FAT12-style
  1148 00002274 50                  <1> 	push ax				; Save filename
  1149                              <1> 
  1150 00002275 F8                  <1> 	clc
  1151                              <1> 
  1152 00002276 E8B801              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1153                              <1> 
  1154 00002279 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
  1155                              <1> 
  1156 0000227C 58                  <1> 	pop ax				; Get chosen filename back
  1157                              <1> 
  1158 0000227D E82E01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1159 00002280 7269                <1> 	jc .failure			; If entry can't be found
  1160                              <1> 
  1161                              <1> 
  1162 00002282 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
  1163 00002286 A3[EE22]            <1> 	mov word [.cluster], ax		; And save it
  1164                              <1> 
  1165 00002289 C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
  1166                              <1> 
  1167 0000228C 47                  <1> 	inc di
  1168                              <1> 
  1169 0000228D B90000              <1> 	mov cx, 0			; Set rest of data in root dir entry to zeros
  1170                              <1> .clean_loop:
  1171 00002290 C60500              <1> 	mov byte [di], 0
  1172 00002293 47                  <1> 	inc di
  1173 00002294 41                  <1> 	inc cx
  1174 00002295 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
  1175 00002298 7CF6                <1> 	jl .clean_loop
  1176                              <1> 
  1177 0000229A E8BF01              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
  1178                              <1> 
  1179                              <1> 
  1180 0000229D E84601              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
  1181 000022A0 BF0060              <1> 	mov di, disk_buffer		; And DI points to it
  1182                              <1> 
  1183                              <1> 
  1184                              <1> .more_clusters:
  1185 000022A3 A1[EE22]            <1> 	mov word ax, [.cluster]		; Get cluster contents
  1186                              <1> 
  1187 000022A6 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
  1188 000022A9 743D                <1> 	je .nothing_to_do
  1189                              <1> 
  1190 000022AB BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
  1191 000022AE F7E3                <1> 	mul bx
  1192 000022B0 BB0200              <1> 	mov bx, 2
  1193 000022B3 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
  1194 000022B5 BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1195 000022B8 01C6                <1> 	add si, ax
  1196 000022BA 3E8B04              <1> 	mov ax, word [ds:si]
  1197                              <1> 
  1198 000022BD 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
  1199                              <1> 
  1200 000022BF 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
  1201                              <1> 					; with next cluster; if odd, drop first 4 bits
  1202                              <1> .odd:
  1203 000022C1 50                  <1> 	push ax
  1204 000022C2 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
  1205 000022C5 3E8904              <1> 	mov word [ds:si], ax
  1206 000022C8 58                  <1> 	pop ax
  1207                              <1> 
  1208 000022C9 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
  1209 000022CC EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1210                              <1> 
  1211                              <1> .even:
  1212 000022CE 50                  <1> 	push ax
  1213 000022CF 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
  1214 000022D2 3E8904              <1> 	mov word [ds:si], ax
  1215 000022D5 58                  <1> 	pop ax
  1216                              <1> 
  1217 000022D6 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
  1218                              <1> 
  1219                              <1> .calculate_cluster_cont:
  1220 000022D9 A3[EE22]            <1> 	mov word [.cluster], ax		; Store cluster
  1221                              <1> 
  1222 000022DC 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
  1223 000022DF 7302                <1> 	jae .end
  1224                              <1> 
  1225 000022E1 EBC0                <1> 	jmp .more_clusters		; If not, grab more
  1226                              <1> 
  1227                              <1> .end:
  1228 000022E3 E82C01              <1> 	call disk_write_fat
  1229 000022E6 7203                <1> 	jc .failure
  1230                              <1> 
  1231                              <1> .nothing_to_do:
  1232 000022E8 61                  <1> 	popa
  1233 000022E9 F8                  <1> 	clc
  1234 000022EA C3                  <1> 	ret
  1235                              <1> 
  1236                              <1> .failure:
  1237 000022EB 61                  <1> 	popa
  1238 000022EC F9                  <1> 	stc
  1239 000022ED C3                  <1> 	ret
  1240                              <1> 
  1241                              <1> 
  1242 000022EE 0000                <1> 	.cluster dw 0
  1243                              <1> 
  1244                              <1> 
  1245                              <1> ; --------------------------------------------------------------------------
  1246                              <1> ; os_rename_file -- Change the name of a file on the disk
  1247                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
  1248                              <1> ; OUT: carry set on error
  1249                              <1> 
  1250                              <1> os_rename_file:
  1251 000022F0 53                  <1> 	push bx
  1252 000022F1 50                  <1> 	push ax
  1253                              <1> 
  1254 000022F2 F8                  <1> 	clc
  1255                              <1> 
  1256 000022F3 E83B01              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1257                              <1> 
  1258 000022F6 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
  1259                              <1> 
  1260 000022F9 58                  <1> 	pop ax				; Get chosen filename back
  1261                              <1> 
  1262 000022FA E803EB              <1> 	call string_uppercase
  1263 000022FD E84A00              <1> 	call int_filename_convert
  1264                              <1> 
  1265 00002300 E8AB00              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1266 00002303 7217                <1> 	jc .fail_read			; Quit out if file not found
  1267                              <1> 
  1268 00002305 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
  1269                              <1> 
  1270 00002306 89D8                <1> 	mov ax, bx
  1271                              <1> 
  1272 00002308 E8F5EA              <1> 	call string_uppercase
  1273 0000230B E83C00              <1> 	call int_filename_convert
  1274                              <1> 
  1275 0000230E 89C6                <1> 	mov si, ax
  1276                              <1> 
  1277 00002310 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
  1278 00002313 F3A4                <1> 	rep movsb
  1279                              <1> 
  1280 00002315 E84401              <1> 	call disk_write_root_dir	; Save root dir to disk
  1281 00002318 7205                <1> 	jc .fail_write
  1282                              <1> 
  1283 0000231A F8                  <1> 	clc
  1284 0000231B C3                  <1> 	ret
  1285                              <1> 
  1286                              <1> .fail_read:
  1287 0000231C 58                  <1> 	pop ax
  1288 0000231D F9                  <1> 	stc
  1289 0000231E C3                  <1> 	ret
  1290                              <1> 
  1291                              <1> .fail_write:
  1292 0000231F F9                  <1> 	stc
  1293 00002320 C3                  <1> 	ret
  1294                              <1> 
  1295                              <1> 
  1296                              <1> ; --------------------------------------------------------------------------
  1297                              <1> ; os_get_file_size -- Get file size information for specified file
  1298                              <1> ; IN: AX = filename; OUT: BX = file size in bytes (up to 64K)
  1299                              <1> ; or carry set if file not found
  1300                              <1> 
  1301                              <1> os_get_file_size:
  1302 00002321 60                  <1> 	pusha
  1303                              <1> 
  1304 00002322 E8DBEA              <1> 	call string_uppercase
  1305 00002325 E82200              <1> 	call int_filename_convert
  1306                              <1> 
  1307 00002328 F8                  <1> 	clc
  1308                              <1> 
  1309 00002329 50                  <1> 	push ax
  1310                              <1> 
  1311 0000232A E80401              <1> 	call disk_read_root_dir
  1312 0000232D 7216                <1> 	jc .failure
  1313                              <1> 
  1314 0000232F 58                  <1> 	pop ax
  1315                              <1> 
  1316 00002330 BF0060              <1> 	mov di, disk_buffer
  1317                              <1> 
  1318 00002333 E87800              <1> 	call disk_get_root_entry
  1319 00002336 720D                <1> 	jc .failure
  1320                              <1> 
  1321 00002338 8B5D1C              <1> 	mov word bx, [di+28]
  1322                              <1> 
  1323 0000233B 891E[4823]          <1> 	mov word [.tmp], bx
  1324                              <1> 
  1325 0000233F 61                  <1> 	popa
  1326                              <1> 
  1327 00002340 8B1E[4823]          <1> 	mov word bx, [.tmp]
  1328                              <1> 
  1329 00002344 C3                  <1> 	ret
  1330                              <1> 
  1331                              <1> .failure:
  1332 00002345 61                  <1> 	popa
  1333 00002346 F9                  <1> 	stc
  1334 00002347 C3                  <1> 	ret
  1335                              <1> 
  1336                              <1> 
  1337 00002348 0000                <1> 	.tmp	dw 0
  1338                              <1> 
  1339                              <1> 
  1340                              <1> ; ==================================================================
  1341                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  1342                              <1> 
  1343                              <1> ; ------------------------------------------------------------------
  1344                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  1345                              <1> ; IN: AX = filename string
  1346                              <1> ; OUT: AX = location of converted string (carry set if invalid)
  1347                              <1> 
  1348                              <1> int_filename_convert:
  1349 0000234A 60                  <1> 	pusha
  1350                              <1> 
  1351 0000234B 89C6                <1> 	mov si, ax
  1352                              <1> 
  1353 0000234D E861EA              <1> 	call string_length
  1354 00002350 83F80E              <1> 	cmp ax, 14			; Filename too long?
  1355 00002353 7F49                <1> 	jg .failure			; Fail if so
  1356                              <1> 
  1357 00002355 83F800              <1> 	cmp ax, 0
  1358 00002358 7444                <1> 	je .failure			; Similarly, fail if zero-char string
  1359                              <1> 
  1360 0000235A 89C2                <1> 	mov dx, ax			; Store string length for now
  1361                              <1> 
  1362 0000235C BF[A123]            <1> 	mov di, .dest_string
  1363                              <1> 
  1364 0000235F B90000              <1> 	mov cx, 0
  1365                              <1> .copy_loop:
  1366 00002362 AC                  <1> 	lodsb
  1367 00002363 3C2E                <1> 	cmp al, '.'
  1368 00002365 7408                <1> 	je .extension_found
  1369 00002367 AA                  <1> 	stosb
  1370 00002368 41                  <1> 	inc cx
  1371 00002369 39D1                <1> 	cmp cx, dx
  1372 0000236B 7F31                <1> 	jg .failure			; No extension found = wrong
  1373 0000236D EBF3                <1> 	jmp .copy_loop
  1374                              <1> 
  1375                              <1> .extension_found:
  1376 0000236F 83F900              <1> 	cmp cx, 0
  1377 00002372 742A                <1> 	je .failure			; Fail if extension dot is first char
  1378                              <1> 
  1379 00002374 83F908              <1> 	cmp cx, 8
  1380 00002377 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  1381                              <1> 
  1382                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  1383                              <1> 	; with spaces, if necessary
  1384                              <1> 
  1385                              <1> .add_spaces:
  1386 00002379 C60520              <1> 	mov byte [di], ' '
  1387 0000237C 47                  <1> 	inc di
  1388 0000237D 41                  <1> 	inc cx
  1389 0000237E 83F908              <1> 	cmp cx, 8
  1390 00002381 7CF6                <1> 	jl .add_spaces
  1391                              <1> 
  1392                              <1> 	; Finally, copy over the extension
  1393                              <1> .do_extension:
  1394 00002383 AC                  <1> 	lodsb				; 3 characters
  1395 00002384 3C00                <1> 	cmp al, 0
  1396 00002386 7416                <1> 	je .failure
  1397 00002388 AA                  <1> 	stosb
  1398 00002389 AC                  <1> 	lodsb
  1399 0000238A 3C00                <1> 	cmp al, 0
  1400 0000238C 7410                <1> 	je .failure
  1401 0000238E AA                  <1> 	stosb
  1402 0000238F AC                  <1> 	lodsb
  1403 00002390 3C00                <1> 	cmp al, 0
  1404 00002392 740A                <1> 	je .failure
  1405 00002394 AA                  <1> 	stosb
  1406                              <1> 
  1407 00002395 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  1408                              <1> 
  1409 00002398 61                  <1> 	popa
  1410 00002399 B8[A123]            <1> 	mov ax, .dest_string
  1411 0000239C F8                  <1> 	clc				; Clear carry for success
  1412 0000239D C3                  <1> 	ret
  1413                              <1> 
  1414                              <1> 
  1415                              <1> .failure:
  1416 0000239E 61                  <1> 	popa
  1417 0000239F F9                  <1> 	stc				; Set carry for failure
  1418 000023A0 C3                  <1> 	ret
  1419                              <1> 
  1420                              <1> 
  1421 000023A1 00<rep Dh>          <1> 	.dest_string	times 13 db 0
  1422                              <1> 
  1423                              <1> 
  1424                              <1> ; --------------------------------------------------------------------------
  1425                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  1426                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  1427                              <1> ; or carry set if file not found
  1428                              <1> 
  1429                              <1> disk_get_root_entry:
  1430 000023AE 60                  <1> 	pusha
  1431                              <1> 
  1432 000023AF A3[E223]            <1> 	mov word [.filename], ax
  1433                              <1> 
  1434 000023B2 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  1435 000023B5 B80000              <1> 	mov ax, 0			; Searching at offset 0
  1436                              <1> 
  1437                              <1> .to_next_root_entry:
  1438 000023B8 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  1439                              <1> 
  1440 000023BA 8B36[E223]          <1> 	mov word si, [.filename]	; Start searching for filename
  1441 000023BE B90B00              <1> 	mov cx, 11
  1442 000023C1 F3A6                <1> 	rep cmpsb
  1443 000023C3 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  1444                              <1> 
  1445 000023C5 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  1446                              <1> 
  1447 000023C8 BF0060              <1> 	mov di, disk_buffer		; Point to next root dir entry
  1448 000023CB 01C7                <1> 	add di, ax
  1449                              <1> 
  1450 000023CD 87D1                <1> 	xchg dx, cx			; Get the original CX back
  1451 000023CF E2E7                <1> 	loop .to_next_root_entry
  1452                              <1> 
  1453 000023D1 61                  <1> 	popa
  1454                              <1> 
  1455 000023D2 F9                  <1> 	stc				; Set carry if entry not found
  1456 000023D3 C3                  <1> 	ret
  1457                              <1> 
  1458                              <1> 
  1459                              <1> .found_file:
  1460 000023D4 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  1461                              <1> 
  1462 000023D7 893E[E423]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  1463                              <1> 
  1464 000023DB 61                  <1> 	popa
  1465                              <1> 
  1466 000023DC 8B3E[E423]          <1> 	mov word di, [.tmp]
  1467                              <1> 
  1468 000023E0 F8                  <1> 	clc
  1469 000023E1 C3                  <1> 	ret
  1470                              <1> 
  1471                              <1> 
  1472 000023E2 0000                <1> 	.filename	dw 0
  1473 000023E4 0000                <1> 	.tmp		dw 0
  1474                              <1> 
  1475                              <1> 
  1476                              <1> ; --------------------------------------------------------------------------
  1477                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  1478                              <1> ; IN: Nothing; OUT: carry set if failure
  1479                              <1> 
  1480                              <1> disk_read_fat:
  1481 000023E6 60                  <1> 	pusha
  1482                              <1> 
  1483 000023E7 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1484 000023EA E89D00              <1> 	call disk_convert_l2hts
  1485                              <1> 
  1486 000023ED BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1487 000023F0 BB0020              <1> 	mov bx, 2000h
  1488 000023F3 8EC3                <1> 	mov es, bx
  1489 000023F5 89F3                <1> 	mov bx, si
  1490                              <1> 
  1491 000023F7 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1492 000023F9 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  1493                              <1> 
  1494 000023FB 60                  <1> 	pusha				; Prepare to enter loop
  1495                              <1> 
  1496                              <1> 
  1497                              <1> .read_fat_loop:
  1498 000023FC 61                  <1> 	popa
  1499 000023FD 60                  <1> 	pusha
  1500                              <1> 
  1501 000023FE F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1502 000023FF CD13                <1> 	int 13h				; Read sectors
  1503                              <1> 
  1504 00002401 7308                <1> 	jnc .fat_done
  1505 00002403 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  1506 00002406 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  1507                              <1> 
  1508 00002408 61                  <1> 	popa
  1509 00002409 EB04                <1> 	jmp .read_failure		; Fatal double error
  1510                              <1> 
  1511                              <1> .fat_done:
  1512 0000240B 61                  <1> 	popa				; Restore registers from main loop
  1513                              <1> 
  1514 0000240C 61                  <1> 	popa				; And restore registers from start of system call
  1515 0000240D F8                  <1> 	clc
  1516 0000240E C3                  <1> 	ret
  1517                              <1> 
  1518                              <1> .read_failure:
  1519 0000240F 61                  <1> 	popa
  1520 00002410 F9                  <1> 	stc				; Set carry flag (for failure)
  1521 00002411 C3                  <1> 	ret
  1522                              <1> 
  1523                              <1> 
  1524                              <1> ; --------------------------------------------------------------------------
  1525                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  1526                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  1527                              <1> 
  1528                              <1> disk_write_fat:
  1529 00002412 60                  <1> 	pusha
  1530                              <1> 
  1531 00002413 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1532 00002416 E87100              <1> 	call disk_convert_l2hts
  1533                              <1> 
  1534 00002419 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1535 0000241C 8CDB                <1> 	mov bx, ds
  1536 0000241E 8EC3                <1> 	mov es, bx
  1537 00002420 89F3                <1> 	mov bx, si
  1538                              <1> 
  1539 00002422 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1540 00002424 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  1541                              <1> 
  1542 00002426 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1543 00002427 CD13                <1> 	int 13h				; Write sectors
  1544                              <1> 
  1545 00002429 7203                <1> 	jc .write_failure		; Fatal double error
  1546                              <1> 
  1547 0000242B 61                  <1> 	popa				; And restore from start of system call
  1548 0000242C F8                  <1> 	clc
  1549 0000242D C3                  <1> 	ret
  1550                              <1> 
  1551                              <1> .write_failure:
  1552 0000242E 61                  <1> 	popa
  1553 0000242F F9                  <1> 	stc				; Set carry flag (for failure)
  1554 00002430 C3                  <1> 	ret
  1555                              <1> 
  1556                              <1> 
  1557                              <1> ; --------------------------------------------------------------------------
  1558                              <1> ; disk_read_root_dir -- Get the root directory contents
  1559                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  1560                              <1> 
  1561                              <1> disk_read_root_dir:
  1562 00002431 60                  <1> 	pusha
  1563                              <1> 
  1564 00002432 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1565 00002435 E85200              <1> 	call disk_convert_l2hts
  1566                              <1> 
  1567 00002438 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1568 0000243B 8CDB                <1> 	mov bx, ds
  1569 0000243D 8EC3                <1> 	mov es, bx
  1570 0000243F 89F3                <1> 	mov bx, si
  1571                              <1> 
  1572 00002441 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1573 00002443 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  1574                              <1> 
  1575 00002445 60                  <1> 	pusha				; Prepare to enter loop
  1576                              <1> 
  1577                              <1> 
  1578                              <1> .read_root_dir_loop:
  1579 00002446 61                  <1> 	popa
  1580 00002447 60                  <1> 	pusha
  1581                              <1> 
  1582 00002448 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1583 00002449 CD13                <1> 	int 13h				; Read sectors
  1584                              <1> 
  1585 0000244B 7308                <1> 	jnc .root_dir_finished
  1586 0000244D E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  1587 00002450 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  1588                              <1> 
  1589 00002452 61                  <1> 	popa
  1590 00002453 EB04                <1> 	jmp .read_failure		; Fatal double error
  1591                              <1> 
  1592                              <1> 
  1593                              <1> .root_dir_finished:
  1594 00002455 61                  <1> 	popa				; Restore registers from main loop
  1595                              <1> 
  1596 00002456 61                  <1> 	popa				; And restore from start of this system call
  1597 00002457 F8                  <1> 	clc				; Clear carry (for success)
  1598 00002458 C3                  <1> 	ret
  1599                              <1> 
  1600                              <1> .read_failure:
  1601 00002459 61                  <1> 	popa
  1602 0000245A F9                  <1> 	stc				; Set carry flag (for failure)
  1603 0000245B C3                  <1> 	ret
  1604                              <1> 
  1605                              <1> 
  1606                              <1> ; --------------------------------------------------------------------------
  1607                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  1608                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  1609                              <1> 
  1610                              <1> disk_write_root_dir:
  1611 0000245C 60                  <1> 	pusha
  1612                              <1> 
  1613 0000245D B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1614 00002460 E82700              <1> 	call disk_convert_l2hts
  1615                              <1> 
  1616 00002463 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1617 00002466 8CDB                <1> 	mov bx, ds
  1618 00002468 8EC3                <1> 	mov es, bx
  1619 0000246A 89F3                <1> 	mov bx, si
  1620                              <1> 
  1621 0000246C B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1622 0000246E B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  1623                              <1> 
  1624 00002470 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1625 00002471 CD13                <1> 	int 13h				; Write sectors
  1626 00002473 7203                <1> 	jc .write_failure
  1627                              <1> 
  1628 00002475 61                  <1> 	popa				; And restore from start of this system call
  1629 00002476 F8                  <1> 	clc
  1630 00002477 C3                  <1> 	ret
  1631                              <1> 
  1632                              <1> .write_failure:
  1633 00002478 61                  <1> 	popa
  1634 00002479 F9                  <1> 	stc				; Set carry flag (for failure)
  1635 0000247A C3                  <1> 	ret
  1636                              <1> 
  1637                              <1> 
  1638                              <1> ; --------------------------------------------------------------------------
  1639                              <1> ; Reset floppy disk
  1640                              <1> 
  1641                              <1> disk_reset_floppy:
  1642 0000247B 50                  <1> 	push ax
  1643 0000247C 52                  <1> 	push dx
  1644 0000247D B80000              <1> 	mov ax, 0
  1645                              <1> ; ******************************************************************
  1646 00002480 8A16[B924]          <1> 	mov dl, [bootdev]
  1647                              <1> ; ******************************************************************
  1648 00002484 F9                  <1> 	stc
  1649 00002485 CD13                <1> 	int 13h
  1650 00002487 5A                  <1> 	pop dx
  1651 00002488 58                  <1> 	pop ax
  1652 00002489 C3                  <1> 	ret
  1653                              <1> 
  1654                              <1> 
  1655                              <1> ; --------------------------------------------------------------------------
  1656                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  1657                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  1658                              <1> 
  1659                              <1> disk_convert_l2hts:
  1660 0000248A 53                  <1> 	push bx
  1661 0000248B 50                  <1> 	push ax
  1662                              <1> 
  1663 0000248C 89C3                <1> 	mov bx, ax			; Save logical sector
  1664                              <1> 
  1665 0000248E BA0000              <1> 	mov dx, 0			; First the sector
  1666 00002491 F736[B724]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1667 00002495 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  1668 00002498 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  1669 0000249A 89D8                <1> 	mov ax, bx
  1670                              <1> 
  1671 0000249C BA0000              <1> 	mov dx, 0			; Now calculate the head
  1672 0000249F F736[B724]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1673 000024A3 BA0000              <1> 	mov dx, 0
  1674 000024A6 F736[B524]          <1> 	div word [Sides]		; Floppy sides
  1675 000024AA 88D6                <1> 	mov dh, dl			; Head/side
  1676 000024AC 88C5                <1> 	mov ch, al			; Track
  1677                              <1> 
  1678 000024AE 58                  <1> 	pop ax
  1679 000024AF 5B                  <1> 	pop bx
  1680                              <1> 
  1681                              <1> ; ******************************************************************
  1682 000024B0 8A16[B924]          <1> 	mov dl, [bootdev]		; Set correct device
  1683                              <1> ; ******************************************************************
  1684                              <1> 
  1685 000024B4 C3                  <1> 	ret
  1686                              <1> 
  1687                              <1> 
  1688 000024B5 0200                <1> 	Sides dw 2
  1689 000024B7 1200                <1> 	SecsPerTrack dw 18
  1690                              <1> ; ******************************************************************
  1691 000024B9 00                  <1> 	bootdev db 0			; Boot device number
  1692                              <1> ; ******************************************************************
  1693                              <1> ; ==================================================================
   380                                      %include "./includes/checkin.asm"
   381                              <1> check_com:      ; AX = command
   382 000024BA BE[B001]            <1>     mov si, in_buffer
   383 000024BD 89C7                <1>     mov di, ax
   384                              <1> 
   385                              <1> .check_loop:
   386 000024BF AC                  <1>     lodsb
   387 000024C0 3A05                <1>     cmp al, [di]
   388 000024C2 7509                <1>     jne .not_equal
   389                              <1>     
   390 000024C4 B000                <1>     mov al, 0
   391 000024C6 3805                <1>     cmp [di], al
   392 000024C8 7405                <1>     je .done
   393                              <1> 
   394 000024CA 47                  <1>     inc di
   395 000024CB EBF2                <1>     jmp .check_loop
   396                              <1> 
   397                              <1> .not_equal:
   398 000024CD F9                  <1>     stc
   399 000024CE C3                  <1>     ret
   400                              <1> 
   401                              <1> .done:
   402 000024CF F8                  <1>     clc
   403 000024D0 C3                  <1>     ret
   381                                  
   382                                  ; ==================================================================
   383                                  ; END OF KERNEL
   384                                  ; ==================================================================
