     1                                  ; ==================================================================
     2                                  ; The Kronk Operating System kernel
     3                                  ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                                  ;
     5                                  ; This is loaded from the drive by BOOTLOAD.BIN, as KERNEL.BIN
     6                                  ; ==================================================================
     7                                  
     8                                      ORG 0x0000
     9                                      BITS 16
    10                                  
    11                                  JUMP_VECTORS:
    12 00000000 EB39                        jmp kernel_start
    13 00000002 E9051B                      jmp print
    14 00000005 E9540D                      jmp cls
    15 00000008 E96821                      jmp os_file_exists
    16 0000000B E9781D                      jmp os_load_file
    17 0000000E E98121                      jmp os_create_file
    18 00000011 E90D22                      jmp os_remove_file
    19 00000014 E9AE1E                      jmp os_write_file
    20 00000017 E9C40D                      jmp string_lowercase
    21 0000001A E9A40D                      jmp string_uppercase
    22 0000001D E9E40D                      jmp string_truncate
    23 00000020 E94F0D                      jmp string_length
    24 00000023 E99A11                      jmp move_cursor
    25 00000026 E9A011                      jmp get_cursor_pos
    26 00000029 E9B011                      jmp print_horiz_line
    27 0000002C E9CA11                      jmp input_dialog
    28 0000002F E93418                      jmp list_dialog
    29 00000032 E91E12                      jmp dialog_box
    30 00000035 E97411                      jmp change_cursor
    31 00000038 E95611                      jmp string_clear
    32                                  
    33                                  
    34                                      %define KRONKOS_VER '0.3.2'
    35                                      %define KRONKOS_API 4
    36                                      
    37                                      ; RAM location for kernel disk operations
    38                                      disk_buffer     equ 24576
    39                                  
    40                                      ; Screen mouse clamps
    41                                      screenmaxW      equ 0x004E
    42                                      screenminW      equ 0x0001
    43                                      screenmaxH      equ 0x0017
    44                                      screenminH      equ 0x0001
    45                                      
    46                                      ; Mouse buttons
    47                                      leftMButton     equ 0x09
    48                                      rightMButton    equ 0x0A
    49                                  
    50                                      ; Screen modes
    51                                      vidRes          equ 0x13
    52                                      cliRes          equ 0x03
    53                                  
    54                                  ; ******************************************************************
    55                                  ; Start the kernel
    56                                  kernel_start:
    57 0000003B E8621A                      call seed_random
    58                                  
    59 0000003E FA                          cli                         ; Clear interrupts
    60 0000003F B80020                      mov ax, 0x2000              ; The bootloader loads us at 0x2000
    61 00000042 8ED8                        mov ds, ax                  ; Set DS and ES to 0x2000
    62 00000044 8EC0                        mov es, ax
    63                                  
    64                                      ; Stack just below 0x2000:0x0000 starting at 0x1000:0x0000.
    65                                      ; First push will set SS:SP to 0x1000:0xfffe because SP will wrap.
    66 00000046 B80010                      mov ax, 0x1000
    67 00000049 8ED0                        mov ss, ax
    68 0000004B 31E4                        xor sp, sp
    69                                  
    70 0000004D FC                          cld                         ; Clear Direction Flag (DF=0 is for forward string movement)
    71                                  ; ******************************************************************
    72                                  
    73                                  ; ------------------------------------------------------------------
    74                                  ; KERNEL CODE START
    75                                  RESET:
    76 0000004E 31C0                    	xor ax, ax
    77 00000050 31DB                    	xor bx, bx
    78 00000052 31C9                    	xor cx, cx
    79 00000054 31D2                    	xor dx, dx
    80 00000056 31F6                    	xor si, si
    81 00000058 31FF                    	xor di, di
    82                                  
    83                                      ; Change the cursor to a solid block
    84 0000005A B500                        mov ch, 0x00
    85 0000005C E84D11                      call change_cursor
    86                                  
    87                                      ; Check if SETTINGS.KSF exists
    88 0000005F B8[1803]                    mov ax, settings_filename
    89 00000062 E80E21                      call os_file_exists
    90 00000065 7311                        jnc .skip_setup     ; If it does... skip the setup
    91                                  
    92 00000067 E86B0A                      call setup_init
    93                                  
    94                                      ; Save the settings
    95 0000006A B8[1803]                    mov ax, settings_filename
    96 0000006D BB0090                      mov bx, 36864
    97 00000070 B9[7901]                    mov cx, usrNam
    98 00000073 E84F1E                      call os_write_file
    99                                  
   100 00000076 EBD6                        jmp RESET
   101                                  
   102                                  .skip_setup:
   103                                      ; Load the settings file
   104 00000078 B8[1803]                    mov ax, settings_filename
   105 0000007B B90090                      mov cx, 36864
   106 0000007E 31DB                        xor bx, bx
   107 00000080 E8031D                      call os_load_file
   108                                  
   109 00000083 89DE                        mov si, bx
   110 00000085 BF[7901]                    mov di, usrNam
   111 00000088 E8700D                      call string_copy
   112                                  
   113 0000008B 8A26[8E01]                  mov ah, [vidMode]
   114 0000008F 80FC00                      cmp ah, 0
   115 00000092 7405                        je .startCli
   116 00000094 80FC01                      cmp ah, 1
   117 00000097 7405                        je .startVideo
   118                                  
   119                                  .startCli:
   120 00000099 E8D504                      call kronk_cli
   121 0000009C EBFE                        jmp $
   122                                  
   123                                  .startVideo:
   124 0000009E E8110A                      call kronk_vid
   125 000000A1 EBFE                        jmp $
   126                                  
   127                                  
   128                                  ; ------------------------------------------------------------------
   129                                  ; KERNEL SUBROUTINES
   130                                      error_ext:
   131 000000A3 5E                              pop si
   132                                  
   133 000000A4 B8[5F03]                        mov ax, err1_ext
   134 000000A7 BB[7103]                        mov bx, err2_ext
   135 000000AA 31C9                            xor cx, cx
   136 000000AC 31D2                            xor dx, dx
   137 000000AE E8A211                          call dialog_box
   138                                  
   139 000000B1 B79F                            mov bh, 0x9F
   140 000000B3 E8A60C                          call cls
   141                                  
   142 000000B6 C3                              ret
   143                                  
   144                                      execute_bas_program:
   145 000000B7 5E                              pop si
   146 000000B8 56                              push si
   147                                          
   148 000000B9 89F3                            mov bx, si
   149 000000BB 89F0                            mov ax, si
   150 000000BD E8B20C                          call string_length
   151                                  
   152 000000C0 89DE                            mov si, bx
   153 000000C2 01C6                            add si, ax
   154                                  
   155 000000C4 83EE03                          sub si, 3
   156                                  
   157 000000C7 BF[5C03]                        mov di, bas_ext
   158 000000CA B90300                          mov cx, 3
   159 000000CD F3A6                            rep cmpsb
   160 000000CF 75D2                            jne error_ext
   161                                  
   162 000000D1 5E                              pop si
   163                                          
   164 000000D2 89F0                            mov ax, si
   165 000000D4 B90080                          mov cx, 32768
   166 000000D7 E8AC1C                          call os_load_file
   167                                  
   168 000000DA B70F                            mov bh, 0x0F
   169 000000DC E87D0C                          call cls
   170                                  
   171 000000DF B80080                          mov ax, 32768
   172 000000E2 31F6                            xor si, si
   173                                          ;call os_run_basic
   174                                  
   175 000000E4 BE[EF03]                        mov si, new_line
   176 000000E7 E8201A                          call print
   177                                  
   178 000000EA B79F                            mov bh, 0x9F
   179 000000EC E86D0C                          call cls
   180                                  
   181 000000EF C3                              ret
   182                                  
   183                                      execute_bin_program:
   184 000000F0 BE[EF03]                        mov si, new_line
   185 000000F3 E8141A                          call print
   186                                  
   187 000000F6 31C0                    		xor ax, ax
   188 000000F8 31DB                    		xor bx, bx
   189 000000FA 31C9                    		xor cx, cx
   190 000000FC 31D2                    		xor dx, dx
   191 000000FE 31F6                    		xor si, si
   192 00000100 31FF                    		xor di, di
   193                                  
   194 00000102 E8(0080)                        call 32768
   195 00000105 B70F                            mov bh, 0x0F
   196 00000107 E8520C                          call cls
   197                                  
   198 0000010A BE[2503]                        mov si, prg_done_msg
   199 0000010D E8FA19                          call print
   200 00000110 30E4                            xor ah, ah
   201 00000112 CD16                            int 0x16
   202                                          
   203 00000114 B70F                            mov bh, 0x0F
   204 00000116 E8430C                          call cls
   205                                  
   206 00000119 C3                              ret
   207                                  
   208                                      try_run_file:
   209 0000011A E8A40C                          call string_uppercase
   210 0000011D 89C6                            mov si, ax
   211 0000011F BF[0D03]                        mov di, kern_filename
   212 00000122 E8570D                          call string_compare
   213 00000125 7232                            jc load_kern_err
   214                                  
   215 00000127 E84920                          call os_file_exists
   216 0000012A 722B                            jc .not_found
   217 0000012C F8                              clc
   218                                  
   219 0000012D 89C6                            mov si, ax
   220 0000012F 56                              push si 
   221                                  
   222 00000130 89F3                            mov bx, si
   223 00000132 89F0                            mov ax, si
   224 00000134 E83B0C                          call string_length
   225                                  
   226 00000137 89DE                            mov si, bx
   227 00000139 01C6                            add si, ax
   228                                  
   229 0000013B 83EE03                          sub si, 3
   230                                  
   231 0000013E BF[5903]                        mov di, bin_ext
   232 00000141 B90300                          mov cx, 3
   233 00000144 F3A6                            rep cmpsb
   234 00000146 0F856DFF                        jne execute_bas_program
   235 0000014A 5E                              pop si
   236                                  
   237 0000014B 89F0                            mov ax, si
   238 0000014D B90080                          mov cx, 32768
   239 00000150 E8331C                          call os_load_file
   240                                  
   241 00000153 E89AFF                          call execute_bin_program
   242 00000156 C3                              ret
   243                                  
   244                                          .not_found:
   245 00000157 F9                                  stc
   246 00000158 C3                                  ret
   247                                  
   248                                          load_kern_err:
   249 00000159 5E                                  pop si
   250                                  
   251 0000015A B8[8F03]                            mov ax, err3_ext
   252 0000015D BB[A203]                            mov bx, err4_ext
   253 00000160 31C9                                xor cx, cx
   254 00000162 31D2                                xor dx, dx
   255 00000164 E8EC10                              call dialog_box
   256                                  
   257 00000167 B79F                                mov bh, 0x9F
   258 00000169 E8F00B                              call cls
   259                                  
   260 0000016C C3                                  ret
   261                                  
   262                                  ; ------------------------------------------------------------------
   263                                  ; STRINGS AND OTHER VARIABLES
   264                                  
   265                                      ; DEBUG VARIABLES START
   266 0000016D 4D653F20476F6E6761-         tmp:                db "Me? Gongaga", 0
   266 00000176 676100             
   267                                      ; END
   268                                  
   269                                      ; USER RELATED VARIABLES START
   270 00000179 00<rept>                    usrNam:             times 21 db 0
   271                                  
   272 0000018E 0000                        vidMode:            dw 0x00
   273                                      cli_color:          equ 0x0f
   274                                      vid_backcolor:      equ 0x01
   275                                      vid_forecolor:      equ 0x0f
   276                                      ; END
   277                                  
   278                                      ; TMP VARIABLES START
   279 00000190 4D4F555345204C4546-         mouse_left:         db "MOUSE LEFT", 0
   279 00000199 5400               
   280 0000019B 4D4F55534520524947-         mouse_right:        db "MOUSE RIGHT", 0
   280 000001A4 485400             
   281                                      ; END
   282                                  
   283                                      ; CLI SPECIFIC VARIABLES START
   284 000001A7 3A3E2000                	in_msg:				db ":> ", 0
   285 000001AB 00<rept>                	in_buffer: 			times 41 db 0
   286 000001D4 206973206E6F74206B-         not_com:            db " is not known command", 0x0a, 0x0d, 0
   286 000001DD 6E6F776E20636F6D6D-
   286 000001E6 616E640A0D00       
   287                                      ; END
   288                                  
   289                                      ; CLI COMMANDS START
   290 000001EC 7265737461727400            restart_com:        db "restart", 0
   291 000001F4 73687574646F776E00          shutdown_com:       db "shutdown", 0
   292 000001FD 73657474696E677300          settings_com:       db "settings", 0
   293 00000206 636C65617200                clear_com:          db "clear", 0
   294 0000020C 64697200                    dir_com:            db "dir", 0
   295 00000210 68656C7000                  help_com:           db "help", 0
   296 00000215 6564697400                  edit_com:           db "edit", 0
   297 0000021A 6C6F616400                  load_com:           db "load", 0
   298 0000021F 6D6B00                      mk_com:             db "mk", 0
   299 00000222 726D00                      rm_com:             db "rm", 0
   300                                      ; END
   301                                  
   302                                      ; MOUSE VARIABLES START
   303 00000225 4D4F55534520495320-         mouse_yes:          db "MOUSE IS CONNECTED!", 0
   303 0000022E 434F4E4E4543544544-
   303 00000237 2100               
   304 00000239 4D4F55534520495320-         mouse_no:           db "MOUSE IS NOT CONNECTED!", 0
   304 00000242 4E4F5420434F4E4E45-
   304 0000024B 435445442100       
   305                                      ; END
   306                                  
   307                                      ; WELCOME SCREEN VARIABLES START
   308 00000251 0A0D204B726F6E6B4F-     	welcome_msg1:		db 0x0a, 0x0d, " KronkOS ver. ", KRONKOS_VER
   308 0000025A 53207665722E20302E-
   308 00000263 332E32             
   309 00000266 20<rept>                						times 44-18 db " "
   310 00000280 0A0D2000                						db 0x0a, 0x0d, " ", 0
   311 00000284 204B696C6F20427974-     	welcome_msg2:		db " Kilo Bytes of total memory available. ", 0x0a, 0x0d, 0
   311 0000028D 6573206F6620746F74-
   311 00000296 616C206D656D6F7279-
   311 0000029F 20617661696C61626C-
   311 000002A8 652E200A0D00       
   312 000002AE 20<rept>                	welcome_msg3:		times 45 db " "
   313 000002DB 0A0D20547970652027-     						db 0x0a, 0x0d, " Type 'help' and press enter to start off.   ", 0x0a, 0x0d, 0
   313 000002E4 68656C702720616E64-
   313 000002ED 20707265737320656E-
   313 000002F6 74657220746F207374-
   313 000002FF 617274206F66662E20-
   313 00000308 20200A0D00         
   314                                  	; END
   315                                  
   316                                      ; FILE RELATED VARIABLES START
   317 0000030D 4B45524E454C2E4249-     	kern_filename:		db 'KERNEL.BIN', 0
   317 00000316 4E00               
   318 00000318 53455454494E47532E-         settings_filename:  db 'SETTINGS.KSF', 0
   318 00000321 4B534600           
   319 00000325 3E3E3E2050726F6772-     	prg_done_msg:	    db '>>> Program finished --- press a key to continue...', 0
   319 0000032E 616D2066696E697368-
   319 00000337 6564202D2D2D207072-
   319 00000340 6573732061206B6579-
   319 00000349 20746F20636F6E7469-
   319 00000352 6E75652E2E2E00     
   320                                  
   321 00000359 424B46                  	bin_ext:			db 'BKF'
   322 0000035C 424153                  	bas_ext:			db 'BAS'
   323 0000035F 556E6B6E6F776E2065-     	err1_ext:			db "Unknown extension", 0
   323 00000368 7874656E73696F6E00 
   324 00000371 4F6E6C79202E424B46-     	err2_ext:			db "Only .BKF and .BAS is allowed", 0
   324 0000037A 20616E64202E424153-
   324 00000383 20697320616C6C6F77-
   324 0000038C 656400             
   325 0000038F 4572726F72206C6F61-     	err3_ext:			db "Error loading file", 0
   325 00000398 64696E672066696C65-
   325 000003A1 00                 
   326 000003A2 596F752063616E2774-     	err4_ext:			db "You can't load KERNEL.BIN", 0
   326 000003AB 206C6F6164204B4552-
   326 000003B4 4E454C2E42494E00   
   327 000003BC 596F752063616E2774-         err5_ext:           db "You can't load SETTINGS.KSF", 0
   327 000003C5 206C6F616420534554-
   327 000003CE 54494E47532E4B5346-
   327 000003D7 00                 
   328 000003D8 0A0D46696C65206E6F-         notfound_msg:	    db 0x0a, 0x0d, "File not found", 0x0a, 0x0a, 0x0d, 0
   328 000003E1 7420666F756E640A0A-
   328 000003EA 0D00               
   329                                      ; END
   330                                  
   331                                      ; OTHER VARIABLES START
   332 000003EC 00                      	fmt_12_24:			db 0 		; (Non-zero = 24 hour format)
   333 000003ED 012F                    	fmt_date:			db 1, '/'	; 0, 1, 2 = M/D/Y, D/M/Y or Y/M/D
   334                                  									; Bit 7 = use name for months
   335                                  									; If bit 7 = 0, second byte = separator character
   336                                  
   337 000003EF 0A0D00                  	new_line:			db 0x0a, 0x0d, 0
   338 000003F2 202D2D2000              	file_size_sep:		db " -- ", 0
   339 000003F7 2042797465730A0D00      	file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   340                                      ; END
   341                                  
   342                                      ; MENUBAR VARIABLES START
   343                                      mb_color:           equ 0x30
   344 00000400 20<rept>                    mb_fill:            times 79 db " "
   345 0000044F 00                                              db 0
   346                                      ; END
   347                                  
   348                                  ; ------------------------------------------------------------------
   349                                  ; INCLUDED FILES
   350                                  
   351                                      %include "./includes/settings_menu.asm"
     1                              <1> show_settings:
     2 00000450 60                  <1>     pusha
     3                              <1> 
     4                              <1> .main_menu:
     5 00000451 B8[BF04]            <1>     mov ax, .main_options
     6 00000454 BB[DA04]            <1>     mov bx, .main_header
     7 00000457 B9[E304]            <1>     mov cx, .main_string
     8 0000045A E80914              <1>     call list_dialog
     9                              <1> 
    10 0000045D 83F801              <1>     cmp ax, 1
    11 00000460 7402                <1>     je .display_menu
    12                              <1> 
    13 00000462 EB54                <1>     jmp .end
    14                              <1> 
    15                              <1> .display_menu:
    16 00000464 B8[0205]            <1>     mov ax, .display_options
    17 00000467 BB[1B05]            <1>     mov bx, .display_header
    18 0000046A B9[2A05]            <1>     mov cx, .display_string
    19 0000046D E8F613              <1>     call list_dialog
    20                              <1> 
    21 00000470 83F801              <1>     cmp ax, 1
    22 00000473 7407                <1>     je .change_cli
    23                              <1> 
    24 00000475 83F802              <1>     cmp ax, 2
    25 00000478 7420                <1>     je .change_vid
    26                              <1> 
    27 0000047A EBD5                <1>     jmp .main_menu
    28                              <1> 
    29                              <1> .change_cli:
    30 0000047C B8[4005]            <1>     mov ax, .display_restart1
    31 0000047F BB[5A05]            <1>     mov bx, .display_restart2
    32 00000482 31C9                <1>     xor cx, cx
    33 00000484 BA0100              <1>     mov dx, 1
    34 00000487 E8C90D              <1>     call dialog_box
    35                              <1> 
    36 0000048A 85C0                <1>     test ax, ax
    37 0000048C 75D6                <1>     jnz .display_menu
    38                              <1> 
    39                              <1> 
    40 0000048E C606[8E01]00        <1>     mov byte [vidMode], 0
    41 00000493 31C0                <1>     xor ax, ax
    42 00000495 CD13                <1>     int 0x13
    43 00000497 E9B4FB              <1>     jmp RESET
    44                              <1> 
    45                              <1> .change_vid:
    46 0000049A B8[4005]            <1>     mov ax, .display_restart1
    47 0000049D BB[5A05]            <1>     mov bx, .display_restart2
    48 000004A0 31C9                <1>     xor cx, cx
    49 000004A2 BA0100              <1>     mov dx, 1
    50 000004A5 E8AB0D              <1>     call dialog_box
    51                              <1> 
    52 000004A8 85C0                <1>     test ax, ax
    53 000004AA 75B8                <1>     jnz .display_menu
    54                              <1> 
    55 000004AC C606[8E01]01        <1>     mov byte [vidMode], 1
    56 000004B1 31C0                <1>     xor ax, ax
    57 000004B3 CD13                <1>     int 0x13
    58 000004B5 E996FB              <1>     jmp RESET
    59                              <1> 
    60                              <1> .end:
    61 000004B8 B70F                <1>     mov bh, cli_color
    62 000004BA E89F08              <1>     call cls
    63                              <1> 
    64 000004BD 61                  <1>     popa
    65 000004BE C3                  <1>     ret
    66                              <1> 
    67                              <1> 
    68 000004BF 444953504C41592C    <1> .main_options:      db "DISPLAY,"
    69 000004C7 555345522C          <1>                     db "USER,"
    70 000004CC 455849542053455454- <1>                     db "EXIT SETTINGS", 0
    70 000004D5 494E475300          <1>
    71 000004DA 53455454494E475300  <1> .main_header:       db "SETTINGS", 0
    72 000004E3 4368616E6765207468- <1> .main_string:       db "Change the settings of KronkOS", 0
    72 000004EC 652073657474696E67- <1>
    72 000004F5 73206F66204B726F6E- <1>
    72 000004FE 6B4F5300            <1>
    73                              <1> 
    74 00000502 434C49204D4F44452C  <1> .display_options:   db "CLI MODE,"
    75 0000050B 564944454F204D4F44- <1>                     db "VIDEO MODE,"
    75 00000514 452C                <1>
    76 00000516 4241434B00          <1>                     db "BACK", 0
    77 0000051B 564944454F20534554- <1> .display_header:    db "VIDEO SETTINGS", 0
    77 00000524 54494E475300        <1>
    78 0000052A 4368616E6765207468- <1> .display_string:    db "Change the video mode", 0
    78 00000533 6520766964656F206D- <1>
    78 0000053C 6F646500            <1>
    79 00000540 546869732077696C6C- <1> .display_restart1:  db "This will restart KronkOS", 0
    79 00000549 207265737461727420- <1>
    79 00000552 4B726F6E6B4F5300    <1>
    80 0000055A 507265737320274F4B- <1> .display_restart2:  db "Press 'OK' to continue", 0
    80 00000563 2720746F20636F6E74- <1>
    80 0000056C 696E756500          <1>
   352                                      %include "./includes/cli.asm"
     1                              <1> kronk_cli:
     2 00000571 B80000              <1>     mov ax, 0
     3 00000574 B70F                <1>     mov bh, cli_color
     4 00000576 E8B70E              <1>     call switch_mode
     5                              <1>     
     6                              <1>     ; Disable color blinking
     7 00000579 B80310              <1>     mov ax, 0x1003
     8 0000057C BB0000              <1>     mov bx, 0x0000
     9 0000057F CD10                <1>     int 0x10
    10                              <1> 
    11                              <1>     ; Draw welcome menu
    12 00000581 BE[5102]            <1>     mov si, welcome_msg1
    13 00000584 E89115              <1>     call welcome_print
    14                              <1> 
    15 00000587 B488                <1>     mov ah, 0x88
    16 00000589 CD15                <1>     int 0x15
    17 0000058B E84D09              <1>     call int_to_string
    18 0000058E 89C6                <1>     mov si, ax
    19 00000590 E88515              <1>     call welcome_print
    20                              <1> 
    21 00000593 BE[8402]            <1>     mov si, welcome_msg2
    22 00000596 E87F15              <1>     call welcome_print
    23 00000599 BE[AE02]            <1>     mov si, welcome_msg3
    24 0000059C E87915              <1>     call welcome_print
    25                              <1> 
    26 0000059F B80A0E              <1>     mov ax, 0x0e0a
    27 000005A2 CD10                <1>     int 0x10
    28                              <1> 
    29                              <1> ; The loop that gets the input
    30                              <1> .input_loop:
    31                              <1>     ; Change the cursor to a solid block
    32 000005A4 B500                <1>     mov ch, 0x00
    33 000005A6 E8030C              <1>     call change_cursor
    34                              <1> 
    35 000005A9 E86B04              <1>     call check_pos
    36 000005AC E88E04              <1>     call draw_menu_bar
    37                              <1> 
    38                              <1>     ; Print the username and the input msg
    39                              <1>     ;mov si, usrNam
    40                              <1>     ;call print
    41 000005AF BE[A701]            <1>     mov si, in_msg
    42 000005B2 E85515              <1>     call print
    43                              <1> 
    44                              <1>     ; Get the input and save it in in_buffer 
    45 000005B5 E87A14              <1>     call get_input
    46                              <1> 
    47                              <1>     ; Check the input
    48 000005B8 B8[FD01]            <1>     mov ax, settings_com
    49 000005BB E8B01E              <1>     call check_com
    50 000005BE 0F83C400            <1>     jnc .settings
    51                              <1> 
    52 000005C2 B8[0602]            <1>     mov ax, clear_com
    53 000005C5 E8A61E              <1>     call check_com
    54 000005C8 0F83C000            <1>     jnc .clear
    55                              <1> 
    56 000005CC B8[0C02]            <1>     mov ax, dir_com
    57 000005CF E89C1E              <1>     call check_com
    58 000005D2 0F83BE00            <1>     jnc .dir
    59                              <1> 
    60 000005D6 B8[1002]            <1>     mov ax, help_com
    61 000005D9 E8921E              <1>     call check_com
    62 000005DC 0F836301            <1>     jnc .show_help
    63                              <1>     
    64                              <1>     ; ----------------------------------
    65                              <1>     ; MK AND RM
    66                              <1> 
    67 000005E0 60                  <1>     pusha
    68                              <1> 
    69 000005E1 BE[AE01]            <1>     mov si, in_buffer+3
    70 000005E4 BF[A809]            <1>     mov di, .tmp_filename
    71 000005E7 E81108              <1>     call string_copy
    72                              <1> 
    73 000005EA BE[AB01]            <1>     mov si, in_buffer
    74 000005ED BF[BC09]            <1>     mov di, .tmp_inbuffer
    75 000005F0 E80808              <1>     call string_copy
    76                              <1> 
    77 000005F3 BE[AB01]            <1>     mov si, in_buffer
    78 000005F6 B80200              <1>     mov ax, 2
    79 000005F9 E80808              <1>     call string_truncate
    80                              <1>     
    81 000005FC B8[1F02]            <1>     mov ax, mk_com
    82 000005FF E86C1E              <1>     call check_com
    83 00000602 0F831003            <1>     jnc .make_file
    84                              <1> 
    85 00000606 B8[2202]            <1>     mov ax, rm_com
    86 00000609 E8621E              <1>     call check_com
    87 0000060C 0F833103            <1>     jnc .remove_file
    88                              <1> 
    89 00000610 BE[BC09]            <1>     mov si, .tmp_inbuffer
    90 00000613 BF[AB01]            <1>     mov di, in_buffer
    91 00000616 E8E207              <1>     call string_copy
    92                              <1> 
    93 00000619 61                  <1>     popa
    94                              <1> 
    95                              <1>     ; ----------------------------------
    96                              <1>     ; LOAD AND EDIT
    97                              <1> 
    98 0000061A 60                  <1>     pusha
    99                              <1> 
   100 0000061B BE[B001]            <1>     mov si, in_buffer+5
   101 0000061E BF[A809]            <1>     mov di, .tmp_filename
   102 00000621 E8D707              <1>     call string_copy
   103                              <1> 
   104 00000624 BE[AB01]            <1>     mov si, in_buffer
   105 00000627 BF[BC09]            <1>     mov di, .tmp_inbuffer
   106 0000062A E8CE07              <1>     call string_copy
   107                              <1> 
   108 0000062D BE[AB01]            <1>     mov si, in_buffer
   109 00000630 B80400              <1>     mov ax, 4
   110 00000633 E8CE07              <1>     call string_truncate
   111                              <1> 
   112 00000636 B8[1A02]            <1>     mov ax, load_com
   113 00000639 E8321E              <1>     call check_com
   114 0000063C 0F832C03            <1>     jnc .load_file
   115                              <1> 
   116 00000640 BE[BC09]            <1>     mov si, .tmp_inbuffer
   117 00000643 BF[AB01]            <1>     mov di, in_buffer
   118 00000646 E8B207              <1>     call string_copy
   119                              <1> 
   120 00000649 61                  <1>     popa
   121                              <1> 
   122 0000064A B8[EC01]            <1>     mov ax, restart_com
   123 0000064D E81E1E              <1>     call check_com
   124 00000650 0F833403            <1>     jnc .restart
   125                              <1> 
   126 00000654 B8[F401]            <1>     mov ax, shutdown_com
   127 00000657 E8141E              <1>     call check_com
   128 0000065A 0F833203            <1>     jnc .shutdown
   129 0000065E 7200                <1>     jc .not_equal
   130                              <1> 
   131                              <1> .not_equal:
   132 00000660 B40E                <1>     mov ah, 0x0e
   133 00000662 B00A                <1>     mov al, 0x0a
   134 00000664 CD10                <1>     int 0x10
   135                              <1> 
   136 00000666 B40E                <1>     mov ah, 0x0e
   137 00000668 B022                <1>     mov al, '"'
   138 0000066A CD10                <1>     int 0x10
   139                              <1> 
   140 0000066C BE[AB01]            <1>     mov si, in_buffer
   141 0000066F E89814              <1>     call print
   142                              <1> 
   143 00000672 B40E                <1>     mov ah, 0x0e
   144 00000674 B022                <1>     mov al, '"'
   145 00000676 CD10                <1>     int 0x10
   146                              <1>     
   147 00000678 BE[D401]            <1>     mov si, not_com
   148 0000067B E88C14              <1>     call print
   149                              <1>     
   150                              <1>     ; Create a new line
   151 0000067E B80A0E              <1>     mov ax, 0x0e0a
   152 00000681 CD10                <1>     int 0x10
   153                              <1> 
   154 00000683 E91EFF              <1>     jmp .input_loop
   155                              <1> 
   156                              <1> ; ----------------------------------
   157                              <1> ; SETTINGS
   158                              <1> 
   159                              <1> .settings:
   160 00000686 E8C7FD              <1>     call show_settings
   161 00000689 E918FF              <1>     jmp .input_loop
   162                              <1> 
   163                              <1> ; ----------------------------------
   164                              <1> ; CLEAR
   165                              <1> 
   166                              <1> .clear:
   167 0000068C B70F                <1>     mov bh, cli_color
   168 0000068E E8CB06              <1>     call cls
   169 00000691 E910FF              <1>     jmp .input_loop
   170                              <1> 
   171                              <1> ; ----------------------------------
   172                              <1> ; DIR
   173                              <1> 
   174                              <1> .dir:
   175 00000694 31C0                <1>     xor ax, ax
   176 00000696 E84916              <1>     call os_get_file_list
   177                              <1> 
   178 00000699 50                  <1>     push ax
   179 0000069A B80A0E              <1>     mov ax, 0x0e0a
   180 0000069D CD10                <1>     int 0x10
   181 0000069F CD10                <1>     int 0x10
   182 000006A1 B00D                <1>     mov al, 0x0d
   183 000006A3 CD10                <1>     int 0x10
   184 000006A5 58                  <1>     pop ax
   185                              <1> 
   186 000006A6 89C6                <1>     mov si, ax
   187 000006A8 BF[A809]            <1>     mov di, .tmp_filename
   188 000006AB BA0000              <1>     mov dx, 0
   189                              <1> 
   190 000006AE B40E                <1>     mov ah, 0x0e
   191 000006B0 B020                <1>     mov al, ' '
   192 000006B2 CD10                <1>     int 0x10
   193                              <1> 
   194                              <1>     .loop:
   195 000006B4 AC                  <1>         lodsb
   196 000006B5 3C2C                <1>         cmp al, ','
   197 000006B7 740C                <1>         je .add_size
   198 000006B9 3C00                <1>         cmp al, 0
   199 000006BB 744C                <1>         je .done
   200                              <1> 
   201 000006BD AA                  <1>         stosb
   202 000006BE 42                  <1>         inc dx
   203                              <1> 
   204 000006BF B40E                <1>         mov ah, 0x0e
   205 000006C1 CD10                <1>         int 0x10
   206                              <1> 
   207 000006C3 EBEF                <1>         jmp .loop
   208                              <1> 
   209                              <1>     .add_size:
   210 000006C5 60                  <1>         pusha
   211 000006C6 83FA0C              <1>         cmp dx, 12
   212 000006C9 7D03                <1>         jge .continue
   213                              <1> 
   214 000006CB E82F00              <1>         call .add_spaces
   215                              <1> 
   216                              <1>         .continue:
   217 000006CE BE[E509]            <1>         mov si, .file_size_sep
   218 000006D1 E83614              <1>         call print
   219                              <1> 
   220 000006D4 89D0                <1>         mov ax, dx
   221 000006D6 E82B07              <1>         call string_truncate
   222                              <1> 
   223 000006D9 B8[A809]            <1>         mov ax, .tmp_filename
   224 000006DC E8F61B              <1>         call os_get_file_size
   225                              <1> 
   226 000006DF 89D8                <1>         mov ax, bx
   227 000006E1 E8F707              <1>         call int_to_string
   228 000006E4 89C6                <1>         mov si, ax
   229 000006E6 E82114              <1>         call print
   230                              <1> 
   231 000006E9 BE[F703]            <1>         mov si, file_size_typ
   232 000006EC E81B14              <1>         call print
   233                              <1> 
   234 000006EF B8200E              <1>         mov ax, 0x0e20
   235 000006F2 CD10                <1>         int 0x10
   236                              <1> 
   237 000006F4 61                  <1>         popa
   238                              <1> 
   239 000006F5 BF[A809]            <1>         mov di, .tmp_filename
   240 000006F8 BA0000              <1>         mov dx, 0
   241 000006FB EBB7                <1>         jmp .loop
   242                              <1> 
   243                              <1>     .add_spaces:
   244 000006FD B8200E              <1>         mov ax, 0x0e20
   245 00000700 CD10                <1>         int 0x10
   246 00000702 42                  <1>         inc dx
   247 00000703 83FA0C              <1>         cmp dx, 12
   248 00000706 75F5                <1>         jne .add_spaces
   249 00000708 C3                  <1>         ret
   250                              <1> 
   251                              <1>     .done:
   252 00000709 83FA0C              <1>         cmp dx, 12
   253 0000070C 7D03                <1>         jge .done_c
   254                              <1> 
   255 0000070E E8ECFF              <1>         call .add_spaces
   256                              <1> 
   257                              <1>         .done_c:
   258 00000711 BE[E509]            <1>         mov si, .file_size_sep
   259 00000714 E8F313              <1>         call print
   260                              <1> 
   261 00000717 BE[A809]            <1>         mov si, .tmp_filename
   262 0000071A 89D0                <1>         mov ax, dx
   263 0000071C E8E506              <1>         call string_truncate
   264                              <1> 
   265 0000071F B8[A809]            <1>         mov ax, .tmp_filename
   266 00000722 E8B01B              <1>         call os_get_file_size
   267                              <1> 
   268 00000725 89D8                <1>         mov ax, bx
   269 00000727 E8B107              <1>         call int_to_string
   270 0000072A 89C6                <1>         mov si, ax
   271 0000072C E8DB13              <1>         call print
   272                              <1> 
   273 0000072F BE[EA09]            <1>         mov si, .file_size_typ
   274 00000732 E8D513              <1>         call print
   275                              <1> 
   276 00000735 50                  <1>     push ax
   277                              <1> 
   278 00000736 B80A0E              <1>     mov ax, 0x0e0a
   279 00000739 CD10                <1>     int 0x10
   280 0000073B B00D                <1>     mov al, 0x0d
   281 0000073D CD10                <1>     int 0x10
   282                              <1> 
   283 0000073F 58                  <1>     pop ax
   284                              <1> 
   285 00000740 E961FE              <1>     jmp .input_loop
   286                              <1> 
   287                              <1> ; ----------------------------------
   288                              <1> ; HELP
   289                              <1> 
   290                              <1> .show_help:
   291 00000743 B8[7307]            <1>     mov ax, .help_commands
   292 00000746 BB[E508]            <1>     mov bx, .help_header
   293 00000749 B9[EF08]            <1>     mov cx, .help_string
   294 0000074C E81711              <1>     call list_dialog
   295                              <1> 
   296 0000074F 83F804              <1>     cmp ax, 4
   297 00000752 0F8430FF            <1>     je .settings
   298                              <1>     
   299 00000756 B70F                <1>     mov bh, cli_color
   300 00000758 E80106              <1>     call cls
   301                              <1> 
   302 0000075B 83F802              <1>     cmp ax, 2
   303 0000075E 0F8432FF            <1>     je .dir
   304 00000762 83F809              <1>     cmp ax, 9
   305 00000765 0F841F02            <1>     je .restart
   306 00000769 83F80A              <1>     cmp ax, 10
   307 0000076C 0F842002            <1>     je .shutdown
   308                              <1> 
   309 00000770 E931FE              <1>     jmp .input_loop
   310                              <1> 
   311 00000773 48454C502020202020- <1>     .help_commands:     db "HELP       --  What you're looking at,"
   311 0000077C 20202D2D2020576861- <1>
   311 00000785 7420796F7527726520- <1>
   311 0000078E 6C6F6F6B696E672061- <1>
   311 00000797 742C                <1>
   312 00000799 444952202020202020- <1>                         db "DIR        --  Show a list of all files,"
   312 000007A2 20202D2D202053686F- <1>
   312 000007AB 772061206C69737420- <1>
   312 000007B4 6F6620616C6C206669- <1>
   312 000007BD 6C65732C            <1>
   313 000007C1 434C45415220202020- <1>                         db "CLEAR      --  Clear the terminal,"
   313 000007CA 20202D2D2020436C65- <1>
   313 000007D3 617220746865207465- <1>
   313 000007DC 726D696E616C2C      <1>
   314 000007E3 53455454494E475320- <1>                         db "SETTINGS   --  Show the settings menu,"
   314 000007EC 20202D2D202053686F- <1>
   314 000007F5 772074686520736574- <1>
   314 000007FE 74696E6773206D656E- <1>
   314 00000807 752C                <1>
   315 00000809 4D4B2046494C452020- <1>                         db "MK FILE    --  Create a file,"
   315 00000812 20202D2D2020437265- <1>
   315 0000081B 61746520612066696C- <1>
   315 00000824 652C                <1>
   316 00000826 524D2046494C452020- <1>                         db "RM FILE    --  Delete a file,"
   316 0000082F 20202D2D202044656C- <1>
   316 00000838 65746520612066696C- <1>
   316 00000841 652C                <1>
   317 00000843 4C4F41442046494C45- <1>                         db "LOAD FILE  --  Load/run a file,"
   317 0000084C 20202D2D20204C6F61- <1>
   317 00000855 642F72756E20612066- <1>
   317 0000085E 696C652C            <1>
   318 00000862 454449542046494C45- <1>                         db "EDIT FILE  --  Load and edit a file,"
   318 0000086B 20202D2D20204C6F61- <1>
   318 00000874 6420616E6420656469- <1>
   318 0000087D 7420612066696C652C  <1>
   319 00000886 524553544152542020- <1>                         db "RESTART    --  Restart KronkOS,"
   319 0000088F 20202D2D2020526573- <1>
   319 00000898 74617274204B726F6E- <1>
   319 000008A1 6B4F532C            <1>
   320 000008A5 53485554444F574E20- <1>                         db "SHUTDOWN   --  Shutdown KronkOS,,"
   320 000008AE 20202D2D2020536875- <1>
   320 000008B7 74646F776E204B726F- <1>
   320 000008C0 6E6B4F532C2C        <1>
   321 000008C6 43414E43454C202020- <1>                         db "CANCEL     --  Leave this menu", 0
   321 000008CF 20202D2D20204C6561- <1>
   321 000008D8 76652074686973206D- <1>
   321 000008E1 656E7500            <1>
   322 000008E5 48454C50204D454E55- <1>     .help_header:       db "HELP MENU", 0
   322 000008EE 00                  <1>
   323 000008EF 507265737320454E54- <1>     .help_string:       db "Press ENTER to run any of the commands", 0
   323 000008F8 455220746F2072756E- <1>
   323 00000901 20616E79206F662074- <1>
   323 0000090A 686520636F6D6D616E- <1>
   323 00000913 647300              <1>
   324                              <1> 
   325                              <1> ; ----------------------------------
   326                              <1> ; MAKE FILE
   327                              <1> 
   328                              <1> .make_file:
   329 00000916 60                  <1>     pusha
   330 00000917 B8[A809]            <1>     mov ax, .tmp_filename
   331 0000091A E87518              <1>     call os_create_file
   332                              <1>     
   333 0000091D B80A0E              <1>     mov ax, 0x0e0a
   334 00000920 CD10                <1>     int 0x10
   335 00000922 B00D                <1>     mov al, 0x0d
   336 00000924 CD10                <1>     int 0x10
   337                              <1> 
   338 00000926 BE[A809]            <1>     mov si, .tmp_filename
   339 00000929 E8DE11              <1>     call print
   340 0000092C BE[050A]            <1>     mov si, .tmp_filemk
   341 0000092F E8D811              <1>     call print
   342                              <1> 
   343 00000932 B80A0E              <1>     mov ax, 0x0e0a
   344 00000935 CD10                <1>     int 0x10
   345 00000937 CD10                <1>     int 0x10
   346 00000939 B00D                <1>     mov al, 0x0d
   347 0000093B CD10                <1>     int 0x10
   348                              <1> 
   349 0000093D 61                  <1>     popa
   350                              <1> 
   351 0000093E E963FC              <1>     jmp .input_loop
   352                              <1> 
   353                              <1> ; ----------------------------------
   354                              <1> ; REMOVE FILE
   355                              <1> 
   356                              <1> .remove_file:
   357 00000941 60                  <1>     pusha
   358 00000942 B8[A809]            <1>     mov ax, .tmp_filename
   359 00000945 E8D918              <1>     call os_remove_file
   360                              <1>     
   361 00000948 B80A0E              <1>     mov ax, 0x0e0a
   362 0000094B CD10                <1>     int 0x10
   363 0000094D B00D                <1>     mov al, 0x0d
   364 0000094F CD10                <1>     int 0x10
   365                              <1> 
   366 00000951 BE[A809]            <1>     mov si, .tmp_filename
   367 00000954 E8B311              <1>     call print
   368 00000957 BE[F309]            <1>     mov si, .tmp_filerm
   369 0000095A E8AD11              <1>     call print
   370                              <1> 
   371 0000095D B80A0E              <1>     mov ax, 0x0e0a
   372 00000960 CD10                <1>     int 0x10
   373 00000962 CD10                <1>     int 0x10
   374 00000964 B00D                <1>     mov al, 0x0d
   375 00000966 CD10                <1>     int 0x10
   376                              <1> 
   377 00000968 61                  <1>     popa
   378                              <1> 
   379 00000969 E938FC              <1>     jmp .input_loop
   380                              <1> 
   381                              <1> ; ----------------------------------
   382                              <1> ; LOAD FILE
   383                              <1> 
   384                              <1> .load_file:
   385 0000096C 60                  <1>     pusha
   386 0000096D 31C0                <1>     xor ax, ax
   387                              <1> 
   388 0000096F B8[A809]            <1>     mov ax, .tmp_filename
   389 00000972 E8A5F7              <1>     call try_run_file
   390 00000975 7204                <1>     jc .not_found
   391                              <1> 
   392 00000977 61                  <1>     popa
   393 00000978 E929FC              <1>     jmp .input_loop
   394                              <1> 
   395                              <1>     .not_found:
   396 0000097B BE[D803]            <1>         mov si, notfound_msg
   397 0000097E E88911              <1>         call print
   398                              <1> 
   399 00000981 61                  <1>         popa
   400 00000982 E91FFC              <1>         jmp .input_loop
   401                              <1> 
   402                              <1> ; ----------------------------------
   403                              <1> ; EDIT FILE
   404                              <1> 
   405                              <1> .edit_file:
   406 00000985 E91CFC              <1>     jmp .input_loop
   407                              <1> 
   408                              <1> ; ----------------------------------
   409                              <1> ; RESTART
   410                              <1> 
   411                              <1> .restart:
   412 00000988 B80000              <1>     mov ax, 0x00
   413 0000098B CD13                <1>     int 0x13
   414 0000098D CD19                <1>     int 0x19
   415                              <1> 
   416                              <1>     ; Halt cpu if restart fails
   417 0000098F F4                  <1>     hlt
   418                              <1> 
   419                              <1> ; ----------------------------------
   420                              <1> ; SHUTDOWN
   421                              <1> 
   422                              <1> .shutdown:
   423 00000990 31C0                <1>     xor ax, ax
   424 00000992 CD13                <1>     int 0x13
   425                              <1> 
   426 00000994 B80010              <1>     mov ax, 0x1000
   427 00000997 8CD0                <1>     mov ax, ss
   428 00000999 BC00F0              <1>     mov sp, 0xf000
   429 0000099C B80753              <1>     mov ax, 0x5307
   430 0000099F BB0100              <1>     mov bx, 0x0001
   431 000009A2 B90300              <1>     mov cx, 0x0003
   432 000009A5 CD15                <1>     int 0x15
   433                              <1> 
   434                              <1>     ; Halt cpu if shutdown fails
   435 000009A7 F4                  <1>     hlt
   436                              <1> 
   437                              <1> 
   438 000009A8 00<rept>            <1> .tmp_filename:      times 20 db 0
   439 000009BC 00<rept>            <1> .tmp_inbuffer:      times 41 db 0
   440 000009E5 202D2D2000          <1> .file_size_sep:		db " -- ", 0
   441 000009EA 2042797465730A0D00  <1> .file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   442 000009F3 20686173206265656E- <1> .tmp_filerm:        db " has been deleted", 0
   442 000009FC 2064656C6574656400  <1>
   443 00000A05 20686173206265656E- <1> .tmp_filemk:        db " has been created", 0
   443 00000A0E 206372656174656400  <1>
   353                                      %include "./includes/menubar.asm"
     1                              <1> check_pos:
     2 00000A17 60                  <1>     pusha
     3                              <1> 
     4 00000A18 B403                <1>     mov ah, 0x03
     5 00000A1A 30FF                <1>     xor bh, bh
     6 00000A1C CD10                <1>     int 0x10
     7                              <1> 
     8 00000A1E 80FE18              <1>     cmp dh, 24
     9 00000A21 7402                <1>     je .at_end
    10                              <1> 
    11 00000A23 61                  <1>     popa
    12 00000A24 C3                  <1>     ret
    13                              <1> 
    14                              <1> .at_end:
    15 00000A25 B80306              <1>     mov ax, 0x0603
    16 00000A28 B70F                <1>     mov bh, cli_color
    17 00000A2A BA4F18              <1> 	mov dx, 0x184f
    18 00000A2D 31C9                <1> 	xor cx, cx
    19 00000A2F CD10                <1>     int 0x10
    20                              <1> 
    21 00000A31 B402                <1>     mov ah, 0x02
    22 00000A33 30FF                <1>     xor bh, bh
    23 00000A35 30D2                <1>     xor dl, dl
    24 00000A37 B615                <1>     mov dh, 21
    25 00000A39 CD10                <1>     int 0x10
    26                              <1> 
    27 00000A3B 61                  <1>     popa
    28 00000A3C C3                  <1>     ret
    29                              <1> 
    30                              <1> draw_menu_bar:
    31 00000A3D 60                  <1>     pusha
    32                              <1> 
    33 00000A3E B403                <1>     mov ah, 0x03
    34 00000A40 30FF                <1>     xor bh, bh
    35 00000A42 CD10                <1>     int 0x10
    36                              <1> 
    37 00000A44 52                  <1>     push dx
    38                              <1> 
    39 00000A45 B80407              <1>     mov ax, 0x0704
    40 00000A48 B70F                <1>     mov bh, cli_color
    41 00000A4A BA4F18              <1> 	mov dx, 0x184f
    42 00000A4D 31C9                <1> 	xor cx, cx
    43 00000A4F CD10                <1>     int 0x10
    44 00000A51 B80406              <1>     mov ax, 0x0604
    45 00000A54 CD10                <1>     int 0x10
    46                              <1>     
    47 00000A56 B402                <1>     mov ah, 0x02
    48 00000A58 B618                <1>     mov dh, 24
    49 00000A5A 30FF                <1>     xor bh, bh
    50 00000A5C 30D2                <1>     xor dl, dl
    51 00000A5E CD10                <1>     int 0x10
    52                              <1> 
    53 00000A60 BE[0004]            <1>     mov si, mb_fill
    54 00000A63 B330                <1>     mov bl, mb_color
    55 00000A65 E8DB10              <1>     call print_atr
    56                              <1> 
    57 00000A68 B402                <1>     mov ah, 0x02
    58 00000A6A B618                <1>     mov dh, 24
    59 00000A6C B201                <1>     mov dl, 1
    60 00000A6E 30FF                <1>     xor bh, bh
    61 00000A70 CD10                <1>     int 0x10
    62                              <1> 
    63 00000A72 E82505              <1>     call get_time_string
    64 00000A75 89DE                <1>     mov si, bx
    65 00000A77 B330                <1>     mov bl, mb_color
    66 00000A79 E8C710              <1>     call print_atr
    67                              <1> 
    68 00000A7C B402                <1>     mov ah, 0x02
    69 00000A7E B618                <1>     mov dh, 24
    70 00000A80 B21C                <1>     mov dl, 28
    71 00000A82 30FF                <1>     xor bh, bh
    72 00000A84 CD10                <1>     int 0x10
    73                              <1> 
    74 00000A86 B8[7901]            <1>     mov ax, usrNam
    75 00000A89 E83503              <1>     call string_uppercase
    76 00000A8C 89C6                <1>     mov si, ax
    77 00000A8E B330                <1>     mov bl, mb_color
    78 00000A90 E8B010              <1>     call print_atr
    79                              <1> 
    80 00000A93 B402                <1>     mov ah, 0x02
    81 00000A95 B618                <1>     mov dh, 24
    82 00000A97 B245                <1>     mov dl, 69
    83 00000A99 30FF                <1>     xor bh, bh
    84 00000A9B CD10                <1>     int 0x10
    85                              <1> 
    86 00000A9D E8B105              <1>     call get_date_string
    87 00000AA0 89DE                <1>     mov si, bx
    88 00000AA2 B330                <1>     mov bl, mb_color
    89 00000AA4 E89C10              <1>     call print_atr
    90                              <1> 
    91 00000AA7 B402                <1>     mov ah, 0x02
    92 00000AA9 30FF                <1>     xor bh, bh
    93 00000AAB 30D2                <1>     xor dl, dl
    94 00000AAD 5A                  <1>     pop dx
    95 00000AAE CD10                <1>     int 0x10
    96                              <1> 
    97 00000AB0 61                  <1>     popa
    98 00000AB1 C3                  <1>     ret
   354                                      %include "./includes/video.asm"
     1                              <1> kronk_vid:
     2 00000AB2 B80100              <1>     mov ax, 1
     3 00000AB5 B701                <1>     mov bh, vid_backcolor
     4 00000AB7 E87609              <1>     call switch_mode
     5                              <1>     
     6                              <1>     ; Disable color blinking
     7 00000ABA B80310              <1>     mov ax, 0x1003
     8 00000ABD BB0000              <1>     mov bx, 0x0000
     9 00000AC0 CD10                <1>     int 0x10
    10                              <1> 
    11                              <1>     ; Initalize and enable the mouse if possible
    12 00000AC2 E8A710              <1>     call mouse_initialize
    13 00000AC5 720A                <1>     jc vid_input
    14 00000AC7 B001                <1>     mov al, 1
    15 00000AC9 A2[D20A]            <1>     mov [mouse_working], al
    16 00000ACC E8CB10              <1>     call mouse_enable
    17 00000ACF EB00                <1>     jmp vid_input
    18                              <1> 
    19                              <1> vid_input:
    20                              <1>     ;mov si, mb_string
    21                              <1>     ;xor bh, bh
    22                              <1>     ;mov bl, vid_forecolor
    23                              <1>     ;call print_atr
    24                              <1> 
    25                              <1>     ;mov bh, vid_backcolor
    26                              <1>     ;call cls
    27                              <1> 
    28                              <1>     ;mov al, [mouse_working]
    29                              <1>     ;cmp al, 0
    30                              <1>     ;call mouse_loop
    31                              <1>     ;call move_cursor
    32                              <1> 
    33                              <1>     ;mov si, sejt
    34                              <1>     ;xor bh, bh
    35                              <1>     ;mov bl, vid_forecolor
    36                              <1>     ;call print_atr
    37                              <1> 
    38 00000AD1 F4                  <1>     hlt
    39                              <1> 
    40                              <1> ; ------------------------------------------------------------------
    41                              <1> ; STRINGS AND OTHER VARIABLES
    42                              <1> 
    43 00000AD2 00                  <1>     mouse_working:      db 0
    44 00000AD3 2000                <1>     sejt:               db " ", 0
   355                                      %include "./includes/setup.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; The Kronk Operating System setup file
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; This is loaded from the drive by KERNEL.BIN, at first boot
     6                              <1> ; ==================================================================
     7                              <1> setup_init:
     8                              <1> 
     9                              <1>     ; Color variables
    10                              <1>     basic_colors    equ 0x1F
    11                              <1>     marked_colors   equ 0x1E
    12                              <1> 
    13                              <1>     ; Setup text box variables
    14                              <1>     edge_width      equ 14
    15                              <1>     border_length   equ 50
    16                              <1>     
    17                              <1>     ; Disable color blinking
    18 00000AD5 B80310              <1>     mov ax, 0x1003
    19 00000AD8 BB0000              <1>     mov bx, 0x0000
    20 00000ADB CD10                <1>     int 0x10
    21                              <1> 
    22 00000ADD EB00                <1>     jmp setup_start
    23                              <1> 
    24                              <1> ; ******************************************************************
    25                              <1> ; Start the setup
    26                              <1> setup_start:
    27 00000ADF 60                  <1>     pusha
    28 00000AE0 B71F                <1>     mov bh, basic_colors
    29 00000AE2 E87702              <1>     call cls
    30                              <1> 
    31 00000AE5 BE[470D]            <1>     mov si, setup_string
    32 00000AE8 E86C09              <1>     call setup_bottom_string
    33                              <1> 
    34 00000AEB BE[6C0B]            <1>     mov si, usr_set
    35 00000AEE E8290C              <1>     call draw_setup_box
    36                              <1> 
    37 00000AF1 B8[580B]            <1>     mov ax, usr_save
    38 00000AF4 E87809              <1>     call setup_input
    39                              <1> 
    40 00000AF7 B71F                <1>     mov bh, basic_colors
    41 00000AF9 E86002              <1>     call cls
    42                              <1> 
    43 00000AFC BE[9B0B]            <1>     mov si, vid_set
    44 00000AFF E8180C              <1>     call draw_setup_box
    45                              <1> 
    46 00000B02 B8[120D]            <1>     mov ax, vid_opt1
    47 00000B05 BB[1B0D]            <1>     mov bx, vid_opt2
    48 00000B08 B9[260D]            <1>     mov cx, vid_opt3
    49 00000B0B BAE11F              <1>     mov dx, 0x1fe1
    50 00000B0E E8560A              <1>     call setup_choose
    51                              <1> 
    52 00000B11 83F802              <1>     cmp ax, 2
    53 00000B14 7517                <1>     jne .setup_done
    54                              <1> 
    55                              <1>     ; User has choosen "cancel" and KronkOS will therefore shutdown
    56 00000B16 31C0                <1>     xor ax, ax
    57 00000B18 CD13                <1>     int 0x13
    58                              <1> 
    59 00000B1A B80010              <1>     mov ax, 0x1000
    60 00000B1D 8CD0                <1>     mov ax, ss
    61 00000B1F BC00F0              <1>     mov sp, 0xf000
    62 00000B22 B80753              <1>     mov ax, 0x5307
    63 00000B25 BB0100              <1>     mov bx, 0x0001
    64 00000B28 B90300              <1>     mov cx, 0x0003
    65 00000B2B CD15                <1>     int 0x15
    66                              <1> 
    67                              <1> .setup_done:
    68 00000B2D A3[8E01]            <1>     mov [vidMode], ax
    69                              <1> 
    70 00000B30 BE[580B]            <1>     mov si, usr_save
    71 00000B33 BF[7901]            <1>     mov di, usrNam
    72 00000B36 E8C202              <1>     call string_copy
    73                              <1> 
    74 00000B39 61                  <1>     popa
    75 00000B3A C3                  <1>     ret
    76                              <1> 
    77                              <1> ; ******************************************************************
    78                              <1> 
    79                              <1> ; ------------------------------------------------------------------
    80                              <1> ; VARIABLES
    81 00000B3B 766964656F6D6F6465- <1>     vidmode_save:   db "videomode,", 0
    81 00000B44 2C00                <1>
    82 00000B46 300A0D00            <1>     cli_save:       db "0", 0x0a, 0x0d, 0
    83 00000B4A 310A0D00            <1>     vid_save:       db "1", 0x0a, 0x0d, 0
    84 00000B4E 757365726E616D652C- <1>     usrname_save:   db "username,", 0
    84 00000B57 00                  <1>
    85 00000B58 00<rept>            <1>     usr_save:       times 20 db 0
    86                              <1> 
    87 00000B6C 506C6561736520656E- <1>     usr_set:    db "Please enter your username, and press enter...", 0
    87 00000B75 74657220796F757220- <1>
    87 00000B7E 757365726E616D652C- <1>
    87 00000B87 20616E642070726573- <1>
    87 00000B90 7320656E7465722E2E- <1>
    87 00000B99 2E00                <1>
    88                              <1> 
    89 00000B9B 506C65617365206368- <1>     vid_set:    db "Please choose a standard view mode...", 0x0a, 0x0a
    89 00000BA4 6F6F73652061207374- <1>
    89 00000BAD 616E64617264207669- <1>
    89 00000BB6 6577206D6F64652E2E- <1>
    89 00000BBF 2E0A0A              <1>
    90 00000BC2 564944454F204D4F44- <1>                 db "VIDEO MODE is for the more casual user, that", 0x0a, "just want to be able to use KronkOS with ease by using a nice graphical interface.", 0x0a, 0x0a
    90 00000BCB 4520697320666F7220- <1>
    90 00000BD4 746865206D6F726520- <1>
    90 00000BDD 63617375616C207573- <1>
    90 00000BE6 65722C20746861740A- <1>
    90 00000BEF 6A7573742077616E74- <1>
    90 00000BF8 20746F206265206162- <1>
    90 00000C01 6C6520746F20757365- <1>
    90 00000C0A 204B726F6E6B4F5320- <1>
    90 00000C13 776974682065617365- <1>
    90 00000C1C 206279207573696E67- <1>
    90 00000C25 2061206E6963652067- <1>
    90 00000C2E 726170686963616C20- <1>
    90 00000C37 696E74657266616365- <1>
    90 00000C40 2E0A0A              <1>
    91 00000C43 434C49204D4F444520- <1>                 db "CLI MODE is for the more advanced user, where", 0x0a, "instead of pressing buttons, you use commands to", 0x0a, "execute the various actions you desire.", 0x0a, 0x0a
    91 00000C4C 697320666F72207468- <1>
    91 00000C55 65206D6F7265206164- <1>
    91 00000C5E 76616E636564207573- <1>
    91 00000C67 65722C207768657265- <1>
    91 00000C70 0A696E737465616420- <1>
    91 00000C79 6F6620707265737369- <1>
    91 00000C82 6E6720627574746F6E- <1>
    91 00000C8B 732C20796F75207573- <1>
    91 00000C94 6520636F6D6D616E64- <1>
    91 00000C9D 7320746F0A65786563- <1>
    91 00000CA6 757465207468652076- <1>
    91 00000CAF 6172696F7573206163- <1>
    91 00000CB8 74696F6E7320796F75- <1>
    91 00000CC1 206465736972652E0A- <1>
    91 00000CCA 0A                  <1>
    92 00000CCB 557365207468652061- <1>                 db "Use the arrow keys and 'ENTER' to select between the different options", 0
    92 00000CD4 72726F77206B657973- <1>
    92 00000CDD 20616E642027454E54- <1>
    92 00000CE6 45522720746F207365- <1>
    92 00000CEF 6C6563742062657477- <1>
    92 00000CF8 65656E207468652064- <1>
    92 00000D01 6966666572656E7420- <1>
    92 00000D0A 6F7074696F6E7300    <1>
    93                              <1> 
    94 00000D12 434C49204D4F444500  <1>     vid_opt1:   db "CLI MODE", 0
    95 00000D1B 564944454F204D4F44- <1>     vid_opt2:   db "VIDEO MODE", 0
    95 00000D24 4500                <1>
    96 00000D26 43616E63656C202857- <1>     vid_opt3:   db "Cancel (Will shutdown KronkOS)", 0
    96 00000D2F 696C6C207368757464- <1>
    96 00000D38 6F776E204B726F6E6B- <1>
    96 00000D41 4F532900            <1>
    97                              <1> 
    98 00000D45 0000                <1>     vid_chosen: dw 0
    99                              <1> 
   100 00000D47 204B726F6E6B4F5320- <1>     setup_string: db " KronkOS ", KRONKOS_VER, " setup", 0
   100 00000D50 302E332E3220736574- <1>
   100 00000D59 757000              <1>
   356                                      %include "./includes/cls.asm"
     1                              <1> cls:
     2 00000D5C 60                  <1>     pusha
     3                              <1>     
     4 00000D5D B406                <1>     mov ah, 0x06
     5 00000D5F BA4F18              <1>     mov dx, 0x184f
     6                              <1> 
     7 00000D62 30C0                <1>     xor al, al
     8 00000D64 31C9                <1>     xor cx, cx
     9                              <1> 
    10 00000D66 CD10                <1>     int 0x10
    11                              <1>     
    12 00000D68 B402                <1>     mov ah, 0x2
    13 00000D6A 31D2                <1>     xor dx, dx
    14 00000D6C 30FF                <1>     xor bh, bh
    15                              <1> 
    16 00000D6E CD10                <1>     int 0x10
    17                              <1>     
    18 00000D70 61                  <1>     popa
    19 00000D71 C3                  <1>     ret
   357                                      %include "./includes/string.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; KronkOS -- The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019-2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; STRING MANIPULATION ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; string_length -- Return length of a string
    10                              <1> ; IN: AX = string location
    11                              <1> ; OUT AX = length (other regs preserved)
    12                              <1> 
    13                              <1> string_length:
    14 00000D72 60                  <1>     pusha
    15 00000D73 89C3                <1>     mov bx, ax
    16 00000D75 B90000              <1>     mov cx, 0
    17                              <1> 
    18                              <1>     .more:
    19 00000D78 803F00              <1>         cmp byte [bx], 0
    20 00000D7B 7404                <1>         je .done
    21 00000D7D 43                  <1>         inc bx
    22 00000D7E 41                  <1>         inc cx
    23 00000D7F EBF7                <1>         jmp .more
    24                              <1> 
    25                              <1>     .done:
    26 00000D81 890E[8A0D]          <1>         mov word [.tmp_counter], cx
    27 00000D85 61                  <1>         popa
    28                              <1> 
    29 00000D86 A1[8A0D]            <1>         mov ax, [.tmp_counter]
    30 00000D89 C3                  <1>         ret
    31                              <1> 
    32 00000D8A 0000                <1>         .tmp_counter dw 0
    33                              <1> 
    34                              <1> ; ------------------------------------------------------------------
    35                              <1> ; find_char_in_string -- Find location of character in a string
    36                              <1> ; IN: SI = string location, AL = character to find
    37                              <1> ; OUT AX = location in string, or 0 if not present
    38                              <1> 
    39                              <1> find_char_in_string:
    40 00000D8C 60                  <1>     pusha
    41 00000D8D B90100              <1>     mov cx, 1
    42                              <1> 
    43                              <1>     .more:
    44 00000D90 3804                <1>         cmp byte [si], al
    45 00000D92 7409                <1>         je .done
    46 00000D94 803C00              <1>         cmp byte [si], 0
    47 00000D97 740D                <1>         je .notfound
    48                              <1>         
    49 00000D99 46                  <1>         inc si
    50 00000D9A 41                  <1>         inc cx
    51                              <1> 
    52 00000D9B EBF3                <1>         jmp .more
    53                              <1>     
    54                              <1>     .done:
    55 00000D9D 890E[AB0D]          <1>         mov [.tmp], cx
    56 00000DA1 61                  <1>         popa
    57 00000DA2 A1[AB0D]            <1>         mov ax, [.tmp]
    58                              <1> 
    59 00000DA5 C3                  <1>         ret
    60                              <1>     
    61                              <1>     .notfound:
    62 00000DA6 61                  <1>         popa
    63 00000DA7 B80000              <1>         mov ax, 0
    64                              <1> 
    65 00000DAA C3                  <1>         ret
    66                              <1> 
    67 00000DAB 0000                <1>     .tmp dw 0
    68                              <1> 
    69                              <1> ; ------------------------------------------------------------------
    70                              <1> ; string_charchange -- Change a character in a string
    71                              <1> ; IN: SI = string location, AL = char to find, BL = char to replace with
    72                              <1> 
    73                              <1> string_charchange:
    74 00000DAD 60                  <1>     pusha
    75 00000DAE 88C1                <1>     mov cl, al
    76                              <1> 
    77                              <1>     .loop:
    78 00000DB0 8A04                <1>         mov byte al, [si]
    79 00000DB2 3C00                <1>         cmp al, 0
    80 00000DB4 7409                <1>         je .finish
    81 00000DB6 38C8                <1>         cmp al, cl
    82 00000DB8 7502                <1>         jne .nochange
    83                              <1> 
    84 00000DBA 881C                <1>         mov byte [si], bl
    85                              <1> 
    86                              <1>     .nochange:
    87 00000DBC 46                  <1>         inc si
    88 00000DBD EBF1                <1>         jmp .loop
    89                              <1>     
    90                              <1>     .finish:
    91 00000DBF 61                  <1>         popa
    92 00000DC0 C3                  <1>         ret
    93                              <1> 
    94                              <1> ; ------------------------------------------------------------------
    95                              <1> ; string_uppercase -- Convert string to upper case
    96                              <1> ; IN/OUT: AX = string location
    97                              <1> 
    98                              <1> string_uppercase:
    99 00000DC1 60                  <1>     pusha
   100 00000DC2 89C6                <1>     mov si, ax
   101                              <1> 
   102                              <1>     .more:
   103 00000DC4 803C00              <1>         cmp byte [si], 0
   104 00000DC7 7413                <1>         je .done
   105                              <1> 
   106 00000DC9 803C61              <1>         cmp byte [si], 'a'
   107 00000DCC 720B                <1>         jb .noatoz
   108 00000DCE 803C7A              <1>         cmp byte [si], 'z'
   109 00000DD1 7706                <1>         ja .noatoz
   110                              <1> 
   111 00000DD3 802C20              <1>         sub byte [si], 0x20
   112                              <1> 
   113 00000DD6 46                  <1>         inc si
   114 00000DD7 EBEB                <1>         jmp .more
   115                              <1> 
   116                              <1>     .noatoz:
   117 00000DD9 46                  <1>         inc si
   118 00000DDA EBE8                <1>         jmp .more
   119                              <1> 
   120                              <1>     .done:
   121 00000DDC 61                  <1>         popa
   122 00000DDD C3                  <1>         ret
   123                              <1> 
   124                              <1> ; ------------------------------------------------------------------
   125                              <1> ; string_lowercase -- Convert string to lower case
   126                              <1> ; IN/OUT: AX = string location
   127                              <1> 
   128                              <1> string_lowercase:
   129 00000DDE 60                  <1>     pusha
   130 00000DDF 89C6                <1>     mov si, ax
   131                              <1> 
   132                              <1>     .more:
   133 00000DE1 803C00              <1>         cmp byte [si], 0
   134 00000DE4 7413                <1>         je .done
   135                              <1> 
   136 00000DE6 803C41              <1>         cmp byte [si], 'A'
   137 00000DE9 720B                <1>         jb .noatoz
   138 00000DEB 803C5A              <1>         cmp byte [si], 'Z'
   139 00000DEE 7706                <1>         ja .noatoz
   140                              <1> 
   141 00000DF0 800420              <1>         add byte [si], 0x20
   142                              <1> 
   143 00000DF3 46                  <1>         inc si
   144 00000DF4 EBEB                <1>         jmp .more
   145                              <1>     
   146                              <1>     .noatoz:
   147 00000DF6 46                  <1>         inc si
   148 00000DF7 EBE8                <1>         jmp .more
   149                              <1> 
   150                              <1>     .done:
   151 00000DF9 61                  <1>         popa
   152 00000DFA C3                  <1>         ret
   153                              <1>         
   154                              <1> ; ------------------------------------------------------------------
   155                              <1> ; string_copy -- Copy one string on to another
   156                              <1> ; IN: SI = source
   157                              <1> ; OUT: DI = destination
   158                              <1> 
   159                              <1> string_copy:
   160 00000DFB 60                  <1>     pusha
   161                              <1> 
   162                              <1>     .more:
   163 00000DFC AC                  <1>         lodsb
   164 00000DFD AA                  <1>         stosb
   165                              <1> 
   166 00000DFE 84C0                <1>         test al, al
   167 00000E00 75FA                <1>         jnz .more
   168                              <1> 
   169                              <1>     .done:
   170 00000E02 61                  <1>         popa
   171 00000E03 C3                  <1>         ret
   172                              <1> 
   173                              <1> ; ------------------------------------------------------------------
   174                              <1> ; string_truncate -- Chop string down to specified number of characters
   175                              <1> ; IN: SI = string location, AX = number of characters
   176                              <1> ; OUT: Modified string
   177                              <1> 
   178                              <1> string_truncate:
   179 00000E04 60                  <1>     pusha
   180                              <1> 
   181 00000E05 01C6                <1>     add si, ax
   182 00000E07 C60400              <1>     mov byte [si], 0
   183                              <1> 
   184 00000E0A 61                  <1>     popa
   185 00000E0B C3                  <1>     ret
   186                              <1> 
   187                              <1> ; ------------------------------------------------------------------
   188                              <1> ; string_add
   189                              <1> ; IN: AX = string one; BX = string two
   190                              <1> ; OUT AX = product
   191                              <1> 
   192                              <1> string_add:
   193                              <1>     .add_loop:
   194 00000E0C AC                  <1>         lodsb
   195 00000E0D AA                  <1>         stosb
   196                              <1> 
   197 00000E0E 3C00                <1>         cmp al, 0
   198 00000E10 75FA                <1>         jne .add_loop
   199                              <1> 
   200 00000E12 C3                  <1>         ret
   201                              <1> 
   202                              <1> ; ------------------------------------------------------------------
   203                              <1> ; string_join -- Join two strings into a third seperate string
   204                              <1> ; IN/OUT: AX = string one, BX = string two, CX = product destination
   205                              <1> 
   206                              <1> string_join:
   207 00000E13 60                  <1>     pusha
   208                              <1>     
   209 00000E14 89C6                <1>     mov si, ax
   210 00000E16 89CF                <1>     mov di, cx
   211                              <1> 
   212 00000E18 E8E0FF              <1>     call string_copy
   213 00000E1B E854FF              <1>     call string_length
   214                              <1> 
   215 00000E1E 01C1                <1>     add cx, ax
   216                              <1> 
   217 00000E20 89DE                <1>     mov si, bx
   218 00000E22 89CF                <1>     mov di, cx
   219 00000E24 E8D4FF              <1>     call string_copy
   220                              <1> 
   221 00000E27 61                  <1>     popa
   222 00000E28 C3                  <1>     ret
   223                              <1> 
   224                              <1> ; ------------------------------------------------------------------
   225                              <1> ; string_chomp -- Strip away extra spaces from a string
   226                              <1> ; IN: AX = string location
   227                              <1> 
   228                              <1> string_chomp:
   229 00000E29 60                  <1>     pusha
   230                              <1> 
   231 00000E2A 89C2                <1>     mov dx, ax
   232                              <1> 
   233 00000E2C 89C7                <1>     mov di, ax
   234 00000E2E B90000              <1>     mov cx, 0
   235                              <1> 
   236                              <1>     .keepcounting:
   237 00000E31 803D20              <1>         cmp byte [di], ' '
   238 00000E34 7504                <1>         jne .counted
   239 00000E36 41                  <1>         inc cx
   240 00000E37 47                  <1>         inc di
   241 00000E38 EBF7                <1>         jmp .keepcounting
   242                              <1> 
   243                              <1>     .counted:
   244 00000E3A 83F900              <1>         cmp cx, 0
   245 00000E3D 740E                <1>         je .finished_copy
   246                              <1> 
   247 00000E3F 89FE                <1>         mov si, di
   248 00000E41 89D7                <1>         mov di, dx
   249                              <1>     
   250                              <1>     .keep_copying:
   251 00000E43 AC                  <1>         lodsb
   252 00000E44 8805                <1>         mov [di], al
   253 00000E46 3C00                <1>         cmp al, 0
   254 00000E48 7403                <1>         je .finished_copy
   255 00000E4A 47                  <1>         inc di
   256                              <1> 
   257 00000E4B EBF6                <1>         jmp .keep_copying
   258                              <1> 
   259                              <1>     .finished_copy:
   260 00000E4D 89D0                <1>         mov ax, dx
   261                              <1> 
   262 00000E4F E820FF              <1>         call string_length
   263 00000E52 83F800              <1>         cmp ax, 0
   264 00000E55 740F                <1>         je .done
   265                              <1> 
   266 00000E57 89D6                <1>         mov si, dx
   267 00000E59 01C6                <1>         add si, ax
   268                              <1>     
   269                              <1>     .more:
   270 00000E5B 4E                  <1>         dec si
   271 00000E5C 803C20              <1>         cmp byte [si], ' '
   272 00000E5F 7505                <1>         jne .done
   273 00000E61 C60400              <1>         mov byte [si], 0
   274 00000E64 EBF5                <1>         jmp .more
   275                              <1>     
   276                              <1>     .done:
   277 00000E66 61                  <1>         popa
   278 00000E67 C3                  <1>         ret
   279                              <1> 
   280                              <1> ; ------------------------------------------------------------------
   281                              <1> ; string_strip -- Remove a character from a string (max 255 chars)
   282                              <1> ; IN: SI = string location, AL = character to remove
   283                              <1> ; OUT: SI = modified string
   284                              <1> 
   285                              <1> string_strip:
   286 00000E68 60                  <1>     pusha
   287                              <1> 
   288 00000E69 89F7                <1>     mov di, si
   289 00000E6B 88C3                <1>     mov bl, al
   290                              <1> 
   291                              <1>     .nextchar:
   292 00000E6D AC                  <1>         lodsb
   293 00000E6E AA                  <1>         stosb
   294 00000E6F 3C00                <1>         cmp al, 0
   295 00000E71 7407                <1>         je .finish
   296 00000E73 38D8                <1>         cmp al, bl
   297 00000E75 75F6                <1>         jne .nextchar
   298                              <1> 
   299                              <1>     .skip:
   300 00000E77 4F                  <1>         dec di
   301 00000E78 EBF3                <1>         jmp .nextchar
   302                              <1> 
   303                              <1>     .finish:
   304 00000E7A 61                  <1>         popa
   305 00000E7B C3                  <1>         ret
   306                              <1> 
   307                              <1> ; ------------------------------------------------------------------
   308                              <1> ; string_compare -- Check if two strings match
   309                              <1> ; IN: SI = string one, DI = string two
   310                              <1> ; OUT: carry set if same, clear if different
   311                              <1> 
   312                              <1> string_compare:
   313 00000E7C 60                  <1>     pusha
   314                              <1> 
   315                              <1>     .more:
   316 00000E7D 8A04                <1>         mov al, [si]
   317 00000E7F 8A1D                <1>         mov bl, [di]
   318                              <1> 
   319 00000E81 80FB00              <1>         cmp bl, 0
   320 00000E84 740B                <1>         je .terminated
   321                              <1> 
   322 00000E86 38D8                <1>         cmp al, bl
   323 00000E88 7504                <1>         jne .not_same
   324                              <1> 
   325 00000E8A 46                  <1>         inc si
   326 00000E8B 47                  <1>         inc di
   327 00000E8C EBEF                <1>         jmp .more
   328                              <1>     
   329                              <1>     .not_same:
   330 00000E8E 61                  <1>         popa
   331 00000E8F F8                  <1>         clc
   332 00000E90 C3                  <1>         ret
   333                              <1>     
   334                              <1>     .terminated:
   335 00000E91 61                  <1>         popa
   336 00000E92 F9                  <1>         stc
   337 00000E93 C3                  <1>         ret
   338                              <1> 
   339                              <1> ; ------------------------------------------------------------------
   340                              <1> ; string_to_int -- Convert string to an integer
   341                              <1> ; IN: SI = string (max 5 chars, up to '65536')
   342                              <1> ; OUT: AX = number
   343                              <1> 
   344                              <1> string_to_int:
   345 00000E94 60                  <1>     pusha
   346                              <1> 
   347 00000E95 89F0                <1>     mov ax, si
   348 00000E97 E8D8FE              <1>     call string_length
   349                              <1> 
   350 00000E9A 01C6                <1>     add si, ax
   351 00000E9C 4E                  <1>     dec si
   352                              <1> 
   353 00000E9D 89C1                <1>     mov cx, ax
   354                              <1> 
   355 00000E9F BB0000              <1>     mov bx, 0
   356 00000EA2 B80000              <1>     mov ax, 0
   357                              <1> 
   358 00000EA5 C706[D70E]0100      <1>     mov word [.multiplier], 1
   359                              <1> 
   360                              <1>     .loop:
   361 00000EAB B80000              <1>         mov ax, 0
   362 00000EAE 8A04                <1>         mov byte al, [si]
   363 00000EB0 2C30                <1>         sub al, 48
   364                              <1> 
   365 00000EB2 F726[D70E]          <1>         mul word [.multiplier]
   366 00000EB6 01C3                <1>         add bx, ax
   367                              <1> 
   368 00000EB8 50                  <1>         push ax
   369 00000EB9 A1[D70E]            <1>         mov word ax, [.multiplier]
   370 00000EBC BA0A00              <1>         mov dx, 10
   371 00000EBF F7E2                <1>         mul dx
   372 00000EC1 A3[D70E]            <1>         mov word [.multiplier], ax
   373 00000EC4 58                  <1>         pop ax
   374                              <1> 
   375 00000EC5 49                  <1>         dec cx
   376 00000EC6 83F900              <1>         cmp cx, 0
   377 00000EC9 7403                <1>         je .finish
   378 00000ECB 4E                  <1>         dec si
   379 00000ECC EBDD                <1>         jmp .loop
   380                              <1>     
   381                              <1>     .finish:
   382 00000ECE 891E[D90E]          <1>         mov word [.tmp], bx
   383 00000ED2 61                  <1>         popa
   384 00000ED3 A1[D90E]            <1>         mov word ax, [.tmp]
   385                              <1> 
   386 00000ED6 C3                  <1>         ret
   387                              <1> 
   388 00000ED7 0000                <1>     .multiplier dw 0
   389 00000ED9 0000                <1>     .tmp        dw 0
   390                              <1> 
   391                              <1> ; ------------------------------------------------------------------
   392                              <1> ; int_to_string -- Convert unsigned integer to a string
   393                              <1> ; IN: AX = unsigned int
   394                              <1> ; OUT: AX = string
   395                              <1> 
   396                              <1> int_to_string:
   397 00000EDB 60                  <1>     pusha
   398                              <1> 
   399 00000EDC B90000              <1>     mov cx, 0
   400 00000EDF BB0A00              <1>     mov bx, 10
   401 00000EE2 BF[020F]            <1>     mov di, .t
   402                              <1> 
   403                              <1>     .push:
   404 00000EE5 BA0000              <1>         mov dx, 0
   405 00000EE8 F7F3                <1>         div bx
   406 00000EEA 41                  <1>         inc cx
   407 00000EEB 52                  <1>         push dx
   408 00000EEC 85C0                <1>         test ax, ax
   409 00000EEE 75F5                <1>         jnz .push
   410                              <1> 
   411                              <1>     .pop:
   412 00000EF0 5A                  <1>         pop dx
   413 00000EF1 80C230              <1>         add dl, '0'
   414 00000EF4 8815                <1>         mov [di], dl
   415 00000EF6 47                  <1>         inc di
   416 00000EF7 49                  <1>         dec cx
   417 00000EF8 75F6                <1>         jnz .pop
   418                              <1> 
   419 00000EFA C60500              <1>         mov byte [di], 0
   420                              <1> 
   421 00000EFD 61                  <1>         popa
   422 00000EFE B8[020F]            <1>         mov ax, .t
   423 00000F01 C3                  <1>         ret
   424                              <1> 
   425 00000F02 00<rept>            <1>         .t times 7 db 0
   426                              <1> 
   427                              <1> ; ------------------------------------------------------------------
   428                              <1> ; sint_to_string -- Convert signed integer to string
   429                              <1> ; IN: AX = signed int
   430                              <1> ; OUT: AX = string location
   431                              <1> 
   432                              <1> sint_to_string:
   433 00000F09 60                  <1>     pusha
   434                              <1> 
   435 00000F0A B90000              <1>     mov cx, 0
   436 00000F0D BB0A00              <1>     mov bx, 10
   437 00000F10 BF[3E0F]            <1>     mov di, .t
   438                              <1> 
   439 00000F13 85C0                <1>     test ax, ax
   440 00000F15 7802                <1>     js .neg
   441 00000F17 EB08                <1>     jmp .push
   442                              <1> 
   443                              <1>     .neg:
   444 00000F19 F7D8                <1>         neg ax
   445 00000F1B C606[3E0F]2D        <1>         mov byte [.t], '-'
   446 00000F20 47                  <1>         inc di
   447                              <1>     
   448                              <1>     .push:
   449 00000F21 BA0000              <1>         mov dx, 0
   450 00000F24 F7F3                <1>         div bx
   451 00000F26 41                  <1>         inc cx
   452 00000F27 52                  <1>         push dx
   453 00000F28 85C0                <1>         test ax, ax
   454 00000F2A 75F5                <1>         jnz .push
   455                              <1> 
   456                              <1>     .pop:
   457 00000F2C 5A                  <1>         pop dx
   458 00000F2D 80C230              <1>         add dl, '0'
   459 00000F30 8815                <1>         mov [di], dl
   460 00000F32 47                  <1>         inc di
   461 00000F33 49                  <1>         dec cx
   462 00000F34 75F6                <1>         jnz .pop
   463                              <1> 
   464 00000F36 C60500              <1>         mov byte [di], 0
   465                              <1> 
   466 00000F39 61                  <1>         popa
   467 00000F3A B8[3E0F]            <1>         mov ax, .t
   468 00000F3D C3                  <1>         ret
   469                              <1> 
   470 00000F3E 00<rept>            <1>         .t times 7 db 0
   471                              <1>         
   472                              <1> ; ------------------------------------------------------------------
   473                              <1> ; lint_to_string -- Convert long integer to string
   474                              <1> ; IN: DX:AX = long unsigned int, BX = number base, DI = string location
   475                              <1> ; OUT: DI = location of converted string
   476                              <1> 
   477                              <1> lint_to_string:
   478 00000F45 60                  <1>     pusha
   479                              <1> 
   480 00000F46 89FE                <1>     mov si, di
   481 00000F48 C7050000            <1>     mov word [di], 0
   482                              <1> 
   483 00000F4C 83FB25              <1>     cmp bx, 37
   484 00000F4F 773B                <1>     ja .done
   485                              <1> 
   486 00000F51 83FB00              <1>     cmp bx, 0
   487 00000F54 7436                <1>     je .done
   488                              <1> 
   489                              <1>     .conversion_loop:
   490 00000F56 B90000              <1>         mov cx, 0
   491                              <1> 
   492 00000F59 91                  <1>         xchg ax, cx
   493 00000F5A 92                  <1>         xchg ax, dx
   494 00000F5B F7F3                <1>         div bx
   495                              <1> 
   496 00000F5D 91                  <1>         xchg ax, cx
   497 00000F5E F7F3                <1>         div bx
   498 00000F60 87CA                <1>         xchg cx, dx
   499                              <1>     
   500                              <1>     .save_digit:
   501 00000F62 83F909              <1>         cmp cx, 9
   502 00000F65 7E03                <1>         jle .convert_digit
   503                              <1> 
   504 00000F67 83C107              <1>         add cx, 'A'-'9'-1
   505                              <1> 
   506                              <1>     .convert_digit:
   507 00000F6A 83C130              <1>         add cx, '0'
   508                              <1> 
   509 00000F6D 50                  <1>         push ax
   510 00000F6E 53                  <1>         push bx
   511 00000F6F 89F0                <1>         mov ax, si
   512 00000F71 E8FEFD              <1>         call string_length
   513                              <1> 
   514 00000F74 89F7                <1>         mov di, si
   515 00000F76 01C7                <1>         add di, ax
   516 00000F78 40                  <1>         inc ax
   517                              <1>     
   518                              <1>     .move_string_up:
   519 00000F79 8A1D                <1>         mov bl, [di]
   520 00000F7B 885D01              <1>         mov [di+1], bl
   521 00000F7E 4F                  <1>         dec di
   522 00000F7F 48                  <1>         dec ax
   523 00000F80 75F7                <1>         jnz .move_string_up
   524                              <1> 
   525 00000F82 5B                  <1>         pop bx
   526 00000F83 58                  <1>         pop ax
   527 00000F84 880C                <1>         mov [si], cl
   528                              <1>     
   529                              <1>     .test_end:
   530 00000F86 89D1                <1>         mov cx, dx
   531 00000F88 09C1                <1>         or cx, ax
   532 00000F8A 75CA                <1>         jnz .conversion_loop
   533                              <1>     
   534                              <1>     .done:
   535 00000F8C 61                  <1>         popa
   536 00000F8D C3                  <1>         ret
   537                              <1>         
   538                              <1> ; ------------------------------------------------------------------
   539                              <1> ; set_time_fmt -- Set time reporting format (eg '10:25 AM' or '2300 hours')
   540                              <1> ; IN: AL = format flag, 0 = 12-hr format
   541                              <1> 
   542                              <1> set_time_fmt:
   543 00000F8E 60                  <1> 	pusha
   544 00000F8F 3C00                <1> 	cmp al, 0
   545 00000F91 7402                <1> 	je .store
   546 00000F93 B0FF                <1> 	mov al, 0x0FF
   547                              <1> .store:
   548 00000F95 A2[EC03]            <1> 	mov [fmt_12_24], al
   549 00000F98 61                  <1> 	popa
   550 00000F99 C3                  <1> 	ret
   551                              <1> 
   552                              <1> 
   553                              <1> ; ------------------------------------------------------------------
   554                              <1> ; get_time_string -- Get current time in a string (eg '10:25')
   555                              <1> ; OUT: BX = string location
   556                              <1> 
   557                              <1> get_time_string:
   558 00000F9A 60                  <1> 	pusha
   559                              <1> 
   560 00000F9B 89DF                <1> 	mov di, bx
   561                              <1> 
   562 00000F9D F8                  <1> 	clc
   563 00000F9E B402                <1> 	mov ah, 2
   564 00000FA0 CD1A                <1> 	int 0x1A
   565 00000FA2 7305                <1> 	jnc .read
   566                              <1> 
   567 00000FA4 F8                  <1> 	clc
   568 00000FA5 B402                <1> 	mov ah, 2
   569 00000FA7 CD1A                <1> 	int 0x1A
   570                              <1> 
   571                              <1> .read:
   572 00000FA9 88E8                <1> 	mov al, ch
   573 00000FAB E8380B              <1> 	call bcd_to_int
   574 00000FAE 89C2                <1> 	mov dx, ax
   575                              <1> 
   576 00000FB0 88E8                <1> 	mov al,	ch
   577 00000FB2 C0E804              <1> 	shr al, 4
   578 00000FB5 80E50F              <1> 	and ch, 0x0F
   579 00000FB8 F606[EC03]FF        <1> 	test byte [fmt_12_24], 0x0FF
   580 00000FBD 740A                <1> 	jz .twelve_hr
   581                              <1> 
   582 00000FBF E86900              <1> 	call .add_digit
   583 00000FC2 88E8                <1> 	mov al, ch
   584 00000FC4 E86400              <1> 	call .add_digit
   585 00000FC7 EB2F                <1> 	jmp short .minutes
   586                              <1> 
   587                              <1> .twelve_hr:
   588 00000FC9 83FA00              <1> 	cmp dx, 0
   589 00000FCC 741B                <1> 	je .midnight
   590                              <1> 
   591 00000FCE 83FA0A              <1> 	cmp dx, 10
   592 00000FD1 7C1D                <1> 	jl .twelve_st1
   593                              <1> 
   594 00000FD3 83FA0C              <1> 	cmp dx, 12
   595 00000FD6 7E15                <1> 	jle .twelve_st2
   596                              <1> 
   597 00000FD8 89D0                <1> 	mov ax, dx
   598 00000FDA 83E80C              <1> 	sub ax, 12
   599 00000FDD B30A                <1> 	mov bl, 10
   600 00000FDF F6F3                <1> 	div bl
   601 00000FE1 88E5                <1> 	mov ch, ah
   602                              <1> 
   603 00000FE3 3C00                <1> 	cmp al, 0
   604 00000FE5 7409                <1> 	je .twelve_st1
   605                              <1> 
   606 00000FE7 EB04                <1> 	jmp short .twelve_st2
   607                              <1> 
   608                              <1> .midnight:
   609 00000FE9 B001                <1> 	mov al, 1
   610 00000FEB B502                <1> 	mov ch, 2
   611                              <1> 
   612                              <1> .twelve_st2:
   613 00000FED E83B00              <1> 	call .add_digit
   614                              <1> .twelve_st1:
   615 00000FF0 88E8                <1> 	mov al, ch
   616 00000FF2 E83600              <1> 	call .add_digit
   617                              <1> 
   618 00000FF5 B03A                <1> 	mov al, ':'
   619 00000FF7 AA                  <1> 	stosb
   620                              <1> 
   621                              <1> .minutes:
   622 00000FF8 88C8                <1> 	mov al, cl
   623 00000FFA C0E804              <1> 	shr al, 4
   624 00000FFD 80E10F              <1> 	and cl, 0x0F
   625 00001000 E82800              <1> 	call .add_digit
   626 00001003 88C8                <1> 	mov al, cl
   627 00001005 E82300              <1> 	call .add_digit
   628                              <1> 
   629 00001008 B020                <1> 	mov al, ' '
   630 0000100A AA                  <1> 	stosb
   631                              <1> 
   632 0000100B BE[2F10]            <1> 	mov si, .hours_string
   633 0000100E F606[EC03]FF        <1> 	test byte [fmt_12_24], 0x0FF
   634 00001013 750B                <1> 	jnz .copy
   635                              <1> 
   636 00001015 BE[3810]            <1> 	mov si, .pm_string
   637 00001018 83FA0C              <1> 	cmp dx, 12
   638 0000101B 7F03                <1> 	jg .copy
   639                              <1> 
   640 0000101D BE[3510]            <1> 	mov si, .am_string
   641                              <1> 
   642                              <1> .copy:
   643 00001020 80C301              <1>     add bl, 1
   644 00001023 AC                  <1> 	lodsb
   645 00001024 AA                  <1> 	stosb
   646 00001025 3C00                <1> 	cmp al, 0
   647 00001027 75F7                <1> 	jne .copy
   648                              <1> 
   649 00001029 61                  <1> 	popa
   650 0000102A C3                  <1> 	ret
   651                              <1> 
   652                              <1> .add_digit:
   653 0000102B 0430                <1> 	add al, '0'
   654 0000102D AA                  <1> 	stosb
   655 0000102E C3                  <1> 	ret
   656                              <1> 
   657                              <1> 
   658 0000102F 686F75727300        <1> 	.hours_string	db 'hours', 0
   659 00001035 414D00              <1> 	.am_string 	db 'AM', 0
   660 00001038 504D00              <1> 	.pm_string 	db 'PM', 0
   661                              <1> 
   662                              <1> 
   663                              <1> ; ------------------------------------------------------------------
   664                              <1> ; set_date_fmt -- Set date reporting format (M/D/Y, D/M/Y or Y/M/D - 0, 1, 2)
   665                              <1> ; IN: AX = format flag, 0-2
   666                              <1> ; If AX bit 7 = 1 = use name for months
   667                              <1> ; If AX bit 7 = 0, high byte = separator character
   668                              <1> 
   669                              <1> set_date_fmt:
   670 0000103B 60                  <1> 	pusha
   671 0000103C A880                <1> 	test al, 0x80
   672 0000103E 7505                <1> 	jnz .fmt_clear
   673                              <1> 
   674 00001040 25037F              <1> 	and ax, 0x7F03
   675 00001043 EB03                <1> 	jmp short .fmt_test
   676                              <1> 
   677                              <1> .fmt_clear:
   678 00001045 83E003              <1> 	and ax, 0003
   679                              <1> 
   680                              <1> .fmt_test:
   681 00001048 3C03                <1> 	cmp al, 3
   682 0000104A 7303                <1> 	jae .leave
   683 0000104C A3[ED03]            <1> 	mov [fmt_date], ax
   684                              <1> 
   685                              <1> .leave:
   686 0000104F 61                  <1> 	popa
   687 00001050 C3                  <1> 	ret
   688                              <1> 
   689                              <1> 
   690                              <1> ; ------------------------------------------------------------------
   691                              <1> ; get_date_string -- Get current date in a string (eg '12/31/2007')
   692                              <1> ; OUT: BX = string location
   693                              <1> 
   694                              <1> get_date_string:
   695 00001051 60                  <1> 	pusha
   696                              <1> 
   697 00001052 89DF                <1> 	mov di, bx
   698 00001054 8B1E[ED03]          <1> 	mov bx, [fmt_date]
   699 00001058 81E3037F            <1> 	and bx, 0x7F03
   700                              <1> 
   701 0000105C F8                  <1> 	clc
   702 0000105D B404                <1> 	mov ah, 4
   703 0000105F CD1A                <1> 	int 0x1A
   704 00001061 7305                <1> 	jnc .read
   705                              <1> 
   706 00001063 F8                  <1> 	clc
   707 00001064 B404                <1> 	mov ah, 4
   708 00001066 CD1A                <1> 	int 0x1A
   709                              <1> 
   710                              <1> .read:
   711 00001068 80FB02              <1> 	cmp bl, 2
   712 0000106B 751C                <1> 	jne .try_fmt1
   713                              <1> 
   714 0000106D 88EC                <1> 	mov ah, ch
   715 0000106F E8A000              <1> 	call .add_2digits
   716 00001072 88CC                <1> 	mov ah, cl
   717 00001074 E89B00              <1> 	call .add_2digits
   718 00001077 B02F                <1> 	mov al, '/'
   719 00001079 AA                  <1> 	stosb
   720                              <1> 
   721 0000107A 88F4                <1> 	mov ah, dh
   722 0000107C E89300              <1> 	call .add_2digits
   723 0000107F B02F                <1> 	mov al, '/'
   724 00001081 AA                  <1> 	stosb
   725                              <1> 
   726 00001082 88D4                <1> 	mov ah, dl
   727 00001084 E88B00              <1> 	call .add_2digits
   728 00001087 EB71                <1> 	jmp .done
   729                              <1> 
   730                              <1> .try_fmt1:
   731 00001089 80FB01              <1> 	cmp bl, 1
   732 0000108C 7536                <1> 	jne .do_fmt0
   733                              <1> 
   734 0000108E 88D4                <1> 	mov ah, dl
   735 00001090 E86D00              <1> 	call .add_1or2digits
   736                              <1> 
   737 00001093 88F8                <1> 	mov al, bh
   738 00001095 80FF00              <1> 	cmp bh, 0
   739 00001098 7502                <1> 	jne .fmt1_day
   740                              <1> 
   741 0000109A B020                <1> 	mov al, ' '
   742                              <1> 
   743                              <1> .fmt1_day:
   744 0000109C AA                  <1> 	stosb
   745                              <1> 
   746 0000109D 88F4                <1> 	mov ah,	dh
   747 0000109F 80FF00              <1> 	cmp bh, 0
   748 000010A2 7509                <1> 	jne .fmt1_month
   749                              <1> 
   750 000010A4 E87F00              <1> 	call .add_month
   751 000010A7 B82C20              <1> 	mov ax, ', '
   752 000010AA AB                  <1> 	stosw
   753 000010AB EB06                <1> 	jmp short .fmt1_century
   754                              <1> 
   755                              <1> .fmt1_month:
   756 000010AD E85000              <1> 	call .add_1or2digits
   757 000010B0 88F8                <1> 	mov al, bh
   758 000010B2 AA                  <1> 	stosb
   759                              <1> 
   760                              <1> .fmt1_century:
   761 000010B3 88EC                <1> 	mov ah,	ch
   762 000010B5 80FC00              <1> 	cmp ah, 0
   763 000010B8 7403                <1> 	je .fmt1_year
   764                              <1> 
   765 000010BA E84300              <1> 	call .add_1or2digits
   766                              <1> 
   767                              <1> .fmt1_year:
   768 000010BD 88CC                <1> 	mov ah, cl
   769 000010BF E85000              <1> 	call .add_2digits
   770                              <1> 
   771 000010C2 EB36                <1> 	jmp .done
   772                              <1> 
   773                              <1> .do_fmt0:
   774 000010C4 88F4                <1> 	mov ah,	dh
   775 000010C6 80FF00              <1> 	cmp bh, 0
   776 000010C9 7508                <1> 	jne .fmt0_month
   777                              <1> 
   778 000010CB E85800              <1> 	call .add_month
   779 000010CE B020                <1> 	mov al, ' '
   780 000010D0 AA                  <1> 	stosb
   781 000010D1 EB06                <1> 	jmp short .fmt0_day
   782                              <1> 
   783                              <1> .fmt0_month:
   784 000010D3 E82A00              <1> 	call .add_1or2digits
   785 000010D6 88F8                <1> 	mov al, bh
   786 000010D8 AA                  <1> 	stosb
   787                              <1> 
   788                              <1> .fmt0_day:
   789 000010D9 88D4                <1> 	mov ah, dl
   790 000010DB E82200              <1> 	call .add_1or2digits
   791                              <1> 
   792 000010DE 88F8                <1> 	mov al, bh
   793 000010E0 80FF00              <1> 	cmp bh, 0
   794 000010E3 7505                <1> 	jne .fmt0_day2
   795                              <1> 
   796 000010E5 B02C                <1> 	mov al, ','
   797 000010E7 AA                  <1> 	stosb
   798 000010E8 B020                <1> 	mov al, ' '
   799                              <1> 
   800                              <1> .fmt0_day2:
   801 000010EA AA                  <1> 	stosb
   802                              <1> 
   803                              <1> .fmt0_century:
   804 000010EB 88EC                <1> 	mov ah,	ch
   805 000010ED 80FC00              <1> 	cmp ah, 0
   806 000010F0 7403                <1> 	je .fmt0_year
   807                              <1> 
   808 000010F2 E80B00              <1> 	call .add_1or2digits
   809                              <1> 
   810                              <1> .fmt0_year:
   811 000010F5 88CC                <1> 	mov ah, cl
   812 000010F7 E81800              <1> 	call .add_2digits
   813                              <1> 
   814                              <1> 
   815                              <1> .done:
   816 000010FA B80000              <1> 	mov ax, 0
   817 000010FD AB                  <1> 	stosw
   818                              <1> 
   819 000010FE 61                  <1> 	popa
   820 000010FF C3                  <1> 	ret
   821                              <1> 
   822                              <1> 
   823                              <1> .add_1or2digits:
   824 00001100 F6C4F0              <1> 	test ah, 0x0F0
   825 00001103 7405                <1> 	jz .only_one
   826 00001105 E80A00              <1> 	call .add_2digits
   827 00001108 EB07                <1> 	jmp short .two_done
   828                              <1> .only_one:
   829 0000110A 88E0                <1> 	mov al, ah
   830 0000110C 240F                <1> 	and al, 0x0F
   831 0000110E E81100              <1> 	call .add_digit
   832                              <1> .two_done:
   833 00001111 C3                  <1> 	ret
   834                              <1> 
   835                              <1> .add_2digits:
   836 00001112 88E0                <1> 	mov al, ah
   837 00001114 C0E804              <1> 	shr al, 4
   838 00001117 E80800              <1> 	call .add_digit
   839 0000111A 88E0                <1> 	mov al, ah
   840 0000111C 240F                <1> 	and al, 0x0F
   841 0000111E E80100              <1> 	call .add_digit
   842 00001121 C3                  <1> 	ret
   843                              <1> 
   844                              <1> .add_digit:
   845 00001122 0430                <1> 	add al, '0'
   846 00001124 AA                  <1> 	stosb
   847 00001125 C3                  <1> 	ret
   848                              <1> 
   849                              <1> .add_month:
   850 00001126 53                  <1> 	push bx
   851 00001127 51                  <1> 	push cx
   852 00001128 88E0                <1> 	mov al, ah
   853 0000112A E8B909              <1> 	call bcd_to_int
   854 0000112D FEC8                <1> 	dec al
   855 0000112F B304                <1> 	mov bl, 4
   856 00001131 F6E3                <1> 	mul bl
   857 00001133 BE[4711]            <1> 	mov si, .months
   858 00001136 01C6                <1> 	add si, ax
   859 00001138 B90400              <1> 	mov cx, 4
   860 0000113B F3A4                <1> 	rep movsb
   861 0000113D 807DFF20            <1> 	cmp byte [di-1], ' '
   862 00001141 7501                <1> 	jne .done_month
   863 00001143 4F                  <1> 	dec di
   864                              <1> .done_month:
   865 00001144 59                  <1> 	pop cx
   866 00001145 5B                  <1> 	pop bx
   867 00001146 C3                  <1> 	ret
   868                              <1> 
   869 00001147 4A616E2E4665622E4D- <1> 	.months db 'Jan.Feb.Mar.Apr.May JuneJulyAug.SeptOct.Nov.Dec.'
   869 00001150 61722E4170722E4D61- <1>
   869 00001159 79204A756E654A756C- <1>
   869 00001162 794175672E53657074- <1>
   869 0000116B 4F63742E4E6F762E44- <1>
   869 00001174 65632E              <1>
   870                              <1> 
   871                              <1> ; ------------------------------------------------------------------
   872                              <1> ; string_tokenize -- Reads tokens separated by specified char from
   873                              <1> ; a string. Returns pointer to next token, or 0 if none left
   874                              <1> ; IN: AL = separator char, SI = beginning
   875                              <1> ; OUT: DI = next token or 0 if none
   876                              <1> 
   877                              <1> string_tokenize:
   878 00001177 56                  <1> 	push si
   879                              <1> 
   880                              <1>     .next_char:
   881 00001178 3804                <1> 	    cmp byte [si], al
   882 0000117A 7408                <1> 	    je .return_token
   883 0000117C 803C00              <1> 	    cmp byte [si], 0
   884 0000117F 740B                <1> 	    jz .no_more
   885 00001181 46                  <1> 	    inc si
   886 00001182 EBF4                <1> 	    jmp .next_char
   887                              <1> 
   888                              <1>     .return_token:
   889 00001184 C60400              <1> 	    mov byte [si], 0
   890 00001187 46                  <1> 	    inc si
   891 00001188 89F7                <1> 	    mov di, si
   892 0000118A 5E                  <1> 	    pop si
   893 0000118B C3                  <1> 	    ret
   894                              <1> 
   895                              <1>     .no_more:
   896 0000118C BF0000              <1> 	    mov di, 0
   897 0000118F 5E                  <1> 	    pop si
   898 00001190 C3                  <1> 	    ret
   899                              <1> 
   900                              <1> ; ------------------------------------------------------------------
   901                              <1> ; string_clear -- Clears a variable
   902                              <1> ; IN: DI  = variable, AX = length
   903                              <1> ; OUT: empty variable
   904                              <1> 
   905                              <1> string_clear:
   906 00001191 60                  <1>     pusha
   907 00001192 BB0100              <1>     mov bx, 1
   908                              <1>     
   909                              <1>     .loop:
   910 00001195 30C0                <1>         xor al, al
   911 00001197 AA                  <1>         stosb
   912 00001198 43                  <1>         inc bx
   913                              <1> 
   914 00001199 39D8                <1>         cmp ax, bx
   915 0000119B 75F8                <1>         jne .loop
   916 0000119D 61                  <1>         popa
   917 0000119E C3                  <1>         ret
   918                              <1> 
   919                              <1> ; ==================================================================
   358                                      %include "./includes/screen.asm"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; show_cursor -- Turns on cursor in text mode
     3                              <1> ; IN/OUT: Nothing
     4                              <1> 
     5                              <1> show_cursor:
     6 0000119F 60                  <1> 	pusha
     7                              <1> 
     8 000011A0 B506                <1> 	mov ch, 6
     9 000011A2 B107                <1> 	mov cl, 7
    10 000011A4 B401                <1> 	mov ah, 1
    11 000011A6 B003                <1> 	mov al, 3
    12 000011A8 CD10                <1> 	int 10h
    13                              <1> 
    14 000011AA 61                  <1> 	popa
    15 000011AB C3                  <1> 	ret
    16                              <1> 
    17                              <1> ; ------------------------------------------------------------------
    18                              <1> ; change_cursor -- Change the cursors look
    19                              <1> ; IN: CH = 0x00/0x06
    20                              <1> 
    21                              <1> change_cursor:
    22 000011AC 60                  <1> 	pusha
    23                              <1> 
    24 000011AD B401                <1> 	mov ah, 0x01
    25 000011AF B107                <1> 	mov cl, 0x07
    26 000011B1 CD10                <1> 	int 10h
    27                              <1> 
    28 000011B3 61                  <1> 	popa
    29 000011B4 C3                  <1> 	ret
    30                              <1> 
    31                              <1> ; ------------------------------------------------------------------
    32                              <1> ; hide_cursor -- Turns off cursor in text mode
    33                              <1> ; IN/OUT: Nothing
    34                              <1> 
    35                              <1> hide_cursor:
    36 000011B5 60                  <1> 	pusha
    37                              <1> 
    38 000011B6 B520                <1> 	mov ch, 32
    39 000011B8 B401                <1> 	mov ah, 1
    40 000011BA B003                <1> 	mov al, 3
    41 000011BC CD10                <1> 	int 10h
    42                              <1> 
    43 000011BE 61                  <1> 	popa
    44 000011BF C3                  <1> 	ret
    45                              <1> 
    46                              <1> ; ------------------------------------------------------------------
    47                              <1> ; move_cursor -- Moves cursor in text mode
    48                              <1> ; IN: DH, DL = row, column
    49                              <1> 
    50                              <1> move_cursor:
    51 000011C0 60                  <1> 	pusha
    52                              <1> 
    53 000011C1 B700                <1> 	mov bh, 0
    54 000011C3 B402                <1> 	mov ah, 2
    55 000011C5 CD10                <1> 	int 0x10
    56                              <1> 
    57 000011C7 61                  <1> 	popa
    58 000011C8 C3                  <1> 	ret
    59                              <1> 
    60                              <1> ; ------------------------------------------------------------------
    61                              <1> ; get_cursor_pos -- Return position of text cursor
    62                              <1> ; OUT: DH, DL = row, column
    63                              <1> 
    64                              <1> get_cursor_pos:
    65 000011C9 60                  <1> 	pusha
    66                              <1> 
    67 000011CA B700                <1> 	mov bh, 0
    68 000011CC B403                <1> 	mov ah, 3
    69 000011CE CD10                <1> 	int 0x10
    70                              <1> 
    71 000011D0 8916[DA11]          <1> 	mov [.tmp], dx
    72 000011D4 61                  <1> 	popa
    73 000011D5 8B16[DA11]          <1> 	mov dx, [.tmp]
    74 000011D9 C3                  <1> 	ret
    75                              <1> 
    76 000011DA 0000                <1> 	.tmp dw 0
    77                              <1> 
    78                              <1> ; ------------------------------------------------------------------
    79                              <1> ; print_horiz_line -- Draw a horizontal line on the screen
    80                              <1> ; IN: AX = line type (1 for double (=), otherwise single (-))
    81                              <1> 
    82                              <1> print_horiz_line:
    83 000011DC 60                  <1> 	pusha
    84                              <1> 
    85 000011DD 89C1                <1> 	mov cx, ax
    86 000011DF B0C4                <1> 	mov al, 196
    87                              <1> 
    88 000011E1 83F901              <1> 	cmp cx, 1
    89 000011E4 7502                <1> 	jne .ready
    90 000011E6 B0CD                <1> 	mov al, 205
    91                              <1> 
    92                              <1> 	.ready:
    93 000011E8 B90000              <1> 		mov cx, 0
    94 000011EB B40E                <1> 		mov ah, 0Eh
    95                              <1> 
    96                              <1> 	.restart:
    97 000011ED CD10                <1> 		int 0x10
    98 000011EF 41                  <1> 		inc cx
    99 000011F0 83F950              <1> 		cmp cx, 80
   100 000011F3 7402                <1> 		je .done
   101 000011F5 EBF6                <1> 		jmp .restart
   102                              <1> 
   103                              <1> 	.done:
   104 000011F7 61                  <1> 		popa
   105 000011F8 C3                  <1> 		ret
   106                              <1> 
   107                              <1> ; ------------------------------------------------------------------
   108                              <1> ; input_dialog -- Get text string from user via a dialog box
   109                              <1> ; IN: AX = string location, BX = message to show
   110                              <1> ; OUT: AX = string location
   111                              <1> 
   112                              <1> input_dialog:
   113 000011F9 60                  <1> 	pusha
   114                              <1> 
   115 000011FA 50                  <1> 	push ax
   116 000011FB 53                  <1> 	push bx
   117                              <1> 
   118                              <1> 
   119 000011FC B60A                <1> 	mov dh, 10
   120 000011FE B20C                <1> 	mov dl, 12
   121                              <1> 
   122                              <1> .redbox:
   123 00001200 E8BDFF              <1> 	call move_cursor
   124                              <1> 
   125 00001203 60                  <1> 	pusha
   126 00001204 B409                <1> 	mov ah, 09h
   127 00001206 B700                <1> 	mov bh, 0
   128 00001208 B93700              <1> 	mov cx, 55
   129 0000120B B31F                <1> 	mov bl, 0x1F
   130 0000120D B020                <1> 	mov al, ' '
   131 0000120F CD10                <1> 	int 0x10
   132 00001211 61                  <1> 	popa
   133                              <1> 
   134 00001212 FEC6                <1> 	inc dh
   135 00001214 80FE10              <1> 	cmp dh, 16
   136 00001217 7402                <1> 	je .boxdone
   137 00001219 EBE5                <1> 	jmp .redbox
   138                              <1> 
   139                              <1> 
   140                              <1> .boxdone:
   141 0000121B B20E                <1> 	mov dl, 14
   142 0000121D B60B                <1> 	mov dh, 11
   143 0000121F E89EFF              <1> 	call move_cursor
   144                              <1> 
   145                              <1> 
   146 00001222 5B                  <1> 	pop bx
   147 00001223 89DE                <1> 	mov si, bx
   148 00001225 E8E208              <1> 	call print
   149                              <1> 
   150 00001228 B20E                <1> 	mov dl, 14
   151 0000122A B60D                <1> 	mov dh, 13
   152 0000122C E891FF              <1> 	call move_cursor
   153                              <1> 
   154                              <1> 
   155 0000122F 58                  <1> 	pop ax
   156 00001230 BB3200              <1> 	mov bx, 50
   157 00001233 E89B01              <1> 	call input_string
   158                              <1> 
   159 00001236 61                  <1> 	popa
   160 00001237 C3                  <1> 	ret
   161                              <1> 
   162                              <1> ; ------------------------------------------------------------------
   163                              <1> ; draw_block -- Render block of specified colour
   164                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   165                              <1> 
   166                              <1> draw_block:
   167 00001238 60                  <1> 	pusha
   168                              <1> 
   169                              <1> .more:
   170 00001239 E884FF              <1> 	call move_cursor		; Move to block starting position
   171                              <1> 
   172 0000123C B409                <1> 	mov ah, 09h			; Draw colour section
   173 0000123E B700                <1> 	mov bh, 0
   174 00001240 89F1                <1> 	mov cx, si
   175 00001242 B020                <1> 	mov al, ' '
   176 00001244 CD10                <1> 	int 10h
   177                              <1> 
   178 00001246 FEC6                <1> 	inc dh				; Get ready for next line
   179                              <1> 
   180 00001248 B80000              <1> 	mov ax, 0
   181 0000124B 88F0                <1> 	mov al, dh			; Get current Y position into DL
   182 0000124D 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
   183 0000124F 75E8                <1> 	jne .more			; If not, keep drawing
   184                              <1> 
   185 00001251 61                  <1> 	popa
   186 00001252 C3                  <1> 	ret
   187                              <1> 
   188                              <1> ; ------------------------------------------------------------------
   189                              <1> ; dialog_box -- Print dialog box in middle of screen, with button(s)
   190                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display)
   191                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
   192                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   193                              <1> ; NOTE: Each string is limited to 40 characters
   194                              <1> 
   195                              <1> dialog_box:
   196 00001253 60                  <1> 	pusha
   197                              <1> 
   198 00001254 8916[CF13]          <1> 	mov [.tmp], dx
   199                              <1> 
   200 00001258 E85AFF              <1> 	call hide_cursor
   201                              <1> 
   202 0000125B B609                <1> 	mov dh, 9			; First, draw blue background box
   203 0000125D B213                <1> 	mov dl, 19
   204                              <1> 
   205                              <1> .redbox:				; Loop to draw all lines of box
   206 0000125F E85EFF              <1> 	call move_cursor
   207                              <1> 
   208 00001262 60                  <1> 	pusha
   209 00001263 B409                <1> 	mov ah, 0x09
   210 00001265 B700                <1> 	mov bh, 0
   211 00001267 B92A00              <1> 	mov cx, 42
   212 0000126A B31F                <1> 	mov bl, 0x1F		; White on blue
   213 0000126C B020                <1> 	mov al, ' '
   214 0000126E CD10                <1> 	int 10h
   215 00001270 61                  <1> 	popa
   216                              <1> 
   217 00001271 FEC6                <1> 	inc dh
   218 00001273 80FE10              <1> 	cmp dh, 16
   219 00001276 7402                <1> 	je .boxdone
   220 00001278 EBE5                <1> 	jmp .redbox
   221                              <1> 
   222                              <1> 
   223                              <1> .boxdone:
   224 0000127A 83F800              <1> 	cmp ax, 0			; Skip string params if zero
   225 0000127D 740C                <1> 	je .no_first_string
   226 0000127F B214                <1> 	mov dl, 20
   227 00001281 B60A                <1> 	mov dh, 10
   228 00001283 E83AFF              <1> 	call move_cursor
   229                              <1> 
   230 00001286 89C6                <1> 	mov si, ax			; First string
   231 00001288 E87F08              <1> 	call print
   232                              <1> 
   233                              <1> .no_first_string:
   234 0000128B 83FB00              <1> 	cmp bx, 0
   235 0000128E 740C                <1> 	je .no_second_string
   236 00001290 B214                <1> 	mov dl, 20
   237 00001292 B60B                <1> 	mov dh, 11
   238 00001294 E829FF              <1> 	call move_cursor
   239                              <1> 
   240 00001297 89DE                <1> 	mov si, bx			; Second string
   241 00001299 E86E08              <1> 	call print
   242                              <1> 
   243                              <1> .no_second_string:
   244 0000129C 83F900              <1> 	cmp cx, 0
   245 0000129F 740C                <1> 	je .no_third_string
   246 000012A1 B214                <1> 	mov dl, 20
   247 000012A3 B60C                <1> 	mov dh, 12
   248 000012A5 E818FF              <1> 	call move_cursor
   249                              <1> 
   250 000012A8 89CE                <1> 	mov si, cx			; Third string
   251 000012AA E85D08              <1> 	call print
   252                              <1> 
   253                              <1> .no_third_string:
   254 000012AD 8B16[CF13]          <1> 	mov dx, [.tmp]
   255 000012B1 83FA00              <1> 	cmp dx, 0
   256 000012B4 7405                <1> 	je .one_button
   257 000012B6 83FA01              <1> 	cmp dx, 1
   258 000012B9 741E                <1> 	je .two_button
   259                              <1> 
   260                              <1> 
   261                              <1> .one_button:
   262 000012BB B3F0                <1> 	mov bl, 11110000b		; Black on white
   263 000012BD B60E                <1> 	mov dh, 14
   264 000012BF B223                <1> 	mov dl, 35
   265 000012C1 BE0800              <1> 	mov si, 8
   266 000012C4 BF0F00              <1> 	mov di, 15
   267 000012C7 E86EFF              <1> 	call draw_block
   268                              <1> 
   269 000012CA B226                <1> 	mov dl, 38			; OK button, centred at bottom of box
   270 000012CC B60E                <1> 	mov dh, 14
   271 000012CE E8EFFE              <1> 	call move_cursor
   272 000012D1 BE[AF13]            <1> 	mov si, .ok_button_string
   273 000012D4 E83308              <1> 	call print
   274                              <1> 
   275 000012D7 EB2E                <1> 	jmp .one_button_wait
   276                              <1> 
   277                              <1> 
   278                              <1> .two_button:
   279 000012D9 B3F0                <1> 	mov bl, 11110000b		; Black on white
   280 000012DB B60E                <1> 	mov dh, 14
   281 000012DD B21B                <1> 	mov dl, 27
   282 000012DF BE0800              <1> 	mov si, 8
   283 000012E2 BF0F00              <1> 	mov di, 15
   284 000012E5 E850FF              <1> 	call draw_block
   285                              <1> 
   286 000012E8 B21E                <1> 	mov dl, 30			; OK button
   287 000012EA B60E                <1> 	mov dh, 14
   288 000012EC E8D1FE              <1> 	call move_cursor
   289 000012EF BE[AF13]            <1> 	mov si, .ok_button_string
   290 000012F2 E81508              <1> 	call print
   291                              <1> 
   292 000012F5 B22C                <1> 	mov dl, 44			; Cancel button
   293 000012F7 B60E                <1> 	mov dh, 14
   294 000012F9 E8C4FE              <1> 	call move_cursor
   295 000012FC BE[B213]            <1> 	mov si, .cancel_button_string
   296 000012FF E80808              <1> 	call print
   297                              <1> 
   298 00001302 B90000              <1> 	mov cx, 0			; Default button = 0
   299 00001305 EB0D                <1> 	jmp .two_button_wait
   300                              <1> 
   301                              <1> 
   302                              <1> 
   303                              <1> .one_button_wait:
   304 00001307 B400                <1> 	mov ah, 0x00
   305 00001309 CD16                <1> 	int 0x16
   306                              <1> 
   307 0000130B 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
   308 0000130D 75F8                <1> 	jne .one_button_wait
   309                              <1> 
   310 0000130F E88DFE              <1> 	call show_cursor
   311                              <1> 
   312 00001312 61                  <1> 	popa
   313 00001313 C3                  <1> 	ret
   314                              <1> 
   315                              <1> 
   316                              <1> .two_button_wait:
   317 00001314 B400                <1> 	mov ah, 0x00
   318 00001316 CD16                <1> 	int 0x16
   319                              <1> 	
   320 00001318 80FC4B              <1> 	cmp ah, 0x4B			; Left cursor key pressed?
   321 0000131B 753D                <1> 	jne .noleft
   322                              <1> 
   323 0000131D B3F0                <1> 	mov bl, 11110000b		; Black on white
   324 0000131F B60E                <1> 	mov dh, 14
   325 00001321 B21B                <1> 	mov dl, 27
   326 00001323 BE0800              <1> 	mov si, 8
   327 00001326 BF0F00              <1> 	mov di, 15
   328 00001329 E80CFF              <1> 	call draw_block
   329                              <1> 
   330 0000132C B21E                <1> 	mov dl, 30				; OK button
   331 0000132E B60E                <1> 	mov dh, 14
   332 00001330 E88DFE              <1> 	call move_cursor
   333 00001333 BE[AF13]            <1> 	mov si, .ok_button_string
   334 00001336 E8D107              <1> 	call print
   335                              <1> 
   336 00001339 B31F                <1> 	mov bl, 0x1F		; White on blue for cancel button
   337 0000133B B60E                <1> 	mov dh, 14
   338 0000133D B22A                <1> 	mov dl, 42
   339 0000133F BE0900              <1> 	mov si, 9
   340 00001342 BF0F00              <1> 	mov di, 15
   341 00001345 E8F0FE              <1> 	call draw_block
   342                              <1> 
   343 00001348 B22C                <1> 	mov dl, 44				; Cancel button
   344 0000134A B60E                <1> 	mov dh, 14
   345 0000134C E871FE              <1> 	call move_cursor
   346 0000134F BE[B213]            <1> 	mov si, .cancel_button_string
   347 00001352 E8B507              <1> 	call print
   348                              <1> 
   349 00001355 B90000              <1> 	mov cx, 0				; And update result we'll return
   350 00001358 EBBA                <1> 	jmp .two_button_wait
   351                              <1> 
   352                              <1> 
   353                              <1> .noleft:
   354 0000135A 80FC4D              <1> 	cmp ah, 0x4D			; Right cursor key pressed?
   355 0000135D 753E                <1> 	jne .noright
   356                              <1> 
   357                              <1> 
   358 0000135F B31F                <1> 	mov bl, 0x1F		; Black on white
   359 00001361 B60E                <1> 	mov dh, 14
   360 00001363 B21B                <1> 	mov dl, 27
   361 00001365 BE0800              <1> 	mov si, 8
   362 00001368 BF0F00              <1> 	mov di, 15
   363 0000136B E8CAFE              <1> 	call draw_block
   364                              <1> 
   365 0000136E B21E                <1> 	mov dl, 30				; OK button
   366 00001370 B60E                <1> 	mov dh, 14
   367 00001372 E84BFE              <1> 	call move_cursor
   368 00001375 BE[AF13]            <1> 	mov si, .ok_button_string
   369 00001378 E88F07              <1> 	call print
   370                              <1> 
   371 0000137B B3F0                <1> 	mov bl, 11110000b		; White on blue for cancel button
   372 0000137D B60E                <1> 	mov dh, 14
   373 0000137F B22B                <1> 	mov dl, 43
   374 00001381 BE0800              <1> 	mov si, 8
   375 00001384 BF0F00              <1> 	mov di, 15
   376 00001387 E8AEFE              <1> 	call draw_block
   377                              <1> 
   378 0000138A B22C                <1> 	mov dl, 44				; Cancel button
   379 0000138C B60E                <1> 	mov dh, 14
   380 0000138E E82FFE              <1> 	call move_cursor
   381 00001391 BE[B213]            <1> 	mov si, .cancel_button_string
   382 00001394 E87307              <1> 	call print
   383                              <1> 
   384 00001397 B90100              <1> 	mov cx, 1				; And update result we'll return
   385 0000139A E977FF              <1> 	jmp .two_button_wait
   386                              <1> 
   387                              <1> 
   388                              <1> .noright:
   389 0000139D 3C0D                <1> 	cmp al, 13				; Wait for enter key (13) to be pressed
   390 0000139F 0F8571FF            <1> 	jne .two_button_wait
   391                              <1> 
   392 000013A3 E8F9FD              <1> 	call show_cursor
   393                              <1> 
   394 000013A6 890E[CF13]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
   395 000013AA 61                  <1> 	popa
   396 000013AB A1[CF13]            <1> 	mov ax, [.tmp]
   397                              <1> 
   398 000013AE C3                  <1> 	ret
   399                              <1> 
   400                              <1> 
   401 000013AF 4F4B00              <1> 	.ok_button_string	db 'OK', 0
   402 000013B2 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
   403 000013B9 2020204F4B20202000  <1> 	.ok_button_noselect	db '   OK   ', 0
   404 000013C2 20202043616E63656C- <1> 	.cancel_button_noselect	db '   Cancel   ', 0
   404 000013CB 20202000            <1>
   405                              <1> 
   406 000013CF 0000                <1> 	.tmp dw 0
   407                              <1> 
   408                              <1> ; ------------------------------------------------------------------
   409                              <1> ; input_string --- Get a string from keyboard input
   410                              <1> ; IN: AX = output address, BX = maximum bytes of output string
   411                              <1> ; OUT: nothing
   412                              <1> 
   413                              <1> input_string:
   414 000013D1 60                  <1> 	pusha
   415                              <1> 
   416                              <1> 	; If the character count is zero, don't do anything.
   417 000013D2 83FB00              <1> 	cmp bx, 0
   418 000013D5 7424                <1> 	je .done
   419                              <1> 
   420 000013D7 89C7                <1> 	mov di, ax			; DI = Current position in buffer
   421                              <1> 	
   422 000013D9 4B                  <1> 	dec bx				; BX = Maximum characters in string
   423 000013DA 89D9                <1> 	mov cx, bx			; CX = Remaining character count
   424                              <1> 
   425                              <1> .get_char:
   426 000013DC B400                <1> 	mov ah, 0x00
   427 000013DE CD16                <1> 	int 0x16
   428                              <1> 
   429 000013E0 3C08                <1> 	cmp al, 8
   430 000013E2 7419                <1> 	je .backspace
   431                              <1> 
   432 000013E4 3C0D                <1> 	cmp al, 13			; The ENTER key ends the prompt
   433 000013E6 7410                <1> 	je .end_string
   434                              <1> 
   435                              <1> 	; Do not add any characters if the maximum size has been reached.
   436 000013E8 E3F2                <1> 	jcxz .get_char
   437                              <1> 
   438                              <1> 	; Only add printable characters (ASCII Values 32-126)
   439 000013EA 3C20                <1> 	cmp al, ' '
   440 000013EC 72EE                <1> 	jb .get_char
   441                              <1> 
   442 000013EE 3C7E                <1> 	cmp al, 126
   443 000013F0 77EA                <1> 	ja .get_char
   444                              <1> 
   445 000013F2 E83100              <1> 	call .add_char
   446                              <1> 
   447 000013F5 49                  <1> 	dec cx
   448 000013F6 EBE4                <1> 	jmp .get_char
   449                              <1> 
   450                              <1> .end_string:
   451 000013F8 B000                <1> 	mov al, 0
   452 000013FA AA                  <1> 	stosb
   453                              <1> 
   454                              <1> .done:
   455 000013FB 61                  <1> 	popa
   456 000013FC C3                  <1> 	ret
   457                              <1> 
   458                              <1> .backspace:
   459                              <1> 	; Check if there are any characters to backspace
   460 000013FD 39D9                <1> 	cmp cx, bx 
   461 000013FF 73DB                <1> 	jae .get_char
   462                              <1> 
   463 00001401 41                  <1> 	inc cx				; Increase characters remaining
   464                              <1> 
   465 00001402 E80A00              <1> 	call .reverse_cursor		; Move back to the previous character
   466 00001405 B020                <1> 	mov al, ' '			; Print a space on the character
   467 00001407 E81C00              <1> 	call .add_char
   468 0000140A E80200              <1> 	call .reverse_cursor		; Now move the cursor back again
   469                              <1> 
   470 0000140D EBCD                <1> 	jmp .get_char
   471                              <1> 
   472                              <1> .reverse_cursor:
   473 0000140F 4F                  <1> 	dec di				; Move the output pointer backwards
   474                              <1> 	
   475 00001410 E8B6FD              <1> 	call get_cursor_pos
   476 00001413 80FA00              <1> 	cmp dl, 0			; Is the cursor at the start of line?
   477 00001416 7406                <1> 	je .back_line
   478                              <1> 
   479 00001418 FECA                <1> 	dec dl				; If not, just decrease the column
   480 0000141A E8A3FD              <1> 	call move_cursor
   481 0000141D C3                  <1> 	ret
   482                              <1> 
   483                              <1> .back_line:
   484 0000141E FECE                <1> 	dec dh				; Otherwise, move the cursor to the end
   485 00001420 B24F                <1> 	mov dl, 79			; of the previous line.
   486 00001422 E89BFD              <1> 	call move_cursor
   487 00001425 C3                  <1> 	ret
   488                              <1> 
   489                              <1> 
   490                              <1> .add_char:
   491 00001426 AA                  <1> 	stosb
   492 00001427 B40E                <1> 	mov ah, 0x0E			; Teletype Function
   493 00001429 B700                <1> 	mov bh, 0			; Video Page 0
   494 0000142B 55                  <1> 	push bp				; Some BIOS's may mess up BP
   495 0000142C CD10                <1> 	int 0x10
   496 0000142E 5D                  <1> 	pop bp
   497 0000142F C3                  <1> 	ret
   498                              <1> 
   499                              <1> ; ------------------------------------------------------------------
   500                              <1> ; switch_mode -- Switch between VIDEO and CLI mode
   501                              <1> ; IN: AX = mode (0 for CLI and 1 for video)
   502                              <1> ;	  BH = color scheme (only background for video)
   503                              <1> ; OUT: Switches mode
   504                              <1> 
   505                              <1> switch_mode:
   506 00001430 60                  <1> 	pusha
   507 00001431 30DB                <1> 	xor bl, bl
   508                              <1> 
   509 00001433 85C0                <1> 	test ax, ax
   510 00001435 7405                <1> 	je .switch_cli
   511                              <1> 
   512 00001437 83F801              <1> 	cmp ax, 1
   513 0000143A 740F                <1> 	je .switch_vid
   514                              <1> 
   515                              <1> .switch_cli:
   516                              <1> 	; Switch to text mode
   517 0000143C B80300              <1> 	mov ax, cliRes
   518 0000143F CD10                <1> 	int 0x10
   519                              <1> 
   520                              <1> 	; Change the cursor
   521 00001441 31C9                <1> 	xor cx, cx
   522 00001443 E866FD              <1> 	call change_cursor
   523                              <1> 
   524                              <1> 	; Clear the screen and change color scheme
   525 00001446 E813F9              <1> 	call cls
   526                              <1> 
   527 00001449 EB0A                <1> 	jmp .done
   528                              <1> 
   529                              <1> .switch_vid:
   530                              <1> 	; Switch to video mode
   531 0000144B B81300              <1> 	mov ax, vidRes
   532 0000144E CD10                <1> 	int 0x10
   533                              <1> 
   534                              <1> 	; Clear the screen and change the background color
   535 00001450 E809F9              <1> 	call cls
   536                              <1> 
   537 00001453 EB00                <1> 	jmp .done
   538                              <1> 
   539                              <1> .done:
   540 00001455 61                  <1> 	popa
   541 00001456 C3                  <1> 	ret
   542                              <1> 
   543                              <1> ; ------------------------------------------------------------------
   544                              <1> ; setup_bottom_string -- Draw a string in the bottom of the setup screen
   545                              <1> ; IN: SI = String location
   546                              <1> 
   547                              <1> setup_bottom_string:
   548 00001457 56                  <1> 	push si
   549 00001458 B617                <1>     mov dh, 23
   550 0000145A 30D2                <1>     xor dl, dl
   551 0000145C E861FD              <1>     call move_cursor
   552                              <1> 
   553 0000145F B80100              <1>     mov ax, 1
   554 00001462 E877FD              <1>     call print_horiz_line
   555                              <1> 	
   556 00001465 5E                  <1> 	pop si
   557 00001466 E8A106              <1>     call print
   558                              <1> 
   559 00001469 31D2                <1>     xor dx, dx
   560 0000146B E852FD              <1>     call move_cursor
   561                              <1> 
   562 0000146E C3                  <1> 	ret
   563                              <1> 
   564                              <1> ; ------------------------------------------------------------------
   565                              <1> ; setup_input -- Get keyboard input for the setup
   566                              <1> ; IN: AX = string location
   567                              <1> ; OUT: AX = string location
   568                              <1> 
   569                              <1> setup_input:
   570 0000146F 60                  <1> 	pusha
   571 00001470 89C7                <1> 	mov di, ax
   572 00001472 50                  <1> 	push ax
   573                              <1> 
   574                              <1> 	; Position the mouse
   575 00001473 B403                <1> 	mov ah, 0x03
   576 00001475 B700                <1> 	mov bh, 0
   577 00001477 CD10                <1> 	int 0x10
   578                              <1> 
   579 00001479 B402                <1> 	mov ah, 0x02
   580 0000147B B21B                <1> 	mov dl, 27
   581 0000147D FEC6                <1> 	inc dh
   582 0000147F CD10                <1> 	int 0x10
   583                              <1> 
   584                              <1> 	; And draw the top/sides
   585 00001481 BE[2C15]            <1> 	mov si, .top_bar
   586 00001484 E88306              <1> 	call print
   587                              <1> 
   588 00001487 B402                <1> 	mov ah, 0x02
   589 00001489 B21B                <1> 	mov dl, 27
   590 0000148B FEC6                <1> 	inc dh
   591 0000148D CD10                <1> 	int 0x10
   592                              <1> 	
   593 0000148F 8836[6615]          <1> 	mov [.mouse_pos], dh
   594 00001493 BE[4515]            <1> 	mov si, .sidl_bar
   595 00001496 E87106              <1> 	call print
   596                              <1> 	
   597 00001499 B402                <1> 	mov ah, 0x02
   598 0000149B B21B                <1> 	mov dl, 27
   599 0000149D FEC6                <1> 	inc dh
   600 0000149F CD10                <1> 	int 0x10
   601                              <1> 
   602 000014A1 BE[4C15]            <1> 	mov si, .bot_bar
   603 000014A4 E86306              <1> 	call print
   604                              <1> 
   605 000014A7 B402                <1> 	mov ah, 0x02
   606 000014A9 B21B                <1> 	mov dl, 27
   607 000014AB 8A36[6615]          <1> 	mov dh, [.mouse_pos]
   608 000014AF CD10                <1> 	int 0x10
   609                              <1> 
   610 000014B1 30DB                <1> 	xor bl, bl
   611                              <1> 
   612                              <1> 	; Clear the string location
   613                              <1> .clear_loop:
   614 000014B3 B000                <1> 	mov al, 0
   615 000014B5 AA                  <1> 	stosb
   616 000014B6 FEC3                <1> 	inc bl
   617                              <1> 
   618 000014B8 80FB14              <1> 	cmp bl, 20
   619 000014BB 75F6                <1> 	jne .clear_loop
   620                              <1> 
   621 000014BD B403                <1> 	mov ah, 0x03
   622 000014BF B700                <1> 	mov bh, 0
   623 000014C1 CD10                <1> 	int 0x10
   624                              <1> 
   625 000014C3 B402                <1> 	mov ah, 0x02
   626 000014C5 B21D                <1> 	mov dl, 29
   627 000014C7 CD10                <1> 	int 0x10
   628                              <1> 
   629 000014C9 58                  <1> 	pop ax
   630 000014CA 89C7                <1> 	mov di, ax
   631 000014CC 30DB                <1> 	xor bl, bl
   632                              <1> 
   633                              <1> .input_loop:
   634 000014CE B403                <1> 	mov ah, 0x03
   635 000014D0 B700                <1> 	mov bh, 0
   636 000014D2 CD10                <1> 	int 0x10
   637                              <1> 
   638 000014D4 8816[6615]          <1> 	mov [.mouse_pos], dl
   639                              <1> 
   640 000014D8 B402                <1> 	mov ah, 0x02
   641 000014DA B230                <1> 	mov dl, 48
   642 000014DC CD10                <1> 	int 0x10
   643                              <1> 
   644 000014DE BE[4815]            <1> 	mov si, .sidr_bar
   645 000014E1 E82606              <1> 	call print
   646                              <1> 
   647 000014E4 B402                <1> 	mov ah, 0x02
   648 000014E6 8A16[6615]          <1> 	mov dl, [.mouse_pos]
   649 000014EA CD10                <1> 	int 0x10
   650                              <1> 
   651 000014EC B400                <1> 	mov ah, 0x00
   652 000014EE CD16                <1> 	int 0x16
   653                              <1> 
   654 000014F0 3C0D                <1> 	cmp al, 0x0d
   655 000014F2 7436                <1> 	je .input_done
   656                              <1> 
   657 000014F4 3C08                <1> 	cmp al, 0x08
   658 000014F6 7524                <1> 	jne .not_back
   659                              <1> 
   660                              <1> 	; Pressed backspace
   661 000014F8 B403                <1> 	mov ah, 0x03
   662 000014FA B700                <1> 	mov bh, 0
   663 000014FC CD10                <1> 	int 0x10
   664                              <1> 
   665 000014FE 80FA1D              <1> 	cmp dl, 29
   666 00001501 74CB                <1> 	je .input_loop
   667                              <1> 
   668 00001503 FECA                <1> 	dec dl
   669 00001505 FECB                <1> 	dec bl
   670                              <1> 
   671 00001507 B402                <1> 	mov ah, 0x02
   672 00001509 CD10                <1> 	int 0x10
   673                              <1> 
   674 0000150B B40E                <1> 	mov ah, 0x0e
   675 0000150D B000                <1> 	mov al, 0
   676 0000150F CD10                <1> 	int 0x10
   677                              <1> 	
   678 00001511 B402                <1> 	mov ah, 0x02
   679 00001513 CD10                <1> 	int 0x10
   680                              <1> 
   681 00001515 4F                  <1> 	dec di
   682 00001516 B000                <1> 	mov al, 0
   683 00001518 AA                  <1> 	stosb
   684 00001519 4F                  <1> 	dec di
   685                              <1> 
   686 0000151A EBB2                <1> 	jmp .input_loop
   687                              <1> 
   688                              <1> .not_back:
   689 0000151C 80FB13              <1> 	cmp bl, 19
   690 0000151F 74AD                <1> 	je .input_loop
   691 00001521 FEC3                <1> 	inc bl
   692                              <1> 
   693 00001523 AA                  <1> 	stosb
   694                              <1> 
   695 00001524 B40E                <1> 	mov ah, 0x0e
   696 00001526 CD10                <1> 	int 0x10
   697                              <1> 
   698 00001528 EBA4                <1> 	jmp .input_loop 
   699                              <1> 
   700                              <1> .input_done:
   701 0000152A 61                  <1> 	popa
   702 0000152B C3                  <1> 	ret
   703                              <1> 
   704 0000152C DA                  <1> .top_bar:	db 0xda
   705 0000152D C4<rept>            <1> 			times 21 db 0xc4
   706 00001542 BF0A00              <1> 			db 0xbf, 0x0a, 0
   707 00001545 B32000              <1> .sidl_bar:	db 0xb3, 0x20, 0
   708 00001548 20B30A00            <1> .sidr_bar:	db 0x20, 0xb3, 0x0a, 0
   709 0000154C C0                  <1> .bot_bar:	db 0xc0
   710 0000154D C4<rept>            <1> 			times 21 db 0xc4
   711 00001562 D90A0D00            <1> 			db 0xd9, 0x0a, 0x0d, 0
   712                              <1> 
   713 00001566 1D                  <1> .mouse_pos:	db 29
   714                              <1> 
   715                              <1> ; ------------------------------------------------------------------
   716                              <1> ; setup_choose -- Draw text and use the cursors to choose between them
   717                              <1> ; IN: AX, BX, CX = options
   718                              <1> ;	  DH = not focused color
   719                              <1> ;	  DL = focused color
   720                              <1> ; OUT: AX = options choosen (starting at 0)
   721                              <1> 
   722                              <1> setup_choose:
   723 00001567 E84BFC              <1> 	call hide_cursor
   724 0000156A 60                  <1> 	pusha
   725 0000156B 52                  <1> 	push dx
   726                              <1> 
   727 0000156C 8A16[9F16]          <1> 	mov dl, [.start_x]
   728 00001570 8A36[A016]          <1> 	mov dh, [.start_y]
   729 00001574 E849FC              <1> 	call move_cursor
   730 00001577 5A                  <1> 	pop dx
   731                              <1> 	
   732 00001578 89C6                <1> 	mov si, ax
   733 0000157A BF[A116]            <1> 	mov di, .option1
   734 0000157D E87BF8              <1> 	call string_copy
   735                              <1> 	
   736 00001580 89DE                <1> 	mov si, bx
   737 00001582 BF[C916]            <1> 	mov di, .option2
   738 00001585 E873F8              <1> 	call string_copy
   739                              <1> 
   740 00001588 89CE                <1> 	mov si, cx
   741 0000158A BF[F116]            <1> 	mov di, .option3
   742 0000158D E86BF8              <1> 	call string_copy
   743                              <1> 
   744 00001590 31C9                <1> 	xor cx, cx
   745 00001592 EB03                <1> 	jmp .choose_loop
   746                              <1> 
   747 00001594 E9F700              <1> 	jmp .done
   748                              <1> 
   749                              <1> .choose_loop:
   750 00001597 E84100              <1> 	call .print_options
   751 0000159A E80B00              <1> 	call .check_arrows
   752 0000159D E8C800              <1> 	call .clear_bottom
   753                              <1> 
   754 000015A0 83F803              <1> 	cmp ax, 3
   755 000015A3 75F2                <1> 	jne .choose_loop
   756 000015A5 E9E600              <1> 	jmp .done
   757                              <1> 
   758                              <1> .check_arrows:
   759 000015A8 60                  <1> 	pusha
   760 000015A9 BE[470D]            <1>     mov si, setup_string
   761 000015AC E8A8FE              <1>     call setup_bottom_string
   762 000015AF 61                  <1> 	popa
   763                              <1> 
   764 000015B0 31C0                <1> 	xor ax, ax
   765 000015B2 CD16                <1> 	int 0x16
   766                              <1> 
   767 000015B4 80FC48              <1> 	cmp ah, 0x48	; UP
   768 000015B7 740A                <1> 	je .up
   769 000015B9 80FC50              <1> 	cmp ah, 0x50	; DOWN
   770 000015BC 740F                <1> 	je .down
   771                              <1> 
   772 000015BE 3C0D                <1> 	cmp al, 0x0D	; ENTER
   773 000015C0 7415                <1> 	je .enter
   774                              <1> 
   775 000015C2 C3                  <1> 	ret				; Failsafe return
   776                              <1> 
   777                              <1> 	.up:
   778 000015C3 85C9                <1> 		test cx, cx
   779 000015C5 7402                <1> 		jz .at_top
   780                              <1> 
   781 000015C7 49                  <1> 		dec cx
   782 000015C8 C3                  <1> 		ret
   783                              <1> 	
   784                              <1> 		.at_top:
   785 000015C9 B90200              <1> 			mov cx, 2
   786 000015CC C3                  <1> 			ret
   787                              <1> 	
   788                              <1> 	.down:
   789 000015CD 83F902              <1> 		cmp cx, 2
   790 000015D0 7402                <1> 		je .at_bottom
   791                              <1> 
   792 000015D2 41                  <1> 		inc cx
   793 000015D3 C3                  <1> 		ret
   794                              <1> 
   795                              <1> 		.at_bottom:
   796 000015D4 31C9                <1> 			xor cx, cx
   797 000015D6 C3                  <1> 			ret
   798                              <1> 
   799                              <1> 	.enter:
   800 000015D7 B80300              <1> 		mov ax, 3
   801 000015DA C3                  <1> 		ret
   802                              <1> 
   803                              <1> .print_options:
   804 000015DB 83F900              <1> 	cmp cx, 0
   805 000015DE 740A                <1> 	je .mark_1
   806                              <1> 
   807 000015E0 83F901              <1> 	cmp cx, 1
   808 000015E3 7419                <1> 	je .mark_2
   809                              <1> 
   810 000015E5 83F902              <1> 	cmp cx, 2
   811 000015E8 7428                <1> 	je .mark_3
   812                              <1> 
   813                              <1> 	.mark_1:
   814 000015EA BE[A116]            <1> 		mov si, .option1
   815 000015ED E83F00              <1> 		call .print_marked
   816                              <1> 
   817 000015F0 BE[C916]            <1> 		mov si, .option2
   818 000015F3 E82F00              <1> 		call .print_normal
   819                              <1> 
   820 000015F6 BE[F116]            <1> 		mov si, .option3
   821 000015F9 E82900              <1> 		call .print_normal
   822                              <1> 
   823 000015FC EB26                <1> 		jmp .mark_done
   824                              <1> 	
   825                              <1> 	.mark_2:
   826 000015FE BE[A116]            <1> 		mov si, .option1
   827 00001601 E82100              <1> 		call .print_normal
   828                              <1> 
   829 00001604 BE[C916]            <1> 		mov si, .option2
   830 00001607 E82500              <1> 		call .print_marked
   831                              <1> 
   832 0000160A BE[F116]            <1> 		mov si, .option3
   833 0000160D E81500              <1> 		call .print_normal
   834                              <1> 
   835 00001610 EB12                <1> 		jmp .mark_done
   836                              <1> 	
   837                              <1> 	.mark_3:
   838 00001612 BE[A116]            <1> 		mov si, .option1
   839 00001615 E80D00              <1> 		call .print_normal
   840                              <1> 
   841 00001618 BE[C916]            <1> 		mov si, .option2
   842 0000161B E80700              <1> 		call .print_normal
   843                              <1> 
   844 0000161E BE[F116]            <1> 		mov si, .option3
   845 00001621 E80B00              <1> 		call .print_marked
   846                              <1> 
   847                              <1> 	.mark_done:
   848 00001624 C3                  <1> 		ret
   849                              <1> 
   850                              <1> .print_normal:
   851 00001625 E81700              <1> 	call .print_space
   852 00001628 E8DF04              <1> 	call print
   853 0000162B E82D00              <1> 	call .new_line
   854                              <1> 
   855 0000162E C3                  <1> 	ret
   856                              <1> 
   857                              <1> .print_marked:
   858 0000162F 53                  <1> 	push bx
   859                              <1> 
   860 00001630 E80C00              <1> 	call .print_space
   861 00001633 31DB                <1> 	xor bx, bx
   862 00001635 88D3                <1> 	mov bl, dl
   863 00001637 E80905              <1> 	call print_atr
   864 0000163A E81E00              <1> 	call .new_line
   865                              <1> 
   866 0000163D 5B                  <1> 	pop bx
   867 0000163E C3                  <1> 	ret
   868                              <1> 
   869                              <1> .print_space:
   870 0000163F 53                  <1> 	push bx
   871                              <1> 
   872 00001640 31DB                <1> 	xor bx, bx
   873 00001642 BB2800              <1> 	mov bx, .screen_mid
   874                              <1> 	
   875 00001645 89F0                <1> 	mov ax, si
   876 00001647 E828F7              <1> 	call string_length
   877 0000164A D1F8                <1> 	sar ax, 1
   878                              <1> 
   879 0000164C 29C3                <1> 	sub bx, ax
   880                              <1> 
   881                              <1> 	.space_loop:
   882 0000164E B40E                <1> 		mov ah, 0x0e
   883 00001650 B020                <1> 		mov al, ' '
   884 00001652 CD10                <1> 		int 0x10
   885                              <1> 
   886 00001654 4B                  <1> 		dec bx
   887 00001655 85DB                <1> 		test bx, bx
   888 00001657 75F5                <1> 		jnz .space_loop
   889                              <1> 
   890 00001659 5B                  <1> 	pop bx
   891 0000165A C3                  <1> 	ret
   892                              <1> 
   893                              <1> .new_line:
   894 0000165B 50                  <1> 	push ax
   895                              <1> 
   896 0000165C B80A0E              <1> 	mov ax, 0x0E0A
   897 0000165F CD10                <1> 	int 0x10
   898 00001661 B80D0E              <1> 	mov ax, 0x0E0D
   899 00001664 CD10                <1> 	int 0x10
   900                              <1> 
   901 00001666 58                  <1> 	pop ax
   902 00001667 C3                  <1> 	ret
   903                              <1> 
   904                              <1> .clear_bottom:
   905 00001668 60                  <1> 	pusha
   906                              <1> 
   907 00001669 8A36[A016]          <1> 	mov dh, [.start_y]
   908 0000166D 8A16[9F16]          <1> 	mov dl, [.start_x]
   909 00001671 E84CFB              <1> 	call move_cursor
   910                              <1> 
   911 00001674 B80A07              <1> 	mov ax, 0x070A
   912 00001677 B71F                <1> 	mov bh, 0x1F
   913 00001679 31C9                <1> 	xor cx, cx
   914 0000167B BA4F18              <1> 	mov dx, 0x184f
   915 0000167E CD10                <1> 	int 0x10
   916                              <1> 	
   917 00001680 B80A06              <1> 	mov ax, 0x060A
   918 00001683 B71F                <1> 	mov bh, 0x1F
   919 00001685 31C9                <1> 	xor cx, cx
   920 00001687 BA4F18              <1> 	mov dx, 0x184f
   921 0000168A CD10                <1> 	int 0x10
   922                              <1> 
   923 0000168C 61                  <1> 	popa
   924 0000168D C3                  <1> 	ret
   925                              <1> 
   926                              <1> .done:
   927 0000168E E8D7FF              <1> 	call .clear_bottom
   928 00001691 890E[1917]          <1> 	mov [.option_picked], cx
   929                              <1> 
   930 00001695 61                  <1> 	popa
   931 00001696 E806FB              <1> 	call show_cursor
   932                              <1> 
   933 00001699 0FB606[1917]        <1> 	movzx ax, [.option_picked]
   934 0000169E C3                  <1> 	ret
   935                              <1> 
   936                              <1> .screen_mid		equ 40
   937 0000169F 00                  <1> .start_x:		db 0
   938 000016A0 12                  <1> .start_y:		db 18
   939                              <1> 
   940 000016A1 00<rept>            <1> .option1:		times 40 db 0
   941 000016C9 00<rept>            <1> .option2:		times 40 db 0
   942 000016F1 00<rept>            <1> .option3:		times 40 db 0
   943                              <1> 
   944 00001719 00                  <1> .option_picked:	db 0
   945                              <1> 
   946                              <1> ; ------------------------------------------------------------------
   947                              <1> ; draw_setup_box -- Draw a text box for the setup
   948                              <1> ; IN: SI = location of the string
   949                              <1> ; OUT: prints a box that's meant for the setup
   950                              <1> 
   951                              <1> draw_setup_box:
   952 0000171A 60                  <1> 	pusha
   953 0000171B 30DB                <1> 	xor bl, bl
   954                              <1> 
   955 0000171D 31D2                <1> 	xor dx, dx
   956 0000171F E89EFA              <1> 	call move_cursor
   957                              <1> 
   958 00001722 56                  <1> 	push si
   959 00001723 BE[8617]            <1> 	mov si, .setbox_top
   960 00001726 E8E103              <1> 	call print
   961                              <1> 
   962 00001729 BE[1118]            <1> 	mov si, .setbox_nwl
   963 0000172C E8DB03              <1> 	call print
   964                              <1> 
   965 0000172F 5E                  <1> 	pop si
   966                              <1> 
   967                              <1> .print_loop:
   968 00001730 AC                  <1> 	lodsb
   969 00001731 84C0                <1> 	test al, al
   970 00001733 7446                <1> 	je .done
   971                              <1> 
   972 00001735 3C0A                <1> 	cmp al, 0x0a
   973 00001737 740D                <1> 	je .new_line
   974                              <1> 
   975 00001739 80FB30              <1> 	cmp bl, 48
   976 0000173C 7408                <1> 	je .new_line
   977                              <1> 
   978 0000173E B40E                <1> 	mov ah, 0x0e
   979 00001740 CD10                <1> 	int 0x10
   980                              <1> 	
   981 00001742 FEC3                <1> 	inc bl
   982                              <1> 
   983 00001744 EBEA                <1> 	jmp .print_loop
   984                              <1> 
   985                              <1> .new_line:
   986 00001746 E80A00              <1> 	call .finish_line
   987                              <1> 
   988 00001749 56                  <1> 	push si
   989 0000174A BE[1118]            <1> 	mov si, .setbox_nwl
   990 0000174D E8BA03              <1> 	call print
   991 00001750 5E                  <1> 	pop si
   992                              <1> 
   993 00001751 EBDD                <1> 	jmp .print_loop
   994                              <1> 
   995                              <1> .finish_line:
   996 00001753 B730                <1> 	mov bh, border_length-2
   997 00001755 28DF                <1> 	sub bh, bl
   998                              <1> 
   999                              <1> .finish_loop:
  1000 00001757 80FF00              <1> 	cmp bh, 0
  1001 0000175A 760A                <1> 	jbe .loop_done
  1002                              <1> 
  1003 0000175C B40E                <1> 	mov ah, 0x0e
  1004 0000175E B020                <1> 	mov al, " "
  1005 00001760 CD10                <1> 	int 0x10
  1006 00001762 FECF                <1> 	dec bh
  1007                              <1> 
  1008 00001764 EBF1                <1> 	jmp .finish_loop
  1009                              <1> 
  1010                              <1> .loop_done:
  1011 00001766 56                  <1> 	push si
  1012 00001767 BE[2218]            <1> 	mov si, .setbox_fnl
  1013 0000176A E89D03              <1> 	call print
  1014 0000176D 5E                  <1> 	pop si
  1015 0000176E 31DB                <1> 	xor bx, bx
  1016                              <1> 
  1017 00001770 B80A0E              <1> 	mov ax, 0x0e0a
  1018 00001773 CD10                <1> 	int 0x10
  1019                              <1> 
  1020 00001775 B80D0E              <1> 	mov ax, 0x0e0d
  1021 00001778 CD10                <1> 	int 0x10
  1022                              <1> 	
  1023 0000177A C3                  <1> 	ret
  1024                              <1> 
  1025                              <1> .done:
  1026 0000177B E8D5FF              <1> 	call .finish_line
  1027                              <1> 
  1028 0000177E BE[CC17]            <1> 	mov si, .setbox_bot
  1029 00001781 E88603              <1> 	call print
  1030                              <1> 
  1031 00001784 61                  <1> 	popa
  1032 00001785 C3                  <1> 	ret
  1033                              <1> 	
  1034                              <1> 
  1035 00001786 0A                  <1> .setbox_top:	db 0x0a
  1036 00001787 20<rept>            <1>         		times edge_width db " "
  1037 00001795 DA                  <1>                 db 0xDA
  1038 00001796 C4<rept>            <1>                 times border_length db 0xC4
  1039 000017C8 BF0A0D00            <1>                 db 0xBF, 0x0a, 0x0d, 0
  1040                              <1> 
  1041 000017CC 20<rept>            <1> .setbox_bot:	times edge_width db " "
  1042 000017DA C0                  <1>                 db 0xC0
  1043 000017DB C4<rept>            <1>                 times border_length db 0xC4
  1044 0000180D D90A0D00            <1>                 db 0xD9, 0x0a, 0x0d, 0
  1045                              <1> 
  1046 00001811 20<rept>            <1> .setbox_nwl:	times edge_width db " "
  1047 0000181F B32000              <1> 				db 0xB3, " ", 0
  1048                              <1> 
  1049 00001822 20B300              <1> .setbox_fnl:	db " ", 0xB3, 0
  1050                              <1> 
  1051                              <1> ; ------------------------------------------------------------------
  1052                              <1> ; draw_box -- Draw a box
  1053                              <1> ; IN: AL = color
  1054                              <1> ;	  BX = end x position
  1055                              <1> ;	  CX = end y position
  1056                              <1> ;	  DH = start x position
  1057                              <1> ;	  DL = start y position
  1058                              <1> ; OUT: Draws box
  1059                              <1> 
  1060                              <1> draw_box:
  1061 00001825 60                  <1> 	pusha
  1062                              <1> 
  1063 00001826 8836[5E18]          <1> 	mov [.startx], dh
  1064 0000182A 8816[6018]          <1> 	mov [.starty], dl
  1065 0000182E 891E[6218]          <1> 	mov [.endx], bx
  1066 00001832 890E[6418]          <1> 	mov [.endy], cx
  1067                              <1> 
  1068 00001836 8B0E[5E18]          <1> 	mov cx, [.startx]
  1069 0000183A 8B16[6018]          <1> 	mov dx, [.starty]
  1070 0000183E B40C                <1> 	mov ah, 0x0C
  1071                              <1> 
  1072                              <1> 	.x_loop:
  1073 00001840 3B0E[6218]          <1> 		cmp cx, [.endx]
  1074 00001844 7405                <1> 		je .y_loop
  1075                              <1> 
  1076 00001846 CD10                <1> 		int 0x10
  1077                              <1> 
  1078 00001848 41                  <1> 		inc cx
  1079 00001849 EBF5                <1> 		jmp .x_loop
  1080                              <1> 
  1081                              <1> 	.y_loop:
  1082 0000184B CD10                <1> 		int 0x10
  1083                              <1> 
  1084 0000184D 3B16[6418]          <1> 		cmp dx, [.endy]
  1085 00001851 7407                <1> 		je .done
  1086                              <1> 
  1087 00001853 8B0E[5E18]          <1> 		mov cx, [.startx]
  1088 00001857 42                  <1> 		inc dx
  1089 00001858 EBE6                <1> 		jmp .x_loop
  1090                              <1> 	
  1091                              <1> 	.done:
  1092 0000185A 61                  <1> 		popa
  1093 0000185B C3                  <1> 		ret
  1094                              <1> 
  1095 0000185C 0000                <1> 	.tmp:    dw 0
  1096 0000185E 0000                <1> 	.startx: dw 0
  1097 00001860 0000                <1> 	.starty: dw 0
  1098 00001862 0000                <1> 	.endx:   dw 0
  1099 00001864 0000                <1> 	.endy:	 dw 0
  1100                              <1> 
  1101                              <1> ; ------------------------------------------------------------------
  1102                              <1> ; list_dialog -- Show a dialog with a list of options
  1103                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1104                              <1> ;     BX = first help string, CX = second help string
  1105                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1106                              <1> 
  1107                              <1> list_dialog:
  1108 00001866 60                  <1> 	pusha
  1109                              <1> 
  1110 00001867 50                  <1> 	push ax				; Store string list for now
  1111                              <1> 
  1112 00001868 51                  <1> 	push cx				; And help strings
  1113 00001869 53                  <1> 	push bx
  1114                              <1> 
  1115 0000186A E848F9              <1> 	call hide_cursor
  1116                              <1> 
  1117                              <1> 
  1118 0000186D B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1119 0000186F 89C6                <1> 	mov si, ax
  1120                              <1> .count_loop:
  1121 00001871 AC                  <1> 	lodsb
  1122 00001872 3C00                <1> 	cmp al, 0
  1123 00001874 7408                <1> 	je .done_count
  1124 00001876 3C2C                <1> 	cmp al, ','
  1125 00001878 75F7                <1> 	jne .count_loop
  1126 0000187A FEC1                <1> 	inc cl
  1127 0000187C EBF3                <1> 	jmp .count_loop
  1128                              <1> 
  1129                              <1> .done_count:
  1130 0000187E FEC1                <1> 	inc cl
  1131 00001880 880E[D919]          <1> 	mov byte [.num_of_entries], cl
  1132                              <1> 
  1133 00001884 B39F                <1> 	mov bl, 0x9F		; White on light blue
  1134 00001886 B20F                <1> 	mov dl, 15			; Start X position
  1135 00001888 B602                <1> 	mov dh, 2			; Start Y position
  1136 0000188A BE3200              <1> 	mov si, 50			; Width
  1137 0000188D BF1700              <1> 	mov di, 23			; Finish Y position
  1138 00001890 E8A5F9              <1> 	call draw_block		; Draw option selector window
  1139                              <1> 
  1140 00001893 B210                <1> 	mov dl, 16			; Show first line of help text...
  1141 00001895 B603                <1> 	mov dh, 3
  1142 00001897 E826F9              <1> 	call move_cursor
  1143                              <1> 
  1144 0000189A 5E                  <1> 	pop si				; Get back first string
  1145 0000189B E86C02              <1> 	call print
  1146                              <1> 
  1147 0000189E FEC6                <1> 	inc dh				; ...and the second
  1148 000018A0 E81DF9              <1> 	call move_cursor
  1149                              <1> 
  1150 000018A3 5E                  <1> 	pop si
  1151 000018A4 E86302              <1> 	call print
  1152                              <1> 
  1153                              <1> 
  1154 000018A7 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1155 000018A8 8936[DB19]          <1> 	mov word [.list_string], si
  1156                              <1> 
  1157                              <1> 
  1158                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1159                              <1> 	; entry and let the user move up and down using the cursor keys
  1160                              <1> 
  1161 000018AC C606[DA19]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1162                              <1> 
  1163 000018B1 B214                <1> 	mov dl, 20			; Set up starting position for selector
  1164 000018B3 B607                <1> 	mov dh, 7
  1165                              <1> 
  1166 000018B5 E808F9              <1> 	call move_cursor
  1167                              <1> 
  1168                              <1> .more_select:
  1169 000018B8 60                  <1> 	pusha
  1170 000018B9 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1171 000018BB B210                <1> 	mov dl, 16
  1172 000018BD B606                <1> 	mov dh, 6
  1173 000018BF BE3000              <1> 	mov si, 48
  1174 000018C2 BF1600              <1> 	mov di, 22
  1175 000018C5 E870F9              <1> 	call draw_block
  1176 000018C8 61                  <1> 	popa
  1177                              <1> 
  1178 000018C9 E8E100              <1> 	call .draw_black_bar
  1179                              <1> 
  1180 000018CC 8B36[DB19]          <1> 	mov word si, [.list_string]
  1181 000018D0 E89A00              <1> 	call .draw_list
  1182                              <1> 
  1183                              <1> .another_key:
  1184 000018D3 B400                <1> 	mov ah, 0x00
  1185 000018D5 CD16                <1> 	int 0x16
  1186                              <1> 
  1187 000018D7 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1188 000018DA 740F                <1> 	je .go_up
  1189 000018DC 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1190 000018DF 741B                <1> 	je .go_down
  1191 000018E1 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1192 000018E3 7468                <1> 	je .option_selected
  1193 000018E5 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1194 000018E7 747E                <1> 	je .esc_pressed
  1195 000018E9 EBCD                <1> 	jmp .more_select		; If not, wait for another key
  1196                              <1> 
  1197                              <1> 
  1198                              <1> .go_up:
  1199 000018EB 80FE07              <1> 	cmp dh, 7			; Already at top?
  1200 000018EE 7E32                <1> 	jle .hit_top
  1201                              <1> 
  1202 000018F0 E8CF00              <1> 	call .draw_white_bar
  1203                              <1> 
  1204 000018F3 B219                <1> 	mov dl, 25
  1205 000018F5 E8C8F8              <1> 	call move_cursor
  1206                              <1> 
  1207 000018F8 FECE                <1> 	dec dh				; Row to select (increasing down)
  1208 000018FA EBBC                <1> 	jmp .more_select
  1209                              <1> 
  1210                              <1> 
  1211                              <1> .go_down:				; Already at bottom of list?
  1212 000018FC 80FE14              <1> 	cmp dh, 20
  1213 000018FF 7430                <1> 	je .hit_bottom
  1214                              <1> 
  1215 00001901 B90000              <1> 	mov cx, 0
  1216 00001904 88F1                <1> 	mov byte cl, dh
  1217                              <1> 
  1218 00001906 80E907              <1> 	sub cl, 7
  1219 00001909 FEC1                <1> 	inc cl
  1220 0000190B 020E[DA19]          <1> 	add byte cl, [.skip_num]
  1221                              <1> 
  1222 0000190F A0[D919]            <1> 	mov byte al, [.num_of_entries]
  1223 00001912 38C1                <1> 	cmp cl, al
  1224 00001914 74BD                <1> 	je .another_key
  1225                              <1> 
  1226 00001916 E8A900              <1> 	call .draw_white_bar
  1227                              <1> 
  1228 00001919 B219                <1> 	mov dl, 25
  1229 0000191B E8A2F8              <1> 	call move_cursor
  1230                              <1> 
  1231 0000191E FEC6                <1> 	inc dh
  1232 00001920 EB96                <1> 	jmp .more_select
  1233                              <1> 
  1234                              <1> 
  1235                              <1> .hit_top:
  1236 00001922 8A0E[DA19]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1237 00001926 80F900              <1> 	cmp cl, 0
  1238 00001929 74A8                <1> 	je .another_key			; If not, wait for another key
  1239                              <1> 
  1240 0000192B FE0E[DA19]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1241 0000192F EB87                <1> 	jmp .more_select
  1242                              <1> 
  1243                              <1> 
  1244                              <1> .hit_bottom:				; See if there's more to scroll
  1245 00001931 B90000              <1> 	mov cx, 0
  1246 00001934 88F1                <1> 	mov byte cl, dh
  1247                              <1> 
  1248 00001936 80E907              <1> 	sub cl, 7
  1249 00001939 FEC1                <1> 	inc cl
  1250 0000193B 020E[DA19]          <1> 	add byte cl, [.skip_num]
  1251                              <1> 
  1252 0000193F A0[D919]            <1> 	mov byte al, [.num_of_entries]
  1253 00001942 38C1                <1> 	cmp cl, al
  1254 00001944 748D                <1> 	je .another_key
  1255                              <1> 
  1256 00001946 FE06[DA19]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1257 0000194A E96BFF              <1> 	jmp .more_select
  1258                              <1> 
  1259                              <1> 
  1260                              <1> 
  1261                              <1> .option_selected:
  1262 0000194D E84FF8              <1> 	call show_cursor
  1263                              <1> 
  1264 00001950 80EE07              <1> 	sub dh, 7
  1265                              <1> 
  1266 00001953 B80000              <1> 	mov ax, 0
  1267 00001956 88F0                <1> 	mov al, dh
  1268                              <1> 
  1269 00001958 FEC0                <1> 	inc al				; Options start from 1
  1270 0000195A 0206[DA19]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1271                              <1> 
  1272 0000195E A3[D719]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1273                              <1> 
  1274 00001961 61                  <1> 	popa
  1275                              <1> 
  1276 00001962 A1[D719]            <1> 	mov word ax, [.tmp]
  1277 00001965 F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1278 00001966 C3                  <1> 	ret
  1279                              <1> 
  1280                              <1> 
  1281                              <1> 
  1282                              <1> .esc_pressed:
  1283 00001967 E835F8              <1> 	call show_cursor
  1284 0000196A 61                  <1> 	popa
  1285 0000196B F9                  <1> 	stc				; Set carry for Esc
  1286 0000196C C3                  <1> 	ret
  1287                              <1> 
  1288                              <1> 
  1289                              <1> 
  1290                              <1> .draw_list:
  1291 0000196D 60                  <1> 	pusha
  1292                              <1> 
  1293 0000196E B212                <1> 	mov dl, 18			; Get into position for option list text
  1294 00001970 B607                <1> 	mov dh, 7
  1295 00001972 E84BF8              <1> 	call move_cursor
  1296                              <1> 
  1297                              <1> 
  1298 00001975 B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  1299 00001978 8A0E[DA19]          <1> 	mov byte cl, [.skip_num]
  1300                              <1> 
  1301                              <1> .skip_loop:
  1302 0000197C 83F900              <1> 	cmp cx, 0
  1303 0000197F 7408                <1> 	je .skip_loop_finished
  1304                              <1> .more_lodsb:
  1305 00001981 AC                  <1> 	lodsb
  1306 00001982 3C2C                <1> 	cmp al, ','
  1307 00001984 75FB                <1> 	jne .more_lodsb
  1308 00001986 49                  <1> 	dec cx
  1309 00001987 EBF3                <1> 	jmp .skip_loop
  1310                              <1> 
  1311                              <1> 
  1312                              <1> .skip_loop_finished:
  1313 00001989 BB0000              <1> 	mov bx, 0			; Counter for total number of options
  1314                              <1> 
  1315                              <1> 
  1316                              <1> .more:
  1317 0000198C AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  1318                              <1> 
  1319 0000198D 3C00                <1> 	cmp al, 0			; End of string?
  1320 0000198F 7417                <1> 	je .done_list
  1321                              <1> 
  1322 00001991 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1323 00001993 7406                <1> 	je .newline
  1324                              <1> 
  1325 00001995 B40E                <1> 	mov ah, 0Eh
  1326 00001997 CD10                <1> 	int 10h
  1327 00001999 EBF1                <1> 	jmp .more
  1328                              <1> 
  1329                              <1> .newline:
  1330 0000199B B212                <1> 	mov dl, 18			; Go back to starting X position
  1331 0000199D FEC6                <1> 	inc dh				; But jump down a line
  1332 0000199F E81EF8              <1> 	call move_cursor
  1333                              <1> 
  1334 000019A2 43                  <1> 	inc bx				; Update the number-of-options counter
  1335 000019A3 83FB0E              <1> 	cmp bx, 14			; Limit to one screen of options
  1336 000019A6 7CE4                <1> 	jl .more
  1337                              <1> 
  1338                              <1> .done_list:
  1339 000019A8 61                  <1> 	popa
  1340 000019A9 E814F8              <1> 	call move_cursor
  1341                              <1> 
  1342 000019AC C3                  <1> 	ret
  1343                              <1> 
  1344                              <1> 
  1345                              <1> 
  1346                              <1> .draw_black_bar:
  1347 000019AD 60                  <1> 	pusha
  1348                              <1> 
  1349 000019AE B211                <1> 	mov dl, 17
  1350 000019B0 E80DF8              <1> 	call move_cursor
  1351                              <1> 
  1352 000019B3 B409                <1> 	mov ah, 09h			; Draw white bar at top
  1353 000019B5 B700                <1> 	mov bh, 0
  1354 000019B7 B92E00              <1> 	mov cx, 46
  1355 000019BA B30F                <1> 	mov bl, 00001111b		; White text on black background
  1356 000019BC B020                <1> 	mov al, ' '
  1357 000019BE CD10                <1> 	int 10h
  1358                              <1> 
  1359 000019C0 61                  <1> 	popa
  1360 000019C1 C3                  <1> 	ret
  1361                              <1> 
  1362                              <1> 
  1363                              <1> 
  1364                              <1> .draw_white_bar:
  1365 000019C2 60                  <1> 	pusha
  1366                              <1> 
  1367 000019C3 B211                <1> 	mov dl, 17
  1368 000019C5 E8F8F7              <1> 	call move_cursor
  1369                              <1> 
  1370 000019C8 B409                <1> 	mov ah, 09h			; Draw white bar at top
  1371 000019CA B700                <1> 	mov bh, 0
  1372 000019CC B92E00              <1> 	mov cx, 46
  1373 000019CF B3F0                <1> 	mov bl, 11110000b		; Black text on white background
  1374 000019D1 B020                <1> 	mov al, ' '
  1375 000019D3 CD10                <1> 	int 10h
  1376                              <1> 
  1377 000019D5 61                  <1> 	popa
  1378 000019D6 C3                  <1> 	ret
  1379                              <1> 
  1380                              <1> 
  1381 000019D7 0000                <1> 	.tmp			dw 0
  1382 000019D9 00                  <1> 	.num_of_entries		db 0
  1383 000019DA 00                  <1> 	.skip_num		db 0
  1384 000019DB 0000                <1> 	.list_string		dw 0
   359                                      %include "./includes/misc.asm"
     1                              <1> ; get_api_version -- Return current version of KronkOS API
     2                              <1> ; OUT: AL = API version number
     3                              <1> 
     4                              <1> get_api_version:
     5 000019DD B004                <1> 	mov al, KRONKOS_API
     6 000019DF C3                  <1> 	ret
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; fatal_error -- Display error message and halt execution
    10                              <1> ; IN: AX = error message string location
    11                              <1> 
    12                              <1> fatal_error:
    13 000019E0 89C3                <1> 	mov bx, ax			; Store string location for now
    14                              <1> 
    15 000019E2 B600                <1> 	mov dh, 0
    16 000019E4 B200                <1> 	mov dl, 0
    17 000019E6 E8D7F7              <1> 	call move_cursor
    18                              <1> 
    19 000019E9 60                  <1> 	pusha
    20 000019EA B409                <1> 	mov ah, 0x09		; Draw red bar at top
    21 000019EC B700                <1> 	mov bh, 0
    22 000019EE B9F000              <1> 	mov cx, 240
    23 000019F1 B34F                <1> 	mov bl, 01001111b
    24 000019F3 B020                <1> 	mov al, ' '
    25 000019F5 CD10                <1> 	int 10h
    26 000019F7 61                  <1> 	popa
    27                              <1> 
    28 000019F8 B600                <1> 	mov dh, 0
    29 000019FA B200                <1> 	mov dl, 0
    30 000019FC E8C1F7              <1> 	call move_cursor
    31                              <1> 
    32 000019FF BE[0C1A]            <1> 	mov si, .msg_inform		; Inform of fatal error
    33 00001A02 E80501              <1> 	call print
    34                              <1> 
    35 00001A05 89DE                <1> 	mov si, bx			; Program-supplied error message
    36 00001A07 E80001              <1> 	call print
    37                              <1> 
    38 00001A0A EBFE                <1> 	jmp $				; Halt execution
    39                              <1> 
    40                              <1> 	
    41 00001A0C 464154414C204F5045- <1> 	.msg_inform		db 'FATAL OPERATING SYSTEM ERROR!', 0x0d, 0x0a, 0
    41 00001A15 524154494E47205359- <1>
    41 00001A1E 5354454D204552524F- <1>
    41 00001A27 52210D0A00          <1>
    42                              <1> 
    43                              <1> ; ------------------------------------------------------------------
    44                              <1> ; bios_wait -- Wait
    45                              <1> ; IN: CX:DX time
    46                              <1> 
    47                              <1> bios_wait:
    48 00001A2C B80086              <1> 	mov ax, 0x8600
    49 00001A2F CD15                <1>     int 0x15
    50 00001A31 C3                  <1>     ret
   360                                      %include "./includes/input.asm"
     1                              <1> get_input:
     2 00001A32 60                  <1>     pusha
     3 00001A33 B200                <1>     mov dl, 0
     4 00001A35 BE[AB01]            <1>     mov si, in_buffer
     5                              <1> 
     6                              <1>     ; Clear the input buffer for use
     7                              <1>     .clear_loop:
     8 00001A38 C60400              <1>         mov byte [si], 0
     9                              <1> 
    10 00001A3B 46                  <1>         inc si
    11 00001A3C FEC2                <1>         inc dl
    12                              <1> 
    13 00001A3E 80FA1E              <1>         cmp dl, 30
    14 00001A41 75F5                <1>         jne .clear_loop
    15                              <1> 
    16 00001A43 BE[AB01]            <1>     mov si, in_buffer
    17 00001A46 30DB                <1>     xor bl, bl ; Used for checking the length of the buffer
    18                              <1> 
    19                              <1> ; The actual loop
    20                              <1> .input_loop:
    21 00001A48 B400                <1>     mov ah, 0x00
    22 00001A4A CD16                <1>     int 0x16
    23                              <1> 
    24                              <1>     ; Check if the user pressed enter
    25 00001A4C 3C0D                <1>     cmp al, 0x0d
    26 00001A4E 7442                <1>     je .input_done
    27                              <1> 
    28                              <1>     ; Check if the user pressed backspace
    29 00001A50 3C08                <1>     cmp al, 0x08
    30 00001A52 7524                <1>     jne .not_back
    31                              <1> 
    32                              <1>     ; ******************************
    33                              <1>     ; The user pressed backspace!
    34                              <1> 
    35                              <1>     ; Get current cursor position
    36 00001A54 B403                <1>     mov ah, 0x03
    37 00001A56 B700                <1>     mov bh, 0
    38 00001A58 CD10                <1>     int 0x10
    39                              <1> 
    40 00001A5A 80FA03              <1>     cmp dl, 3 ; 3 = backspace limit
    41 00001A5D 74E9                <1>     je .input_loop
    42                              <1> 
    43 00001A5F FECA                <1>     dec dl
    44 00001A61 FECB                <1>     dec bl
    45                              <1> 
    46                              <1>     ; Move one back
    47 00001A63 B402                <1>     mov ah, 0x02
    48 00001A65 CD10                <1>     int 0x10
    49                              <1> 
    50 00001A67 B40E                <1>     mov ah, 0x0e
    51 00001A69 B000                <1>     mov al, 0
    52 00001A6B CD10                <1>     int 0x10
    53                              <1> 
    54 00001A6D B402                <1>     mov ah, 0x02
    55 00001A6F CD10                <1>     int 0x10
    56                              <1> 
    57                              <1>     ; Remove the last character from the input buffer
    58 00001A71 4E                  <1>     dec si
    59 00001A72 B000                <1>     mov al, 0
    60 00001A74 8804                <1>     mov [si], al
    61                              <1> 
    62 00001A76 EBD0                <1>     jmp .input_loop
    63                              <1>     
    64                              <1>     ; ******************************
    65                              <1> 
    66                              <1>     ; Show the pressed character and save it to the input buffer
    67                              <1>     .not_back:
    68 00001A78 80FB28              <1>         cmp bl, 40
    69 00001A7B 74CB                <1>         je .input_loop
    70 00001A7D FEC3                <1>         inc bl
    71                              <1> 
    72 00001A7F 8804                <1>         mov [si], al
    73 00001A81 46                  <1>         inc si
    74                              <1> 
    75 00001A82 B40E                <1>         mov ah, 0x0e
    76 00001A84 3C61                <1>         cmp al, 'a'
    77 00001A86 7206                <1>         jb .noatoz
    78 00001A88 3C7A                <1>         cmp al, 'z'
    79 00001A8A 7702                <1>         ja .noatoz
    80                              <1>         
    81 00001A8C 24DF                <1>         and al, 0xdf
    82                              <1>         .noatoz:
    83 00001A8E CD10                <1>         int 0x10
    84                              <1> 
    85 00001A90 EBB6                <1>         jmp .input_loop
    86                              <1> 
    87                              <1>     ; Return the cursor to the start and return
    88                              <1>     .input_done:
    89 00001A92 B8[AB01]            <1>         mov ax, in_buffer
    90 00001A95 E846F3              <1>         call string_lowercase
    91                              <1> 
    92 00001A98 B40E                <1>         mov ah, 0x0e
    93 00001A9A B00D                <1>         mov al, 0x0d
    94 00001A9C CD10                <1>         int 0x10
    95                              <1> 
    96 00001A9E 61                  <1>         popa
    97 00001A9F C3                  <1>         ret
   361                                      %include "./includes/math.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; KronkOS -- The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; MATH ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; seed_random -- Seed the random number generator based on clock
    10                              <1> 
    11                              <1> seed_random:
    12 00001AA0 53                  <1> 	push bx
    13 00001AA1 50                  <1> 	push ax
    14                              <1> 
    15 00001AA2 BB0000              <1> 	mov bx, 0
    16 00001AA5 B002                <1> 	mov al, 0x02
    17 00001AA7 E670                <1> 	out 0x70, al
    18 00001AA9 E471                <1> 	in al, 0x71
    19                              <1> 
    20 00001AAB 88C3                <1> 	mov bl, al
    21 00001AAD C1E308              <1> 	shl bx, 8
    22 00001AB0 B000                <1> 	mov al, 0
    23 00001AB2 E670                <1> 	out 0x70, al
    24 00001AB4 E471                <1> 	in al, 0x71
    25                              <1> 
    26 00001AB6 891E[BD1A]          <1> 	mov word [random_seed], bx
    27                              <1> 
    28 00001ABA 58                  <1> 	pop ax
    29 00001ABB 5B                  <1> 	pop bx
    30 00001ABC C3                  <1> 	ret
    31                              <1> 
    32 00001ABD 0000                <1> 	random_seed dw 0
    33                              <1> 
    34                              <1> ; ------------------------------------------------------------------
    35                              <1> ; get_random -- Return a random integer between low and high (inclusive)
    36                              <1> ; IN: AX = low integer, BX = high integer
    37                              <1> ; OUT: CX = random integer
    38                              <1> 
    39                              <1> get_random:
    40 00001ABF 52                  <1> 	push dx
    41 00001AC0 53                  <1> 	push bx
    42 00001AC1 50                  <1> 	push ax
    43                              <1> 
    44 00001AC2 29C3                <1> 	sub bx, ax
    45 00001AC4 E80F00              <1> 	call .generate_random
    46 00001AC7 89DA                <1> 	mov dx, bx
    47 00001AC9 83C201              <1> 	add dx, 1
    48 00001ACC F7E2                <1> 	mul dx
    49 00001ACE 89D1                <1> 	mov cx, dx
    50                              <1> 
    51 00001AD0 58                  <1> 	pop ax
    52 00001AD1 5B                  <1> 	pop bx
    53 00001AD2 5A                  <1> 	pop dx
    54 00001AD3 01C1                <1> 	add cx, ax
    55 00001AD5 C3                  <1> 	ret
    56                              <1> 
    57                              <1> 	.generate_random:
    58 00001AD6 52                  <1> 		push dx
    59 00001AD7 53                  <1> 		push bx
    60                              <1> 
    61 00001AD8 A1[BD1A]            <1> 		mov ax, [random_seed]
    62 00001ADB BA8373              <1> 		mov dx, 0x7383
    63 00001ADE F7E2                <1> 		mul dx
    64 00001AE0 A3[BD1A]            <1> 		mov [random_seed], ax
    65                              <1> 
    66 00001AE3 5B                  <1> 		pop bx
    67 00001AE4 5A                  <1> 		pop dx
    68                              <1> 		
    69 00001AE5 C3                  <1> 		ret
    70                              <1> 
    71                              <1> ; ------------------------------------------------------------------
    72                              <1> ; bcd_to_int -- Converts binary coded decimal number to an integer
    73                              <1> ; IN: AL = BCD number
    74                              <1> ; OUT: AX = integer value
    75                              <1> 
    76                              <1> bcd_to_int:
    77 00001AE6 60                  <1> 	pusha
    78                              <1> 
    79 00001AE7 88C3                <1> 	mov bl, al
    80                              <1> 
    81 00001AE9 83E00F              <1> 	and ax, 0x0F
    82 00001AEC 89C1                <1> 	mov cx, ax
    83                              <1> 
    84 00001AEE C0EB04              <1> 	shr bl, 4
    85 00001AF1 B00A                <1> 	mov al, 10
    86 00001AF3 F6E3                <1> 	mul bl
    87                              <1> 
    88 00001AF5 01C8                <1> 	add ax, cx
    89 00001AF7 A3[FF1A]            <1> 	mov [.tmp], ax
    90                              <1> 
    91 00001AFA 61                  <1> 	popa
    92 00001AFB A1[FF1A]            <1> 	mov ax, [.tmp]
    93 00001AFE C3                  <1> 	ret
    94                              <1> 
    95 00001AFF 0000                <1> 	.tmp	dw 0
    96                              <1> 	
    97                              <1> ; ------------------------------------------------------------------
    98                              <1> ; long_int_negate -- Multiply value in DX:AX by -1
    99                              <1> ; IN: DX:AX = long integer
   100                              <1> ; OUT: DX:AX = -(initial DX:AX)
   101                              <1> 
   102                              <1> long_int_negate:
   103 00001B01 F7D8                <1> 	neg ax
   104 00001B03 83D200              <1> 	adc dx, 0
   105 00001B06 F7DA                <1> 	neg dx
   106 00001B08 C3                  <1> 	ret
   107                              <1> 
   108                              <1> ; ------------------------------------------------------------------
   109                              <1> ; hex_to_int -- Convert a hexadecimal to decimal
   110                              <1> ; IN: AX = number to be converted, BX = base
   111                              <1> 
   112                              <1> hex_to_int:
   113 00001B09 C3                  <1> 	ret
   114                              <1> 
   115                              <1> ; ==================================================================
   362                                      %include "./includes/print.asm"
     1                              <1> ; ------------------------------------------------------------------
     2                              <1> ; print -- Print a string to the screen
     3                              <1> ; IN: SI = The location of the string
     4                              <1> 
     5                              <1> print:
     6 00001B0A 60                  <1>     pusha
     7 00001B0B B40E                <1>     mov ah, 0x0e
     8                              <1> 
     9                              <1> .repeat:
    10 00001B0D AC                  <1>     lodsb
    11 00001B0E 84C0                <1>     test al, al
    12 00001B10 7404                <1>     jz .done
    13                              <1> 
    14 00001B12 CD10                <1>     int 0x10
    15 00001B14 EBF7                <1>     jmp short .repeat
    16                              <1> 
    17                              <1> .done:
    18 00001B16 61                  <1>     popa
    19 00001B17 C3                  <1>     ret
    20                              <1> 
    21                              <1> ; ------------------------------------------------------------------
    22                              <1> ; welcome_print -- Print the welcome message
    23                              <1> ; IN: SI = The location of the string
    24                              <1> 
    25                              <1> welcome_print:
    26 00001B18 B409                <1>     mov ah, 0x09
    27 00001B1A B90100              <1>     mov cx, 1
    28 00001B1D 31DB                <1>     xor bx, bx
    29 00001B1F B330                <1>     mov bl, mb_color
    30                              <1> 
    31                              <1>     .repeat:
    32 00001B21 AC                  <1>         lodsb
    33 00001B22 3C00                <1>         cmp al, 0
    34 00001B24 741C                <1>         je .done
    35                              <1> 
    36 00001B26 3C0A                <1>         cmp al, 0x0a
    37 00001B28 7410                <1>         je .other_char
    38 00001B2A 3C0D                <1>         cmp al, 0x0d
    39 00001B2C 740C                <1>         je .other_char
    40                              <1> 
    41 00001B2E E898F6              <1>         call get_cursor_pos
    42 00001B31 FEC2                <1>         inc dl
    43 00001B33 E88AF6              <1>         call move_cursor
    44                              <1> 
    45 00001B36 CD10                <1>         int 0x10
    46 00001B38 EBE7                <1>         jmp short .repeat
    47                              <1> 
    48                              <1>     .other_char:
    49 00001B3A B40E                <1>         mov ah, 0x0e
    50 00001B3C CD10                <1>         int 0x10
    51                              <1> 
    52 00001B3E B409                <1>         mov ah, 0x09
    53 00001B40 EBDF                <1>         jmp .repeat
    54                              <1> 
    55                              <1>     .done:
    56 00001B42 C3                  <1>         ret
    57                              <1> 
    58                              <1> ; ------------------------------------------------------------------
    59                              <1> ; print_atr -- Print a string with attribute to the screen
    60                              <1> ; IN: SI = The location of the string
    61                              <1> ;     BH = Page number
    62                              <1> ;     BL = Attribute
    63                              <1> 
    64                              <1> print_atr:
    65 00001B43 60                  <1>     pusha
    66 00001B44 B90100              <1>     mov cx, 1
    67 00001B47 B409                <1>     mov ah, 0x09
    68                              <1> 
    69                              <1> .repeat:
    70 00001B49 AC                  <1>     lodsb
    71 00001B4A 84C0                <1>     test al, al
    72 00001B4C 741C                <1>     jz .done
    73                              <1> 
    74 00001B4E 3C0A                <1>     cmp al, 0x0a
    75 00001B50 7410                <1>     je .special_char
    76                              <1> 
    77 00001B52 3C0D                <1>     cmp al, 0x0d
    78 00001B54 740C                <1>     je .special_char
    79                              <1> 
    80 00001B56 CD10                <1>     int 0x10
    81                              <1> 
    82 00001B58 E86EF6              <1>     call get_cursor_pos
    83 00001B5B FEC2                <1>     inc dl
    84 00001B5D E860F6              <1>     call move_cursor
    85                              <1> 
    86 00001B60 EBE7                <1>     jmp short .repeat
    87                              <1> 
    88                              <1> .special_char:
    89 00001B62 B40E                <1>     mov ah, 0x0e
    90 00001B64 CD10                <1>     int 0x10
    91 00001B66 B409                <1>     mov ah, 0x09
    92                              <1> 
    93 00001B68 EBDF                <1>     jmp short .repeat
    94                              <1> 
    95                              <1> .done:
    96 00001B6A 61                  <1>     popa
    97 00001B6B C3                  <1>     ret
   363                                      %include "./includes/mouse.asm"
     1                              <1> HW_EQUIP_PS2     equ 4          ; PS2 mouse installed?
     2                              <1> MOUSE_PKT_BYTES  equ 3          ; Number of bytes in mouse packet
     3                              <1> MOUSE_RESOLUTION equ 3          ; Mouse resolution 8 counts/mm
     4                              <1> ARG_OFFSETS      equ 6          ; Offset of args from BP
     5                              <1> 
     6                              <1> mouse_initialize:
     7 00001B6C 06                  <1>     push es
     8 00001B6D 53                  <1>     push bx
     9                              <1> 
    10 00001B6E CD11                <1>     int 0x11
    11 00001B70 A90400              <1>     test ax, HW_EQUIP_PS2
    12 00001B73 7421                <1>     jz .no_mouse
    13                              <1> 
    14 00001B75 B805C2              <1>     mov ax, 0xC205
    15 00001B78 B703                <1>     mov bh, MOUSE_PKT_BYTES
    16 00001B7A CD15                <1>     int 0x15
    17 00001B7C 7218                <1>     jc .no_mouse
    18                              <1> 
    19 00001B7E B803C2              <1>     mov ax, 0xC203
    20 00001B81 B703                <1>     mov bh, MOUSE_RESOLUTION
    21 00001B83 CD15                <1>     int 0x15
    22 00001B85 720F                <1>     jc .no_mouse
    23                              <1> 
    24 00001B87 0E                  <1>     push cs
    25 00001B88 07                  <1>     pop es
    26                              <1> 
    27 00001B89 BB[011C]            <1>     mov bx, mouse_callback_dummy
    28 00001B8C B807C2              <1>     mov ax, 0xC207
    29 00001B8F CD15                <1>     int 0x15
    30 00001B91 7203                <1>     jc .no_mouse
    31                              <1> 
    32 00001B93 F8                  <1>     clc
    33 00001B94 EB01                <1>     jmp .finished
    34                              <1>     
    35                              <1>     .no_mouse:
    36 00001B96 F9                  <1>         stc
    37                              <1>     
    38                              <1>     .finished:
    39 00001B97 5B                  <1>         pop bx
    40 00001B98 07                  <1>         pop es
    41 00001B99 C3                  <1>         ret
    42                              <1> 
    43                              <1> 
    44                              <1> mouse_enable:
    45 00001B9A 06                  <1>     push es
    46 00001B9B 53                  <1>     push bx
    47                              <1> 
    48 00001B9C E81400              <1>     call mouse_disable
    49                              <1> 
    50 00001B9F 0E                  <1>     push cs
    51 00001BA0 07                  <1>     pop es
    52 00001BA1 BB[C61B]            <1>     mov bx, mouse_callback
    53 00001BA4 B807C2              <1>     mov ax, 0xC207
    54 00001BA7 CD15                <1>     int 0x15
    55                              <1> 
    56 00001BA9 B800C2              <1>     mov ax, 0xC200
    57 00001BAC B701                <1>     mov bh, 1
    58 00001BAE CD15                <1>     int 0x15
    59                              <1> 
    60 00001BB0 5B                  <1>     pop bx
    61 00001BB1 07                  <1>     pop es
    62 00001BB2 C3                  <1>     ret
    63                              <1> 
    64                              <1> 
    65                              <1> mouse_disable:
    66 00001BB3 06                  <1>     push es
    67 00001BB4 53                  <1>     push bx
    68                              <1> 
    69 00001BB5 B800C2              <1>     mov ax, 0xC200
    70 00001BB8 31DB                <1>     xor bx, bx
    71 00001BBA CD15                <1>     int 0x15
    72                              <1> 
    73 00001BBC 8EC3                <1>     mov es, bx
    74 00001BBE B807C2              <1>     mov ax, 0xC207
    75 00001BC1 CD15                <1>     int 0x15
    76                              <1> 
    77 00001BC3 5B                  <1>     pop bx
    78 00001BC4 07                  <1>     pop es
    79 00001BC5 C3                  <1>     ret
    80                              <1> 
    81                              <1> 
    82                              <1> mouse_callback:
    83 00001BC6 55                  <1>     push bp
    84 00001BC7 89E5                <1>     mov bp, sp
    85                              <1> 
    86 00001BC9 1E                  <1>     push ds
    87 00001BCA 50                  <1>     push ax
    88 00001BCB 53                  <1>     push bx
    89 00001BCC 51                  <1>     push cx
    90 00001BCD 52                  <1>     push dx
    91                              <1> 
    92 00001BCE 0E                  <1>     push cs
    93 00001BCF 1F                  <1>     pop ds
    94                              <1> 
    95 00001BD0 8A460C              <1>     mov al, [bp+ARG_OFFSETS+6]
    96 00001BD3 88C3                <1>     mov bl, al
    97 00001BD5 B103                <1>     mov cl, 3
    98 00001BD7 D2E0                <1>     shl al, cl
    99                              <1> 
   100 00001BD9 18F6                <1>     sbb dh, dh
   101 00001BDB 98                  <1>     cbw
   102 00001BDC 8A5608              <1>     mov dl, [bp+ARG_OFFSETS+2]
   103 00001BDF 8A460A              <1>     mov al, [bp+ARG_OFFSETS+4]
   104                              <1> 
   105 00001BE2 F7DA                <1>     neg dx
   106 00001BE4 8B0E[B41C]          <1>     mov cx, [mouseY]
   107 00001BE8 01CA                <1>     add dx, cx
   108 00001BEA 8B0E[B21C]          <1>     mov cx, [mouseX]
   109 00001BEE 01C8                <1>     add ax, cx
   110                              <1> 
   111 00001BF0 881E[B61C]          <1>     mov [curStatus], bl
   112 00001BF4 A3[B21C]            <1>     mov [mouseX], ax
   113 00001BF7 8916[B41C]          <1>     mov [mouseY], dx
   114                              <1> 
   115 00001BFB 5A                  <1>     pop dx
   116 00001BFC 59                  <1>     pop cx
   117 00001BFD 5B                  <1>     pop bx
   118 00001BFE 58                  <1>     pop ax
   119 00001BFF 1F                  <1>     pop ds
   120 00001C00 5D                  <1>     pop bp
   121                              <1> 
   122                              <1> mouse_callback_dummy:
   123 00001C01 CB                  <1>     retf
   124                              <1> 
   125                              <1> poll_mouse:
   126 00001C02 50                  <1>     push ax
   127 00001C03 53                  <1>     push bx
   128 00001C04 52                  <1>     push dx
   129                              <1>     
   130 00001C05 BB0200              <1>     mov bx, 0x0002
   131                              <1> 
   132 00001C08 FA                  <1>     cli
   133 00001C09 A1[B21C]            <1>     mov ax, [mouseX]
   134 00001C0C 8B16[B41C]          <1>     mov dx, [mouseY]
   135 00001C10 FB                  <1>     sti
   136                              <1> 
   137 00001C11 5A                  <1>     pop dx
   138 00001C12 5B                  <1>     pop bx
   139 00001C13 58                  <1>     pop ax
   140 00001C14 C3                  <1>     ret
   141                              <1> 
   142                              <1> clamp_mouse:
   143 00001C15 A1[B21C]            <1>     mov ax, [mouseX]
   144                              <1> 
   145 00001C18 83F84E              <1>     cmp ax, screenmaxW
   146 00001C1B 7D17                <1>     jge .r_edge
   147                              <1> 
   148 00001C1D BA0100              <1>     mov dx, screenminW
   149 00001C20 39D0                <1>     cmp ax, dx
   150 00001C22 7E22                <1>     jle .l_edge
   151                              <1> 
   152 00001C24 BA0100              <1>     mov dx, screenminH
   153 00001C27 A1[B41C]            <1>     mov ax, [mouseY]
   154 00001C2A 39D0                <1>     cmp ax, dx
   155 00001C2C 7E2A                <1>     jle .t_edge
   156                              <1> 
   157 00001C2E 83F817              <1>     cmp ax, screenmaxH
   158 00001C31 7D37                <1>     jge .b_edge
   159                              <1> 
   160 00001C33 C3                  <1>     ret
   161                              <1> 
   162                              <1> .r_edge:
   163 00001C34 C706[B21C]4E00      <1>     mov word [mouseX], screenmaxW
   164 00001C3A 8A16[B21C]          <1>     mov dl, [mouseX]
   165 00001C3E 8A36[B41C]          <1>     mov dh, [mouseY]
   166 00001C42 E87BF5              <1>     call move_cursor
   167 00001C45 C3                  <1>     ret
   168                              <1> 
   169                              <1> .l_edge:
   170 00001C46 C706[B21C]0100      <1>     mov word [mouseX], screenminW
   171 00001C4C 8A16[B21C]          <1>     mov dl, [mouseX]
   172 00001C50 8A36[B41C]          <1>     mov dh, [mouseY]
   173 00001C54 E869F5              <1>     call move_cursor
   174 00001C57 C3                  <1>     ret
   175                              <1> 
   176                              <1> .t_edge:
   177 00001C58 C706[B41C]0100      <1>     mov word [mouseY], screenminH
   178 00001C5E 8A16[B21C]          <1>     mov dl, [mouseX]
   179 00001C62 8A36[B41C]          <1>     mov dh, [mouseY]
   180 00001C66 E857F5              <1>     call move_cursor
   181 00001C69 C3                  <1>     ret
   182                              <1> 
   183                              <1> .b_edge:
   184 00001C6A C706[B41C]1700      <1>     mov word [mouseY], screenmaxH
   185 00001C70 8A16[B21C]          <1>     mov dl, [mouseX]
   186 00001C74 8A36[B41C]          <1>     mov dh, [mouseY]
   187 00001C78 E845F5              <1>     call move_cursor
   188 00001C7B C3                  <1>     ret
   189                              <1> 
   190                              <1> no_mouse:
   191 00001C7C B8[2502]            <1>     mov ax, mouse_yes
   192 00001C7F 31DB                <1>     xor bx, bx
   193 00001C81 31C9                <1>     xor cx, cx
   194 00001C83 BA0000              <1>     mov dx, 0
   195 00001C86 E8CAF5              <1>     call dialog_box
   196                              <1> 
   197 00001C89 31C0                <1>     xor ax, ax
   198 00001C8B CD13                <1>     int 0x13
   199                              <1> 
   200 00001C8D B80010              <1>     mov ax, 0x1000
   201 00001C90 8CD0                <1>     mov ax, ss
   202 00001C92 BC00F0              <1>     mov sp, 0xf000
   203 00001C95 B80753              <1>     mov ax, 0x5307
   204 00001C98 BB0100              <1>     mov bx, 0x0001
   205 00001C9B B90300              <1>     mov cx, 0x0003
   206 00001C9E CD15                <1>     int 0x15
   207                              <1> 
   208                              <1> mouse_loop:
   209 00001CA0 E85FFF              <1>     call poll_mouse
   210 00001CA3 8A16[B21C]          <1>     mov dl, [mouseX]
   211 00001CA7 8A36[B41C]          <1>     mov dh, [mouseY]
   212                              <1>     
   213 00001CAB E812F5              <1>     call move_cursor
   214 00001CAE E864FF              <1>     call clamp_mouse
   215                              <1> 
   216 00001CB1 C3                  <1>     ret
   217                              <1> 
   218 00001CB2 0000                <1> mouseX:         dw 0
   219 00001CB4 0000                <1> mouseY:         dw 0
   220 00001CB6 00                  <1> curStatus:      db 0
   221 00001CB7 0D4572726F72207365- <1> noMouseMsg:     db 0x0d, "Error setting up and initializing mouse", 0x0a, 0x0d, 0
   221 00001CC0 7474696E6720757020- <1>
   221 00001CC9 616E6420696E697469- <1>
   221 00001CD2 616C697A696E67206D- <1>
   221 00001CDB 6F7573650A0D00      <1>
   364                                      %include "./includes/disk.asm"
     1                              <1> ; ==================================================================
     2                              <1> ; The Kronk Operating System kernel
     3                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                              <1> ;
     5                              <1> ; FAT12 FLOPPY DISK ROUTINES
     6                              <1> ; ==================================================================
     7                              <1> 
     8                              <1> ; ------------------------------------------------------------------
     9                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
    10                              <1> ; IN/OUT: AX = location to store zero-terminated filename string
    11                              <1> 
    12                              <1> os_get_file_list:
    13 00001CE2 60                  <1> 	pusha
    14                              <1> 
    15 00001CE3 A3[841D]            <1> 	mov word [.file_list_tmp], ax
    16                              <1> 
    17 00001CE6 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
    18                              <1> 
    19 00001CEC E84007              <1> 	call disk_reset_floppy		; Just in case disk was changed
    20                              <1> 
    21 00001CEF B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
    22 00001CF2 E84907              <1> 	call disk_convert_l2hts
    23                              <1> 
    24 00001CF5 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
    25 00001CF8 89F3                <1> 	mov bx, si
    26                              <1> 
    27 00001CFA B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
    28 00001CFC B00E                <1> 	mov al, 14			; And read 14 of them
    29                              <1> 
    30 00001CFE 60                  <1> 	pusha				; Prepare to enter loop
    31                              <1> 
    32                              <1> 
    33                              <1> .read_root_dir:
    34 00001CFF 61                  <1> 	popa
    35 00001D00 60                  <1> 	pusha
    36                              <1> 
    37 00001D01 F9                  <1> 	stc
    38 00001D02 CD13                <1> 	int 13h				; Read sectors
    39 00001D04 E82807              <1> 	call disk_reset_floppy		; Check we've read them OK
    40 00001D07 7307                <1> 	jnc .show_dir_init		; No errors, continue
    41                              <1> 
    42 00001D09 E82307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
    43 00001D0C 73F1                <1> 	jnc .read_root_dir
    44 00001D0E EB6E                <1> 	jmp .done			; Double error, exit 'dir' routine
    45                              <1> 
    46                              <1> .show_dir_init:
    47 00001D10 61                  <1> 	popa
    48                              <1> 
    49 00001D11 B80000              <1> 	mov ax, 0
    50 00001D14 BE0060              <1> 	mov si, disk_buffer		; Data reader from start of filenames
    51                              <1> 
    52 00001D17 8B3E[841D]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
    53                              <1> 
    54                              <1> 
    55                              <1> .start_entry:
    56 00001D1B 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
    57 00001D1E 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
    58 00001D20 7457                <1> 	je .skip
    59                              <1> 
    60 00001D22 A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
    61 00001D24 7553                <1> 	jnz .skip			; Yes, ignore it
    62                              <1> 
    63 00001D26 8A04                <1> 	mov al, [si]
    64 00001D28 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
    65 00001D2A 744D                <1> 	je .skip
    66                              <1> 
    67 00001D2C 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
    68 00001D2E 744E                <1> 	je .done
    69                              <1> 
    70                              <1> 
    71 00001D30 B90100              <1> 	mov cx, 1			; Set char counter
    72 00001D33 89F2                <1> 	mov dx, si			; Beginning of possible entry
    73                              <1> 
    74                              <1> .testdirentry:
    75 00001D35 46                  <1> 	inc si
    76 00001D36 8A04                <1> 	mov al, [si]			; Test for most unusable characters
    77 00001D38 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
    78 00001D3A 7C3B                <1> 	jl .nxtdirentry
    79 00001D3C 3C7E                <1> 	cmp al, '~'
    80 00001D3E 7737                <1> 	ja .nxtdirentry
    81                              <1> 
    82 00001D40 41                  <1> 	inc cx
    83 00001D41 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
    84 00001D44 7402                <1> 	je .gotfilename
    85 00001D46 EBED                <1> 	jmp .testdirentry
    86                              <1> 
    87                              <1> 
    88                              <1> .gotfilename:				; Got a filename that passes testing
    89 00001D48 89D6                <1> 	mov si, dx			; DX = where getting string
    90                              <1> 
    91 00001D4A B90000              <1> 	mov cx, 0
    92                              <1> .loopy:
    93 00001D4D 8A04                <1> 	mov byte al, [si]
    94 00001D4F 3C20                <1> 	cmp al, ' '
    95 00001D51 7411                <1> 	je .ignore_space
    96 00001D53 8805                <1> 	mov byte [di], al
    97 00001D55 46                  <1> 	inc si
    98 00001D56 47                  <1> 	inc di
    99 00001D57 41                  <1> 	inc cx
   100 00001D58 83F908              <1> 	cmp cx, 8
   101 00001D5B 7410                <1> 	je .add_dot
   102 00001D5D 83F90B              <1> 	cmp cx, 11
   103 00001D60 7411                <1> 	je .done_copy
   104 00001D62 EBE9                <1> 	jmp .loopy
   105                              <1> 
   106                              <1> .ignore_space:
   107 00001D64 46                  <1> 	inc si
   108 00001D65 41                  <1> 	inc cx
   109 00001D66 83F908              <1> 	cmp cx, 8
   110 00001D69 7402                <1> 	je .add_dot
   111 00001D6B EBE0                <1> 	jmp .loopy
   112                              <1> 
   113                              <1> .add_dot:
   114 00001D6D C6052E              <1> 	mov byte [di], '.'
   115 00001D70 47                  <1> 	inc di
   116 00001D71 EBDA                <1> 	jmp .loopy
   117                              <1> 
   118                              <1> .done_copy:
   119 00001D73 C6052C              <1> 	mov byte [di], ','
   120 00001D76 47                  <1> 	inc di
   121                              <1> 
   122                              <1> .nxtdirentry:
   123 00001D77 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
   124                              <1> 
   125                              <1> .skip:
   126 00001D79 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
   127 00001D7C EB9D                <1> 	jmp .start_entry
   128                              <1> 
   129                              <1> 
   130                              <1> .done:
   131 00001D7E 4F                  <1> 	dec di
   132 00001D7F C60500              <1> 	mov byte [di], 0		; Zero-terminate string (gets rid of final comma)
   133                              <1> 
   134 00001D82 61                  <1> 	popa
   135 00001D83 C3                  <1> 	ret
   136                              <1> 
   137 00001D84 0000                <1> 	.file_list_tmp		dw 0
   138                              <1> 
   139                              <1> ; ------------------------------------------------------------------
   140                              <1> ; os_load_file -- Load file into RAM
   141                              <1> ; IN: AX = location of filename, CX = location in RAM to load file
   142                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
   143                              <1> 
   144                              <1> os_load_file:
   145 00001D86 E838F0              <1> 	call string_uppercase
   146 00001D89 E87205              <1> 	call int_filename_convert
   147                              <1> 
   148 00001D8C A3[8E1E]            <1> 	mov [.filename_loc], ax		; Store filename location
   149 00001D8F 890E[901E]          <1> 	mov [.load_position], cx	; And where to load the file!
   150                              <1> 
   151 00001D93 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   152                              <1> 
   153 00001D99 E89306              <1> 	call disk_reset_floppy		; In case floppy has been changed
   154 00001D9C 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
   155                              <1> 
   156 00001D9E B8[A01E]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
   157 00001DA1 E93CFC              <1> 	jmp fatal_error
   158                              <1> 
   159                              <1> 
   160                              <1> .floppy_ok:				; Ready to read first block of data
   161 00001DA4 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   162 00001DA7 E89406              <1> 	call disk_convert_l2hts
   163                              <1> 
   164 00001DAA BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   165 00001DAD 89F3                <1> 	mov bx, si
   166                              <1> 
   167 00001DAF B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   168 00001DB1 B00E                <1> 	mov al, 14			; 14 root directory sectors
   169                              <1> 
   170 00001DB3 60                  <1> 	pusha				; Prepare to enter loop
   171                              <1> 
   172                              <1> 
   173                              <1> .read_root_dir:
   174 00001DB4 61                  <1> 	popa
   175 00001DB5 60                  <1> 	pusha
   176                              <1> 
   177 00001DB6 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
   178 00001DB7 CD13                <1> 	int 13h				; Read sectors
   179 00001DB9 7308                <1> 	jnc .search_root_dir		; No errors = continue
   180                              <1> 
   181 00001DBB E87106              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
   182 00001DBE 73F4                <1> 	jnc .read_root_dir
   183                              <1> 
   184 00001DC0 61                  <1> 	popa
   185 00001DC1 EB38                <1> 	jmp .root_problem		; Double error = exit
   186                              <1> 
   187                              <1> .search_root_dir:
   188 00001DC3 61                  <1> 	popa
   189                              <1> 
   190 00001DC4 B9E000              <1> 	mov cx, word 224		; Search all entries in root dir
   191 00001DC7 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
   192                              <1> 
   193                              <1> .next_root_entry:
   194 00001DCA 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
   195 00001DCD BF0060              <1> 	mov di, disk_buffer		; Point root dir at next entry
   196 00001DD0 01DF                <1> 	add di, bx
   197                              <1> 
   198 00001DD2 8A05                <1> 	mov al, [di]			; First character of name
   199                              <1> 
   200 00001DD4 3C00                <1> 	cmp al, 0			; Last file name already checked?
   201 00001DD6 7423                <1> 	je .root_problem
   202                              <1> 
   203 00001DD8 3CE5                <1> 	cmp al, 229			; Was this file deleted?
   204 00001DDA 74EE                <1> 	je .next_root_entry		; If yes, skip it
   205                              <1> 
   206 00001DDC 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
   207                              <1> 
   208 00001DDF 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
   209 00001DE1 74E7                <1> 	je .next_root_entry
   210                              <1> 
   211 00001DE3 A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   212 00001DE5 75E3                <1> 	jnz .next_root_entry
   213                              <1> 
   214 00001DE7 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
   215                              <1> 
   216 00001DEB 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
   217 00001DED E8D1EF              <1> 	call string_uppercase
   218                              <1> 
   219 00001DF0 8B36[8E1E]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
   220                              <1> 
   221 00001DF4 E885F0              <1> 	call string_compare		; Current entry same as requested?
   222 00001DF7 7207                <1> 	jc .found_file_to_load
   223                              <1> 
   224 00001DF9 E2CF                <1> 	loop .next_root_entry
   225                              <1> 
   226                              <1> .root_problem:
   227 00001DFB BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
   228 00001DFE F9                  <1> 	stc				; return with size = 0 and carry set
   229 00001DFF C3                  <1> 	ret
   230                              <1> 
   231                              <1> 
   232                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
   233 00001E00 8B451C              <1> 	mov ax, [di+28]			; Store file size to return to calling routine
   234 00001E03 A3[921E]            <1> 	mov word [.file_size], ax
   235                              <1> 
   236 00001E06 83F800              <1> 	cmp ax, 0			; If the file size is zero, don't bother trying
   237 00001E09 7478                <1> 	je .end				; to read more clusters
   238                              <1> 
   239 00001E0B 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
   240 00001E0E A3[8A1E]            <1> 	mov word [.cluster], ax
   241                              <1> 
   242 00001E11 B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
   243 00001E14 E82706              <1> 	call disk_convert_l2hts
   244                              <1> 
   245 00001E17 BF0060              <1> 	mov di, disk_buffer		; ES:BX points to our buffer
   246 00001E1A 89FB                <1> 	mov bx, di
   247                              <1> 
   248 00001E1C B402                <1> 	mov ah, 2			; int 13h params: read sectors
   249 00001E1E B009                <1> 	mov al, 9			; And read 9 of them
   250                              <1> 
   251 00001E20 60                  <1> 	pusha
   252                              <1> 
   253                              <1> .read_fat:
   254 00001E21 61                  <1> 	popa				; In case registers altered by int 13h
   255 00001E22 60                  <1> 	pusha
   256                              <1> 
   257 00001E23 F9                  <1> 	stc
   258 00001E24 CD13                <1> 	int 13h
   259 00001E26 7308                <1> 	jnc .read_fat_ok
   260                              <1> 
   261 00001E28 E80406              <1> 	call disk_reset_floppy
   262 00001E2B 73F4                <1> 	jnc .read_fat
   263                              <1> 
   264 00001E2D 61                  <1> 	popa
   265 00001E2E EBCB                <1> 	jmp .root_problem
   266                              <1> 
   267                              <1> 
   268                              <1> .read_fat_ok:
   269 00001E30 61                  <1> 	popa
   270                              <1> 
   271                              <1> 
   272                              <1> .load_file_sector:
   273 00001E31 A1[8A1E]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
   274 00001E34 83C01F              <1> 	add ax, 31
   275                              <1> 
   276 00001E37 E80406              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
   277                              <1> 
   278 00001E3A 8B1E[901E]          <1> 	mov bx, [.load_position]
   279                              <1> 
   280                              <1> 
   281 00001E3E B402                <1> 	mov ah, 02			; AH = read sectors, AL = just read 1
   282 00001E40 B001                <1> 	mov al, 01
   283                              <1> 
   284 00001E42 F9                  <1> 	stc
   285 00001E43 CD13                <1> 	int 13h
   286 00001E45 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
   287                              <1> 
   288 00001E47 E8E505              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
   289 00001E4A 73E5                <1> 	jnc .load_file_sector
   290                              <1> 
   291 00001E4C B8[A01E]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
   292 00001E4F E98EFB              <1> 	jmp fatal_error
   293                              <1> 
   294                              <1> 
   295                              <1> .calculate_next_cluster:
   296 00001E52 A1[8A1E]            <1> 	mov ax, [.cluster]
   297 00001E55 BB0300              <1> 	mov bx, 3
   298 00001E58 F7E3                <1> 	mul bx
   299 00001E5A BB0200              <1> 	mov bx, 2
   300 00001E5D F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
   301 00001E5F BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   302 00001E62 01C6                <1> 	add si, ax
   303 00001E64 3E8B04              <1> 	mov ax, word [ds:si]
   304                              <1> 
   305 00001E67 09D2                <1> 	or dx, dx			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
   306                              <1> 
   307 00001E69 7405                <1> 	jz .even			; If [CLUSTER] = even, drop last 4 bits of word
   308                              <1> 					; with next cluster; if odd, drop first 4 bits
   309                              <1> 
   310                              <1> .odd:
   311 00001E6B C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
   312 00001E6E EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   313                              <1> 
   314                              <1> .even:
   315 00001E70 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
   316                              <1> 
   317                              <1> .calculate_cluster_cont:
   318 00001E73 A3[8A1E]            <1> 	mov word [.cluster], ax		; Store cluster
   319                              <1> 
   320 00001E76 3DF80F              <1> 	cmp ax, 0FF8h
   321 00001E79 7308                <1> 	jae .end
   322                              <1> 
   323 00001E7B 8106[901E]0002      <1> 	add word [.load_position], 512
   324 00001E81 EBAE                <1> 	jmp .load_file_sector		; Onto next sector!
   325                              <1> 
   326                              <1> 
   327                              <1> .end:
   328 00001E83 8B1E[921E]          <1> 	mov bx, [.file_size]		; Get file size to pass back in BX
   329 00001E87 F8                  <1> 	clc				; Carry clear = good load
   330 00001E88 C3                  <1> 	ret
   331                              <1> 
   332                              <1> 
   333 00001E89 00                  <1> 	.bootd		db 0 		; Boot device number
   334 00001E8A 0000                <1> 	.cluster	dw 0 		; Cluster of the file we want to load
   335 00001E8C 0000                <1> 	.pointer	dw 0 		; Pointer into disk_buffer, for loading 'file2load'
   336                              <1> 
   337 00001E8E 0000                <1> 	.filename_loc	dw 0		; Temporary store of filename location
   338 00001E90 0000                <1> 	.load_position	dw 0		; Where we'll load the file
   339 00001E92 0000                <1> 	.file_size	dw 0		; Size of the file
   340                              <1> 
   341 00001E94 00<rept>            <1> 	.string_buff	times 12 db 0	; For size (integer) printing
   342                              <1> 
   343 00001EA0 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy failed to reset', 0
   343 00001EA9 696C653A20466C6F70- <1>
   343 00001EB2 7079206661696C6564- <1>
   343 00001EBB 20746F207265736574- <1>
   343 00001EC4 00                  <1>
   344                              <1> 
   345                              <1> 
   346                              <1> ; --------------------------------------------------------------------------
   347                              <1> ; os_write_file -- Save (max 64K) file to disk
   348                              <1> ; IN: AX = filename, BX = data location, CX = bytes to write
   349                              <1> ; OUT: Carry clear if OK, set if failure
   350                              <1> 
   351                              <1> os_write_file:
   352 00001EC5 60                  <1> 	pusha
   353                              <1> 
   354 00001EC6 89C6                <1> 	mov si, ax
   355 00001EC8 E8A7EE              <1> 	call string_length
   356 00001ECB 83F800              <1> 	cmp ax, 0
   357 00001ECE 0F849201            <1> 	je near .failure
   358 00001ED2 89F0                <1> 	mov ax, si
   359                              <1> 
   360 00001ED4 E8EAEE              <1> 	call string_uppercase
   361 00001ED7 E82404              <1> 	call int_filename_convert	; Make filename FAT12-style
   362 00001EDA 0F828601            <1> 	jc near .failure
   363                              <1> 
   364 00001EDE 890E[6720]          <1> 	mov word [.filesize], cx
   365 00001EE2 891E[6D20]          <1> 	mov word [.location], bx
   366 00001EE6 A3[7120]            <1> 	mov word [.filename], ax
   367                              <1> 
   368 00001EE9 E88702              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
   369 00001EEC 0F837401            <1> 	jnc near .failure
   370                              <1> 
   371                              <1> 
   372                              <1> 	; First, zero out the .free_clusters list from any previous execution
   373 00001EF0 60                  <1> 	pusha
   374                              <1> 
   375 00001EF1 BF[7320]            <1> 	mov di, .free_clusters
   376 00001EF4 B98000              <1> 	mov cx, 128
   377                              <1> .clean_free_loop:
   378 00001EF7 C7050000            <1> 	mov word [di], 0
   379 00001EFB 47                  <1> 	inc di
   380 00001EFC 47                  <1> 	inc di
   381 00001EFD E2F8                <1> 	loop .clean_free_loop
   382                              <1> 
   383 00001EFF 61                  <1> 	popa
   384                              <1> 
   385                              <1> 
   386                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
   387                              <1> 
   388 00001F00 89C8                <1> 	mov ax, cx
   389 00001F02 BA0000              <1> 	mov dx, 0
   390 00001F05 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
   391 00001F08 F7F3                <1> 	div bx
   392 00001F0A 83FA00              <1> 	cmp dx, 0
   393 00001F0D 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
   394 00001F0F EB03                <1> 	jmp .carry_on
   395                              <1> 
   396                              <1> .add_a_bit:
   397 00001F11 83C001              <1> 	add ax, 1
   398                              <1> .carry_on:
   399                              <1> 
   400 00001F14 A3[6F20]            <1> 	mov word [.clusters_needed], ax
   401                              <1> 
   402 00001F17 A1[7120]            <1> 	mov word ax, [.filename]	; Get filename back
   403                              <1> 
   404 00001F1A E87502              <1> 	call os_create_file		; Create empty root dir entry for this file
   405 00001F1D 0F824301            <1> 	jc near .failure		; If we can't write to the media, jump out
   406                              <1> 
   407 00001F21 8B1E[6720]          <1> 	mov word bx, [.filesize]
   408 00001F25 83FB00              <1> 	cmp bx, 0
   409 00001F28 0F843501            <1> 	je near .finished
   410                              <1> 
   411 00001F2C E86B04              <1> 	call disk_read_fat		; Get FAT copy into RAM
   412 00001F2F BE0360              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
   413                              <1> 
   414 00001F32 BB0200              <1> 	mov bx, 2			; Current cluster counter
   415 00001F35 8B0E[6F20]          <1> 	mov word cx, [.clusters_needed]
   416 00001F39 BA0000              <1> 	mov dx, 0			; Offset in .free_clusters list
   417                              <1> 
   418                              <1> .find_free_cluster:
   419 00001F3C AD                  <1> 	lodsw				; Get a word
   420 00001F3D 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
   421 00001F40 740D                <1> 	jz .found_free_even		; Free entry?
   422                              <1> 
   423                              <1> .more_odd:
   424 00001F42 43                  <1> 	inc bx				; If not, bump our counter
   425 00001F43 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
   426                              <1> 
   427 00001F44 AD                  <1> 	lodsw				; Get word
   428 00001F45 C1E804              <1> 	shr ax, 4			; Shift for odd
   429 00001F48 09C0                <1> 	or ax, ax			; Free entry?
   430 00001F4A 7416                <1> 	jz .found_free_odd
   431                              <1> 
   432                              <1> .more_even:
   433 00001F4C 43                  <1> 	inc bx				; If not, keep going
   434 00001F4D EBED                <1> 	jmp .find_free_cluster
   435                              <1> 
   436                              <1> 
   437                              <1> .found_free_even:
   438 00001F4F 56                  <1> 	push si
   439 00001F50 BE[7320]            <1> 	mov si, .free_clusters		; Store cluster
   440 00001F53 01D6                <1> 	add si, dx
   441 00001F55 891C                <1> 	mov word [si], bx
   442 00001F57 5E                  <1> 	pop si
   443                              <1> 
   444 00001F58 49                  <1> 	dec cx				; Got all the clusters we need?
   445 00001F59 83F900              <1> 	cmp cx, 0
   446 00001F5C 7417                <1> 	je .finished_list
   447                              <1> 
   448 00001F5E 42                  <1> 	inc dx				; Next word in our list
   449 00001F5F 42                  <1> 	inc dx
   450 00001F60 EBE0                <1> 	jmp .more_odd
   451                              <1> 
   452                              <1> .found_free_odd:
   453 00001F62 56                  <1> 	push si
   454 00001F63 BE[7320]            <1> 	mov si, .free_clusters		; Store cluster
   455 00001F66 01D6                <1> 	add si, dx
   456 00001F68 891C                <1> 	mov word [si], bx
   457 00001F6A 5E                  <1> 	pop si
   458                              <1> 
   459 00001F6B 49                  <1> 	dec cx
   460 00001F6C 83F900              <1> 	cmp cx, 0
   461 00001F6F 7404                <1> 	je .finished_list
   462                              <1> 
   463 00001F71 42                  <1> 	inc dx				; Next word in our list
   464 00001F72 42                  <1> 	inc dx
   465 00001F73 EBD7                <1> 	jmp .more_even
   466                              <1> 
   467                              <1> 
   468                              <1> 
   469                              <1> .finished_list:
   470                              <1> 
   471                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
   472                              <1> 	; that correspond to free clusters on the disk; the next job is to
   473                              <1> 	; create a cluster chain in the FAT for our file
   474                              <1> 
   475 00001F75 B90000              <1> 	mov cx, 0			; .free_clusters offset counter
   476 00001F78 C706[6B20]0100      <1> 	mov word [.count], 1		; General cluster counter
   477                              <1> 
   478                              <1> .chain_loop:
   479 00001F7E A1[6B20]            <1> 	mov word ax, [.count]		; Is this the last cluster?
   480 00001F81 3B06[6F20]          <1> 	cmp word ax, [.clusters_needed]
   481 00001F85 7455                <1> 	je .last_cluster
   482                              <1> 
   483 00001F87 BF[7320]            <1> 	mov di, .free_clusters
   484                              <1> 
   485 00001F8A 01CF                <1> 	add di, cx
   486 00001F8C 8B1D                <1> 	mov word bx, [di]		; Get cluster
   487                              <1> 
   488 00001F8E 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
   489 00001F90 BA0000              <1> 	mov dx, 0
   490 00001F93 BB0300              <1> 	mov bx, 3
   491 00001F96 F7E3                <1> 	mul bx
   492 00001F98 BB0200              <1> 	mov bx, 2
   493 00001F9B F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   494 00001F9D BE0060              <1> 	mov si, disk_buffer
   495 00001FA0 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   496 00001FA2 3E8B04              <1> 	mov ax, word [ds:si]
   497                              <1> 
   498 00001FA5 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   499 00001FA7 741B                <1> 	jz .even
   500                              <1> 
   501                              <1> .odd:
   502 00001FA9 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
   503 00001FAC BF[7320]            <1> 	mov di, .free_clusters
   504 00001FAF 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   505 00001FB1 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
   506 00001FB4 C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
   507 00001FB7 01D8                <1> 	add ax, bx
   508                              <1> 
   509 00001FB9 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   510                              <1> 
   511 00001FBC FF06[6B20]          <1> 	inc word [.count]
   512 00001FC0 41                  <1> 	inc cx				; Move on a word in .free_clusters
   513 00001FC1 41                  <1> 	inc cx
   514                              <1> 
   515 00001FC2 EBBA                <1> 	jmp .chain_loop
   516                              <1> 
   517                              <1> .even:
   518 00001FC4 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
   519 00001FC7 BF[7320]            <1> 	mov di, .free_clusters
   520 00001FCA 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   521 00001FCC 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
   522                              <1> 
   523 00001FCF 01D8                <1> 	add ax, bx
   524                              <1> 
   525 00001FD1 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   526                              <1> 
   527 00001FD4 FF06[6B20]          <1> 	inc word [.count]
   528 00001FD8 41                  <1> 	inc cx				; Move on a word in .free_clusters
   529 00001FD9 41                  <1> 	inc cx
   530                              <1> 
   531 00001FDA EBA2                <1> 	jmp .chain_loop
   532                              <1> 
   533                              <1> 
   534                              <1> 
   535                              <1> .last_cluster:
   536 00001FDC BF[7320]            <1> 	mov di, .free_clusters
   537 00001FDF 01CF                <1> 	add di, cx
   538 00001FE1 8B1D                <1> 	mov word bx, [di]		; Get cluster
   539                              <1> 
   540 00001FE3 89D8                <1> 	mov ax, bx
   541                              <1> 
   542 00001FE5 BA0000              <1> 	mov dx, 0
   543 00001FE8 BB0300              <1> 	mov bx, 3
   544 00001FEB F7E3                <1> 	mul bx
   545 00001FED BB0200              <1> 	mov bx, 2
   546 00001FF0 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   547 00001FF2 BE0060              <1> 	mov si, disk_buffer
   548 00001FF5 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   549 00001FF7 3E8B04              <1> 	mov ax, word [ds:si]
   550                              <1> 
   551 00001FFA 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   552 00001FFC 7408                <1> 	jz .even_last
   553                              <1> 
   554                              <1> .odd_last:
   555 00001FFE 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
   556 00002001 83C080              <1> 	add ax, 0FF80h
   557 00002004 EB06                <1> 	jmp .finito
   558                              <1> 
   559                              <1> .even_last:
   560 00002006 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
   561 00002009 05F80F              <1> 	add ax, 0FF8h
   562                              <1> 
   563                              <1> 
   564                              <1> .finito:
   565 0000200C 3E8904              <1> 	mov word [ds:si], ax
   566                              <1> 
   567 0000200F E8B403              <1> 	call disk_write_fat		; Save our FAT back to disk
   568                              <1> 
   569                              <1> 
   570                              <1> 	; Now it's time to save the sectors to disk!
   571                              <1> 
   572 00002012 B90000              <1> 	mov cx, 0
   573                              <1> 
   574                              <1> .save_loop:
   575 00002015 BF[7320]            <1> 	mov di, .free_clusters
   576 00002018 01CF                <1> 	add di, cx
   577 0000201A 8B05                <1> 	mov word ax, [di]
   578                              <1> 
   579 0000201C 83F800              <1> 	cmp ax, 0
   580 0000201F 0F841D00            <1> 	je near .write_root_entry
   581                              <1> 
   582 00002023 60                  <1> 	pusha
   583                              <1> 
   584 00002024 83C01F              <1> 	add ax, 31
   585                              <1> 
   586 00002027 E81404              <1> 	call disk_convert_l2hts
   587                              <1> 
   588 0000202A 8B1E[6D20]          <1> 	mov word bx, [.location]
   589                              <1> 
   590 0000202E B403                <1> 	mov ah, 3
   591 00002030 B001                <1> 	mov al, 1
   592 00002032 F9                  <1> 	stc
   593 00002033 CD13                <1> 	int 13h
   594                              <1> 
   595 00002035 61                  <1> 	popa
   596                              <1> 
   597 00002036 8106[6D20]0002      <1> 	add word [.location], 512
   598 0000203C 41                  <1> 	inc cx
   599 0000203D 41                  <1> 	inc cx
   600 0000203E EBD5                <1> 	jmp .save_loop
   601                              <1> 
   602                              <1> 
   603                              <1> .write_root_entry:
   604                              <1> 
   605                              <1> 	; Now it's time to head back to the root directory, find our
   606                              <1> 	; entry and update it with the cluster in use and file size
   607                              <1> 
   608 00002040 E8A203              <1> 	call disk_read_root_dir
   609                              <1> 
   610 00002043 A1[7120]            <1> 	mov word ax, [.filename]
   611 00002046 E81903              <1> 	call disk_get_root_entry
   612                              <1> 
   613 00002049 A1[7320]            <1> 	mov word ax, [.free_clusters]	; Get first free cluster
   614                              <1> 
   615 0000204C 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
   616                              <1> 
   617 0000204F 8B0E[6720]          <1> 	mov word cx, [.filesize]
   618 00002053 894D1C              <1> 	mov word [di+28], cx
   619                              <1> 
   620 00002056 C6451E00            <1> 	mov byte [di+30], 0		; File size
   621 0000205A C6451F00            <1> 	mov byte [di+31], 0
   622                              <1> 
   623 0000205E E8AF03              <1> 	call disk_write_root_dir
   624                              <1> 
   625                              <1> .finished:
   626 00002061 61                  <1> 	popa
   627 00002062 F8                  <1> 	clc
   628 00002063 C3                  <1> 	ret
   629                              <1> 
   630                              <1> .failure:
   631 00002064 61                  <1> 	popa
   632 00002065 F9                  <1> 	stc				; Couldn't write!
   633 00002066 C3                  <1> 	ret
   634                              <1> 
   635                              <1> 
   636 00002067 0000                <1> 	.filesize	dw 0
   637 00002069 0000                <1> 	.cluster	dw 0
   638 0000206B 0000                <1> 	.count		dw 0
   639 0000206D 0000                <1> 	.location	dw 0
   640                              <1> 
   641 0000206F 0000                <1> 	.clusters_needed	dw 0
   642                              <1> 
   643 00002071 0000                <1> 	.filename	dw 0
   644                              <1> 
   645 00002073 0000<rept>          <1> 	.free_clusters	times 128 dw 0
   646                              <1> 
   647                              <1> 
   648                              <1> ; --------------------------------------------------------------------------
   649                              <1> ; os_file_exists -- Check for presence of file on the floppy
   650                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
   651                              <1> 
   652                              <1> os_file_exists:
   653 00002173 E84BEC              <1> 	call string_uppercase
   654 00002176 E88501              <1> 	call int_filename_convert	; Make FAT12-style filename
   655                              <1> 
   656 00002179 50                  <1> 	push ax
   657 0000217A E8F5EB              <1> 	call string_length
   658 0000217D 83F800              <1> 	cmp ax, 0
   659 00002180 740D                <1> 	je .failure
   660 00002182 58                  <1> 	pop ax
   661                              <1> 
   662 00002183 50                  <1> 	push ax
   663 00002184 E85E02              <1> 	call disk_read_root_dir
   664                              <1> 
   665 00002187 58                  <1> 	pop ax				; Restore filename
   666 00002188 BF0060              <1> 	mov di, disk_buffer
   667 0000218B E8D401              <1> 	call disk_get_root_entry	; Set or clear carry flag
   668                              <1> 	
   669 0000218E C3                  <1> 	ret
   670                              <1> 
   671                              <1> .failure:
   672 0000218F 58                  <1> 	pop ax
   673 00002190 F9                  <1> 	stc
   674 00002191 C3                  <1> 	ret
   675                              <1> 
   676                              <1> 
   677                              <1> ; --------------------------------------------------------------------------
   678                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
   679                              <1> ; IN: AX = location of filename
   680                              <1> 
   681                              <1> os_create_file:
   682 00002192 F8                  <1> 	clc
   683                              <1> 
   684 00002193 E82BEC              <1> 	call string_uppercase
   685 00002196 E86501              <1> 	call int_filename_convert	; Make FAT12-style filename
   686 00002199 60                  <1> 	pusha
   687                              <1> 
   688 0000219A 50                  <1> 	push ax				; Save filename for now
   689                              <1> 
   690 0000219B E8D5FF              <1> 	call os_file_exists		; Does the file already exist?
   691 0000219E 7315                <1> 	jnc .exists_error
   692                              <1> 
   693                              <1> 
   694                              <1> 	; Root dir already read into disk_buffer by os_file_exists
   695                              <1> 
   696 000021A0 BF0060              <1> 	mov di, disk_buffer		; So point DI at it!
   697                              <1> 
   698                              <1> 
   699 000021A3 B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
   700                              <1> .next_entry:
   701 000021A6 8A05                <1> 	mov byte al, [di]
   702 000021A8 3C00                <1> 	cmp al, 0			; Is this a free entry?
   703 000021AA 740D                <1> 	je .found_free_entry
   704 000021AC 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
   705 000021AE 7409                <1> 	je .found_free_entry
   706 000021B0 83C720              <1> 	add di, 32			; If not, go onto next entry
   707 000021B3 E2F1                <1> 	loop .next_entry
   708                              <1> 
   709                              <1> .exists_error:				; We also get here if above loop finds nothing
   710 000021B5 58                  <1> 	pop ax				; Get filename back
   711                              <1> 
   712 000021B6 61                  <1> 	popa
   713 000021B7 F9                  <1> 	stc				; Set carry for failure
   714 000021B8 C3                  <1> 	ret
   715                              <1> 
   716                              <1> 
   717                              <1> .found_free_entry:
   718 000021B9 5E                  <1> 	pop si				; Get filename back
   719 000021BA B90B00              <1> 	mov cx, 11
   720 000021BD F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
   721                              <1> 
   722                              <1> 
   723 000021BF 83EF0B              <1> 	sub di, 11			; Back to start of root dir entry, for clarity
   724                              <1> 
   725                              <1> 
   726 000021C2 C6450B00            <1> 	mov byte [di+11], 0		; Attributes
   727 000021C6 C6450C00            <1> 	mov byte [di+12], 0		; Reserved
   728 000021CA C6450D00            <1> 	mov byte [di+13], 0		; Reserved
   729 000021CE C6450EC6            <1> 	mov byte [di+14], 0C6h		; Creation time
   730 000021D2 C6450F7E            <1> 	mov byte [di+15], 07Eh		; Creation time
   731 000021D6 C6451000            <1> 	mov byte [di+16], 0		; Creation date
   732 000021DA C6451100            <1> 	mov byte [di+17], 0		; Creation date
   733 000021DE C6451200            <1> 	mov byte [di+18], 0		; Last access date
   734 000021E2 C6451300            <1> 	mov byte [di+19], 0		; Last access date
   735 000021E6 C6451400            <1> 	mov byte [di+20], 0		; Ignore in FAT12
   736 000021EA C6451500            <1> 	mov byte [di+21], 0		; Ignore in FAT12
   737 000021EE C64516C6            <1> 	mov byte [di+22], 0C6h		; Last write time
   738 000021F2 C645177E            <1> 	mov byte [di+23], 07Eh		; Last write time
   739 000021F6 C6451800            <1> 	mov byte [di+24], 0		; Last write date
   740 000021FA C6451900            <1> 	mov byte [di+25], 0		; Last write date
   741 000021FE C6451A00            <1> 	mov byte [di+26], 0		; First logical cluster
   742 00002202 C6451B00            <1> 	mov byte [di+27], 0		; First logical cluster
   743 00002206 C6451C00            <1> 	mov byte [di+28], 0		; File size
   744 0000220A C6451D00            <1> 	mov byte [di+29], 0		; File size
   745 0000220E C6451E00            <1> 	mov byte [di+30], 0		; File size
   746 00002212 C6451F00            <1> 	mov byte [di+31], 0		; File size
   747                              <1> 
   748 00002216 E8F701              <1> 	call disk_write_root_dir
   749 00002219 7203                <1> 	jc .failure
   750                              <1> 
   751 0000221B 61                  <1> 	popa
   752 0000221C F8                  <1> 	clc				; Clear carry for success
   753 0000221D C3                  <1> 	ret
   754                              <1> 
   755                              <1> .failure:
   756 0000221E 61                  <1> 	popa
   757 0000221F F9                  <1> 	stc
   758 00002220 C3                  <1> 	ret
   759                              <1> 
   760                              <1> 
   761                              <1> ; --------------------------------------------------------------------------
   762                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
   763                              <1> ; IN: AX = location of filename to remove
   764                              <1> 
   765                              <1> os_remove_file:
   766 00002221 60                  <1> 	pusha
   767 00002222 E89CEB              <1> 	call string_uppercase
   768 00002225 E8D600              <1> 	call int_filename_convert	; Make filename FAT12-style
   769 00002228 50                  <1> 	push ax				; Save filename
   770                              <1> 
   771 00002229 F8                  <1> 	clc
   772                              <1> 
   773 0000222A E8B801              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
   774                              <1> 
   775 0000222D BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
   776                              <1> 
   777 00002230 58                  <1> 	pop ax				; Get chosen filename back
   778                              <1> 
   779 00002231 E82E01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
   780 00002234 7269                <1> 	jc .failure			; If entry can't be found
   781                              <1> 
   782                              <1> 
   783 00002236 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
   784 0000223A A3[A222]            <1> 	mov word [.cluster], ax		; And save it
   785                              <1> 
   786 0000223D C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
   787                              <1> 
   788 00002240 47                  <1> 	inc di
   789                              <1> 
   790 00002241 B90000              <1> 	mov cx, 0			; Set rest of data in root dir entry to zeros
   791                              <1> .clean_loop:
   792 00002244 C60500              <1> 	mov byte [di], 0
   793 00002247 47                  <1> 	inc di
   794 00002248 41                  <1> 	inc cx
   795 00002249 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
   796 0000224C 7CF6                <1> 	jl .clean_loop
   797                              <1> 
   798 0000224E E8BF01              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
   799                              <1> 
   800                              <1> 
   801 00002251 E84601              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
   802 00002254 BF0060              <1> 	mov di, disk_buffer		; And DI points to it
   803                              <1> 
   804                              <1> 
   805                              <1> .more_clusters:
   806 00002257 A1[A222]            <1> 	mov word ax, [.cluster]		; Get cluster contents
   807                              <1> 
   808 0000225A 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
   809 0000225D 743D                <1> 	je .nothing_to_do
   810                              <1> 
   811 0000225F BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
   812 00002262 F7E3                <1> 	mul bx
   813 00002264 BB0200              <1> 	mov bx, 2
   814 00002267 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
   815 00002269 BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   816 0000226C 01C6                <1> 	add si, ax
   817 0000226E 3E8B04              <1> 	mov ax, word [ds:si]
   818                              <1> 
   819 00002271 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
   820                              <1> 
   821 00002273 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
   822                              <1> 					; with next cluster; if odd, drop first 4 bits
   823                              <1> .odd:
   824 00002275 50                  <1> 	push ax
   825 00002276 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
   826 00002279 3E8904              <1> 	mov word [ds:si], ax
   827 0000227C 58                  <1> 	pop ax
   828                              <1> 
   829 0000227D C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
   830 00002280 EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   831                              <1> 
   832                              <1> .even:
   833 00002282 50                  <1> 	push ax
   834 00002283 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
   835 00002286 3E8904              <1> 	mov word [ds:si], ax
   836 00002289 58                  <1> 	pop ax
   837                              <1> 
   838 0000228A 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
   839                              <1> 
   840                              <1> .calculate_cluster_cont:
   841 0000228D A3[A222]            <1> 	mov word [.cluster], ax		; Store cluster
   842                              <1> 
   843 00002290 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
   844 00002293 7302                <1> 	jae .end
   845                              <1> 
   846 00002295 EBC0                <1> 	jmp .more_clusters		; If not, grab more
   847                              <1> 
   848                              <1> .end:
   849 00002297 E82C01              <1> 	call disk_write_fat
   850 0000229A 7203                <1> 	jc .failure
   851                              <1> 
   852                              <1> .nothing_to_do:
   853 0000229C 61                  <1> 	popa
   854 0000229D F8                  <1> 	clc
   855 0000229E C3                  <1> 	ret
   856                              <1> 
   857                              <1> .failure:
   858 0000229F 61                  <1> 	popa
   859 000022A0 F9                  <1> 	stc
   860 000022A1 C3                  <1> 	ret
   861                              <1> 
   862                              <1> 
   863 000022A2 0000                <1> 	.cluster dw 0
   864                              <1> 
   865                              <1> 
   866                              <1> ; --------------------------------------------------------------------------
   867                              <1> ; os_rename_file -- Change the name of a file on the disk
   868                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
   869                              <1> ; OUT: carry set on error
   870                              <1> 
   871                              <1> os_rename_file:
   872 000022A4 53                  <1> 	push bx
   873 000022A5 50                  <1> 	push ax
   874                              <1> 
   875 000022A6 F8                  <1> 	clc
   876                              <1> 
   877 000022A7 E83B01              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
   878                              <1> 
   879 000022AA BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
   880                              <1> 
   881 000022AD 58                  <1> 	pop ax				; Get chosen filename back
   882                              <1> 
   883 000022AE E810EB              <1> 	call string_uppercase
   884 000022B1 E84A00              <1> 	call int_filename_convert
   885                              <1> 
   886 000022B4 E8AB00              <1> 	call disk_get_root_entry	; Entry will be returned in DI
   887 000022B7 7217                <1> 	jc .fail_read			; Quit out if file not found
   888                              <1> 
   889 000022B9 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
   890                              <1> 
   891 000022BA 89D8                <1> 	mov ax, bx
   892                              <1> 
   893 000022BC E802EB              <1> 	call string_uppercase
   894 000022BF E83C00              <1> 	call int_filename_convert
   895                              <1> 
   896 000022C2 89C6                <1> 	mov si, ax
   897                              <1> 
   898 000022C4 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
   899 000022C7 F3A4                <1> 	rep movsb
   900                              <1> 
   901 000022C9 E84401              <1> 	call disk_write_root_dir	; Save root dir to disk
   902 000022CC 7205                <1> 	jc .fail_write
   903                              <1> 
   904 000022CE F8                  <1> 	clc
   905 000022CF C3                  <1> 	ret
   906                              <1> 
   907                              <1> .fail_read:
   908 000022D0 58                  <1> 	pop ax
   909 000022D1 F9                  <1> 	stc
   910 000022D2 C3                  <1> 	ret
   911                              <1> 
   912                              <1> .fail_write:
   913 000022D3 F9                  <1> 	stc
   914 000022D4 C3                  <1> 	ret
   915                              <1> 
   916                              <1> 
   917                              <1> ; --------------------------------------------------------------------------
   918                              <1> ; os_get_file_size -- Get file size information for specified file
   919                              <1> ; IN: AX = filename; OUT: BX = file size in bytes (up to 64K)
   920                              <1> ; or carry set if file not found
   921                              <1> 
   922                              <1> os_get_file_size:
   923 000022D5 60                  <1> 	pusha
   924                              <1> 
   925 000022D6 E8E8EA              <1> 	call string_uppercase
   926 000022D9 E82200              <1> 	call int_filename_convert
   927                              <1> 
   928 000022DC F8                  <1> 	clc
   929                              <1> 
   930 000022DD 50                  <1> 	push ax
   931                              <1> 
   932 000022DE E80401              <1> 	call disk_read_root_dir
   933 000022E1 7216                <1> 	jc .failure
   934                              <1> 
   935 000022E3 58                  <1> 	pop ax
   936                              <1> 
   937 000022E4 BF0060              <1> 	mov di, disk_buffer
   938                              <1> 
   939 000022E7 E87800              <1> 	call disk_get_root_entry
   940 000022EA 720D                <1> 	jc .failure
   941                              <1> 
   942 000022EC 8B5D1C              <1> 	mov word bx, [di+28]
   943                              <1> 
   944 000022EF 891E[FC22]          <1> 	mov word [.tmp], bx
   945                              <1> 
   946 000022F3 61                  <1> 	popa
   947                              <1> 
   948 000022F4 8B1E[FC22]          <1> 	mov word bx, [.tmp]
   949                              <1> 
   950 000022F8 C3                  <1> 	ret
   951                              <1> 
   952                              <1> .failure:
   953 000022F9 61                  <1> 	popa
   954 000022FA F9                  <1> 	stc
   955 000022FB C3                  <1> 	ret
   956                              <1> 
   957                              <1> 
   958 000022FC 0000                <1> 	.tmp	dw 0
   959                              <1> 
   960                              <1> 
   961                              <1> ; ==================================================================
   962                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
   963                              <1> 
   964                              <1> ; ------------------------------------------------------------------
   965                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
   966                              <1> ; IN: AX = filename string
   967                              <1> ; OUT: AX = location of converted string (carry set if invalid)
   968                              <1> 
   969                              <1> int_filename_convert:
   970 000022FE 60                  <1> 	pusha
   971                              <1> 
   972 000022FF 89C6                <1> 	mov si, ax
   973                              <1> 
   974 00002301 E86EEA              <1> 	call string_length
   975 00002304 83F80E              <1> 	cmp ax, 14			; Filename too long?
   976 00002307 7F49                <1> 	jg .failure			; Fail if so
   977                              <1> 
   978 00002309 83F800              <1> 	cmp ax, 0
   979 0000230C 7444                <1> 	je .failure			; Similarly, fail if zero-char string
   980                              <1> 
   981 0000230E 89C2                <1> 	mov dx, ax			; Store string length for now
   982                              <1> 
   983 00002310 BF[5523]            <1> 	mov di, .dest_string
   984                              <1> 
   985 00002313 B90000              <1> 	mov cx, 0
   986                              <1> .copy_loop:
   987 00002316 AC                  <1> 	lodsb
   988 00002317 3C2E                <1> 	cmp al, '.'
   989 00002319 7408                <1> 	je .extension_found
   990 0000231B AA                  <1> 	stosb
   991 0000231C 41                  <1> 	inc cx
   992 0000231D 39D1                <1> 	cmp cx, dx
   993 0000231F 7F31                <1> 	jg .failure			; No extension found = wrong
   994 00002321 EBF3                <1> 	jmp .copy_loop
   995                              <1> 
   996                              <1> .extension_found:
   997 00002323 83F900              <1> 	cmp cx, 0
   998 00002326 742A                <1> 	je .failure			; Fail if extension dot is first char
   999                              <1> 
  1000 00002328 83F908              <1> 	cmp cx, 8
  1001 0000232B 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  1002                              <1> 
  1003                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  1004                              <1> 	; with spaces, if necessary
  1005                              <1> 
  1006                              <1> .add_spaces:
  1007 0000232D C60520              <1> 	mov byte [di], ' '
  1008 00002330 47                  <1> 	inc di
  1009 00002331 41                  <1> 	inc cx
  1010 00002332 83F908              <1> 	cmp cx, 8
  1011 00002335 7CF6                <1> 	jl .add_spaces
  1012                              <1> 
  1013                              <1> 	; Finally, copy over the extension
  1014                              <1> .do_extension:
  1015 00002337 AC                  <1> 	lodsb				; 3 characters
  1016 00002338 3C00                <1> 	cmp al, 0
  1017 0000233A 7416                <1> 	je .failure
  1018 0000233C AA                  <1> 	stosb
  1019 0000233D AC                  <1> 	lodsb
  1020 0000233E 3C00                <1> 	cmp al, 0
  1021 00002340 7410                <1> 	je .failure
  1022 00002342 AA                  <1> 	stosb
  1023 00002343 AC                  <1> 	lodsb
  1024 00002344 3C00                <1> 	cmp al, 0
  1025 00002346 740A                <1> 	je .failure
  1026 00002348 AA                  <1> 	stosb
  1027                              <1> 
  1028 00002349 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  1029                              <1> 
  1030 0000234C 61                  <1> 	popa
  1031 0000234D B8[5523]            <1> 	mov ax, .dest_string
  1032 00002350 F8                  <1> 	clc				; Clear carry for success
  1033 00002351 C3                  <1> 	ret
  1034                              <1> 
  1035                              <1> 
  1036                              <1> .failure:
  1037 00002352 61                  <1> 	popa
  1038 00002353 F9                  <1> 	stc				; Set carry for failure
  1039 00002354 C3                  <1> 	ret
  1040                              <1> 
  1041                              <1> 
  1042 00002355 00<rept>            <1> 	.dest_string	times 13 db 0
  1043                              <1> 
  1044                              <1> 
  1045                              <1> ; --------------------------------------------------------------------------
  1046                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  1047                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  1048                              <1> ; or carry set if file not found
  1049                              <1> 
  1050                              <1> disk_get_root_entry:
  1051 00002362 60                  <1> 	pusha
  1052                              <1> 
  1053 00002363 A3[9623]            <1> 	mov word [.filename], ax
  1054                              <1> 
  1055 00002366 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  1056 00002369 B80000              <1> 	mov ax, 0			; Searching at offset 0
  1057                              <1> 
  1058                              <1> .to_next_root_entry:
  1059 0000236C 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  1060                              <1> 
  1061 0000236E 8B36[9623]          <1> 	mov word si, [.filename]	; Start searching for filename
  1062 00002372 B90B00              <1> 	mov cx, 11
  1063 00002375 F3A6                <1> 	rep cmpsb
  1064 00002377 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  1065                              <1> 
  1066 00002379 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  1067                              <1> 
  1068 0000237C BF0060              <1> 	mov di, disk_buffer		; Point to next root dir entry
  1069 0000237F 01C7                <1> 	add di, ax
  1070                              <1> 
  1071 00002381 87D1                <1> 	xchg dx, cx			; Get the original CX back
  1072 00002383 E2E7                <1> 	loop .to_next_root_entry
  1073                              <1> 
  1074 00002385 61                  <1> 	popa
  1075                              <1> 
  1076 00002386 F9                  <1> 	stc				; Set carry if entry not found
  1077 00002387 C3                  <1> 	ret
  1078                              <1> 
  1079                              <1> 
  1080                              <1> .found_file:
  1081 00002388 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  1082                              <1> 
  1083 0000238B 893E[9823]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  1084                              <1> 
  1085 0000238F 61                  <1> 	popa
  1086                              <1> 
  1087 00002390 8B3E[9823]          <1> 	mov word di, [.tmp]
  1088                              <1> 
  1089 00002394 F8                  <1> 	clc
  1090 00002395 C3                  <1> 	ret
  1091                              <1> 
  1092                              <1> 
  1093 00002396 0000                <1> 	.filename	dw 0
  1094 00002398 0000                <1> 	.tmp		dw 0
  1095                              <1> 
  1096                              <1> 
  1097                              <1> ; --------------------------------------------------------------------------
  1098                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  1099                              <1> ; IN: Nothing; OUT: carry set if failure
  1100                              <1> 
  1101                              <1> disk_read_fat:
  1102 0000239A 60                  <1> 	pusha
  1103                              <1> 
  1104 0000239B B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1105 0000239E E89D00              <1> 	call disk_convert_l2hts
  1106                              <1> 
  1107 000023A1 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1108 000023A4 BB0020              <1> 	mov bx, 2000h
  1109 000023A7 8EC3                <1> 	mov es, bx
  1110 000023A9 89F3                <1> 	mov bx, si
  1111                              <1> 
  1112 000023AB B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1113 000023AD B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  1114                              <1> 
  1115 000023AF 60                  <1> 	pusha				; Prepare to enter loop
  1116                              <1> 
  1117                              <1> 
  1118                              <1> .read_fat_loop:
  1119 000023B0 61                  <1> 	popa
  1120 000023B1 60                  <1> 	pusha
  1121                              <1> 
  1122 000023B2 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1123 000023B3 CD13                <1> 	int 13h				; Read sectors
  1124                              <1> 
  1125 000023B5 7308                <1> 	jnc .fat_done
  1126 000023B7 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  1127 000023BA 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  1128                              <1> 
  1129 000023BC 61                  <1> 	popa
  1130 000023BD EB04                <1> 	jmp .read_failure		; Fatal double error
  1131                              <1> 
  1132                              <1> .fat_done:
  1133 000023BF 61                  <1> 	popa				; Restore registers from main loop
  1134                              <1> 
  1135 000023C0 61                  <1> 	popa				; And restore registers from start of system call
  1136 000023C1 F8                  <1> 	clc
  1137 000023C2 C3                  <1> 	ret
  1138                              <1> 
  1139                              <1> .read_failure:
  1140 000023C3 61                  <1> 	popa
  1141 000023C4 F9                  <1> 	stc				; Set carry flag (for failure)
  1142 000023C5 C3                  <1> 	ret
  1143                              <1> 
  1144                              <1> 
  1145                              <1> ; --------------------------------------------------------------------------
  1146                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  1147                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  1148                              <1> 
  1149                              <1> disk_write_fat:
  1150 000023C6 60                  <1> 	pusha
  1151                              <1> 
  1152 000023C7 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1153 000023CA E87100              <1> 	call disk_convert_l2hts
  1154                              <1> 
  1155 000023CD BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1156 000023D0 8CDB                <1> 	mov bx, ds
  1157 000023D2 8EC3                <1> 	mov es, bx
  1158 000023D4 89F3                <1> 	mov bx, si
  1159                              <1> 
  1160 000023D6 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1161 000023D8 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  1162                              <1> 
  1163 000023DA F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1164 000023DB CD13                <1> 	int 13h				; Write sectors
  1165                              <1> 
  1166 000023DD 7203                <1> 	jc .write_failure		; Fatal double error
  1167                              <1> 
  1168 000023DF 61                  <1> 	popa				; And restore from start of system call
  1169 000023E0 F8                  <1> 	clc
  1170 000023E1 C3                  <1> 	ret
  1171                              <1> 
  1172                              <1> .write_failure:
  1173 000023E2 61                  <1> 	popa
  1174 000023E3 F9                  <1> 	stc				; Set carry flag (for failure)
  1175 000023E4 C3                  <1> 	ret
  1176                              <1> 
  1177                              <1> 
  1178                              <1> ; --------------------------------------------------------------------------
  1179                              <1> ; disk_read_root_dir -- Get the root directory contents
  1180                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  1181                              <1> 
  1182                              <1> disk_read_root_dir:
  1183 000023E5 60                  <1> 	pusha
  1184                              <1> 
  1185 000023E6 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1186 000023E9 E85200              <1> 	call disk_convert_l2hts
  1187                              <1> 
  1188 000023EC BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1189 000023EF 8CDB                <1> 	mov bx, ds
  1190 000023F1 8EC3                <1> 	mov es, bx
  1191 000023F3 89F3                <1> 	mov bx, si
  1192                              <1> 
  1193 000023F5 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1194 000023F7 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  1195                              <1> 
  1196 000023F9 60                  <1> 	pusha				; Prepare to enter loop
  1197                              <1> 
  1198                              <1> 
  1199                              <1> .read_root_dir_loop:
  1200 000023FA 61                  <1> 	popa
  1201 000023FB 60                  <1> 	pusha
  1202                              <1> 
  1203 000023FC F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1204 000023FD CD13                <1> 	int 13h				; Read sectors
  1205                              <1> 
  1206 000023FF 7308                <1> 	jnc .root_dir_finished
  1207 00002401 E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  1208 00002404 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  1209                              <1> 
  1210 00002406 61                  <1> 	popa
  1211 00002407 EB04                <1> 	jmp .read_failure		; Fatal double error
  1212                              <1> 
  1213                              <1> 
  1214                              <1> .root_dir_finished:
  1215 00002409 61                  <1> 	popa				; Restore registers from main loop
  1216                              <1> 
  1217 0000240A 61                  <1> 	popa				; And restore from start of this system call
  1218 0000240B F8                  <1> 	clc				; Clear carry (for success)
  1219 0000240C C3                  <1> 	ret
  1220                              <1> 
  1221                              <1> .read_failure:
  1222 0000240D 61                  <1> 	popa
  1223 0000240E F9                  <1> 	stc				; Set carry flag (for failure)
  1224 0000240F C3                  <1> 	ret
  1225                              <1> 
  1226                              <1> 
  1227                              <1> ; --------------------------------------------------------------------------
  1228                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  1229                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  1230                              <1> 
  1231                              <1> disk_write_root_dir:
  1232 00002410 60                  <1> 	pusha
  1233                              <1> 
  1234 00002411 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1235 00002414 E82700              <1> 	call disk_convert_l2hts
  1236                              <1> 
  1237 00002417 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1238 0000241A 8CDB                <1> 	mov bx, ds
  1239 0000241C 8EC3                <1> 	mov es, bx
  1240 0000241E 89F3                <1> 	mov bx, si
  1241                              <1> 
  1242 00002420 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1243 00002422 B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  1244                              <1> 
  1245 00002424 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1246 00002425 CD13                <1> 	int 13h				; Write sectors
  1247 00002427 7203                <1> 	jc .write_failure
  1248                              <1> 
  1249 00002429 61                  <1> 	popa				; And restore from start of this system call
  1250 0000242A F8                  <1> 	clc
  1251 0000242B C3                  <1> 	ret
  1252                              <1> 
  1253                              <1> .write_failure:
  1254 0000242C 61                  <1> 	popa
  1255 0000242D F9                  <1> 	stc				; Set carry flag (for failure)
  1256 0000242E C3                  <1> 	ret
  1257                              <1> 
  1258                              <1> 
  1259                              <1> ; --------------------------------------------------------------------------
  1260                              <1> ; Reset floppy disk
  1261                              <1> 
  1262                              <1> disk_reset_floppy:
  1263 0000242F 50                  <1> 	push ax
  1264 00002430 52                  <1> 	push dx
  1265 00002431 B80000              <1> 	mov ax, 0
  1266                              <1> ; ******************************************************************
  1267 00002434 8A16[6D24]          <1> 	mov dl, [bootdev]
  1268                              <1> ; ******************************************************************
  1269 00002438 F9                  <1> 	stc
  1270 00002439 CD13                <1> 	int 13h
  1271 0000243B 5A                  <1> 	pop dx
  1272 0000243C 58                  <1> 	pop ax
  1273 0000243D C3                  <1> 	ret
  1274                              <1> 
  1275                              <1> 
  1276                              <1> ; --------------------------------------------------------------------------
  1277                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  1278                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  1279                              <1> 
  1280                              <1> disk_convert_l2hts:
  1281 0000243E 53                  <1> 	push bx
  1282 0000243F 50                  <1> 	push ax
  1283                              <1> 
  1284 00002440 89C3                <1> 	mov bx, ax			; Save logical sector
  1285                              <1> 
  1286 00002442 BA0000              <1> 	mov dx, 0			; First the sector
  1287 00002445 F736[6B24]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1288 00002449 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  1289 0000244C 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  1290 0000244E 89D8                <1> 	mov ax, bx
  1291                              <1> 
  1292 00002450 BA0000              <1> 	mov dx, 0			; Now calculate the head
  1293 00002453 F736[6B24]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1294 00002457 BA0000              <1> 	mov dx, 0
  1295 0000245A F736[6924]          <1> 	div word [Sides]		; Floppy sides
  1296 0000245E 88D6                <1> 	mov dh, dl			; Head/side
  1297 00002460 88C5                <1> 	mov ch, al			; Track
  1298                              <1> 
  1299 00002462 58                  <1> 	pop ax
  1300 00002463 5B                  <1> 	pop bx
  1301                              <1> 
  1302                              <1> ; ******************************************************************
  1303 00002464 8A16[6D24]          <1> 	mov dl, [bootdev]		; Set correct device
  1304                              <1> ; ******************************************************************
  1305                              <1> 
  1306 00002468 C3                  <1> 	ret
  1307                              <1> 
  1308                              <1> 
  1309 00002469 0200                <1> 	Sides dw 2
  1310 0000246B 1200                <1> 	SecsPerTrack dw 18
  1311                              <1> ; ******************************************************************
  1312 0000246D 00                  <1> 	bootdev db 0			; Boot device number
  1313                              <1> ; ******************************************************************
  1314                              <1> ; ==================================================================
   365                                      %include "./includes/checkin.asm"
     1                              <1> check_com:      ; AX = command
     2 0000246E BE[AB01]            <1>     mov si, in_buffer
     3 00002471 89C7                <1>     mov di, ax
     4                              <1> 
     5                              <1> .check_loop:
     6 00002473 AC                  <1>     lodsb
     7 00002474 3A05                <1>     cmp al, [di]
     8 00002476 7509                <1>     jne .not_equal
     9                              <1>     
    10 00002478 B000                <1>     mov al, 0
    11 0000247A 3805                <1>     cmp [di], al
    12 0000247C 7405                <1>     je .done
    13                              <1> 
    14 0000247E 47                  <1>     inc di
    15 0000247F EBF2                <1>     jmp .check_loop
    16                              <1> 
    17                              <1> .not_equal:
    18 00002481 F9                  <1>     stc
    19 00002482 C3                  <1>     ret
    20                              <1> 
    21                              <1> .done:
    22 00002483 F8                  <1>     clc
    23 00002484 C3                  <1>     ret
   366                                  
   367                                  ; ==================================================================
   368                                  ; END OF KERNEL
   369                                  ; ==================================================================
