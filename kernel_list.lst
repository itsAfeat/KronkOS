     1                                  ; ==================================================================
     2                                  ; The Kronk Operating System kernel
     3                                  ; Copyright (C) 2019 - 2020 Alexander Wiencken
     4                                  ;
     5                                  ; This is loaded from the drive by BOOTLOAD.BIN, as KERNEL.BIN
     6                                  ; ==================================================================
     7                                  
     8                                      ORG 0x0000
     9                                      BITS 16
    10                                      
    11                                      %define KRONKOS_VER '0.3.2'
    12                                      %define KRONKOS_API 4
    13                                      
    14                                      ; RAM locations
    15                                      disk_buffer     equ 24576
    16                                      prg_load_loc    equ 32768
    17                                      set_load_loc    equ 36864
    18                                  
    19                                      ; Screen mouse clamps
    20                                      screenmaxW      equ 0x004E
    21                                      screenminW      equ 0x0001
    22                                      screenmaxH      equ 0x0017
    23                                      screenminH      equ 0x0001
    24                                      
    25                                      ; Mouse buttons
    26                                      leftMButton     equ 0x09
    27                                      rightMButton    equ 0x0A
    28                                  
    29                                      ; Screen modes
    30                                      vidRes          equ 0x13
    31                                      cliRes          equ 0x03
    32                                  
    33                                  ; ******************************************************************
    34                                  ; Start the kernel
    35                                  kernel_start:
    36 00000000 E8341B                      call seed_random
    37                                  
    38 00000003 FA                          cli                         ; Clear interrupts
    39 00000004 B80020                      mov ax, 0x2000              ; The bootloader loads us at 0x2000
    40 00000007 8ED8                        mov ds, ax                  ; Set DS and ES to 0x2000
    41 00000009 8EC0                        mov es, ax
    42                                  
    43                                      ; Stack just below 0x2000:0x0000 starting at 0x1000:0x0000.
    44                                      ; First push will set SS:SP to 0x1000:0xfffe because SP will wrap.
    45 0000000B B80010                      mov ax, 0x1000
    46 0000000E 8ED0                        mov ss, ax
    47 00000010 31E4                        xor sp, sp
    48                                  
    49 00000012 FC                          cld                         ; Clear Direction Flag (DF=0 is for forward string movement)
    50                                  ; ******************************************************************
    51                                  
    52                                  
    53                                  ; ==================================================================
    54                                  ; START OF KERNEL
    55                                  ; ==================================================================
    56                                  
    57                                  RESET:
    58 00000013 31C0                    	xor ax, ax
    59 00000015 31DB                    	xor bx, bx
    60 00000017 31C9                    	xor cx, cx
    61 00000019 31D2                    	xor dx, dx
    62 0000001B 31F6                    	xor si, si
    63 0000001D 31FF                    	xor di, di
    64                                  
    65                                      ; Change the cursor to a solid block
    66 0000001F B500                        mov ch, 0x00
    67 00000021 E81112                      call change_cursor
    68                                  
    69                                      ; Check if SETTINGS.KSF exists
    70 00000024 B8[2303]                    mov ax, settings_filename
    71 00000027 E82522                      call os_file_exists
    72 0000002A 7311                        jnc .skip_setup     ; If it does... skip the setup
    73                                  
    74 0000002C E82F0B                      call setup_init
    75                                  
    76                                      ; Save the settings
    77 0000002F B8[2303]                    mov ax, settings_filename
    78 00000032 BB0090                      mov bx, set_load_loc
    79 00000035 B9[8401]                    mov cx, usrNam
    80 00000038 E8661F                      call os_write_file
    81                                  
    82 0000003B EBD6                        jmp RESET
    83                                  
    84                                  .skip_setup:
    85                                      ; Load the settings file
    86 0000003D B8[2303]                    mov ax, settings_filename
    87 00000040 B90090                      mov cx, set_load_loc
    88 00000043 31DB                        xor bx, bx
    89 00000045 E81A1E                      call os_load_file
    90                                  
    91 00000048 89DE                        mov si, bx
    92 0000004A BF[8401]                    mov di, usrNam
    93 0000004D E8340E                      call string_copy
    94                                  
    95 00000050 8A26[9901]                  mov ah, [vidMode]
    96 00000054 80FC00                      cmp ah, 0
    97 00000057 7405                        je .startCli
    98 00000059 80FC01                      cmp ah, 1
    99 0000005C 7404                        je .startVideo
   100                                  
   101                                  .startCli:
   102 0000005E E8E704                      call kronk_cli
   103 00000061 F4                          hlt
   104                                  
   105                                  .startVideo:
   106 00000062 E89C0A                      call kronk_vid
   107 00000065 F4                          hlt
   108                                  
   109                                  
   110                                  ; ==================================================================
   111                                  ; JUMP VECTORS
   112                                  ; ==================================================================
   113                                  
   114                                  JUMP_VECTORS:
   115 00000066 EB98                        jmp kernel_start        ; 0x0066
   116 00000068 E9361B                      jmp print               ; 0x0068
   117 0000006B E9770D                      jmp cls                 ; 0x006B
   118 0000006E E9DE21                      jmp os_file_exists      ; 0x006E
   119 00000071 E9EE1D                      jmp os_load_file        ; 0x0071
   120 00000074 E9F721                      jmp os_create_file      ; 0x0074
   121 00000077 E98322                      jmp os_remove_file      ; 0x0077
   122 0000007A E9241F                      jmp os_write_file       ; 0x007A
   123 0000007D E9E70D                      jmp string_lowercase    ; 0x007D
   124 00000080 E9C70D                      jmp string_uppercase    ; 0x0080
   125 00000083 E9070E                      jmp string_truncate     ; 0x0083
   126 00000086 E9720D                      jmp string_length       ; 0x0086
   127 00000089 E9BD11                      jmp move_cursor         ; 0x0089
   128 0000008C E9C311                      jmp get_cursor_pos      ; 0x008C
   129 0000008F E9D311                      jmp print_horiz_line    ; 0x008F
   130 00000092 E9ED11                      jmp input_dialog        ; 0x0092
   131 00000095 E95818                      jmp list_dialog         ; 0x0095
   132 00000098 E94012                      jmp dialog_box          ; 0x0098
   133 0000009B E99711                      jmp change_cursor       ; 0x009B
   134 0000009E E97911                      jmp string_clear        ; 0x009E
   135 000000A1 E91A1D                      jmp os_get_file_list    ; 0x00A1
   136 000000A4 E9C319                      jmp clear_regs          ; 0x00A4
   137 000000A7 E9BA0E                      jmp int_to_string       ; 0x00A7
   138 000000AA E96D24                      jmp chk_string_ext      ; 0x00AA
   139 000000AD E9EC0D                      jmp string_join         ; 0x00AD
   140 000000B0 E9E20D                      jmp string_add          ; 0x00B0
   141 000000B3 E9CE0D                      jmp string_copy         ; 0x00B3
   142 000000B6 E9211B                      jmp print_atr           ; 0x00B6
   143 000000B9 E99D13                      jmp input_string        ; 0x00B9
   144                                  
   145                                  
   146                                  ; ==================================================================
   147                                  ; KERNEL SUBROUTINES
   148                                  ; ==================================================================
   149                                  
   150                                      error_ext:
   151 000000BC 5E                              pop si
   152                                  
   153 000000BD B8[3603]                        mov ax, err1_ext
   154 000000C0 BB[4803]                        mov bx, err2_ext
   155 000000C3 31C9                            xor cx, cx
   156 000000C5 31D2                            xor dx, dx
   157 000000C7 E81112                          call dialog_box
   158                                  
   159 000000CA B70F                            mov bh, cli_color
   160 000000CC E8160D                          call cls
   161                                  
   162 000000CF C3                              ret
   163                                  
   164                                      try_run_file:
   165 000000D0 E8770D                          call string_uppercase
   166 000000D3 89C6                            mov si, ax
   167 000000D5 BF[1803]                        mov di, kern_filename
   168 000000D8 E82A0E                          call string_compare
   169 000000DB 7230                            jc load_kern_err
   170                                  
   171 000000DD E86F21                          call os_file_exists
   172 000000E0 7229                            jc .not_found
   173 000000E2 F8                              clc
   174                                  
   175 000000E3 89C6                            mov si, ax
   176 000000E5 56                              push si 
   177                                  
   178 000000E6 89F3                            mov bx, si
   179 000000E8 89F0                            mov ax, si
   180 000000EA E80E0D                          call string_length
   181                                  
   182 000000ED 89DE                            mov si, bx
   183 000000EF 01C6                            add si, ax
   184                                  
   185 000000F1 83EE03                          sub si, 3
   186                                  
   187 000000F4 BF[3003]                        mov di, bin_ext
   188 000000F7 B90300                          mov cx, 3
   189 000000FA F3A6                            rep cmpsb
   190 000000FC 7523                            jne execute_bas_program
   191 000000FE 5E                              pop si
   192                                  
   193 000000FF 89F0                            mov ax, si
   194 00000101 B90080                          mov cx, prg_load_loc
   195 00000104 E85B1D                          call os_load_file
   196                                  
   197 00000107 E85000                          call execute_bin_program
   198 0000010A C3                              ret
   199                                  
   200                                          .not_found:
   201 0000010B F9                                  stc
   202 0000010C C3                                  ret
   203                                  
   204                                          load_kern_err:
   205 0000010D 5E                                  pop si
   206                                  
   207 0000010E B8[6603]                            mov ax, err3_ext
   208 00000111 BB[7903]                            mov bx, err4_ext
   209 00000114 31C9                                xor cx, cx
   210 00000116 31D2                                xor dx, dx
   211 00000118 E8C011                              call dialog_box
   212                                  
   213 0000011B B70F                                mov bh, cli_color
   214 0000011D E8C50C                              call cls
   215                                  
   216 00000120 C3                                  ret
   217                                  
   218                                      execute_bas_program:
   219 00000121 5E                              pop si
   220 00000122 56                              push si
   221                                          
   222 00000123 89F3                            mov bx, si
   223 00000125 89F0                            mov ax, si
   224 00000127 E8D10C                          call string_length
   225                                  
   226 0000012A 89DE                            mov si, bx
   227 0000012C 01C6                            add si, ax
   228                                  
   229 0000012E 83EE03                          sub si, 3
   230                                  
   231 00000131 BF[3303]                        mov di, bas_ext
   232 00000134 B90300                          mov cx, 3
   233 00000137 F3A6                            rep cmpsb
   234 00000139 7581                            jne error_ext
   235                                  
   236 0000013B 5E                              pop si
   237                                          
   238 0000013C 89F0                            mov ax, si
   239 0000013E B90080                          mov cx, prg_load_loc
   240 00000141 E81E1D                          call os_load_file
   241                                  
   242 00000144 B70F                            mov bh, 0x0F
   243 00000146 E89C0C                          call cls
   244                                  
   245 00000149 B80080                          mov ax, prg_load_loc
   246 0000014C 31F6                            xor si, si
   247                                          ;call os_run_basic
   248                                  
   249 0000014E BE[C603]                        mov si, new_line
   250 00000151 E84D1A                          call print
   251                                  
   252 00000154 B70F                            mov bh, cli_color
   253 00000156 E88C0C                          call cls
   254                                  
   255 00000159 C3                              ret
   256                                  
   257                                      execute_bin_program:
   258 0000015A BE[C603]                        mov si, new_line
   259 0000015D E8411A                          call print
   260                                  
   261 00000160 31C0                    		xor ax, ax
   262 00000162 31DB                    		xor bx, bx
   263 00000164 31C9                    		xor cx, cx
   264 00000166 31D2                    		xor dx, dx
   265 00000168 31F6                    		xor si, si
   266 0000016A 31FF                    		xor di, di
   267                                  
   268 0000016C E8(0080)                        call prg_load_loc
   269                                          
   270 0000016F B80000                          mov ax, 0
   271 00000172 B70F                            mov bh, 0x0F
   272 00000174 E84313                          call switch_mode
   273                                  
   274 00000177 C3                              ret
   275                                  
   276                                  
   277                                  ; ------------------------------------------------------------------
   278                                  ; STRINGS AND OTHER VARIABLES
   279                                  
   280                                      ; DEBUG VARIABLES START
   281 00000178 4D653F20476F6E6761-         tmp:                db "Me? Gongaga", 0
   281 00000181 676100             
   282                                      ; END
   283                                  
   284                                      ; USER RELATED VARIABLES START
   285 00000184 00<rep 15h>                 usrNam:             times 21 db 0
   286                                  
   287 00000199 0000                        vidMode:            dw 0x00
   288                                      cli_color:          equ 0x0f
   289                                      vid_backcolor:      equ 0x01
   290                                      vid_forecolor:      equ 0x0f
   291                                      ; END
   292                                  
   293                                      ; TMP VARIABLES START
   294 0000019B 4D4F555345204C4546-         mouse_left:         db "MOUSE LEFT", 0
   294 000001A4 5400               
   295 000001A6 4D4F55534520524947-         mouse_right:        db "MOUSE RIGHT", 0
   295 000001AF 485400             
   296                                      ; END
   297                                  
   298                                      ; CLI SPECIFIC VARIABLES START
   299 000001B2 3A3E2000                	in_msg:				db ":> ", 0
   300 000001B6 00<rep 29h>             	in_buffer: 			times 41 db 0
   301 000001DF 206973206E6F74206B-         not_com:            db " is not known command", 0x0a, 0x0d, 0
   301 000001E8 6E6F776E20636F6D6D-
   301 000001F1 616E640A0D00       
   302                                      ; END
   303                                  
   304                                      ; CLI COMMANDS START
   305 000001F7 7265737461727400            restart_com:        db "restart", 0
   306 000001FF 73687574646F776E00          shutdown_com:       db "shutdown", 0
   307 00000208 73657474696E677300          settings_com:       db "settings", 0
   308 00000211 636C65617200                clear_com:          db "clear", 0
   309 00000217 64697200                    dir_com:            db "dir", 0
   310 0000021B 68656C7000                  help_com:           db "help", 0
   311 00000220 6564697400                  edit_com:           db "edit", 0
   312 00000225 6C6F616400                  load_com:           db "load", 0
   313 0000022A 6D6B00                      mk_com:             db "mk", 0
   314 0000022D 726D00                      rm_com:             db "rm", 0
   315                                      ; END
   316                                  
   317                                      ; MOUSE VARIABLES START
   318 00000230 4D4F55534520495320-         mouse_yes:          db "MOUSE IS CONNECTED!", 0
   318 00000239 434F4E4E4543544544-
   318 00000242 2100               
   319 00000244 4D4F55534520495320-         mouse_no:           db "MOUSE IS NOT CONNECTED!", 0
   319 0000024D 4E4F5420434F4E4E45-
   319 00000256 435445442100       
   320                                      ; END
   321                                  
   322                                      ; WELCOME SCREEN VARIABLES START
   323 0000025C 0A0D204B726F6E6B4F-     	welcome_msg1:		db 0x0a, 0x0d, " KronkOS ver. ", KRONKOS_VER
   323 00000265 53207665722E20302E-
   323 0000026E 332E32             
   324 00000271 20<rep 1Ah>             						times 44-18 db " "
   325 0000028B 0A0D2000                						db 0x0a, 0x0d, " ", 0
   326 0000028F 204279746573206F66-     	welcome_msg2:		db " Bytes of total memory available.      ", 0x0a, 0x0d, 0
   326 00000298 20746F74616C206D65-
   326 000002A1 6D6F72792061766169-
   326 000002AA 6C61626C652E202020-
   326 000002B3 2020200A0D00       
   327 000002B9 20<rep 2Dh>             	welcome_msg3:		times 45 db " "
   328 000002E6 0A0D20547970652027-     						db 0x0a, 0x0d, " Type 'help' and press enter to start off.   ", 0x0a, 0x0d, 0
   328 000002EF 68656C702720616E64-
   328 000002F8 20707265737320656E-
   328 00000301 74657220746F207374-
   328 0000030A 617274206F66662E20-
   328 00000313 20200A0D00         
   329                                  	; END
   330                                  
   331                                      ; FILE RELATED VARIABLES START
   332 00000318 4B45524E454C2E4249-     	kern_filename:		db 'KERNEL.BIN', 0
   332 00000321 4E00               
   333 00000323 53455454494E47532E-         settings_filename:  db 'SETTINGS.KSF', 0
   333 0000032C 4B534600           
   334                                  
   335 00000330 424B46                  	bin_ext:			db 'BKF'
   336 00000333 424153                  	bas_ext:			db 'BAS'
   337 00000336 556E6B6E6F776E2065-     	err1_ext:			db "Unknown extension", 0
   337 0000033F 7874656E73696F6E00 
   338 00000348 4F6E6C79202E424B46-     	err2_ext:			db "Only .BKF and .BAS is allowed", 0
   338 00000351 20616E64202E424153-
   338 0000035A 20697320616C6C6F77-
   338 00000363 656400             
   339 00000366 4572726F72206C6F61-     	err3_ext:			db "Error loading file", 0
   339 0000036F 64696E672066696C65-
   339 00000378 00                 
   340 00000379 596F752063616E2774-     	err4_ext:			db "You can't load KERNEL.BIN", 0
   340 00000382 206C6F6164204B4552-
   340 0000038B 4E454C2E42494E00   
   341 00000393 596F752063616E2774-         err5_ext:           db "You can't load SETTINGS.KSF", 0
   341 0000039C 206C6F616420534554-
   341 000003A5 54494E47532E4B5346-
   341 000003AE 00                 
   342 000003AF 0A0D46696C65206E6F-         notfound_msg:	    db 0x0a, 0x0d, "File not found", 0x0a, 0x0a, 0x0d, 0
   342 000003B8 7420666F756E640A0A-
   342 000003C1 0D00               
   343                                      ; END
   344                                  
   345                                      ; OTHER VARIABLES START
   346 000003C3 00                      	fmt_12_24:			db 0 		; (Non-zero = 24 hour format)
   347 000003C4 012F                    	fmt_date:			db 1, '/'	; 0, 1, 2 = M/D/Y, D/M/Y or Y/M/D
   348                                  									; Bit 7 = use name for months
   349                                  									; If bit 7 = 0, second byte = separator character
   350                                  
   351 000003C6 0A0D00                  	new_line:			db 0x0a, 0x0d, 0
   352 000003C9 202D2D2000              	file_size_sep:		db " -- ", 0
   353 000003CE 2042797465730A0D00      	file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   354                                      ; END
   355                                  
   356                                      ; MENUBAR VARIABLES START
   357                                      mb_color:           equ 0x30
   358 000003D7 20<rep 4Fh>                 mb_fill:            times 79 db " "
   359 00000426 00                                              db 0
   360                                      ; END
   361                                  
   362                                  ; ------------------------------------------------------------------
   363                                  ; INCLUDED FILES
   364                                  
   365                                      %include "./includes/settings_menu.asm"
   366                              <1> show_settings:
   367 00000427 60                  <1>     pusha
   368                              <1> 
   369                              <1> .main_menu:
   370 00000428 B8[9604]            <1>     mov ax, .main_options
   371 0000042B BB[B104]            <1>     mov bx, .main_header
   372 0000042E B9[BA04]            <1>     mov cx, .main_string
   373 00000431 E8BC14              <1>     call list_dialog
   374                              <1> 
   375 00000434 83F801              <1>     cmp ax, 1
   376 00000437 7402                <1>     je .display_menu
   377                              <1> 
   378 00000439 EB54                <1>     jmp .end
   379                              <1> 
   380                              <1> .display_menu:
   381 0000043B B8[D904]            <1>     mov ax, .display_options
   382 0000043E BB[F204]            <1>     mov bx, .display_header
   383 00000441 B9[0105]            <1>     mov cx, .display_string
   384 00000444 E8A914              <1>     call list_dialog
   385                              <1> 
   386 00000447 83F801              <1>     cmp ax, 1
   387 0000044A 7407                <1>     je .change_cli
   388                              <1> 
   389 0000044C 83F802              <1>     cmp ax, 2
   390 0000044F 7420                <1>     je .change_vid
   391                              <1> 
   392 00000451 EBD5                <1>     jmp .main_menu
   393                              <1> 
   394                              <1> .change_cli:
   395 00000453 B8[1705]            <1>     mov ax, .display_restart1
   396 00000456 BB[3105]            <1>     mov bx, .display_restart2
   397 00000459 31C9                <1>     xor cx, cx
   398 0000045B BA0100              <1>     mov dx, 1
   399 0000045E E87A0E              <1>     call dialog_box
   400                              <1> 
   401 00000461 85C0                <1>     test ax, ax
   402 00000463 75D6                <1>     jnz .display_menu
   403                              <1> 
   404                              <1> 
   405 00000465 C606[9901]00        <1>     mov byte [vidMode], 0
   406 0000046A 31C0                <1>     xor ax, ax
   407 0000046C CD13                <1>     int 0x13
   408 0000046E E9A2FB              <1>     jmp RESET
   409                              <1> 
   410                              <1> .change_vid:
   411 00000471 B8[1705]            <1>     mov ax, .display_restart1
   412 00000474 BB[3105]            <1>     mov bx, .display_restart2
   413 00000477 31C9                <1>     xor cx, cx
   414 00000479 BA0100              <1>     mov dx, 1
   415 0000047C E85C0E              <1>     call dialog_box
   416                              <1> 
   417 0000047F 85C0                <1>     test ax, ax
   418 00000481 75B8                <1>     jnz .display_menu
   419                              <1> 
   420 00000483 C606[9901]01        <1>     mov byte [vidMode], 1
   421 00000488 31C0                <1>     xor ax, ax
   422 0000048A CD13                <1>     int 0x13
   423 0000048C E984FB              <1>     jmp RESET
   424                              <1> 
   425                              <1> .end:
   426 0000048F B70F                <1>     mov bh, cli_color
   427 00000491 E85109              <1>     call cls
   428                              <1> 
   429 00000494 61                  <1>     popa
   430 00000495 C3                  <1>     ret
   431                              <1> 
   432                              <1> 
   433 00000496 444953504C41592C    <1> .main_options:      db "DISPLAY,"
   434 0000049E 555345522C          <1>                     db "USER,"
   435 000004A3 455849542053455454- <1>                     db "EXIT SETTINGS", 0
   435 000004AC 494E475300          <1>
   436 000004B1 53455454494E475300  <1> .main_header:       db "SETTINGS", 0
   437 000004BA 4368616E6765207468- <1> .main_string:       db "Change the settings of KronkOS", 0
   437 000004C3 652073657474696E67- <1>
   437 000004CC 73206F66204B726F6E- <1>
   437 000004D5 6B4F5300            <1>
   438                              <1> 
   439 000004D9 434C49204D4F44452C  <1> .display_options:   db "CLI MODE,"
   440 000004E2 564944454F204D4F44- <1>                     db "VIDEO MODE,"
   440 000004EB 452C                <1>
   441 000004ED 4241434B00          <1>                     db "BACK", 0
   442 000004F2 564944454F20534554- <1> .display_header:    db "VIDEO SETTINGS", 0
   442 000004FB 54494E475300        <1>
   443 00000501 4368616E6765207468- <1> .display_string:    db "Change the video mode", 0
   443 0000050A 6520766964656F206D- <1>
   443 00000513 6F646500            <1>
   444 00000517 546869732077696C6C- <1> .display_restart1:  db "This will restart KronkOS", 0
   444 00000520 207265737461727420- <1>
   444 00000529 4B726F6E6B4F5300    <1>
   445 00000531 507265737320274F4B- <1> .display_restart2:  db "Press 'OK' to continue", 0
   445 0000053A 2720746F20636F6E74- <1>
   445 00000543 696E756500          <1>
   366                                      %include "./includes/cli.asm"
   367                              <1> kronk_cli:
   368 00000548 B80000              <1>     mov ax, 0
   369 0000054B B70F                <1>     mov bh, cli_color
   370 0000054D E86A0F              <1>     call switch_mode
   371                              <1>     
   372                              <1>     ; Disable color blinking
   373 00000550 B80310              <1>     mov ax, 0x1003
   374 00000553 BB0000              <1>     mov bx, 0x0000
   375 00000556 CD10                <1>     int 0x10
   376                              <1> 
   377                              <1> 	; Let's see if there's a file called AUTORUN.BIN and execute
   378                              <1> 	; it if so, before going to the terminal
   379                              <1> 
   380 00000558 B8[270A]            <1>     mov ax, .autobin_filename
   381 0000055B E8F11C              <1>     call os_file_exists
   382 0000055E 7209                <1>     jc .no_autorun_bin
   383                              <1> 
   384 00000560 B90080              <1>     mov cx, prg_load_loc
   385 00000563 E8FC18              <1>     call os_load_file
   386 00000566 E8F1FB              <1>     call execute_bin_program
   387                              <1> 
   388                              <1> .no_autorun_bin:
   389 00000569 B8[330A]            <1>     mov ax, .autobas_filename
   390 0000056C E8E01C              <1>     call os_file_exists
   391 0000056F 7209                <1>     jc .no_autorun_bas
   392                              <1> 
   393 00000571 B90080              <1>     mov cx, prg_load_loc
   394 00000574 E8EB18              <1>     call os_load_file
   395 00000577 E8A7FB              <1>     call execute_bas_program
   396                              <1> 
   397                              <1> .no_autorun_bas:
   398                              <1>     ; Draw welcome menu
   399 0000057A BE[5C02]            <1>     mov si, welcome_msg1
   400 0000057D E82F16              <1>     call welcome_print
   401                              <1> 
   402 00000580 B488                <1>     mov ah, 0x88
   403 00000582 CD15                <1>     int 0x15
   404 00000584 E8DD09              <1>     call int_to_string
   405 00000587 89C6                <1>     mov si, ax
   406 00000589 E82316              <1>     call welcome_print
   407                              <1> 
   408 0000058C BE[8F02]            <1>     mov si, welcome_msg2
   409 0000058F E81D16              <1>     call welcome_print
   410 00000592 BE[B902]            <1>     mov si, welcome_msg3
   411 00000595 E81716              <1>     call welcome_print
   412                              <1> 
   413 00000598 B80A0E              <1>     mov ax, 0x0e0a
   414 0000059B CD10                <1>     int 0x10
   415                              <1> 
   416                              <1> ; The loop that gets the input
   417                              <1> .input_loop:
   418                              <1>     ; Change the cursor to a solid block
   419 0000059D B500                <1>     mov ch, 0x00
   420 0000059F E8930C              <1>     call change_cursor
   421                              <1> 
   422 000005A2 E8C104              <1>     call check_pos
   423 000005A5 E8E404              <1>     call draw_menu_bar
   424                              <1> 
   425                              <1>     ; Print the username and the input msg
   426                              <1>     ;mov si, usrNam
   427                              <1>     ;call print
   428 000005A8 BE[B201]            <1>     mov si, in_msg
   429 000005AB E8F315              <1>     call print
   430                              <1> 
   431                              <1>     ; Get the input and save it in in_buffer 
   432 000005AE E81815              <1>     call get_input
   433                              <1> 
   434                              <1>     ; Check the input
   435 000005B1 B8[0802]            <1>     mov ax, settings_com
   436 000005B4 E8CD1F              <1>     call check_com
   437 000005B7 0F83C400            <1>     jnc .settings
   438                              <1> 
   439 000005BB B8[1102]            <1>     mov ax, clear_com
   440 000005BE E8C31F              <1>     call check_com
   441 000005C1 0F83C000            <1>     jnc .clear
   442                              <1> 
   443 000005C5 B8[1702]            <1>     mov ax, dir_com
   444 000005C8 E8B91F              <1>     call check_com
   445 000005CB 0F83BE00            <1>     jnc .dir
   446                              <1> 
   447 000005CF B8[1B02]            <1>     mov ax, help_com
   448 000005D2 E8AF1F              <1>     call check_com
   449 000005D5 0F836301            <1>     jnc .show_help
   450                              <1>     
   451                              <1>     ; ----------------------------------
   452                              <1>     ; MK AND RM
   453                              <1> 
   454 000005D9 60                  <1>     pusha
   455                              <1> 
   456 000005DA BE[B901]            <1>     mov si, in_buffer+3
   457 000005DD BF[B809]            <1>     mov di, .tmp_filename
   458 000005E0 E8A108              <1>     call string_copy
   459                              <1> 
   460 000005E3 BE[B601]            <1>     mov si, in_buffer
   461 000005E6 BF[CC09]            <1>     mov di, .tmp_inbuffer
   462 000005E9 E89808              <1>     call string_copy
   463                              <1> 
   464 000005EC BE[B601]            <1>     mov si, in_buffer
   465 000005EF B80200              <1>     mov ax, 2
   466 000005F2 E89808              <1>     call string_truncate
   467                              <1>     
   468 000005F5 B8[2A02]            <1>     mov ax, mk_com
   469 000005F8 E8891F              <1>     call check_com
   470 000005FB 0F831003            <1>     jnc .make_file
   471                              <1> 
   472 000005FF B8[2D02]            <1>     mov ax, rm_com
   473 00000602 E87F1F              <1>     call check_com
   474 00000605 0F833E03            <1>     jnc .remove_file
   475                              <1> 
   476 00000609 BE[CC09]            <1>     mov si, .tmp_inbuffer
   477 0000060C BF[B601]            <1>     mov di, in_buffer
   478 0000060F E87208              <1>     call string_copy
   479                              <1> 
   480 00000612 61                  <1>     popa
   481                              <1> 
   482                              <1>     ; ----------------------------------
   483                              <1>     ; LOAD AND EDIT
   484                              <1> 
   485 00000613 60                  <1>     pusha
   486                              <1> 
   487 00000614 BE[BB01]            <1>     mov si, in_buffer+5
   488 00000617 BF[B809]            <1>     mov di, .tmp_filename
   489 0000061A E86708              <1>     call string_copy
   490                              <1> 
   491 0000061D BE[B601]            <1>     mov si, in_buffer
   492 00000620 BF[CC09]            <1>     mov di, .tmp_inbuffer
   493 00000623 E85E08              <1>     call string_copy
   494                              <1> 
   495 00000626 BE[B601]            <1>     mov si, in_buffer
   496 00000629 B80400              <1>     mov ax, 4
   497 0000062C E85E08              <1>     call string_truncate
   498                              <1> 
   499 0000062F B8[2502]            <1>     mov ax, load_com
   500 00000632 E84F1F              <1>     call check_com
   501 00000635 0F834303            <1>     jnc .load_file
   502                              <1> 
   503 00000639 BE[CC09]            <1>     mov si, .tmp_inbuffer
   504 0000063C BF[B601]            <1>     mov di, in_buffer
   505 0000063F E84208              <1>     call string_copy
   506                              <1> 
   507 00000642 61                  <1>     popa
   508                              <1> 
   509 00000643 B8[F701]            <1>     mov ax, restart_com
   510 00000646 E83B1F              <1>     call check_com
   511 00000649 0F834B03            <1>     jnc .restart
   512                              <1> 
   513 0000064D B8[FF01]            <1>     mov ax, shutdown_com
   514 00000650 E8311F              <1>     call check_com
   515 00000653 0F834903            <1>     jnc .shutdown
   516 00000657 7200                <1>     jc .not_equal
   517                              <1> 
   518                              <1> .not_equal:
   519 00000659 B40E                <1>     mov ah, 0x0e
   520 0000065B B00A                <1>     mov al, 0x0a
   521 0000065D CD10                <1>     int 0x10
   522                              <1> 
   523 0000065F B40E                <1>     mov ah, 0x0e
   524 00000661 B022                <1>     mov al, '"'
   525 00000663 CD10                <1>     int 0x10
   526                              <1> 
   527 00000665 BE[B601]            <1>     mov si, in_buffer
   528 00000668 E83615              <1>     call print
   529                              <1> 
   530 0000066B B40E                <1>     mov ah, 0x0e
   531 0000066D B022                <1>     mov al, '"'
   532 0000066F CD10                <1>     int 0x10
   533                              <1>     
   534 00000671 BE[DF01]            <1>     mov si, not_com
   535 00000674 E82A15              <1>     call print
   536                              <1>     
   537                              <1>     ; Create a new line
   538 00000677 B80A0E              <1>     mov ax, 0x0e0a
   539 0000067A CD10                <1>     int 0x10
   540                              <1> 
   541 0000067C E91EFF              <1>     jmp .input_loop
   542                              <1> 
   543                              <1> ; ----------------------------------
   544                              <1> ; SETTINGS
   545                              <1> 
   546                              <1> .settings:
   547 0000067F E8A5FD              <1>     call show_settings
   548 00000682 E918FF              <1>     jmp .input_loop
   549                              <1> 
   550                              <1> ; ----------------------------------
   551                              <1> ; CLEAR
   552                              <1> 
   553                              <1> .clear:
   554 00000685 B70F                <1>     mov bh, cli_color
   555 00000687 E85B07              <1>     call cls
   556 0000068A E910FF              <1>     jmp .input_loop
   557                              <1> 
   558                              <1> ; ----------------------------------
   559                              <1> ; DIR
   560                              <1> 
   561                              <1> .dir:
   562 0000068D 31C0                <1>     xor ax, ax
   563 0000068F E82C17              <1>     call os_get_file_list
   564                              <1> 
   565 00000692 50                  <1>     push ax
   566 00000693 B80A0E              <1>     mov ax, 0x0e0a
   567 00000696 CD10                <1>     int 0x10
   568 00000698 CD10                <1>     int 0x10
   569 0000069A B00D                <1>     mov al, 0x0d
   570 0000069C CD10                <1>     int 0x10
   571 0000069E 58                  <1>     pop ax
   572                              <1> 
   573 0000069F 89C6                <1>     mov si, ax
   574 000006A1 BF[B809]            <1>     mov di, .tmp_filename
   575 000006A4 BA0000              <1>     mov dx, 0
   576                              <1> 
   577 000006A7 B40E                <1>     mov ah, 0x0e
   578 000006A9 B020                <1>     mov al, ' '
   579 000006AB CD10                <1>     int 0x10
   580                              <1> 
   581                              <1>     .loop:
   582 000006AD AC                  <1>         lodsb
   583 000006AE 3C2C                <1>         cmp al, ','
   584 000006B0 740C                <1>         je .add_size
   585 000006B2 3C00                <1>         cmp al, 0
   586 000006B4 744C                <1>         je .done
   587                              <1> 
   588 000006B6 AA                  <1>         stosb
   589 000006B7 42                  <1>         inc dx
   590                              <1> 
   591 000006B8 B40E                <1>         mov ah, 0x0e
   592 000006BA CD10                <1>         int 0x10
   593                              <1> 
   594 000006BC EBEF                <1>         jmp .loop
   595                              <1> 
   596                              <1>     .add_size:
   597 000006BE 60                  <1>         pusha
   598 000006BF 83FA0C              <1>         cmp dx, 12
   599 000006C2 7D03                <1>         jge .continue
   600                              <1> 
   601 000006C4 E82F00              <1>         call .add_spaces
   602                              <1> 
   603                              <1>         .continue:
   604 000006C7 BE[F509]            <1>         mov si, .file_size_sep
   605 000006CA E8D414              <1>         call print
   606                              <1> 
   607 000006CD 89D0                <1>         mov ax, dx
   608 000006CF E8BB07              <1>         call string_truncate
   609                              <1> 
   610 000006D2 B8[B809]            <1>         mov ax, .tmp_filename
   611 000006D5 E8D91C              <1>         call os_get_file_size
   612                              <1> 
   613 000006D8 89D8                <1>         mov ax, bx
   614 000006DA E88708              <1>         call int_to_string
   615 000006DD 89C6                <1>         mov si, ax
   616 000006DF E8BF14              <1>         call print
   617                              <1> 
   618 000006E2 BE[CE03]            <1>         mov si, file_size_typ
   619 000006E5 E8B914              <1>         call print
   620                              <1> 
   621 000006E8 B8200E              <1>         mov ax, 0x0e20
   622 000006EB CD10                <1>         int 0x10
   623                              <1> 
   624 000006ED 61                  <1>         popa
   625                              <1> 
   626 000006EE BF[B809]            <1>         mov di, .tmp_filename
   627 000006F1 BA0000              <1>         mov dx, 0
   628 000006F4 EBB7                <1>         jmp .loop
   629                              <1> 
   630                              <1>     .add_spaces:
   631 000006F6 B8200E              <1>         mov ax, 0x0e20
   632 000006F9 CD10                <1>         int 0x10
   633 000006FB 42                  <1>         inc dx
   634 000006FC 83FA0C              <1>         cmp dx, 12
   635 000006FF 75F5                <1>         jne .add_spaces
   636 00000701 C3                  <1>         ret
   637                              <1> 
   638                              <1>     .done:
   639 00000702 83FA0C              <1>         cmp dx, 12
   640 00000705 7D03                <1>         jge .done_c
   641                              <1> 
   642 00000707 E8ECFF              <1>         call .add_spaces
   643                              <1> 
   644                              <1>         .done_c:
   645 0000070A BE[F509]            <1>         mov si, .file_size_sep
   646 0000070D E89114              <1>         call print
   647                              <1> 
   648 00000710 BE[B809]            <1>         mov si, .tmp_filename
   649 00000713 89D0                <1>         mov ax, dx
   650 00000715 E87507              <1>         call string_truncate
   651                              <1> 
   652 00000718 B8[B809]            <1>         mov ax, .tmp_filename
   653 0000071B E8931C              <1>         call os_get_file_size
   654                              <1> 
   655 0000071E 89D8                <1>         mov ax, bx
   656 00000720 E84108              <1>         call int_to_string
   657 00000723 89C6                <1>         mov si, ax
   658 00000725 E87914              <1>         call print
   659                              <1> 
   660 00000728 BE[FA09]            <1>         mov si, .file_size_typ
   661 0000072B E87314              <1>         call print
   662                              <1> 
   663 0000072E 50                  <1>     push ax
   664                              <1> 
   665 0000072F B80A0E              <1>     mov ax, 0x0e0a
   666 00000732 CD10                <1>     int 0x10
   667 00000734 B00D                <1>     mov al, 0x0d
   668 00000736 CD10                <1>     int 0x10
   669                              <1> 
   670 00000738 58                  <1>     pop ax
   671                              <1> 
   672 00000739 E961FE              <1>     jmp .input_loop
   673                              <1> 
   674                              <1> ; ----------------------------------
   675                              <1> ; HELP
   676                              <1> 
   677                              <1> .show_help:
   678 0000073C B8[6C07]            <1>     mov ax, .help_commands
   679 0000073F BB[DE08]            <1>     mov bx, .help_header
   680 00000742 B9[E808]            <1>     mov cx, .help_string
   681 00000745 E8A811              <1>     call list_dialog
   682                              <1> 
   683 00000748 83F804              <1>     cmp ax, 4
   684 0000074B 0F8430FF            <1>     je .settings
   685                              <1>     
   686 0000074F B70F                <1>     mov bh, cli_color
   687 00000751 E89106              <1>     call cls
   688                              <1> 
   689 00000754 83F802              <1>     cmp ax, 2
   690 00000757 0F8432FF            <1>     je .dir
   691 0000075B 83F809              <1>     cmp ax, 9
   692 0000075E 0F843602            <1>     je .restart
   693 00000762 83F80A              <1>     cmp ax, 10
   694 00000765 0F843702            <1>     je .shutdown
   695                              <1> 
   696 00000769 E931FE              <1>     jmp .input_loop
   697                              <1> 
   698 0000076C 48454C502020202020- <1>     .help_commands:     db "HELP       --  What you're looking at,"
   698 00000775 20202D2D2020576861- <1>
   698 0000077E 7420796F7527726520- <1>
   698 00000787 6C6F6F6B696E672061- <1>
   698 00000790 742C                <1>
   699 00000792 444952202020202020- <1>                         db "DIR        --  Show a list of all files,"
   699 0000079B 20202D2D202053686F- <1>
   699 000007A4 772061206C69737420- <1>
   699 000007AD 6F6620616C6C206669- <1>
   699 000007B6 6C65732C            <1>
   700 000007BA 434C45415220202020- <1>                         db "CLEAR      --  Clear the terminal,"
   700 000007C3 20202D2D2020436C65- <1>
   700 000007CC 617220746865207465- <1>
   700 000007D5 726D696E616C2C      <1>
   701 000007DC 53455454494E475320- <1>                         db "SETTINGS   --  Show the settings menu,"
   701 000007E5 20202D2D202053686F- <1>
   701 000007EE 772074686520736574- <1>
   701 000007F7 74696E6773206D656E- <1>
   701 00000800 752C                <1>
   702 00000802 4D4B2046494C452020- <1>                         db "MK FILE    --  Create a file,"
   702 0000080B 20202D2D2020437265- <1>
   702 00000814 61746520612066696C- <1>
   702 0000081D 652C                <1>
   703 0000081F 524D2046494C452020- <1>                         db "RM FILE    --  Delete a file,"
   703 00000828 20202D2D202044656C- <1>
   703 00000831 65746520612066696C- <1>
   703 0000083A 652C                <1>
   704 0000083C 4C4F41442046494C45- <1>                         db "LOAD FILE  --  Load/run a file,"
   704 00000845 20202D2D20204C6F61- <1>
   704 0000084E 642F72756E20612066- <1>
   704 00000857 696C652C            <1>
   705 0000085B 454449542046494C45- <1>                         db "EDIT FILE  --  Load and edit a file,"
   705 00000864 20202D2D20204C6F61- <1>
   705 0000086D 6420616E6420656469- <1>
   705 00000876 7420612066696C652C  <1>
   706 0000087F 524553544152542020- <1>                         db "RESTART    --  Restart KronkOS,"
   706 00000888 20202D2D2020526573- <1>
   706 00000891 74617274204B726F6E- <1>
   706 0000089A 6B4F532C            <1>
   707 0000089E 53485554444F574E20- <1>                         db "SHUTDOWN   --  Shutdown KronkOS,,"
   707 000008A7 20202D2D2020536875- <1>
   707 000008B0 74646F776E204B726F- <1>
   707 000008B9 6E6B4F532C2C        <1>
   708 000008BF 43414E43454C202020- <1>                         db "CANCEL     --  Leave this menu", 0
   708 000008C8 20202D2D20204C6561- <1>
   708 000008D1 76652074686973206D- <1>
   708 000008DA 656E7500            <1>
   709 000008DE 48454C50204D454E55- <1>     .help_header:       db "HELP MENU", 0
   709 000008E7 00                  <1>
   710 000008E8 507265737320454E54- <1>     .help_string:       db "Press ENTER to run any of the commands", 0
   710 000008F1 455220746F2072756E- <1>
   710 000008FA 20616E79206F662074- <1>
   710 00000903 686520636F6D6D616E- <1>
   710 0000090C 647300              <1>
   711                              <1> 
   712                              <1> ; ----------------------------------
   713                              <1> ; MAKE FILE
   714                              <1> 
   715                              <1> .make_file:
   716 0000090F 60                  <1>     pusha
   717 00000910 B8[B809]            <1>     mov ax, .tmp_filename
   718 00000913 E83919              <1>     call os_file_exists
   719 00000916 731A                <1>     jnc .file_exists
   720                              <1> 
   721 00000918 E85319              <1>     call os_create_file
   722                              <1>     
   723 0000091B B80A0E              <1>     mov ax, 0x0e0a
   724 0000091E CD10                <1>     int 0x10
   725 00000920 B00D                <1>     mov al, 0x0d
   726 00000922 CD10                <1>     int 0x10
   727                              <1> 
   728 00000924 BE[B809]            <1>     mov si, .tmp_filename
   729 00000927 E87712              <1>     call print
   730 0000092A BE[150A]            <1>     mov si, .tmp_filemk
   731 0000092D E87112              <1>     call print
   732 00000930 EB06                <1>     jmp .make_done
   733                              <1> 
   734                              <1>     .file_exists:
   735 00000932 BE[500A]            <1>         mov si, .file_found
   736 00000935 E86912              <1>         call print
   737                              <1> 
   738                              <1>     .make_done:
   739 00000938 B80A0E              <1>         mov ax, 0x0e0a
   740 0000093B CD10                <1>         int 0x10
   741 0000093D CD10                <1>         int 0x10
   742 0000093F B00D                <1>         mov al, 0x0d
   743 00000941 CD10                <1>         int 0x10
   744 00000943 61                  <1>         popa
   745 00000944 E956FC              <1>         jmp .input_loop
   746                              <1> 
   747                              <1> ; ----------------------------------
   748                              <1> ; REMOVE FILE
   749                              <1> 
   750                              <1> .remove_file:
   751 00000947 60                  <1>     pusha
   752 00000948 B8[B809]            <1>     mov ax, .tmp_filename
   753 0000094B E8AF19              <1>     call os_remove_file
   754 0000094E 7217                <1>     jc .not_file
   755                              <1> 
   756 00000950 B80A0E              <1>     mov ax, 0x0e0a
   757 00000953 CD10                <1>     int 0x10
   758 00000955 B00D                <1>     mov al, 0x0d
   759 00000957 CD10                <1>     int 0x10
   760                              <1> 
   761 00000959 BE[B809]            <1>     mov si, .tmp_filename
   762 0000095C E84212              <1>     call print
   763 0000095F BE[030A]            <1>     mov si, .tmp_filerm
   764 00000962 E83C12              <1>     call print
   765 00000965 EB06                <1>     jmp .finished
   766                              <1> 
   767                              <1>     .not_file:
   768 00000967 BE[3F0A]            <1>         mov si, .file_not_found
   769 0000096A E83412              <1>         call print
   770                              <1> 
   771                              <1>     .finished:
   772 0000096D B80A0E              <1>         mov ax, 0x0e0a
   773 00000970 CD10                <1>         int 0x10
   774 00000972 CD10                <1>         int 0x10
   775 00000974 B00D                <1>         mov al, 0x0d
   776 00000976 CD10                <1>         int 0x10
   777                              <1> 
   778 00000978 61                  <1>     popa
   779                              <1> 
   780 00000979 E921FC              <1>     jmp .input_loop
   781                              <1> 
   782                              <1> ; ----------------------------------
   783                              <1> ; LOAD FILE
   784                              <1> 
   785                              <1> .load_file:
   786 0000097C 60                  <1>     pusha
   787 0000097D 31C0                <1>     xor ax, ax
   788                              <1> 
   789 0000097F B8[B809]            <1>     mov ax, .tmp_filename
   790 00000982 E84BF7              <1>     call try_run_file
   791 00000985 7204                <1>     jc .not_found
   792                              <1> 
   793 00000987 61                  <1>     popa
   794 00000988 E912FC              <1>     jmp .input_loop
   795                              <1> 
   796                              <1>     .not_found:
   797 0000098B BE[AF03]            <1>         mov si, notfound_msg
   798 0000098E E81012              <1>         call print
   799                              <1> 
   800 00000991 61                  <1>         popa
   801 00000992 E908FC              <1>         jmp .input_loop
   802                              <1> 
   803                              <1> ; ----------------------------------
   804                              <1> ; EDIT FILE
   805                              <1> 
   806                              <1> .edit_file:
   807 00000995 E905FC              <1>     jmp .input_loop
   808                              <1> 
   809                              <1> ; ----------------------------------
   810                              <1> ; RESTART
   811                              <1> 
   812                              <1> .restart:
   813 00000998 B80000              <1>     mov ax, 0x00
   814 0000099B CD13                <1>     int 0x13
   815 0000099D CD19                <1>     int 0x19
   816                              <1> 
   817                              <1>     ; Halt cpu if restart fails
   818 0000099F F4                  <1>     hlt
   819                              <1> 
   820                              <1> ; ----------------------------------
   821                              <1> ; SHUTDOWN
   822                              <1> 
   823                              <1> .shutdown:
   824 000009A0 31C0                <1>     xor ax, ax
   825 000009A2 CD13                <1>     int 0x13
   826                              <1> 
   827 000009A4 B80010              <1>     mov ax, 0x1000
   828 000009A7 8CD0                <1>     mov ax, ss
   829 000009A9 BC00F0              <1>     mov sp, 0xf000
   830 000009AC B80753              <1>     mov ax, 0x5307
   831 000009AF BB0100              <1>     mov bx, 0x0001
   832 000009B2 B90300              <1>     mov cx, 0x0003
   833 000009B5 CD15                <1>     int 0x15
   834                              <1> 
   835                              <1>     ; Halt cpu if shutdown fails
   836 000009B7 F4                  <1>     hlt
   837                              <1> 
   838                              <1> 
   839 000009B8 00<rep 14h>         <1> .tmp_filename:      times 20 db 0
   840 000009CC 00<rep 29h>         <1> .tmp_inbuffer:      times 41 db 0
   841 000009F5 202D2D2000          <1> .file_size_sep:		db " -- ", 0
   842 000009FA 2042797465730A0D00  <1> .file_size_typ:		db " Bytes", 0x0a, 0x0d, 0
   843 00000A03 20686173206265656E- <1> .tmp_filerm:        db " has been deleted", 0
   843 00000A0C 2064656C6574656400  <1>
   844 00000A15 20686173206265656E- <1> .tmp_filemk:        db " has been created", 0
   844 00000A1E 206372656174656400  <1>
   845 00000A27 4155544F52554E2E42- <1> .autobin_filename:  db "AUTORUN.BKF", 0
   845 00000A30 4B4600              <1>
   846 00000A33 4155544F52554E2E42- <1> .autobas_filename:  db "AUTORUN.BAS", 0
   846 00000A3C 415300              <1>
   847 00000A3F 0A0D46696C65206E6F- <1> .file_not_found:    db 0x0a, 0x0d, "File not found", 0
   847 00000A48 7420666F756E6400    <1>
   848 00000A50 0A0D46696C6520616C- <1> .file_found:        db 0x0a, 0x0d, "File already exists", 0
   848 00000A59 726561647920657869- <1>
   848 00000A62 73747300            <1>
   367                                      %include "./includes/menubar.asm"
   368                              <1> check_pos:
   369 00000A66 60                  <1>     pusha
   370                              <1> 
   371 00000A67 B403                <1>     mov ah, 0x03
   372 00000A69 30FF                <1>     xor bh, bh
   373 00000A6B CD10                <1>     int 0x10
   374                              <1> 
   375 00000A6D 80FE18              <1>     cmp dh, 24
   376 00000A70 7402                <1>     je .at_end
   377                              <1> 
   378 00000A72 61                  <1>     popa
   379 00000A73 C3                  <1>     ret
   380                              <1> 
   381                              <1> .at_end:
   382 00000A74 B80306              <1>     mov ax, 0x0603
   383 00000A77 B70F                <1>     mov bh, cli_color
   384 00000A79 BA4F18              <1> 	mov dx, 0x184f
   385 00000A7C 31C9                <1> 	xor cx, cx
   386 00000A7E CD10                <1>     int 0x10
   387                              <1> 
   388 00000A80 B402                <1>     mov ah, 0x02
   389 00000A82 30FF                <1>     xor bh, bh
   390 00000A84 30D2                <1>     xor dl, dl
   391 00000A86 B615                <1>     mov dh, 21
   392 00000A88 CD10                <1>     int 0x10
   393                              <1> 
   394 00000A8A 61                  <1>     popa
   395 00000A8B C3                  <1>     ret
   396                              <1> 
   397                              <1> draw_menu_bar:
   398 00000A8C 60                  <1>     pusha
   399                              <1> 
   400 00000A8D B403                <1>     mov ah, 0x03
   401 00000A8F 30FF                <1>     xor bh, bh
   402 00000A91 CD10                <1>     int 0x10
   403                              <1> 
   404 00000A93 52                  <1>     push dx
   405                              <1> 
   406 00000A94 B80407              <1>     mov ax, 0x0704
   407 00000A97 B70F                <1>     mov bh, cli_color
   408 00000A99 BA4F18              <1> 	mov dx, 0x184f
   409 00000A9C 31C9                <1> 	xor cx, cx
   410 00000A9E CD10                <1>     int 0x10
   411 00000AA0 B80406              <1>     mov ax, 0x0604
   412 00000AA3 CD10                <1>     int 0x10
   413                              <1>     
   414 00000AA5 B402                <1>     mov ah, 0x02
   415 00000AA7 B618                <1>     mov dh, 24
   416 00000AA9 30FF                <1>     xor bh, bh
   417 00000AAB 30D2                <1>     xor dl, dl
   418 00000AAD CD10                <1>     int 0x10
   419                              <1> 
   420 00000AAF BE[D703]            <1>     mov si, mb_fill
   421 00000AB2 B330                <1>     mov bl, mb_color
   422 00000AB4 E82311              <1>     call print_atr
   423                              <1> 
   424 00000AB7 B402                <1>     mov ah, 0x02
   425 00000AB9 B618                <1>     mov dh, 24
   426 00000ABB B201                <1>     mov dl, 1
   427 00000ABD 30FF                <1>     xor bh, bh
   428 00000ABF CD10                <1>     int 0x10
   429                              <1> 
   430 00000AC1 E85F05              <1>     call get_time_string
   431 00000AC4 89DE                <1>     mov si, bx
   432 00000AC6 B330                <1>     mov bl, mb_color
   433 00000AC8 E80F11              <1>     call print_atr
   434                              <1> 
   435 00000ACB B402                <1>     mov ah, 0x02
   436 00000ACD B618                <1>     mov dh, 24
   437 00000ACF B21C                <1>     mov dl, 28
   438 00000AD1 30FF                <1>     xor bh, bh
   439 00000AD3 CD10                <1>     int 0x10
   440                              <1> 
   441 00000AD5 B8[8401]            <1>     mov ax, usrNam
   442 00000AD8 E86F03              <1>     call string_uppercase
   443 00000ADB 89C6                <1>     mov si, ax
   444 00000ADD B330                <1>     mov bl, mb_color
   445 00000ADF E8F810              <1>     call print_atr
   446                              <1> 
   447 00000AE2 B402                <1>     mov ah, 0x02
   448 00000AE4 B618                <1>     mov dh, 24
   449 00000AE6 B245                <1>     mov dl, 69
   450 00000AE8 30FF                <1>     xor bh, bh
   451 00000AEA CD10                <1>     int 0x10
   452                              <1> 
   453 00000AEC E8EB05              <1>     call get_date_string
   454 00000AEF 89DE                <1>     mov si, bx
   455 00000AF1 B330                <1>     mov bl, mb_color
   456 00000AF3 E8E410              <1>     call print_atr
   457                              <1> 
   458 00000AF6 B402                <1>     mov ah, 0x02
   459 00000AF8 30FF                <1>     xor bh, bh
   460 00000AFA 30D2                <1>     xor dl, dl
   461 00000AFC 5A                  <1>     pop dx
   462 00000AFD CD10                <1>     int 0x10
   463                              <1> 
   464 00000AFF 61                  <1>     popa
   465 00000B00 C3                  <1>     ret
   368                                      %include "./includes/video.asm"
   369                              <1> kronk_vid:
   370 00000B01 B80100              <1>     mov ax, 1
   371 00000B04 B701                <1>     mov bh, vid_backcolor
   372 00000B06 E8B109              <1>     call switch_mode
   373                              <1>     
   374                              <1>     ; Disable color blinking
   375 00000B09 B80310              <1>     mov ax, 0x1003
   376 00000B0C BB0000              <1>     mov bx, 0x0000
   377 00000B0F CD10                <1>     int 0x10
   378                              <1> 
   379                              <1>     ; Initalize and enable the mouse if possible
   380 00000B11 E83411              <1>     call mouse_initialize
   381 00000B14 7205                <1>     jc error
   382 00000B16 E85D11              <1>     call mouse_enable
   383 00000B19 EB07                <1>     jmp vid_input
   384                              <1> 
   385                              <1> error: 
   386 00000B1B B700                <1>     mov bh, 0x00
   387 00000B1D E8C502              <1>     call cls
   388 00000B20 EBFE                <1>     jmp $
   389                              <1> 
   390                              <1> 
   391                              <1> vid_input:
   392 00000B22 B701                <1>     mov bh, vid_backcolor
   393 00000B24 E8BE02              <1>     call cls
   394                              <1> 
   395                              <1> .at_same:
   396 00000B27 E85212              <1>     call mouse_loop
   397 00000B2A 3A16[590B]          <1>     cmp dl, [lastX]
   398 00000B2E 7511                <1>     jne .moved
   399                              <1> 
   400 00000B30 3A36[5A0B]          <1>     cmp dh, [lastY]
   401 00000B34 750B                <1>     jne .moved
   402                              <1> 
   403 00000B36 BE[5C0B]            <1>     mov si, sejt
   404 00000B39 BB0F00              <1>     mov bx, 0x000F
   405 00000B3C E89B10              <1>     call print_atr
   406                              <1> 
   407 00000B3F EBE6                <1>     jmp .at_same
   408                              <1> 
   409                              <1> .moved:
   410 00000B41 8816[590B]          <1>     mov [lastX], dl
   411 00000B45 8836[5A0B]          <1>     mov [lastY], dh
   412                              <1> 
   413 00000B49 BE[5C0B]            <1>     mov si, sejt
   414 00000B4C BB0F00              <1>     mov bx, 0x000F
   415 00000B4F E88810              <1>     call print_atr
   416                              <1> 
   417 00000B52 EBCE                <1>     jmp vid_input
   418                              <1> 
   419 00000B54 2C2000              <1>     .separator: db ", ", 0
   420 00000B57 0000                <1>     .lastPos:   dw 0
   421                              <1> 
   422                              <1> ; ------------------------------------------------------------------
   423                              <1> ; STRINGS AND OTHER VARIABLES
   424                              <1> 
   425 00000B59 00                  <1>     lastX:              db 0
   426 00000B5A 00                  <1>     lastY:              db 0
   427 00000B5B 00                  <1>     mouse_working:      db 0
   428 00000B5C 5800                <1>     sejt:               db "X", 0
   369                                      %include "./includes/setup.asm"
   370                              <1> ; ==================================================================
   371                              <1> ; The Kronk Operating System setup file
   372                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   373                              <1> ;
   374                              <1> ; This is loaded from the drive by KERNEL.BIN, at first boot
   375                              <1> ; ==================================================================
   376                              <1> setup_init:
   377                              <1> 
   378                              <1>     ; Color variables
   379                              <1>     basic_colors    equ 0x1F
   380                              <1>     marked_colors   equ 0x1E
   381                              <1> 
   382                              <1>     ; Setup text box variables
   383                              <1>     edge_width      equ 14
   384                              <1>     border_length   equ 50
   385                              <1>     
   386                              <1>     ; Disable color blinking
   387 00000B5E B80310              <1>     mov ax, 0x1003
   388 00000B61 BB0000              <1>     mov bx, 0x0000
   389 00000B64 CD10                <1>     int 0x10
   390                              <1> 
   391 00000B66 EB00                <1>     jmp setup_start
   392                              <1> 
   393                              <1> ; ******************************************************************
   394                              <1> ; Start the setup
   395                              <1> setup_start:
   396 00000B68 60                  <1>     pusha
   397 00000B69 B71F                <1>     mov bh, basic_colors
   398 00000B6B E87702              <1>     call cls
   399                              <1> 
   400 00000B6E BE[D00D]            <1>     mov si, setup_string
   401 00000B71 E86D09              <1>     call setup_bottom_string
   402                              <1> 
   403 00000B74 BE[F50B]            <1>     mov si, usr_set
   404 00000B77 E82A0C              <1>     call draw_setup_box
   405                              <1> 
   406 00000B7A B8[E10B]            <1>     mov ax, usr_save
   407 00000B7D E87909              <1>     call setup_input
   408                              <1> 
   409 00000B80 B71F                <1>     mov bh, basic_colors
   410 00000B82 E86002              <1>     call cls
   411                              <1> 
   412 00000B85 BE[240C]            <1>     mov si, vid_set
   413 00000B88 E8190C              <1>     call draw_setup_box
   414                              <1> 
   415 00000B8B B8[9B0D]            <1>     mov ax, vid_opt1
   416 00000B8E BB[A40D]            <1>     mov bx, vid_opt2
   417 00000B91 B9[AF0D]            <1>     mov cx, vid_opt3
   418 00000B94 BAE11F              <1>     mov dx, 0x1fe1
   419 00000B97 E8570A              <1>     call setup_choose
   420                              <1> 
   421 00000B9A 83F802              <1>     cmp ax, 2
   422 00000B9D 7517                <1>     jne .setup_done
   423                              <1> 
   424                              <1>     ; User has choosen "cancel" and KronkOS will therefore shutdown
   425 00000B9F 31C0                <1>     xor ax, ax
   426 00000BA1 CD13                <1>     int 0x13
   427                              <1> 
   428 00000BA3 B80010              <1>     mov ax, 0x1000
   429 00000BA6 8CD0                <1>     mov ax, ss
   430 00000BA8 BC00F0              <1>     mov sp, 0xf000
   431 00000BAB B80753              <1>     mov ax, 0x5307
   432 00000BAE BB0100              <1>     mov bx, 0x0001
   433 00000BB1 B90300              <1>     mov cx, 0x0003
   434 00000BB4 CD15                <1>     int 0x15
   435                              <1> 
   436                              <1> .setup_done:
   437 00000BB6 A3[9901]            <1>     mov [vidMode], ax
   438                              <1> 
   439 00000BB9 BE[E10B]            <1>     mov si, usr_save
   440 00000BBC BF[8401]            <1>     mov di, usrNam
   441 00000BBF E8C202              <1>     call string_copy
   442                              <1> 
   443 00000BC2 61                  <1>     popa
   444 00000BC3 C3                  <1>     ret
   445                              <1> 
   446                              <1> ; ******************************************************************
   447                              <1> 
   448                              <1> ; ------------------------------------------------------------------
   449                              <1> ; VARIABLES
   450 00000BC4 766964656F6D6F6465- <1>     vidmode_save:   db "videomode,", 0
   450 00000BCD 2C00                <1>
   451 00000BCF 300A0D00            <1>     cli_save:       db "0", 0x0a, 0x0d, 0
   452 00000BD3 310A0D00            <1>     vid_save:       db "1", 0x0a, 0x0d, 0
   453 00000BD7 757365726E616D652C- <1>     usrname_save:   db "username,", 0
   453 00000BE0 00                  <1>
   454 00000BE1 00<rep 14h>         <1>     usr_save:       times 20 db 0
   455                              <1> 
   456 00000BF5 506C6561736520656E- <1>     usr_set:    db "Please enter your username, and press enter...", 0
   456 00000BFE 74657220796F757220- <1>
   456 00000C07 757365726E616D652C- <1>
   456 00000C10 20616E642070726573- <1>
   456 00000C19 7320656E7465722E2E- <1>
   456 00000C22 2E00                <1>
   457                              <1> 
   458 00000C24 506C65617365206368- <1>     vid_set:    db "Please choose a standard view mode...", 0x0a, 0x0a
   458 00000C2D 6F6F73652061207374- <1>
   458 00000C36 616E64617264207669- <1>
   458 00000C3F 6577206D6F64652E2E- <1>
   458 00000C48 2E0A0A              <1>
   459 00000C4B 564944454F204D4F44- <1>                 db "VIDEO MODE is for the more casual user, that", 0x0a, "just want to be able to use KronkOS with ease by using a nice graphical interface.", 0x0a, 0x0a
   459 00000C54 4520697320666F7220- <1>
   459 00000C5D 746865206D6F726520- <1>
   459 00000C66 63617375616C207573- <1>
   459 00000C6F 65722C20746861740A- <1>
   459 00000C78 6A7573742077616E74- <1>
   459 00000C81 20746F206265206162- <1>
   459 00000C8A 6C6520746F20757365- <1>
   459 00000C93 204B726F6E6B4F5320- <1>
   459 00000C9C 776974682065617365- <1>
   459 00000CA5 206279207573696E67- <1>
   459 00000CAE 2061206E6963652067- <1>
   459 00000CB7 726170686963616C20- <1>
   459 00000CC0 696E74657266616365- <1>
   459 00000CC9 2E0A0A              <1>
   460 00000CCC 434C49204D4F444520- <1>                 db "CLI MODE is for the more advanced user, where", 0x0a, "instead of pressing buttons, you use commands to", 0x0a, "execute the various actions you desire.", 0x0a, 0x0a
   460 00000CD5 697320666F72207468- <1>
   460 00000CDE 65206D6F7265206164- <1>
   460 00000CE7 76616E636564207573- <1>
   460 00000CF0 65722C207768657265- <1>
   460 00000CF9 0A696E737465616420- <1>
   460 00000D02 6F6620707265737369- <1>
   460 00000D0B 6E6720627574746F6E- <1>
   460 00000D14 732C20796F75207573- <1>
   460 00000D1D 6520636F6D6D616E64- <1>
   460 00000D26 7320746F0A65786563- <1>
   460 00000D2F 757465207468652076- <1>
   460 00000D38 6172696F7573206163- <1>
   460 00000D41 74696F6E7320796F75- <1>
   460 00000D4A 206465736972652E0A- <1>
   460 00000D53 0A                  <1>
   461 00000D54 557365207468652061- <1>                 db "Use the arrow keys and 'ENTER' to select between the different options", 0
   461 00000D5D 72726F77206B657973- <1>
   461 00000D66 20616E642027454E54- <1>
   461 00000D6F 45522720746F207365- <1>
   461 00000D78 6C6563742062657477- <1>
   461 00000D81 65656E207468652064- <1>
   461 00000D8A 6966666572656E7420- <1>
   461 00000D93 6F7074696F6E7300    <1>
   462                              <1> 
   463 00000D9B 434C49204D4F444500  <1>     vid_opt1:   db "CLI MODE", 0
   464 00000DA4 564944454F204D4F44- <1>     vid_opt2:   db "VIDEO MODE", 0
   464 00000DAD 4500                <1>
   465 00000DAF 43616E63656C202857- <1>     vid_opt3:   db "Cancel (Will shutdown KronkOS)", 0
   465 00000DB8 696C6C207368757464- <1>
   465 00000DC1 6F776E204B726F6E6B- <1>
   465 00000DCA 4F532900            <1>
   466                              <1> 
   467 00000DCE 0000                <1>     vid_chosen: dw 0
   468                              <1> 
   469 00000DD0 204B726F6E6B4F5320- <1>     setup_string: db " KronkOS ", KRONKOS_VER, " setup", 0
   469 00000DD9 302E332E3220736574- <1>
   469 00000DE2 757000              <1>
   370                                      %include "./includes/cls.asm"
   371                              <1> ; ------------------------------------------------------------------
   372                              <1> ; cls -- Clear the screen with a self choosen color
   373                              <1> ; IN: BH = Color to clear with
   374                              <1> 
   375                              <1> cls:
   376 00000DE5 60                  <1>     pusha
   377                              <1>     
   378 00000DE6 B406                <1>     mov ah, 0x06
   379 00000DE8 BA4F18              <1>     mov dx, 0x184f
   380                              <1> 
   381 00000DEB 30C0                <1>     xor al, al
   382 00000DED 31C9                <1>     xor cx, cx
   383                              <1> 
   384 00000DEF CD10                <1>     int 0x10
   385                              <1>     
   386 00000DF1 B402                <1>     mov ah, 0x2
   387 00000DF3 31D2                <1>     xor dx, dx
   388 00000DF5 30FF                <1>     xor bh, bh
   389                              <1> 
   390 00000DF7 CD10                <1>     int 0x10
   391                              <1>     
   392 00000DF9 61                  <1>     popa
   393 00000DFA C3                  <1>     ret
   371                                      %include "./includes/string.asm"
   372                              <1> ; ==================================================================
   373                              <1> ; KronkOS -- The Kronk Operating System kernel
   374                              <1> ; Copyright (C) 2019-2020 Alexander Wiencken
   375                              <1> ;
   376                              <1> ; STRING MANIPULATION ROUTINES
   377                              <1> ; ==================================================================
   378                              <1> 
   379                              <1> ; ------------------------------------------------------------------
   380                              <1> ; string_length -- Return length of a string
   381                              <1> ; IN: AX = string location
   382                              <1> ; OUT AX = length (other regs preserved)
   383                              <1> 
   384                              <1> string_length:
   385 00000DFB 60                  <1>     pusha
   386 00000DFC 89C3                <1>     mov bx, ax
   387 00000DFE B90000              <1>     mov cx, 0
   388                              <1> 
   389                              <1>     .more:
   390 00000E01 803F00              <1>         cmp byte [bx], 0
   391 00000E04 7404                <1>         je .done
   392 00000E06 43                  <1>         inc bx
   393 00000E07 41                  <1>         inc cx
   394 00000E08 EBF7                <1>         jmp .more
   395                              <1> 
   396                              <1>     .done:
   397 00000E0A 890E[130E]          <1>         mov word [.tmp_counter], cx
   398 00000E0E 61                  <1>         popa
   399                              <1> 
   400 00000E0F A1[130E]            <1>         mov ax, [.tmp_counter]
   401 00000E12 C3                  <1>         ret
   402                              <1> 
   403 00000E13 0000                <1>         .tmp_counter dw 0
   404                              <1> 
   405                              <1> ; ------------------------------------------------------------------
   406                              <1> ; find_char_in_string -- Find location of character in a string
   407                              <1> ; IN: SI = string location, AL = character to find
   408                              <1> ; OUT AX = location in string, or 0 if not present
   409                              <1> 
   410                              <1> find_char_in_string:
   411 00000E15 60                  <1>     pusha
   412 00000E16 B90100              <1>     mov cx, 1
   413                              <1> 
   414                              <1>     .more:
   415 00000E19 3804                <1>         cmp byte [si], al
   416 00000E1B 7409                <1>         je .done
   417 00000E1D 803C00              <1>         cmp byte [si], 0
   418 00000E20 740D                <1>         je .notfound
   419                              <1>         
   420 00000E22 46                  <1>         inc si
   421 00000E23 41                  <1>         inc cx
   422                              <1> 
   423 00000E24 EBF3                <1>         jmp .more
   424                              <1>     
   425                              <1>     .done:
   426 00000E26 890E[340E]          <1>         mov [.tmp], cx
   427 00000E2A 61                  <1>         popa
   428 00000E2B A1[340E]            <1>         mov ax, [.tmp]
   429                              <1> 
   430 00000E2E C3                  <1>         ret
   431                              <1>     
   432                              <1>     .notfound:
   433 00000E2F 61                  <1>         popa
   434 00000E30 B80000              <1>         mov ax, 0
   435                              <1> 
   436 00000E33 C3                  <1>         ret
   437                              <1> 
   438 00000E34 0000                <1>     .tmp dw 0
   439                              <1> 
   440                              <1> ; ------------------------------------------------------------------
   441                              <1> ; string_charchange -- Change a character in a string
   442                              <1> ; IN: SI = string location, AL = char to find, BL = char to replace with
   443                              <1> 
   444                              <1> string_charchange:
   445 00000E36 60                  <1>     pusha
   446 00000E37 88C1                <1>     mov cl, al
   447                              <1> 
   448                              <1>     .loop:
   449 00000E39 8A04                <1>         mov byte al, [si]
   450 00000E3B 3C00                <1>         cmp al, 0
   451 00000E3D 7409                <1>         je .finish
   452 00000E3F 38C8                <1>         cmp al, cl
   453 00000E41 7502                <1>         jne .nochange
   454                              <1> 
   455 00000E43 881C                <1>         mov byte [si], bl
   456                              <1> 
   457                              <1>     .nochange:
   458 00000E45 46                  <1>         inc si
   459 00000E46 EBF1                <1>         jmp .loop
   460                              <1>     
   461                              <1>     .finish:
   462 00000E48 61                  <1>         popa
   463 00000E49 C3                  <1>         ret
   464                              <1> 
   465                              <1> ; ------------------------------------------------------------------
   466                              <1> ; string_uppercase -- Convert string to upper case
   467                              <1> ; IN/OUT: AX = string location
   468                              <1> 
   469                              <1> string_uppercase:
   470 00000E4A 60                  <1>     pusha
   471 00000E4B 89C6                <1>     mov si, ax
   472                              <1> 
   473                              <1>     .more:
   474 00000E4D 803C00              <1>         cmp byte [si], 0
   475 00000E50 7413                <1>         je .done
   476                              <1> 
   477 00000E52 803C61              <1>         cmp byte [si], 'a'
   478 00000E55 720B                <1>         jb .noatoz
   479 00000E57 803C7A              <1>         cmp byte [si], 'z'
   480 00000E5A 7706                <1>         ja .noatoz
   481                              <1> 
   482 00000E5C 802C20              <1>         sub byte [si], 0x20
   483                              <1> 
   484 00000E5F 46                  <1>         inc si
   485 00000E60 EBEB                <1>         jmp .more
   486                              <1> 
   487                              <1>     .noatoz:
   488 00000E62 46                  <1>         inc si
   489 00000E63 EBE8                <1>         jmp .more
   490                              <1> 
   491                              <1>     .done:
   492 00000E65 61                  <1>         popa
   493 00000E66 C3                  <1>         ret
   494                              <1> 
   495                              <1> ; ------------------------------------------------------------------
   496                              <1> ; string_lowercase -- Convert string to lower case
   497                              <1> ; IN/OUT: AX = string location
   498                              <1> 
   499                              <1> string_lowercase:
   500 00000E67 60                  <1>     pusha
   501 00000E68 89C6                <1>     mov si, ax
   502                              <1> 
   503                              <1>     .more:
   504 00000E6A 803C00              <1>         cmp byte [si], 0
   505 00000E6D 7413                <1>         je .done
   506                              <1> 
   507 00000E6F 803C41              <1>         cmp byte [si], 'A'
   508 00000E72 720B                <1>         jb .noatoz
   509 00000E74 803C5A              <1>         cmp byte [si], 'Z'
   510 00000E77 7706                <1>         ja .noatoz
   511                              <1> 
   512 00000E79 800420              <1>         add byte [si], 0x20
   513                              <1> 
   514 00000E7C 46                  <1>         inc si
   515 00000E7D EBEB                <1>         jmp .more
   516                              <1>     
   517                              <1>     .noatoz:
   518 00000E7F 46                  <1>         inc si
   519 00000E80 EBE8                <1>         jmp .more
   520                              <1> 
   521                              <1>     .done:
   522 00000E82 61                  <1>         popa
   523 00000E83 C3                  <1>         ret
   524                              <1>         
   525                              <1> ; ------------------------------------------------------------------
   526                              <1> ; string_copy -- Copy one string on to another
   527                              <1> ; IN: SI = source
   528                              <1> ; OUT: DI = destination
   529                              <1> 
   530                              <1> string_copy:
   531 00000E84 60                  <1>     pusha
   532                              <1> 
   533                              <1>     .more:
   534 00000E85 AC                  <1>         lodsb
   535 00000E86 AA                  <1>         stosb
   536                              <1> 
   537 00000E87 84C0                <1>         test al, al
   538 00000E89 75FA                <1>         jnz .more
   539                              <1> 
   540                              <1>     .done:
   541 00000E8B 61                  <1>         popa
   542 00000E8C C3                  <1>         ret
   543                              <1> 
   544                              <1> ; ------------------------------------------------------------------
   545                              <1> ; string_truncate -- Chop string down to specified number of characters
   546                              <1> ; IN: SI = string location, AX = number of characters
   547                              <1> ; OUT: Modified string
   548                              <1> 
   549                              <1> string_truncate:
   550 00000E8D 60                  <1>     pusha
   551                              <1> 
   552 00000E8E 01C6                <1>     add si, ax
   553 00000E90 C60400              <1>     mov byte [si], 0
   554                              <1> 
   555 00000E93 61                  <1>     popa
   556 00000E94 C3                  <1>     ret
   557                              <1> 
   558                              <1> ; ------------------------------------------------------------------
   559                              <1> ; string_add
   560                              <1> ; IN: AX = string one; BX = string two
   561                              <1> ; OUT AX = product
   562                              <1> 
   563                              <1> string_add:
   564                              <1>     .add_loop:
   565 00000E95 AC                  <1>         lodsb
   566 00000E96 AA                  <1>         stosb
   567                              <1> 
   568 00000E97 3C00                <1>         cmp al, 0
   569 00000E99 75FA                <1>         jne .add_loop
   570                              <1> 
   571 00000E9B C3                  <1>         ret
   572                              <1> 
   573                              <1> ; ------------------------------------------------------------------
   574                              <1> ; string_join -- Join two strings into a third seperate string
   575                              <1> ; IN/OUT: AX = string one, BX = string two, CX = product destination
   576                              <1> 
   577                              <1> string_join:
   578 00000E9C 60                  <1>     pusha
   579                              <1>     
   580 00000E9D 89C6                <1>     mov si, ax
   581 00000E9F 89CF                <1>     mov di, cx
   582                              <1> 
   583 00000EA1 E8E0FF              <1>     call string_copy
   584 00000EA4 E854FF              <1>     call string_length
   585                              <1> 
   586 00000EA7 01C1                <1>     add cx, ax
   587                              <1> 
   588 00000EA9 89DE                <1>     mov si, bx
   589 00000EAB 89CF                <1>     mov di, cx
   590 00000EAD E8D4FF              <1>     call string_copy
   591                              <1> 
   592 00000EB0 61                  <1>     popa
   593 00000EB1 C3                  <1>     ret
   594                              <1> 
   595                              <1> ; ------------------------------------------------------------------
   596                              <1> ; string_chomp -- Strip away extra spaces from a string
   597                              <1> ; IN: AX = string location
   598                              <1> 
   599                              <1> string_chomp:
   600 00000EB2 60                  <1>     pusha
   601                              <1> 
   602 00000EB3 89C2                <1>     mov dx, ax
   603                              <1> 
   604 00000EB5 89C7                <1>     mov di, ax
   605 00000EB7 B90000              <1>     mov cx, 0
   606                              <1> 
   607                              <1>     .keepcounting:
   608 00000EBA 803D20              <1>         cmp byte [di], ' '
   609 00000EBD 7504                <1>         jne .counted
   610 00000EBF 41                  <1>         inc cx
   611 00000EC0 47                  <1>         inc di
   612 00000EC1 EBF7                <1>         jmp .keepcounting
   613                              <1> 
   614                              <1>     .counted:
   615 00000EC3 83F900              <1>         cmp cx, 0
   616 00000EC6 740E                <1>         je .finished_copy
   617                              <1> 
   618 00000EC8 89FE                <1>         mov si, di
   619 00000ECA 89D7                <1>         mov di, dx
   620                              <1>     
   621                              <1>     .keep_copying:
   622 00000ECC AC                  <1>         lodsb
   623 00000ECD 8805                <1>         mov [di], al
   624 00000ECF 3C00                <1>         cmp al, 0
   625 00000ED1 7403                <1>         je .finished_copy
   626 00000ED3 47                  <1>         inc di
   627                              <1> 
   628 00000ED4 EBF6                <1>         jmp .keep_copying
   629                              <1> 
   630                              <1>     .finished_copy:
   631 00000ED6 89D0                <1>         mov ax, dx
   632                              <1> 
   633 00000ED8 E820FF              <1>         call string_length
   634 00000EDB 83F800              <1>         cmp ax, 0
   635 00000EDE 740F                <1>         je .done
   636                              <1> 
   637 00000EE0 89D6                <1>         mov si, dx
   638 00000EE2 01C6                <1>         add si, ax
   639                              <1>     
   640                              <1>     .more:
   641 00000EE4 4E                  <1>         dec si
   642 00000EE5 803C20              <1>         cmp byte [si], ' '
   643 00000EE8 7505                <1>         jne .done
   644 00000EEA C60400              <1>         mov byte [si], 0
   645 00000EED EBF5                <1>         jmp .more
   646                              <1>     
   647                              <1>     .done:
   648 00000EEF 61                  <1>         popa
   649 00000EF0 C3                  <1>         ret
   650                              <1> 
   651                              <1> ; ------------------------------------------------------------------
   652                              <1> ; string_strip -- Remove a character from a string (max 255 chars)
   653                              <1> ; IN: SI = string location, AL = character to remove
   654                              <1> ; OUT: SI = modified string
   655                              <1> 
   656                              <1> string_strip:
   657 00000EF1 60                  <1>     pusha
   658                              <1> 
   659 00000EF2 89F7                <1>     mov di, si
   660 00000EF4 88C3                <1>     mov bl, al
   661                              <1> 
   662                              <1>     .nextchar:
   663 00000EF6 AC                  <1>         lodsb
   664 00000EF7 AA                  <1>         stosb
   665 00000EF8 3C00                <1>         cmp al, 0
   666 00000EFA 7407                <1>         je .finish
   667 00000EFC 38D8                <1>         cmp al, bl
   668 00000EFE 75F6                <1>         jne .nextchar
   669                              <1> 
   670                              <1>     .skip:
   671 00000F00 4F                  <1>         dec di
   672 00000F01 EBF3                <1>         jmp .nextchar
   673                              <1> 
   674                              <1>     .finish:
   675 00000F03 61                  <1>         popa
   676 00000F04 C3                  <1>         ret
   677                              <1> 
   678                              <1> ; ------------------------------------------------------------------
   679                              <1> ; string_compare -- Check if two strings match
   680                              <1> ; IN: SI = string one, DI = string two
   681                              <1> ; OUT: carry set if same, clear if different
   682                              <1> 
   683                              <1> string_compare:
   684 00000F05 60                  <1>     pusha
   685                              <1> 
   686                              <1>     .more:
   687 00000F06 8A04                <1>         mov al, [si]
   688 00000F08 8A1D                <1>         mov bl, [di]
   689                              <1> 
   690 00000F0A 80FB00              <1>         cmp bl, 0
   691 00000F0D 740B                <1>         je .terminated
   692                              <1> 
   693 00000F0F 38D8                <1>         cmp al, bl
   694 00000F11 7504                <1>         jne .not_same
   695                              <1> 
   696 00000F13 46                  <1>         inc si
   697 00000F14 47                  <1>         inc di
   698 00000F15 EBEF                <1>         jmp .more
   699                              <1>     
   700                              <1>     .not_same:
   701 00000F17 61                  <1>         popa
   702 00000F18 F8                  <1>         clc
   703 00000F19 C3                  <1>         ret
   704                              <1>     
   705                              <1>     .terminated:
   706 00000F1A 61                  <1>         popa
   707 00000F1B F9                  <1>         stc
   708 00000F1C C3                  <1>         ret
   709                              <1> 
   710                              <1> ; ------------------------------------------------------------------
   711                              <1> ; string_to_int -- Convert string to an integer
   712                              <1> ; IN: SI = string (max 5 chars, up to '65536')
   713                              <1> ; OUT: AX = number
   714                              <1> 
   715                              <1> string_to_int:
   716 00000F1D 60                  <1>     pusha
   717                              <1> 
   718 00000F1E 89F0                <1>     mov ax, si
   719 00000F20 E8D8FE              <1>     call string_length
   720                              <1> 
   721 00000F23 01C6                <1>     add si, ax
   722 00000F25 4E                  <1>     dec si
   723                              <1> 
   724 00000F26 89C1                <1>     mov cx, ax
   725                              <1> 
   726 00000F28 BB0000              <1>     mov bx, 0
   727 00000F2B B80000              <1>     mov ax, 0
   728                              <1> 
   729 00000F2E C706[600F]0100      <1>     mov word [.multiplier], 1
   730                              <1> 
   731                              <1>     .loop:
   732 00000F34 B80000              <1>         mov ax, 0
   733 00000F37 8A04                <1>         mov byte al, [si]
   734 00000F39 2C30                <1>         sub al, 48
   735                              <1> 
   736 00000F3B F726[600F]          <1>         mul word [.multiplier]
   737 00000F3F 01C3                <1>         add bx, ax
   738                              <1> 
   739 00000F41 50                  <1>         push ax
   740 00000F42 A1[600F]            <1>         mov word ax, [.multiplier]
   741 00000F45 BA0A00              <1>         mov dx, 10
   742 00000F48 F7E2                <1>         mul dx
   743 00000F4A A3[600F]            <1>         mov word [.multiplier], ax
   744 00000F4D 58                  <1>         pop ax
   745                              <1> 
   746 00000F4E 49                  <1>         dec cx
   747 00000F4F 83F900              <1>         cmp cx, 0
   748 00000F52 7403                <1>         je .finish
   749 00000F54 4E                  <1>         dec si
   750 00000F55 EBDD                <1>         jmp .loop
   751                              <1>     
   752                              <1>     .finish:
   753 00000F57 891E[620F]          <1>         mov word [.tmp], bx
   754 00000F5B 61                  <1>         popa
   755 00000F5C A1[620F]            <1>         mov word ax, [.tmp]
   756                              <1> 
   757 00000F5F C3                  <1>         ret
   758                              <1> 
   759 00000F60 0000                <1>     .multiplier dw 0
   760 00000F62 0000                <1>     .tmp        dw 0
   761                              <1> 
   762                              <1> ; ------------------------------------------------------------------
   763                              <1> ; int_to_string -- Convert unsigned integer to a string
   764                              <1> ; IN: AX = unsigned int
   765                              <1> ; OUT: AX = string
   766                              <1> 
   767                              <1> int_to_string:
   768 00000F64 60                  <1>     pusha
   769                              <1> 
   770 00000F65 B90000              <1>     mov cx, 0
   771 00000F68 BB0A00              <1>     mov bx, 10
   772 00000F6B BF[8B0F]            <1>     mov di, .t
   773                              <1> 
   774                              <1>     .push:
   775 00000F6E BA0000              <1>         mov dx, 0
   776 00000F71 F7F3                <1>         div bx
   777 00000F73 41                  <1>         inc cx
   778 00000F74 52                  <1>         push dx
   779 00000F75 85C0                <1>         test ax, ax
   780 00000F77 75F5                <1>         jnz .push
   781                              <1> 
   782                              <1>     .pop:
   783 00000F79 5A                  <1>         pop dx
   784 00000F7A 80C230              <1>         add dl, '0'
   785 00000F7D 8815                <1>         mov [di], dl
   786 00000F7F 47                  <1>         inc di
   787 00000F80 49                  <1>         dec cx
   788 00000F81 75F6                <1>         jnz .pop
   789                              <1> 
   790 00000F83 C60500              <1>         mov byte [di], 0
   791                              <1> 
   792 00000F86 61                  <1>         popa
   793 00000F87 B8[8B0F]            <1>         mov ax, .t
   794 00000F8A C3                  <1>         ret
   795                              <1> 
   796 00000F8B 00<rep 7h>          <1>         .t times 7 db 0
   797                              <1> 
   798                              <1> ; ------------------------------------------------------------------
   799                              <1> ; sint_to_string -- Convert signed integer to string
   800                              <1> ; IN: AX = signed int
   801                              <1> ; OUT: AX = string location
   802                              <1> 
   803                              <1> sint_to_string:
   804 00000F92 60                  <1>     pusha
   805                              <1> 
   806 00000F93 B90000              <1>     mov cx, 0
   807 00000F96 BB0A00              <1>     mov bx, 10
   808 00000F99 BF[C70F]            <1>     mov di, .t
   809                              <1> 
   810 00000F9C 85C0                <1>     test ax, ax
   811 00000F9E 7802                <1>     js .neg
   812 00000FA0 EB08                <1>     jmp .push
   813                              <1> 
   814                              <1>     .neg:
   815 00000FA2 F7D8                <1>         neg ax
   816 00000FA4 C606[C70F]2D        <1>         mov byte [.t], '-'
   817 00000FA9 47                  <1>         inc di
   818                              <1>     
   819                              <1>     .push:
   820 00000FAA BA0000              <1>         mov dx, 0
   821 00000FAD F7F3                <1>         div bx
   822 00000FAF 41                  <1>         inc cx
   823 00000FB0 52                  <1>         push dx
   824 00000FB1 85C0                <1>         test ax, ax
   825 00000FB3 75F5                <1>         jnz .push
   826                              <1> 
   827                              <1>     .pop:
   828 00000FB5 5A                  <1>         pop dx
   829 00000FB6 80C230              <1>         add dl, '0'
   830 00000FB9 8815                <1>         mov [di], dl
   831 00000FBB 47                  <1>         inc di
   832 00000FBC 49                  <1>         dec cx
   833 00000FBD 75F6                <1>         jnz .pop
   834                              <1> 
   835 00000FBF C60500              <1>         mov byte [di], 0
   836                              <1> 
   837 00000FC2 61                  <1>         popa
   838 00000FC3 B8[C70F]            <1>         mov ax, .t
   839 00000FC6 C3                  <1>         ret
   840                              <1> 
   841 00000FC7 00<rep 7h>          <1>         .t times 7 db 0
   842                              <1>         
   843                              <1> ; ------------------------------------------------------------------
   844                              <1> ; lint_to_string -- Convert long integer to string
   845                              <1> ; IN: DX:AX = long unsigned int, BX = number base, DI = string location
   846                              <1> ; OUT: DI = location of converted string
   847                              <1> 
   848                              <1> lint_to_string:
   849 00000FCE 60                  <1>     pusha
   850                              <1> 
   851 00000FCF 89FE                <1>     mov si, di
   852 00000FD1 C7050000            <1>     mov word [di], 0
   853                              <1> 
   854 00000FD5 83FB25              <1>     cmp bx, 37
   855 00000FD8 773B                <1>     ja .done
   856                              <1> 
   857 00000FDA 83FB00              <1>     cmp bx, 0
   858 00000FDD 7436                <1>     je .done
   859                              <1> 
   860                              <1>     .conversion_loop:
   861 00000FDF B90000              <1>         mov cx, 0
   862                              <1> 
   863 00000FE2 91                  <1>         xchg ax, cx
   864 00000FE3 92                  <1>         xchg ax, dx
   865 00000FE4 F7F3                <1>         div bx
   866                              <1> 
   867 00000FE6 91                  <1>         xchg ax, cx
   868 00000FE7 F7F3                <1>         div bx
   869 00000FE9 87CA                <1>         xchg cx, dx
   870                              <1>     
   871                              <1>     .save_digit:
   872 00000FEB 83F909              <1>         cmp cx, 9
   873 00000FEE 7E03                <1>         jle .convert_digit
   874                              <1> 
   875 00000FF0 83C107              <1>         add cx, 'A'-'9'-1
   876                              <1> 
   877                              <1>     .convert_digit:
   878 00000FF3 83C130              <1>         add cx, '0'
   879                              <1> 
   880 00000FF6 50                  <1>         push ax
   881 00000FF7 53                  <1>         push bx
   882 00000FF8 89F0                <1>         mov ax, si
   883 00000FFA E8FEFD              <1>         call string_length
   884                              <1> 
   885 00000FFD 89F7                <1>         mov di, si
   886 00000FFF 01C7                <1>         add di, ax
   887 00001001 40                  <1>         inc ax
   888                              <1>     
   889                              <1>     .move_string_up:
   890 00001002 8A1D                <1>         mov bl, [di]
   891 00001004 885D01              <1>         mov [di+1], bl
   892 00001007 4F                  <1>         dec di
   893 00001008 48                  <1>         dec ax
   894 00001009 75F7                <1>         jnz .move_string_up
   895                              <1> 
   896 0000100B 5B                  <1>         pop bx
   897 0000100C 58                  <1>         pop ax
   898 0000100D 880C                <1>         mov [si], cl
   899                              <1>     
   900                              <1>     .test_end:
   901 0000100F 89D1                <1>         mov cx, dx
   902 00001011 09C1                <1>         or cx, ax
   903 00001013 75CA                <1>         jnz .conversion_loop
   904                              <1>     
   905                              <1>     .done:
   906 00001015 61                  <1>         popa
   907 00001016 C3                  <1>         ret
   908                              <1>         
   909                              <1> ; ------------------------------------------------------------------
   910                              <1> ; set_time_fmt -- Set time reporting format (eg '10:25 AM' or '2300 hours')
   911                              <1> ; IN: AL = format flag, 0 = 12-hr format
   912                              <1> 
   913                              <1> set_time_fmt:
   914 00001017 60                  <1> 	pusha
   915 00001018 3C00                <1> 	cmp al, 0
   916 0000101A 7402                <1> 	je .store
   917 0000101C B0FF                <1> 	mov al, 0x0FF
   918                              <1> .store:
   919 0000101E A2[C303]            <1> 	mov [fmt_12_24], al
   920 00001021 61                  <1> 	popa
   921 00001022 C3                  <1> 	ret
   922                              <1> 
   923                              <1> 
   924                              <1> ; ------------------------------------------------------------------
   925                              <1> ; get_time_string -- Get current time in a string (eg '10:25')
   926                              <1> ; OUT: BX = string location
   927                              <1> 
   928                              <1> get_time_string:
   929 00001023 60                  <1> 	pusha
   930                              <1> 
   931 00001024 89DF                <1> 	mov di, bx
   932                              <1> 
   933 00001026 F8                  <1> 	clc
   934 00001027 B402                <1> 	mov ah, 2
   935 00001029 CD1A                <1> 	int 0x1A
   936 0000102B 7305                <1> 	jnc .read
   937                              <1> 
   938 0000102D F8                  <1> 	clc
   939 0000102E B402                <1> 	mov ah, 2
   940 00001030 CD1A                <1> 	int 0x1A
   941                              <1> 
   942                              <1> .read:
   943 00001032 88E8                <1> 	mov al, ch
   944 00001034 E8460B              <1> 	call bcd_to_int
   945 00001037 89C2                <1> 	mov dx, ax
   946                              <1> 
   947 00001039 88E8                <1> 	mov al,	ch
   948 0000103B C0E804              <1> 	shr al, 4
   949 0000103E 80E50F              <1> 	and ch, 0x0F
   950 00001041 F606[C303]FF        <1> 	test byte [fmt_12_24], 0x0FF
   951 00001046 740A                <1> 	jz .twelve_hr
   952                              <1> 
   953 00001048 E86900              <1> 	call .add_digit
   954 0000104B 88E8                <1> 	mov al, ch
   955 0000104D E86400              <1> 	call .add_digit
   956 00001050 EB2F                <1> 	jmp short .minutes
   957                              <1> 
   958                              <1> .twelve_hr:
   959 00001052 83FA00              <1> 	cmp dx, 0
   960 00001055 741B                <1> 	je .midnight
   961                              <1> 
   962 00001057 83FA0A              <1> 	cmp dx, 10
   963 0000105A 7C1D                <1> 	jl .twelve_st1
   964                              <1> 
   965 0000105C 83FA0C              <1> 	cmp dx, 12
   966 0000105F 7E15                <1> 	jle .twelve_st2
   967                              <1> 
   968 00001061 89D0                <1> 	mov ax, dx
   969 00001063 83E80C              <1> 	sub ax, 12
   970 00001066 B30A                <1> 	mov bl, 10
   971 00001068 F6F3                <1> 	div bl
   972 0000106A 88E5                <1> 	mov ch, ah
   973                              <1> 
   974 0000106C 3C00                <1> 	cmp al, 0
   975 0000106E 7409                <1> 	je .twelve_st1
   976                              <1> 
   977 00001070 EB04                <1> 	jmp short .twelve_st2
   978                              <1> 
   979                              <1> .midnight:
   980 00001072 B001                <1> 	mov al, 1
   981 00001074 B502                <1> 	mov ch, 2
   982                              <1> 
   983                              <1> .twelve_st2:
   984 00001076 E83B00              <1> 	call .add_digit
   985                              <1> .twelve_st1:
   986 00001079 88E8                <1> 	mov al, ch
   987 0000107B E83600              <1> 	call .add_digit
   988                              <1> 
   989 0000107E B03A                <1> 	mov al, ':'
   990 00001080 AA                  <1> 	stosb
   991                              <1> 
   992                              <1> .minutes:
   993 00001081 88C8                <1> 	mov al, cl
   994 00001083 C0E804              <1> 	shr al, 4
   995 00001086 80E10F              <1> 	and cl, 0x0F
   996 00001089 E82800              <1> 	call .add_digit
   997 0000108C 88C8                <1> 	mov al, cl
   998 0000108E E82300              <1> 	call .add_digit
   999                              <1> 
  1000 00001091 B020                <1> 	mov al, ' '
  1001 00001093 AA                  <1> 	stosb
  1002                              <1> 
  1003 00001094 BE[B810]            <1> 	mov si, .hours_string
  1004 00001097 F606[C303]FF        <1> 	test byte [fmt_12_24], 0x0FF
  1005 0000109C 750B                <1> 	jnz .copy
  1006                              <1> 
  1007 0000109E BE[C110]            <1> 	mov si, .pm_string
  1008 000010A1 83FA0C              <1> 	cmp dx, 12
  1009 000010A4 7F03                <1> 	jg .copy
  1010                              <1> 
  1011 000010A6 BE[BE10]            <1> 	mov si, .am_string
  1012                              <1> 
  1013                              <1> .copy:
  1014 000010A9 80C301              <1>     add bl, 1
  1015 000010AC AC                  <1> 	lodsb
  1016 000010AD AA                  <1> 	stosb
  1017 000010AE 3C00                <1> 	cmp al, 0
  1018 000010B0 75F7                <1> 	jne .copy
  1019                              <1> 
  1020 000010B2 61                  <1> 	popa
  1021 000010B3 C3                  <1> 	ret
  1022                              <1> 
  1023                              <1> .add_digit:
  1024 000010B4 0430                <1> 	add al, '0'
  1025 000010B6 AA                  <1> 	stosb
  1026 000010B7 C3                  <1> 	ret
  1027                              <1> 
  1028                              <1> 
  1029 000010B8 686F75727300        <1> 	.hours_string	db 'hours', 0
  1030 000010BE 414D00              <1> 	.am_string 	db 'AM', 0
  1031 000010C1 504D00              <1> 	.pm_string 	db 'PM', 0
  1032                              <1> 
  1033                              <1> 
  1034                              <1> ; ------------------------------------------------------------------
  1035                              <1> ; set_date_fmt -- Set date reporting format (M/D/Y, D/M/Y or Y/M/D - 0, 1, 2)
  1036                              <1> ; IN: AX = format flag, 0-2
  1037                              <1> ; If AX bit 7 = 1 = use name for months
  1038                              <1> ; If AX bit 7 = 0, high byte = separator character
  1039                              <1> 
  1040                              <1> set_date_fmt:
  1041 000010C4 60                  <1> 	pusha
  1042 000010C5 A880                <1> 	test al, 0x80
  1043 000010C7 7505                <1> 	jnz .fmt_clear
  1044                              <1> 
  1045 000010C9 25037F              <1> 	and ax, 0x7F03
  1046 000010CC EB03                <1> 	jmp short .fmt_test
  1047                              <1> 
  1048                              <1> .fmt_clear:
  1049 000010CE 83E003              <1> 	and ax, 0003
  1050                              <1> 
  1051                              <1> .fmt_test:
  1052 000010D1 3C03                <1> 	cmp al, 3
  1053 000010D3 7303                <1> 	jae .leave
  1054 000010D5 A3[C403]            <1> 	mov [fmt_date], ax
  1055                              <1> 
  1056                              <1> .leave:
  1057 000010D8 61                  <1> 	popa
  1058 000010D9 C3                  <1> 	ret
  1059                              <1> 
  1060                              <1> 
  1061                              <1> ; ------------------------------------------------------------------
  1062                              <1> ; get_date_string -- Get current date in a string (eg '12/31/2007')
  1063                              <1> ; OUT: BX = string location
  1064                              <1> 
  1065                              <1> get_date_string:
  1066 000010DA 60                  <1> 	pusha
  1067                              <1> 
  1068 000010DB 89DF                <1> 	mov di, bx
  1069 000010DD 8B1E[C403]          <1> 	mov bx, [fmt_date]
  1070 000010E1 81E3037F            <1> 	and bx, 0x7F03
  1071                              <1> 
  1072 000010E5 F8                  <1> 	clc
  1073 000010E6 B404                <1> 	mov ah, 4
  1074 000010E8 CD1A                <1> 	int 0x1A
  1075 000010EA 7305                <1> 	jnc .read
  1076                              <1> 
  1077 000010EC F8                  <1> 	clc
  1078 000010ED B404                <1> 	mov ah, 4
  1079 000010EF CD1A                <1> 	int 0x1A
  1080                              <1> 
  1081                              <1> .read:
  1082 000010F1 80FB02              <1> 	cmp bl, 2
  1083 000010F4 751C                <1> 	jne .try_fmt1
  1084                              <1> 
  1085 000010F6 88EC                <1> 	mov ah, ch
  1086 000010F8 E8A000              <1> 	call .add_2digits
  1087 000010FB 88CC                <1> 	mov ah, cl
  1088 000010FD E89B00              <1> 	call .add_2digits
  1089 00001100 B02F                <1> 	mov al, '/'
  1090 00001102 AA                  <1> 	stosb
  1091                              <1> 
  1092 00001103 88F4                <1> 	mov ah, dh
  1093 00001105 E89300              <1> 	call .add_2digits
  1094 00001108 B02F                <1> 	mov al, '/'
  1095 0000110A AA                  <1> 	stosb
  1096                              <1> 
  1097 0000110B 88D4                <1> 	mov ah, dl
  1098 0000110D E88B00              <1> 	call .add_2digits
  1099 00001110 EB71                <1> 	jmp .done
  1100                              <1> 
  1101                              <1> .try_fmt1:
  1102 00001112 80FB01              <1> 	cmp bl, 1
  1103 00001115 7536                <1> 	jne .do_fmt0
  1104                              <1> 
  1105 00001117 88D4                <1> 	mov ah, dl
  1106 00001119 E86D00              <1> 	call .add_1or2digits
  1107                              <1> 
  1108 0000111C 88F8                <1> 	mov al, bh
  1109 0000111E 80FF00              <1> 	cmp bh, 0
  1110 00001121 7502                <1> 	jne .fmt1_day
  1111                              <1> 
  1112 00001123 B020                <1> 	mov al, ' '
  1113                              <1> 
  1114                              <1> .fmt1_day:
  1115 00001125 AA                  <1> 	stosb
  1116                              <1> 
  1117 00001126 88F4                <1> 	mov ah,	dh
  1118 00001128 80FF00              <1> 	cmp bh, 0
  1119 0000112B 7509                <1> 	jne .fmt1_month
  1120                              <1> 
  1121 0000112D E87F00              <1> 	call .add_month
  1122 00001130 B82C20              <1> 	mov ax, ', '
  1123 00001133 AB                  <1> 	stosw
  1124 00001134 EB06                <1> 	jmp short .fmt1_century
  1125                              <1> 
  1126                              <1> .fmt1_month:
  1127 00001136 E85000              <1> 	call .add_1or2digits
  1128 00001139 88F8                <1> 	mov al, bh
  1129 0000113B AA                  <1> 	stosb
  1130                              <1> 
  1131                              <1> .fmt1_century:
  1132 0000113C 88EC                <1> 	mov ah,	ch
  1133 0000113E 80FC00              <1> 	cmp ah, 0
  1134 00001141 7403                <1> 	je .fmt1_year
  1135                              <1> 
  1136 00001143 E84300              <1> 	call .add_1or2digits
  1137                              <1> 
  1138                              <1> .fmt1_year:
  1139 00001146 88CC                <1> 	mov ah, cl
  1140 00001148 E85000              <1> 	call .add_2digits
  1141                              <1> 
  1142 0000114B EB36                <1> 	jmp .done
  1143                              <1> 
  1144                              <1> .do_fmt0:
  1145 0000114D 88F4                <1> 	mov ah,	dh
  1146 0000114F 80FF00              <1> 	cmp bh, 0
  1147 00001152 7508                <1> 	jne .fmt0_month
  1148                              <1> 
  1149 00001154 E85800              <1> 	call .add_month
  1150 00001157 B020                <1> 	mov al, ' '
  1151 00001159 AA                  <1> 	stosb
  1152 0000115A EB06                <1> 	jmp short .fmt0_day
  1153                              <1> 
  1154                              <1> .fmt0_month:
  1155 0000115C E82A00              <1> 	call .add_1or2digits
  1156 0000115F 88F8                <1> 	mov al, bh
  1157 00001161 AA                  <1> 	stosb
  1158                              <1> 
  1159                              <1> .fmt0_day:
  1160 00001162 88D4                <1> 	mov ah, dl
  1161 00001164 E82200              <1> 	call .add_1or2digits
  1162                              <1> 
  1163 00001167 88F8                <1> 	mov al, bh
  1164 00001169 80FF00              <1> 	cmp bh, 0
  1165 0000116C 7505                <1> 	jne .fmt0_day2
  1166                              <1> 
  1167 0000116E B02C                <1> 	mov al, ','
  1168 00001170 AA                  <1> 	stosb
  1169 00001171 B020                <1> 	mov al, ' '
  1170                              <1> 
  1171                              <1> .fmt0_day2:
  1172 00001173 AA                  <1> 	stosb
  1173                              <1> 
  1174                              <1> .fmt0_century:
  1175 00001174 88EC                <1> 	mov ah,	ch
  1176 00001176 80FC00              <1> 	cmp ah, 0
  1177 00001179 7403                <1> 	je .fmt0_year
  1178                              <1> 
  1179 0000117B E80B00              <1> 	call .add_1or2digits
  1180                              <1> 
  1181                              <1> .fmt0_year:
  1182 0000117E 88CC                <1> 	mov ah, cl
  1183 00001180 E81800              <1> 	call .add_2digits
  1184                              <1> 
  1185                              <1> 
  1186                              <1> .done:
  1187 00001183 B80000              <1> 	mov ax, 0
  1188 00001186 AB                  <1> 	stosw
  1189                              <1> 
  1190 00001187 61                  <1> 	popa
  1191 00001188 C3                  <1> 	ret
  1192                              <1> 
  1193                              <1> 
  1194                              <1> .add_1or2digits:
  1195 00001189 F6C4F0              <1> 	test ah, 0x0F0
  1196 0000118C 7405                <1> 	jz .only_one
  1197 0000118E E80A00              <1> 	call .add_2digits
  1198 00001191 EB07                <1> 	jmp short .two_done
  1199                              <1> .only_one:
  1200 00001193 88E0                <1> 	mov al, ah
  1201 00001195 240F                <1> 	and al, 0x0F
  1202 00001197 E81100              <1> 	call .add_digit
  1203                              <1> .two_done:
  1204 0000119A C3                  <1> 	ret
  1205                              <1> 
  1206                              <1> .add_2digits:
  1207 0000119B 88E0                <1> 	mov al, ah
  1208 0000119D C0E804              <1> 	shr al, 4
  1209 000011A0 E80800              <1> 	call .add_digit
  1210 000011A3 88E0                <1> 	mov al, ah
  1211 000011A5 240F                <1> 	and al, 0x0F
  1212 000011A7 E80100              <1> 	call .add_digit
  1213 000011AA C3                  <1> 	ret
  1214                              <1> 
  1215                              <1> .add_digit:
  1216 000011AB 0430                <1> 	add al, '0'
  1217 000011AD AA                  <1> 	stosb
  1218 000011AE C3                  <1> 	ret
  1219                              <1> 
  1220                              <1> .add_month:
  1221 000011AF 53                  <1> 	push bx
  1222 000011B0 51                  <1> 	push cx
  1223 000011B1 88E0                <1> 	mov al, ah
  1224 000011B3 E8C709              <1> 	call bcd_to_int
  1225 000011B6 FEC8                <1> 	dec al
  1226 000011B8 B304                <1> 	mov bl, 4
  1227 000011BA F6E3                <1> 	mul bl
  1228 000011BC BE[D011]            <1> 	mov si, .months
  1229 000011BF 01C6                <1> 	add si, ax
  1230 000011C1 B90400              <1> 	mov cx, 4
  1231 000011C4 F3A4                <1> 	rep movsb
  1232 000011C6 807DFF20            <1> 	cmp byte [di-1], ' '
  1233 000011CA 7501                <1> 	jne .done_month
  1234 000011CC 4F                  <1> 	dec di
  1235                              <1> .done_month:
  1236 000011CD 59                  <1> 	pop cx
  1237 000011CE 5B                  <1> 	pop bx
  1238 000011CF C3                  <1> 	ret
  1239                              <1> 
  1240 000011D0 4A616E2E4665622E4D- <1> 	.months db 'Jan.Feb.Mar.Apr.May JuneJulyAug.SeptOct.Nov.Dec.'
  1240 000011D9 61722E4170722E4D61- <1>
  1240 000011E2 79204A756E654A756C- <1>
  1240 000011EB 794175672E53657074- <1>
  1240 000011F4 4F63742E4E6F762E44- <1>
  1240 000011FD 65632E              <1>
  1241                              <1> 
  1242                              <1> ; ------------------------------------------------------------------
  1243                              <1> ; string_tokenize -- Reads tokens separated by specified char from
  1244                              <1> ; a string. Returns pointer to next token, or 0 if none left
  1245                              <1> ; IN: AL = separator char, SI = beginning
  1246                              <1> ; OUT: DI = next token or 0 if none
  1247                              <1> 
  1248                              <1> string_tokenize:
  1249 00001200 56                  <1> 	push si
  1250                              <1> 
  1251                              <1>     .next_char:
  1252 00001201 3804                <1> 	    cmp byte [si], al
  1253 00001203 7408                <1> 	    je .return_token
  1254 00001205 803C00              <1> 	    cmp byte [si], 0
  1255 00001208 740B                <1> 	    jz .no_more
  1256 0000120A 46                  <1> 	    inc si
  1257 0000120B EBF4                <1> 	    jmp .next_char
  1258                              <1> 
  1259                              <1>     .return_token:
  1260 0000120D C60400              <1> 	    mov byte [si], 0
  1261 00001210 46                  <1> 	    inc si
  1262 00001211 89F7                <1> 	    mov di, si
  1263 00001213 5E                  <1> 	    pop si
  1264 00001214 C3                  <1> 	    ret
  1265                              <1> 
  1266                              <1>     .no_more:
  1267 00001215 BF0000              <1> 	    mov di, 0
  1268 00001218 5E                  <1> 	    pop si
  1269 00001219 C3                  <1> 	    ret
  1270                              <1> 
  1271                              <1> ; ------------------------------------------------------------------
  1272                              <1> ; string_clear -- Clears a variable
  1273                              <1> ; IN: DI  = variable, AX = length
  1274                              <1> ; OUT: empty variable
  1275                              <1> 
  1276                              <1> string_clear:
  1277 0000121A 60                  <1>     pusha
  1278 0000121B BBFFFF              <1>     mov bx, -1
  1279                              <1>     
  1280                              <1>     .loop:
  1281 0000121E 30C0                <1>         xor al, al
  1282 00001220 AA                  <1>         stosb
  1283                              <1>         
  1284 00001221 43                  <1>         inc bx
  1285                              <1> 
  1286 00001222 39D8                <1>         cmp ax, bx
  1287 00001224 75F8                <1>         jne .loop
  1288 00001226 61                  <1>         popa
  1289 00001227 C3                  <1>         ret
  1290                              <1> 
  1291                              <1> ; ==================================================================
   372                                      %include "./includes/screen.asm"
   373                              <1> ; ------------------------------------------------------------------
   374                              <1> ; show_cursor -- Turns on cursor in text mode
   375                              <1> ; IN/OUT: Nothing
   376                              <1> 
   377                              <1> show_cursor:
   378 00001228 60                  <1> 	pusha
   379                              <1> 
   380 00001229 B506                <1> 	mov ch, 6
   381 0000122B B107                <1> 	mov cl, 7
   382 0000122D B401                <1> 	mov ah, 1
   383 0000122F B003                <1> 	mov al, 3
   384 00001231 CD10                <1> 	int 10h
   385                              <1> 
   386 00001233 61                  <1> 	popa
   387 00001234 C3                  <1> 	ret
   388                              <1> 
   389                              <1> ; ------------------------------------------------------------------
   390                              <1> ; change_cursor -- Change the cursors look
   391                              <1> ; IN: CH = 0x00/0x06
   392                              <1> 
   393                              <1> change_cursor:
   394 00001235 60                  <1> 	pusha
   395                              <1> 
   396 00001236 B401                <1> 	mov ah, 0x01
   397 00001238 B107                <1> 	mov cl, 0x07
   398 0000123A CD10                <1> 	int 10h
   399                              <1> 
   400 0000123C 61                  <1> 	popa
   401 0000123D C3                  <1> 	ret
   402                              <1> 
   403                              <1> ; ------------------------------------------------------------------
   404                              <1> ; hide_cursor -- Turns off cursor in text mode
   405                              <1> ; IN/OUT: Nothing
   406                              <1> 
   407                              <1> hide_cursor:
   408 0000123E 60                  <1> 	pusha
   409                              <1> 
   410 0000123F B520                <1> 	mov ch, 32
   411 00001241 B401                <1> 	mov ah, 1
   412 00001243 B003                <1> 	mov al, 3
   413 00001245 CD10                <1> 	int 10h
   414                              <1> 
   415 00001247 61                  <1> 	popa
   416 00001248 C3                  <1> 	ret
   417                              <1> 
   418                              <1> ; ------------------------------------------------------------------
   419                              <1> ; move_cursor -- Moves cursor in text mode
   420                              <1> ; IN: DH, DL = row, column
   421                              <1> 
   422                              <1> move_cursor:
   423 00001249 60                  <1> 	pusha
   424                              <1> 
   425 0000124A B700                <1> 	mov bh, 0
   426 0000124C B402                <1> 	mov ah, 2
   427 0000124E CD10                <1> 	int 0x10
   428                              <1> 
   429 00001250 61                  <1> 	popa
   430 00001251 C3                  <1> 	ret
   431                              <1> 
   432                              <1> ; ------------------------------------------------------------------
   433                              <1> ; get_cursor_pos -- Return position of text cursor
   434                              <1> ; OUT: DH, DL = row, column
   435                              <1> 
   436                              <1> get_cursor_pos:
   437 00001252 60                  <1> 	pusha
   438                              <1> 
   439 00001253 B700                <1> 	mov bh, 0
   440 00001255 B403                <1> 	mov ah, 3
   441 00001257 CD10                <1> 	int 0x10
   442                              <1> 
   443 00001259 8916[6312]          <1> 	mov [.tmp], dx
   444 0000125D 61                  <1> 	popa
   445 0000125E 8B16[6312]          <1> 	mov dx, [.tmp]
   446 00001262 C3                  <1> 	ret
   447                              <1> 
   448 00001263 0000                <1> 	.tmp dw 0
   449                              <1> 
   450                              <1> ; ------------------------------------------------------------------
   451                              <1> ; print_horiz_line -- Draw a horizontal line on the screen
   452                              <1> ; IN: AX = line type (1 for double (=), otherwise single (-))
   453                              <1> 
   454                              <1> print_horiz_line:
   455 00001265 60                  <1> 	pusha
   456                              <1> 
   457 00001266 89C1                <1> 	mov cx, ax
   458 00001268 B0C4                <1> 	mov al, 196
   459                              <1> 
   460 0000126A 83F901              <1> 	cmp cx, 1
   461 0000126D 7502                <1> 	jne .ready
   462 0000126F B0CD                <1> 	mov al, 205
   463                              <1> 
   464                              <1> 	.ready:
   465 00001271 B90000              <1> 		mov cx, 0
   466 00001274 B40E                <1> 		mov ah, 0Eh
   467                              <1> 
   468                              <1> 	.restart:
   469 00001276 CD10                <1> 		int 0x10
   470 00001278 41                  <1> 		inc cx
   471 00001279 83F950              <1> 		cmp cx, 80
   472 0000127C 7402                <1> 		je .done
   473 0000127E EBF6                <1> 		jmp .restart
   474                              <1> 
   475                              <1> 	.done:
   476 00001280 61                  <1> 		popa
   477 00001281 C3                  <1> 		ret
   478                              <1> 
   479                              <1> ; ------------------------------------------------------------------
   480                              <1> ; input_dialog -- Get text string from user via a dialog box
   481                              <1> ; IN: AX = string location, BX = message to show, CX = max length
   482                              <1> ; OUT: AX = string location
   483                              <1> 
   484                              <1> input_dialog:
   485 00001282 60                  <1> 	pusha
   486                              <1> 
   487 00001283 50                  <1> 	push ax
   488 00001284 53                  <1> 	push bx
   489                              <1> 
   490 00001285 B60A                <1> 	mov dh, 10
   491 00001287 B20C                <1> 	mov dl, 12
   492                              <1> 
   493                              <1> .redbox:
   494 00001289 E8BDFF              <1> 	call move_cursor
   495                              <1> 
   496 0000128C 60                  <1> 	pusha
   497 0000128D B409                <1> 	mov ah, 09h
   498 0000128F B700                <1> 	mov bh, 0
   499 00001291 B93700              <1> 	mov cx, 55
   500 00001294 B31F                <1> 	mov bl, 0x1F
   501 00001296 B020                <1> 	mov al, ' '
   502 00001298 CD10                <1> 	int 0x10
   503 0000129A 61                  <1> 	popa
   504                              <1> 
   505 0000129B FEC6                <1> 	inc dh
   506 0000129D 80FE10              <1> 	cmp dh, 16
   507 000012A0 7402                <1> 	je .boxdone
   508 000012A2 EBE5                <1> 	jmp .redbox
   509                              <1> 
   510                              <1> 
   511                              <1> .boxdone:
   512 000012A4 B20E                <1> 	mov dl, 14
   513 000012A6 B60B                <1> 	mov dh, 11
   514 000012A8 E89EFF              <1> 	call move_cursor
   515                              <1> 
   516 000012AB 5B                  <1> 	pop bx
   517 000012AC 89DE                <1> 	mov si, bx
   518 000012AE E8F008              <1> 	call print
   519                              <1> 
   520 000012B1 B20E                <1> 	mov dl, 14
   521 000012B3 B60D                <1> 	mov dh, 13
   522 000012B5 E891FF              <1> 	call move_cursor
   523                              <1> 
   524 000012B8 58                  <1> 	pop ax
   525 000012B9 89CB                <1> 	mov bx, cx
   526 000012BB E89B01              <1> 	call input_string
   527                              <1> 
   528 000012BE 61                  <1> 	popa
   529 000012BF C3                  <1> 	ret
   530                              <1> 
   531                              <1> ; ------------------------------------------------------------------
   532                              <1> ; draw_block -- Render block of specified colour
   533                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
   534                              <1> 
   535                              <1> draw_block:
   536 000012C0 60                  <1> 	pusha
   537                              <1> 
   538                              <1> .more:
   539 000012C1 E885FF              <1> 	call move_cursor		; Move to block starting position
   540                              <1> 
   541 000012C4 B409                <1> 	mov ah, 09h			; Draw colour section
   542 000012C6 B700                <1> 	mov bh, 0
   543 000012C8 89F1                <1> 	mov cx, si
   544 000012CA B020                <1> 	mov al, ' '
   545 000012CC CD10                <1> 	int 10h
   546                              <1> 
   547 000012CE FEC6                <1> 	inc dh				; Get ready for next line
   548                              <1> 
   549 000012D0 B80000              <1> 	mov ax, 0
   550 000012D3 88F0                <1> 	mov al, dh			; Get current Y position into DL
   551 000012D5 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
   552 000012D7 75E8                <1> 	jne .more			; If not, keep drawing
   553                              <1> 
   554 000012D9 61                  <1> 	popa
   555 000012DA C3                  <1> 	ret
   556                              <1> 
   557                              <1> ; ------------------------------------------------------------------
   558                              <1> ; dialog_box -- Print dialog box in middle of screen, with button(s)
   559                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display)
   560                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
   561                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
   562                              <1> ; NOTE: Each string is limited to 40 characters
   563                              <1> 
   564                              <1> dialog_box:
   565 000012DB 60                  <1> 	pusha
   566                              <1> 
   567 000012DC 8916[5714]          <1> 	mov [.tmp], dx
   568                              <1> 
   569 000012E0 E85BFF              <1> 	call hide_cursor
   570                              <1> 
   571 000012E3 B609                <1> 	mov dh, 9			; First, draw blue background box
   572 000012E5 B213                <1> 	mov dl, 19
   573                              <1> 
   574                              <1> .redbox:				; Loop to draw all lines of box
   575 000012E7 E85FFF              <1> 	call move_cursor
   576                              <1> 
   577 000012EA 60                  <1> 	pusha
   578 000012EB B409                <1> 	mov ah, 0x09
   579 000012ED B700                <1> 	mov bh, 0
   580 000012EF B92A00              <1> 	mov cx, 42
   581 000012F2 B31F                <1> 	mov bl, 0x1F		; White on blue
   582 000012F4 B020                <1> 	mov al, ' '
   583 000012F6 CD10                <1> 	int 10h
   584 000012F8 61                  <1> 	popa
   585                              <1> 
   586 000012F9 FEC6                <1> 	inc dh
   587 000012FB 80FE10              <1> 	cmp dh, 16
   588 000012FE 7402                <1> 	je .boxdone
   589 00001300 EBE5                <1> 	jmp .redbox
   590                              <1> 
   591                              <1> 
   592                              <1> .boxdone:
   593 00001302 83F800              <1> 	cmp ax, 0			; Skip string params if zero
   594 00001305 740C                <1> 	je .no_first_string
   595 00001307 B214                <1> 	mov dl, 20
   596 00001309 B60A                <1> 	mov dh, 10
   597 0000130B E83BFF              <1> 	call move_cursor
   598                              <1> 
   599 0000130E 89C6                <1> 	mov si, ax			; First string
   600 00001310 E88E08              <1> 	call print
   601                              <1> 
   602                              <1> .no_first_string:
   603 00001313 83FB00              <1> 	cmp bx, 0
   604 00001316 740C                <1> 	je .no_second_string
   605 00001318 B214                <1> 	mov dl, 20
   606 0000131A B60B                <1> 	mov dh, 11
   607 0000131C E82AFF              <1> 	call move_cursor
   608                              <1> 
   609 0000131F 89DE                <1> 	mov si, bx			; Second string
   610 00001321 E87D08              <1> 	call print
   611                              <1> 
   612                              <1> .no_second_string:
   613 00001324 83F900              <1> 	cmp cx, 0
   614 00001327 740C                <1> 	je .no_third_string
   615 00001329 B214                <1> 	mov dl, 20
   616 0000132B B60C                <1> 	mov dh, 12
   617 0000132D E819FF              <1> 	call move_cursor
   618                              <1> 
   619 00001330 89CE                <1> 	mov si, cx			; Third string
   620 00001332 E86C08              <1> 	call print
   621                              <1> 
   622                              <1> .no_third_string:
   623 00001335 8B16[5714]          <1> 	mov dx, [.tmp]
   624 00001339 83FA00              <1> 	cmp dx, 0
   625 0000133C 7405                <1> 	je .one_button
   626 0000133E 83FA01              <1> 	cmp dx, 1
   627 00001341 741E                <1> 	je .two_button
   628                              <1> 
   629                              <1> 
   630                              <1> .one_button:
   631 00001343 B3F0                <1> 	mov bl, 11110000b		; Black on white
   632 00001345 B60E                <1> 	mov dh, 14
   633 00001347 B223                <1> 	mov dl, 35
   634 00001349 BE0800              <1> 	mov si, 8
   635 0000134C BF0F00              <1> 	mov di, 15
   636 0000134F E86EFF              <1> 	call draw_block
   637                              <1> 
   638 00001352 B226                <1> 	mov dl, 38			; OK button, centred at bottom of box
   639 00001354 B60E                <1> 	mov dh, 14
   640 00001356 E8F0FE              <1> 	call move_cursor
   641 00001359 BE[3714]            <1> 	mov si, .ok_button_string
   642 0000135C E84208              <1> 	call print
   643                              <1> 
   644 0000135F EB2E                <1> 	jmp .one_button_wait
   645                              <1> 
   646                              <1> 
   647                              <1> .two_button:
   648 00001361 B3F0                <1> 	mov bl, 11110000b		; Black on white
   649 00001363 B60E                <1> 	mov dh, 14
   650 00001365 B21B                <1> 	mov dl, 27
   651 00001367 BE0800              <1> 	mov si, 8
   652 0000136A BF0F00              <1> 	mov di, 15
   653 0000136D E850FF              <1> 	call draw_block
   654                              <1> 
   655 00001370 B21E                <1> 	mov dl, 30			; OK button
   656 00001372 B60E                <1> 	mov dh, 14
   657 00001374 E8D2FE              <1> 	call move_cursor
   658 00001377 BE[3714]            <1> 	mov si, .ok_button_string
   659 0000137A E82408              <1> 	call print
   660                              <1> 
   661 0000137D B22C                <1> 	mov dl, 44			; Cancel button
   662 0000137F B60E                <1> 	mov dh, 14
   663 00001381 E8C5FE              <1> 	call move_cursor
   664 00001384 BE[3A14]            <1> 	mov si, .cancel_button_string
   665 00001387 E81708              <1> 	call print
   666                              <1> 
   667 0000138A B90000              <1> 	mov cx, 0			; Default button = 0
   668 0000138D EB0D                <1> 	jmp .two_button_wait
   669                              <1> 
   670                              <1> 
   671                              <1> 
   672                              <1> .one_button_wait:
   673 0000138F B400                <1> 	mov ah, 0x00
   674 00001391 CD16                <1> 	int 0x16
   675                              <1> 
   676 00001393 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
   677 00001395 75F8                <1> 	jne .one_button_wait
   678                              <1> 
   679 00001397 E88EFE              <1> 	call show_cursor
   680                              <1> 
   681 0000139A 61                  <1> 	popa
   682 0000139B C3                  <1> 	ret
   683                              <1> 
   684                              <1> 
   685                              <1> .two_button_wait:
   686 0000139C B400                <1> 	mov ah, 0x00
   687 0000139E CD16                <1> 	int 0x16
   688                              <1> 	
   689 000013A0 80FC4B              <1> 	cmp ah, 0x4B			; Left cursor key pressed?
   690 000013A3 753D                <1> 	jne .noleft
   691                              <1> 
   692 000013A5 B3F0                <1> 	mov bl, 11110000b		; Black on white
   693 000013A7 B60E                <1> 	mov dh, 14
   694 000013A9 B21B                <1> 	mov dl, 27
   695 000013AB BE0800              <1> 	mov si, 8
   696 000013AE BF0F00              <1> 	mov di, 15
   697 000013B1 E80CFF              <1> 	call draw_block
   698                              <1> 
   699 000013B4 B21E                <1> 	mov dl, 30				; OK button
   700 000013B6 B60E                <1> 	mov dh, 14
   701 000013B8 E88EFE              <1> 	call move_cursor
   702 000013BB BE[3714]            <1> 	mov si, .ok_button_string
   703 000013BE E8E007              <1> 	call print
   704                              <1> 
   705 000013C1 B31F                <1> 	mov bl, 0x1F		; White on blue for cancel button
   706 000013C3 B60E                <1> 	mov dh, 14
   707 000013C5 B22A                <1> 	mov dl, 42
   708 000013C7 BE0900              <1> 	mov si, 9
   709 000013CA BF0F00              <1> 	mov di, 15
   710 000013CD E8F0FE              <1> 	call draw_block
   711                              <1> 
   712 000013D0 B22C                <1> 	mov dl, 44				; Cancel button
   713 000013D2 B60E                <1> 	mov dh, 14
   714 000013D4 E872FE              <1> 	call move_cursor
   715 000013D7 BE[3A14]            <1> 	mov si, .cancel_button_string
   716 000013DA E8C407              <1> 	call print
   717                              <1> 
   718 000013DD B90000              <1> 	mov cx, 0				; And update result we'll return
   719 000013E0 EBBA                <1> 	jmp .two_button_wait
   720                              <1> 
   721                              <1> 
   722                              <1> .noleft:
   723 000013E2 80FC4D              <1> 	cmp ah, 0x4D			; Right cursor key pressed?
   724 000013E5 753E                <1> 	jne .noright
   725                              <1> 
   726                              <1> 
   727 000013E7 B31F                <1> 	mov bl, 0x1F		; Black on white
   728 000013E9 B60E                <1> 	mov dh, 14
   729 000013EB B21B                <1> 	mov dl, 27
   730 000013ED BE0800              <1> 	mov si, 8
   731 000013F0 BF0F00              <1> 	mov di, 15
   732 000013F3 E8CAFE              <1> 	call draw_block
   733                              <1> 
   734 000013F6 B21E                <1> 	mov dl, 30				; OK button
   735 000013F8 B60E                <1> 	mov dh, 14
   736 000013FA E84CFE              <1> 	call move_cursor
   737 000013FD BE[3714]            <1> 	mov si, .ok_button_string
   738 00001400 E89E07              <1> 	call print
   739                              <1> 
   740 00001403 B3F0                <1> 	mov bl, 11110000b		; White on blue for cancel button
   741 00001405 B60E                <1> 	mov dh, 14
   742 00001407 B22B                <1> 	mov dl, 43
   743 00001409 BE0800              <1> 	mov si, 8
   744 0000140C BF0F00              <1> 	mov di, 15
   745 0000140F E8AEFE              <1> 	call draw_block
   746                              <1> 
   747 00001412 B22C                <1> 	mov dl, 44				; Cancel button
   748 00001414 B60E                <1> 	mov dh, 14
   749 00001416 E830FE              <1> 	call move_cursor
   750 00001419 BE[3A14]            <1> 	mov si, .cancel_button_string
   751 0000141C E88207              <1> 	call print
   752                              <1> 
   753 0000141F B90100              <1> 	mov cx, 1				; And update result we'll return
   754 00001422 E977FF              <1> 	jmp .two_button_wait
   755                              <1> 
   756                              <1> 
   757                              <1> .noright:
   758 00001425 3C0D                <1> 	cmp al, 13				; Wait for enter key (13) to be pressed
   759 00001427 0F8571FF            <1> 	jne .two_button_wait
   760                              <1> 
   761 0000142B E8FAFD              <1> 	call show_cursor
   762                              <1> 
   763 0000142E 890E[5714]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
   764 00001432 61                  <1> 	popa
   765 00001433 A1[5714]            <1> 	mov ax, [.tmp]
   766                              <1> 
   767 00001436 C3                  <1> 	ret
   768                              <1> 
   769                              <1> 
   770 00001437 4F4B00              <1> 	.ok_button_string	db 'OK', 0
   771 0000143A 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
   772 00001441 2020204F4B20202000  <1> 	.ok_button_noselect	db '   OK   ', 0
   773 0000144A 20202043616E63656C- <1> 	.cancel_button_noselect	db '   Cancel   ', 0
   773 00001453 20202000            <1>
   774                              <1> 
   775 00001457 0000                <1> 	.tmp dw 0
   776                              <1> 
   777                              <1> ; ------------------------------------------------------------------
   778                              <1> ; input_string --- Get a string from keyboard input
   779                              <1> ; IN: AX = output address, BX = maximum bytes of output string
   780                              <1> ; OUT: nothing
   781                              <1> 
   782                              <1> input_string:
   783 00001459 60                  <1> 	pusha
   784                              <1> 
   785                              <1> 	; If the character count is zero, don't do anything.
   786 0000145A 83FB00              <1> 	cmp bx, 0
   787 0000145D 7424                <1> 	je .done
   788                              <1> 
   789 0000145F 89C7                <1> 	mov di, ax			; DI = Current position in buffer
   790                              <1> 	
   791 00001461 4B                  <1> 	dec bx				; BX = Maximum characters in string
   792 00001462 89D9                <1> 	mov cx, bx			; CX = Remaining character count
   793                              <1> 
   794                              <1> .get_char:
   795 00001464 B400                <1> 	mov ah, 0x00
   796 00001466 CD16                <1> 	int 0x16
   797                              <1> 
   798 00001468 3C08                <1> 	cmp al, 8
   799 0000146A 7419                <1> 	je .backspace
   800                              <1> 
   801 0000146C 3C0D                <1> 	cmp al, 13			; The ENTER key ends the prompt
   802 0000146E 7410                <1> 	je .end_string
   803                              <1> 
   804                              <1> 	; Do not add any characters if the maximum size has been reached.
   805 00001470 E3F2                <1> 	jcxz .get_char
   806                              <1> 
   807                              <1> 	; Only add printable characters (ASCII Values 32-126)
   808 00001472 3C20                <1> 	cmp al, ' '
   809 00001474 72EE                <1> 	jb .get_char
   810                              <1> 
   811 00001476 3C7E                <1> 	cmp al, 126
   812 00001478 77EA                <1> 	ja .get_char
   813                              <1> 
   814 0000147A E83100              <1> 	call .add_char
   815                              <1> 
   816 0000147D 49                  <1> 	dec cx
   817 0000147E EBE4                <1> 	jmp .get_char
   818                              <1> 
   819                              <1> .end_string:
   820 00001480 B000                <1> 	mov al, 0
   821 00001482 AA                  <1> 	stosb
   822                              <1> 
   823                              <1> .done:
   824 00001483 61                  <1> 	popa
   825 00001484 C3                  <1> 	ret
   826                              <1> 
   827                              <1> .backspace:
   828                              <1> 	; Check if there are any characters to backspace
   829 00001485 39D9                <1> 	cmp cx, bx 
   830 00001487 73DB                <1> 	jae .get_char
   831                              <1> 
   832 00001489 41                  <1> 	inc cx				; Increase characters remaining
   833                              <1> 
   834 0000148A E80A00              <1> 	call .reverse_cursor		; Move back to the previous character
   835 0000148D B020                <1> 	mov al, ' '			; Print a space on the character
   836 0000148F E81C00              <1> 	call .add_char
   837 00001492 E80200              <1> 	call .reverse_cursor		; Now move the cursor back again
   838                              <1> 
   839 00001495 EBCD                <1> 	jmp .get_char
   840                              <1> 
   841                              <1> .reverse_cursor:
   842 00001497 4F                  <1> 	dec di				; Move the output pointer backwards
   843                              <1> 	
   844 00001498 E8B7FD              <1> 	call get_cursor_pos
   845 0000149B 80FA00              <1> 	cmp dl, 0			; Is the cursor at the start of line?
   846 0000149E 7406                <1> 	je .back_line
   847                              <1> 
   848 000014A0 FECA                <1> 	dec dl				; If not, just decrease the column
   849 000014A2 E8A4FD              <1> 	call move_cursor
   850 000014A5 C3                  <1> 	ret
   851                              <1> 
   852                              <1> .back_line:
   853 000014A6 FECE                <1> 	dec dh				; Otherwise, move the cursor to the end
   854 000014A8 B24F                <1> 	mov dl, 79			; of the previous line.
   855 000014AA E89CFD              <1> 	call move_cursor
   856 000014AD C3                  <1> 	ret
   857                              <1> 
   858                              <1> 
   859                              <1> .add_char:
   860 000014AE AA                  <1> 	stosb
   861 000014AF B40E                <1> 	mov ah, 0x0E			; Teletype Function
   862 000014B1 B700                <1> 	mov bh, 0			; Video Page 0
   863 000014B3 B30F                <1> 	mov bl, 0x0f
   864 000014B5 55                  <1> 	push bp				; Some BIOS's may mess up BP
   865 000014B6 CD10                <1> 	int 0x10
   866 000014B8 5D                  <1> 	pop bp
   867 000014B9 C3                  <1> 	ret
   868                              <1> 
   869                              <1> ; ------------------------------------------------------------------
   870                              <1> ; switch_mode -- Switch between VIDEO and CLI mode
   871                              <1> ; IN: AX = mode (0 for CLI and 1 for video)
   872                              <1> ;	  BH = color scheme (only background for video)
   873                              <1> ; OUT: Switches mode
   874                              <1> 
   875                              <1> switch_mode:
   876 000014BA 60                  <1> 	pusha
   877 000014BB 30DB                <1> 	xor bl, bl
   878                              <1> 
   879 000014BD 85C0                <1> 	test ax, ax
   880 000014BF 7405                <1> 	je .switch_cli
   881                              <1> 
   882 000014C1 83F801              <1> 	cmp ax, 1
   883 000014C4 740F                <1> 	je .switch_vid
   884                              <1> 
   885                              <1> .switch_cli:
   886                              <1> 	; Switch to text mode
   887 000014C6 B80300              <1> 	mov ax, cliRes
   888 000014C9 CD10                <1> 	int 0x10
   889                              <1> 
   890                              <1> 	; Change the cursor
   891 000014CB 31C9                <1> 	xor cx, cx
   892 000014CD E865FD              <1> 	call change_cursor
   893                              <1> 
   894                              <1> 	; Clear the screen and change color scheme
   895 000014D0 E812F9              <1> 	call cls
   896                              <1> 
   897 000014D3 EB0A                <1> 	jmp .done
   898                              <1> 
   899                              <1> .switch_vid:
   900                              <1> 	; Switch to video mode
   901 000014D5 B81300              <1> 	mov ax, vidRes
   902 000014D8 CD10                <1> 	int 0x10
   903                              <1> 
   904                              <1> 	; Clear the screen and change the background color
   905 000014DA E808F9              <1> 	call cls
   906                              <1> 
   907 000014DD EB00                <1> 	jmp .done
   908                              <1> 
   909                              <1> .done:
   910 000014DF 61                  <1> 	popa
   911 000014E0 C3                  <1> 	ret
   912                              <1> 
   913                              <1> ; ------------------------------------------------------------------
   914                              <1> ; setup_bottom_string -- Draw a string in the bottom of the setup screen
   915                              <1> ; IN: SI = String location
   916                              <1> 
   917                              <1> setup_bottom_string:
   918 000014E1 56                  <1> 	push si
   919 000014E2 B617                <1>     mov dh, 23
   920 000014E4 30D2                <1>     xor dl, dl
   921 000014E6 E860FD              <1>     call move_cursor
   922                              <1> 
   923 000014E9 B80100              <1>     mov ax, 1
   924 000014EC E876FD              <1>     call print_horiz_line
   925                              <1> 	
   926 000014EF 5E                  <1> 	pop si
   927 000014F0 E8AE06              <1>     call print
   928                              <1> 
   929 000014F3 31D2                <1>     xor dx, dx
   930 000014F5 E851FD              <1>     call move_cursor
   931                              <1> 
   932 000014F8 C3                  <1> 	ret
   933                              <1> 
   934                              <1> ; ------------------------------------------------------------------
   935                              <1> ; setup_input -- Get keyboard input for the setup
   936                              <1> ; IN: AX = string location
   937                              <1> ; OUT: AX = string location
   938                              <1> 
   939                              <1> setup_input:
   940 000014F9 60                  <1> 	pusha
   941 000014FA 89C7                <1> 	mov di, ax
   942 000014FC 50                  <1> 	push ax
   943                              <1> 
   944                              <1> 	; Position the mouse
   945 000014FD B403                <1> 	mov ah, 0x03
   946 000014FF B700                <1> 	mov bh, 0
   947 00001501 CD10                <1> 	int 0x10
   948                              <1> 
   949 00001503 B402                <1> 	mov ah, 0x02
   950 00001505 B21B                <1> 	mov dl, 27
   951 00001507 FEC6                <1> 	inc dh
   952 00001509 CD10                <1> 	int 0x10
   953                              <1> 
   954                              <1> 	; And draw the top/sides
   955 0000150B BE[B615]            <1> 	mov si, .top_bar
   956 0000150E E89006              <1> 	call print
   957                              <1> 
   958 00001511 B402                <1> 	mov ah, 0x02
   959 00001513 B21B                <1> 	mov dl, 27
   960 00001515 FEC6                <1> 	inc dh
   961 00001517 CD10                <1> 	int 0x10
   962                              <1> 	
   963 00001519 8836[F015]          <1> 	mov [.mouse_pos], dh
   964 0000151D BE[CF15]            <1> 	mov si, .sidl_bar
   965 00001520 E87E06              <1> 	call print
   966                              <1> 	
   967 00001523 B402                <1> 	mov ah, 0x02
   968 00001525 B21B                <1> 	mov dl, 27
   969 00001527 FEC6                <1> 	inc dh
   970 00001529 CD10                <1> 	int 0x10
   971                              <1> 
   972 0000152B BE[D615]            <1> 	mov si, .bot_bar
   973 0000152E E87006              <1> 	call print
   974                              <1> 
   975 00001531 B402                <1> 	mov ah, 0x02
   976 00001533 B21B                <1> 	mov dl, 27
   977 00001535 8A36[F015]          <1> 	mov dh, [.mouse_pos]
   978 00001539 CD10                <1> 	int 0x10
   979                              <1> 
   980 0000153B 30DB                <1> 	xor bl, bl
   981                              <1> 
   982                              <1> 	; Clear the string location
   983                              <1> .clear_loop:
   984 0000153D B000                <1> 	mov al, 0
   985 0000153F AA                  <1> 	stosb
   986 00001540 FEC3                <1> 	inc bl
   987                              <1> 
   988 00001542 80FB14              <1> 	cmp bl, 20
   989 00001545 75F6                <1> 	jne .clear_loop
   990                              <1> 
   991 00001547 B403                <1> 	mov ah, 0x03
   992 00001549 B700                <1> 	mov bh, 0
   993 0000154B CD10                <1> 	int 0x10
   994                              <1> 
   995 0000154D B402                <1> 	mov ah, 0x02
   996 0000154F B21D                <1> 	mov dl, 29
   997 00001551 CD10                <1> 	int 0x10
   998                              <1> 
   999 00001553 58                  <1> 	pop ax
  1000 00001554 89C7                <1> 	mov di, ax
  1001 00001556 30DB                <1> 	xor bl, bl
  1002                              <1> 
  1003                              <1> .input_loop:
  1004 00001558 B403                <1> 	mov ah, 0x03
  1005 0000155A B700                <1> 	mov bh, 0
  1006 0000155C CD10                <1> 	int 0x10
  1007                              <1> 
  1008 0000155E 8816[F015]          <1> 	mov [.mouse_pos], dl
  1009                              <1> 
  1010 00001562 B402                <1> 	mov ah, 0x02
  1011 00001564 B230                <1> 	mov dl, 48
  1012 00001566 CD10                <1> 	int 0x10
  1013                              <1> 
  1014 00001568 BE[D215]            <1> 	mov si, .sidr_bar
  1015 0000156B E83306              <1> 	call print
  1016                              <1> 
  1017 0000156E B402                <1> 	mov ah, 0x02
  1018 00001570 8A16[F015]          <1> 	mov dl, [.mouse_pos]
  1019 00001574 CD10                <1> 	int 0x10
  1020                              <1> 
  1021 00001576 B400                <1> 	mov ah, 0x00
  1022 00001578 CD16                <1> 	int 0x16
  1023                              <1> 
  1024 0000157A 3C0D                <1> 	cmp al, 0x0d
  1025 0000157C 7436                <1> 	je .input_done
  1026                              <1> 
  1027 0000157E 3C08                <1> 	cmp al, 0x08
  1028 00001580 7524                <1> 	jne .not_back
  1029                              <1> 
  1030                              <1> 	; Pressed backspace
  1031 00001582 B403                <1> 	mov ah, 0x03
  1032 00001584 B700                <1> 	mov bh, 0
  1033 00001586 CD10                <1> 	int 0x10
  1034                              <1> 
  1035 00001588 80FA1D              <1> 	cmp dl, 29
  1036 0000158B 74CB                <1> 	je .input_loop
  1037                              <1> 
  1038 0000158D FECA                <1> 	dec dl
  1039 0000158F FECB                <1> 	dec bl
  1040                              <1> 
  1041 00001591 B402                <1> 	mov ah, 0x02
  1042 00001593 CD10                <1> 	int 0x10
  1043                              <1> 
  1044 00001595 B40E                <1> 	mov ah, 0x0e
  1045 00001597 B000                <1> 	mov al, 0
  1046 00001599 CD10                <1> 	int 0x10
  1047                              <1> 	
  1048 0000159B B402                <1> 	mov ah, 0x02
  1049 0000159D CD10                <1> 	int 0x10
  1050                              <1> 
  1051 0000159F 4F                  <1> 	dec di
  1052 000015A0 B000                <1> 	mov al, 0
  1053 000015A2 AA                  <1> 	stosb
  1054 000015A3 4F                  <1> 	dec di
  1055                              <1> 
  1056 000015A4 EBB2                <1> 	jmp .input_loop
  1057                              <1> 
  1058                              <1> .not_back:
  1059 000015A6 80FB13              <1> 	cmp bl, 19
  1060 000015A9 74AD                <1> 	je .input_loop
  1061 000015AB FEC3                <1> 	inc bl
  1062                              <1> 
  1063 000015AD AA                  <1> 	stosb
  1064                              <1> 
  1065 000015AE B40E                <1> 	mov ah, 0x0e
  1066 000015B0 CD10                <1> 	int 0x10
  1067                              <1> 
  1068 000015B2 EBA4                <1> 	jmp .input_loop 
  1069                              <1> 
  1070                              <1> .input_done:
  1071 000015B4 61                  <1> 	popa
  1072 000015B5 C3                  <1> 	ret
  1073                              <1> 
  1074 000015B6 DA                  <1> .top_bar:	db 0xda
  1075 000015B7 C4<rep 15h>         <1> 			times 21 db 0xc4
  1076 000015CC BF0A00              <1> 			db 0xbf, 0x0a, 0
  1077 000015CF B32000              <1> .sidl_bar:	db 0xb3, 0x20, 0
  1078 000015D2 20B30A00            <1> .sidr_bar:	db 0x20, 0xb3, 0x0a, 0
  1079 000015D6 C0                  <1> .bot_bar:	db 0xc0
  1080 000015D7 C4<rep 15h>         <1> 			times 21 db 0xc4
  1081 000015EC D90A0D00            <1> 			db 0xd9, 0x0a, 0x0d, 0
  1082                              <1> 
  1083 000015F0 1D                  <1> .mouse_pos:	db 29
  1084                              <1> 
  1085                              <1> ; ------------------------------------------------------------------
  1086                              <1> ; setup_choose -- Draw text and use the cursors to choose between them
  1087                              <1> ; IN: AX, BX, CX = options
  1088                              <1> ;	  DH = not focused color
  1089                              <1> ;	  DL = focused color
  1090                              <1> ; OUT: AX = options choosen (starting at 0)
  1091                              <1> 
  1092                              <1> setup_choose:
  1093 000015F1 E84AFC              <1> 	call hide_cursor
  1094 000015F4 60                  <1> 	pusha
  1095 000015F5 52                  <1> 	push dx
  1096                              <1> 
  1097 000015F6 8A16[2917]          <1> 	mov dl, [.start_x]
  1098 000015FA 8A36[2A17]          <1> 	mov dh, [.start_y]
  1099 000015FE E848FC              <1> 	call move_cursor
  1100 00001601 5A                  <1> 	pop dx
  1101                              <1> 	
  1102 00001602 89C6                <1> 	mov si, ax
  1103 00001604 BF[2B17]            <1> 	mov di, .option1
  1104 00001607 E87AF8              <1> 	call string_copy
  1105                              <1> 	
  1106 0000160A 89DE                <1> 	mov si, bx
  1107 0000160C BF[5317]            <1> 	mov di, .option2
  1108 0000160F E872F8              <1> 	call string_copy
  1109                              <1> 
  1110 00001612 89CE                <1> 	mov si, cx
  1111 00001614 BF[7B17]            <1> 	mov di, .option3
  1112 00001617 E86AF8              <1> 	call string_copy
  1113                              <1> 
  1114 0000161A 31C9                <1> 	xor cx, cx
  1115 0000161C EB03                <1> 	jmp .choose_loop
  1116                              <1> 
  1117 0000161E E9F700              <1> 	jmp .done
  1118                              <1> 
  1119                              <1> .choose_loop:
  1120 00001621 E84100              <1> 	call .print_options
  1121 00001624 E80B00              <1> 	call .check_arrows
  1122 00001627 E8C800              <1> 	call .clear_bottom
  1123                              <1> 
  1124 0000162A 83F803              <1> 	cmp ax, 3
  1125 0000162D 75F2                <1> 	jne .choose_loop
  1126 0000162F E9E600              <1> 	jmp .done
  1127                              <1> 
  1128                              <1> .check_arrows:
  1129 00001632 60                  <1> 	pusha
  1130 00001633 BE[D00D]            <1>     mov si, setup_string
  1131 00001636 E8A8FE              <1>     call setup_bottom_string
  1132 00001639 61                  <1> 	popa
  1133                              <1> 
  1134 0000163A 31C0                <1> 	xor ax, ax
  1135 0000163C CD16                <1> 	int 0x16
  1136                              <1> 
  1137 0000163E 80FC48              <1> 	cmp ah, 0x48	; UP
  1138 00001641 740A                <1> 	je .up
  1139 00001643 80FC50              <1> 	cmp ah, 0x50	; DOWN
  1140 00001646 740F                <1> 	je .down
  1141                              <1> 
  1142 00001648 3C0D                <1> 	cmp al, 0x0D	; ENTER
  1143 0000164A 7415                <1> 	je .enter
  1144                              <1> 
  1145 0000164C C3                  <1> 	ret				; Failsafe return
  1146                              <1> 
  1147                              <1> 	.up:
  1148 0000164D 85C9                <1> 		test cx, cx
  1149 0000164F 7402                <1> 		jz .at_top
  1150                              <1> 
  1151 00001651 49                  <1> 		dec cx
  1152 00001652 C3                  <1> 		ret
  1153                              <1> 	
  1154                              <1> 		.at_top:
  1155 00001653 B90200              <1> 			mov cx, 2
  1156 00001656 C3                  <1> 			ret
  1157                              <1> 	
  1158                              <1> 	.down:
  1159 00001657 83F902              <1> 		cmp cx, 2
  1160 0000165A 7402                <1> 		je .at_bottom
  1161                              <1> 
  1162 0000165C 41                  <1> 		inc cx
  1163 0000165D C3                  <1> 		ret
  1164                              <1> 
  1165                              <1> 		.at_bottom:
  1166 0000165E 31C9                <1> 			xor cx, cx
  1167 00001660 C3                  <1> 			ret
  1168                              <1> 
  1169                              <1> 	.enter:
  1170 00001661 B80300              <1> 		mov ax, 3
  1171 00001664 C3                  <1> 		ret
  1172                              <1> 
  1173                              <1> .print_options:
  1174 00001665 83F900              <1> 	cmp cx, 0
  1175 00001668 740A                <1> 	je .mark_1
  1176                              <1> 
  1177 0000166A 83F901              <1> 	cmp cx, 1
  1178 0000166D 7419                <1> 	je .mark_2
  1179                              <1> 
  1180 0000166F 83F902              <1> 	cmp cx, 2
  1181 00001672 7428                <1> 	je .mark_3
  1182                              <1> 
  1183                              <1> 	.mark_1:
  1184 00001674 BE[2B17]            <1> 		mov si, .option1
  1185 00001677 E83F00              <1> 		call .print_marked
  1186                              <1> 
  1187 0000167A BE[5317]            <1> 		mov si, .option2
  1188 0000167D E82F00              <1> 		call .print_normal
  1189                              <1> 
  1190 00001680 BE[7B17]            <1> 		mov si, .option3
  1191 00001683 E82900              <1> 		call .print_normal
  1192                              <1> 
  1193 00001686 EB26                <1> 		jmp .mark_done
  1194                              <1> 	
  1195                              <1> 	.mark_2:
  1196 00001688 BE[2B17]            <1> 		mov si, .option1
  1197 0000168B E82100              <1> 		call .print_normal
  1198                              <1> 
  1199 0000168E BE[5317]            <1> 		mov si, .option2
  1200 00001691 E82500              <1> 		call .print_marked
  1201                              <1> 
  1202 00001694 BE[7B17]            <1> 		mov si, .option3
  1203 00001697 E81500              <1> 		call .print_normal
  1204                              <1> 
  1205 0000169A EB12                <1> 		jmp .mark_done
  1206                              <1> 	
  1207                              <1> 	.mark_3:
  1208 0000169C BE[2B17]            <1> 		mov si, .option1
  1209 0000169F E80D00              <1> 		call .print_normal
  1210                              <1> 
  1211 000016A2 BE[5317]            <1> 		mov si, .option2
  1212 000016A5 E80700              <1> 		call .print_normal
  1213                              <1> 
  1214 000016A8 BE[7B17]            <1> 		mov si, .option3
  1215 000016AB E80B00              <1> 		call .print_marked
  1216                              <1> 
  1217                              <1> 	.mark_done:
  1218 000016AE C3                  <1> 		ret
  1219                              <1> 
  1220                              <1> .print_normal:
  1221 000016AF E81700              <1> 	call .print_space
  1222 000016B2 E8EC04              <1> 	call print
  1223 000016B5 E82D00              <1> 	call .new_line
  1224                              <1> 
  1225 000016B8 C3                  <1> 	ret
  1226                              <1> 
  1227                              <1> .print_marked:
  1228 000016B9 53                  <1> 	push bx
  1229                              <1> 
  1230 000016BA E80C00              <1> 	call .print_space
  1231 000016BD 31DB                <1> 	xor bx, bx
  1232 000016BF 88D3                <1> 	mov bl, dl
  1233 000016C1 E81605              <1> 	call print_atr
  1234 000016C4 E81E00              <1> 	call .new_line
  1235                              <1> 
  1236 000016C7 5B                  <1> 	pop bx
  1237 000016C8 C3                  <1> 	ret
  1238                              <1> 
  1239                              <1> .print_space:
  1240 000016C9 53                  <1> 	push bx
  1241                              <1> 
  1242 000016CA 31DB                <1> 	xor bx, bx
  1243 000016CC BB2800              <1> 	mov bx, .screen_mid
  1244                              <1> 	
  1245 000016CF 89F0                <1> 	mov ax, si
  1246 000016D1 E827F7              <1> 	call string_length
  1247 000016D4 D1F8                <1> 	sar ax, 1
  1248                              <1> 
  1249 000016D6 29C3                <1> 	sub bx, ax
  1250                              <1> 
  1251                              <1> 	.space_loop:
  1252 000016D8 B40E                <1> 		mov ah, 0x0e
  1253 000016DA B020                <1> 		mov al, ' '
  1254 000016DC CD10                <1> 		int 0x10
  1255                              <1> 
  1256 000016DE 4B                  <1> 		dec bx
  1257 000016DF 85DB                <1> 		test bx, bx
  1258 000016E1 75F5                <1> 		jnz .space_loop
  1259                              <1> 
  1260 000016E3 5B                  <1> 	pop bx
  1261 000016E4 C3                  <1> 	ret
  1262                              <1> 
  1263                              <1> .new_line:
  1264 000016E5 50                  <1> 	push ax
  1265                              <1> 
  1266 000016E6 B80A0E              <1> 	mov ax, 0x0E0A
  1267 000016E9 CD10                <1> 	int 0x10
  1268 000016EB B80D0E              <1> 	mov ax, 0x0E0D
  1269 000016EE CD10                <1> 	int 0x10
  1270                              <1> 
  1271 000016F0 58                  <1> 	pop ax
  1272 000016F1 C3                  <1> 	ret
  1273                              <1> 
  1274                              <1> .clear_bottom:
  1275 000016F2 60                  <1> 	pusha
  1276                              <1> 
  1277 000016F3 8A36[2A17]          <1> 	mov dh, [.start_y]
  1278 000016F7 8A16[2917]          <1> 	mov dl, [.start_x]
  1279 000016FB E84BFB              <1> 	call move_cursor
  1280                              <1> 
  1281 000016FE B80A07              <1> 	mov ax, 0x070A
  1282 00001701 B71F                <1> 	mov bh, 0x1F
  1283 00001703 31C9                <1> 	xor cx, cx
  1284 00001705 BA4F18              <1> 	mov dx, 0x184f
  1285 00001708 CD10                <1> 	int 0x10
  1286                              <1> 	
  1287 0000170A B80A06              <1> 	mov ax, 0x060A
  1288 0000170D B71F                <1> 	mov bh, 0x1F
  1289 0000170F 31C9                <1> 	xor cx, cx
  1290 00001711 BA4F18              <1> 	mov dx, 0x184f
  1291 00001714 CD10                <1> 	int 0x10
  1292                              <1> 
  1293 00001716 61                  <1> 	popa
  1294 00001717 C3                  <1> 	ret
  1295                              <1> 
  1296                              <1> .done:
  1297 00001718 E8D7FF              <1> 	call .clear_bottom
  1298 0000171B 890E[A317]          <1> 	mov [.option_picked], cx
  1299                              <1> 
  1300 0000171F 61                  <1> 	popa
  1301 00001720 E805FB              <1> 	call show_cursor
  1302                              <1> 
  1303 00001723 0FB606[A317]        <1> 	movzx ax, [.option_picked]
  1304 00001728 C3                  <1> 	ret
  1305                              <1> 
  1306                              <1> .screen_mid		equ 40
  1307 00001729 00                  <1> .start_x:		db 0
  1308 0000172A 12                  <1> .start_y:		db 18
  1309                              <1> 
  1310 0000172B 00<rep 28h>         <1> .option1:		times 40 db 0
  1311 00001753 00<rep 28h>         <1> .option2:		times 40 db 0
  1312 0000177B 00<rep 28h>         <1> .option3:		times 40 db 0
  1313                              <1> 
  1314 000017A3 00                  <1> .option_picked:	db 0
  1315                              <1> 
  1316                              <1> ; ------------------------------------------------------------------
  1317                              <1> ; draw_setup_box -- Draw a text box for the setup
  1318                              <1> ; IN: SI = location of the string
  1319                              <1> ; OUT: prints a box that's meant for the setup
  1320                              <1> 
  1321                              <1> draw_setup_box:
  1322 000017A4 60                  <1> 	pusha
  1323 000017A5 30DB                <1> 	xor bl, bl
  1324                              <1> 
  1325 000017A7 31D2                <1> 	xor dx, dx
  1326 000017A9 E89DFA              <1> 	call move_cursor
  1327                              <1> 
  1328 000017AC 56                  <1> 	push si
  1329 000017AD BE[1018]            <1> 	mov si, .setbox_top
  1330 000017B0 E8EE03              <1> 	call print
  1331                              <1> 
  1332 000017B3 BE[9B18]            <1> 	mov si, .setbox_nwl
  1333 000017B6 E8E803              <1> 	call print
  1334                              <1> 
  1335 000017B9 5E                  <1> 	pop si
  1336                              <1> 
  1337                              <1> .print_loop:
  1338 000017BA AC                  <1> 	lodsb
  1339 000017BB 84C0                <1> 	test al, al
  1340 000017BD 7446                <1> 	je .done
  1341                              <1> 
  1342 000017BF 3C0A                <1> 	cmp al, 0x0a
  1343 000017C1 740D                <1> 	je .new_line
  1344                              <1> 
  1345 000017C3 80FB30              <1> 	cmp bl, 48
  1346 000017C6 7408                <1> 	je .new_line
  1347                              <1> 
  1348 000017C8 B40E                <1> 	mov ah, 0x0e
  1349 000017CA CD10                <1> 	int 0x10
  1350                              <1> 	
  1351 000017CC FEC3                <1> 	inc bl
  1352                              <1> 
  1353 000017CE EBEA                <1> 	jmp .print_loop
  1354                              <1> 
  1355                              <1> .new_line:
  1356 000017D0 E80A00              <1> 	call .finish_line
  1357                              <1> 
  1358 000017D3 56                  <1> 	push si
  1359 000017D4 BE[9B18]            <1> 	mov si, .setbox_nwl
  1360 000017D7 E8C703              <1> 	call print
  1361 000017DA 5E                  <1> 	pop si
  1362                              <1> 
  1363 000017DB EBDD                <1> 	jmp .print_loop
  1364                              <1> 
  1365                              <1> .finish_line:
  1366 000017DD B730                <1> 	mov bh, border_length-2
  1367 000017DF 28DF                <1> 	sub bh, bl
  1368                              <1> 
  1369                              <1> .finish_loop:
  1370 000017E1 80FF00              <1> 	cmp bh, 0
  1371 000017E4 760A                <1> 	jbe .loop_done
  1372                              <1> 
  1373 000017E6 B40E                <1> 	mov ah, 0x0e
  1374 000017E8 B020                <1> 	mov al, " "
  1375 000017EA CD10                <1> 	int 0x10
  1376 000017EC FECF                <1> 	dec bh
  1377                              <1> 
  1378 000017EE EBF1                <1> 	jmp .finish_loop
  1379                              <1> 
  1380                              <1> .loop_done:
  1381 000017F0 56                  <1> 	push si
  1382 000017F1 BE[AC18]            <1> 	mov si, .setbox_fnl
  1383 000017F4 E8AA03              <1> 	call print
  1384 000017F7 5E                  <1> 	pop si
  1385 000017F8 31DB                <1> 	xor bx, bx
  1386                              <1> 
  1387 000017FA B80A0E              <1> 	mov ax, 0x0e0a
  1388 000017FD CD10                <1> 	int 0x10
  1389                              <1> 
  1390 000017FF B80D0E              <1> 	mov ax, 0x0e0d
  1391 00001802 CD10                <1> 	int 0x10
  1392                              <1> 	
  1393 00001804 C3                  <1> 	ret
  1394                              <1> 
  1395                              <1> .done:
  1396 00001805 E8D5FF              <1> 	call .finish_line
  1397                              <1> 
  1398 00001808 BE[5618]            <1> 	mov si, .setbox_bot
  1399 0000180B E89303              <1> 	call print
  1400                              <1> 
  1401 0000180E 61                  <1> 	popa
  1402 0000180F C3                  <1> 	ret
  1403                              <1> 	
  1404                              <1> 
  1405 00001810 0A                  <1> .setbox_top:	db 0x0a
  1406 00001811 20<rep Eh>          <1>         		times edge_width db " "
  1407 0000181F DA                  <1>                 db 0xDA
  1408 00001820 C4<rep 32h>         <1>                 times border_length db 0xC4
  1409 00001852 BF0A0D00            <1>                 db 0xBF, 0x0a, 0x0d, 0
  1410                              <1> 
  1411 00001856 20<rep Eh>          <1> .setbox_bot:	times edge_width db " "
  1412 00001864 C0                  <1>                 db 0xC0
  1413 00001865 C4<rep 32h>         <1>                 times border_length db 0xC4
  1414 00001897 D90A0D00            <1>                 db 0xD9, 0x0a, 0x0d, 0
  1415                              <1> 
  1416 0000189B 20<rep Eh>          <1> .setbox_nwl:	times edge_width db " "
  1417 000018A9 B32000              <1> 				db 0xB3, " ", 0
  1418                              <1> 
  1419 000018AC 20B300              <1> .setbox_fnl:	db " ", 0xB3, 0
  1420                              <1> 
  1421                              <1> ; ------------------------------------------------------------------
  1422                              <1> ; draw_box -- Draw a box
  1423                              <1> ; IN: AL = color
  1424                              <1> ;	  BX = end x position
  1425                              <1> ;	  CX = end y position
  1426                              <1> ;	  DH = start x position
  1427                              <1> ;	  DL = start y position
  1428                              <1> ; OUT: Draws box
  1429                              <1> 
  1430                              <1> draw_box:
  1431 000018AF 60                  <1> 	pusha
  1432                              <1> 
  1433 000018B0 8836[E818]          <1> 	mov [.startx], dh
  1434 000018B4 8816[EA18]          <1> 	mov [.starty], dl
  1435 000018B8 891E[EC18]          <1> 	mov [.endx], bx
  1436 000018BC 890E[EE18]          <1> 	mov [.endy], cx
  1437                              <1> 
  1438 000018C0 8B0E[E818]          <1> 	mov cx, [.startx]
  1439 000018C4 8B16[EA18]          <1> 	mov dx, [.starty]
  1440 000018C8 B40C                <1> 	mov ah, 0x0C
  1441                              <1> 
  1442                              <1> 	.x_loop:
  1443 000018CA 3B0E[EC18]          <1> 		cmp cx, [.endx]
  1444 000018CE 7405                <1> 		je .y_loop
  1445                              <1> 
  1446 000018D0 CD10                <1> 		int 0x10
  1447                              <1> 
  1448 000018D2 41                  <1> 		inc cx
  1449 000018D3 EBF5                <1> 		jmp .x_loop
  1450                              <1> 
  1451                              <1> 	.y_loop:
  1452 000018D5 CD10                <1> 		int 0x10
  1453                              <1> 
  1454 000018D7 3B16[EE18]          <1> 		cmp dx, [.endy]
  1455 000018DB 7407                <1> 		je .done
  1456                              <1> 
  1457 000018DD 8B0E[E818]          <1> 		mov cx, [.startx]
  1458 000018E1 42                  <1> 		inc dx
  1459 000018E2 EBE6                <1> 		jmp .x_loop
  1460                              <1> 	
  1461                              <1> 	.done:
  1462 000018E4 61                  <1> 		popa
  1463 000018E5 C3                  <1> 		ret
  1464                              <1> 
  1465 000018E6 0000                <1> 	.tmp:    dw 0
  1466 000018E8 0000                <1> 	.startx: dw 0
  1467 000018EA 0000                <1> 	.starty: dw 0
  1468 000018EC 0000                <1> 	.endx:   dw 0
  1469 000018EE 0000                <1> 	.endy:	 dw 0
  1470                              <1> 
  1471                              <1> ; ------------------------------------------------------------------
  1472                              <1> ; list_dialog -- Show a dialog with a list of options
  1473                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1474                              <1> ;     BX = first help string, CX = second help string
  1475                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1476                              <1> 
  1477                              <1> list_dialog:
  1478 000018F0 60                  <1> 	pusha
  1479                              <1> 
  1480 000018F1 50                  <1> 	push ax				; Store string list for now
  1481                              <1> 
  1482 000018F2 51                  <1> 	push cx				; And help strings
  1483 000018F3 53                  <1> 	push bx
  1484                              <1> 
  1485 000018F4 E847F9              <1> 	call hide_cursor
  1486                              <1> 
  1487                              <1> 
  1488 000018F7 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1489 000018F9 89C6                <1> 	mov si, ax
  1490                              <1> .count_loop:
  1491 000018FB AC                  <1> 	lodsb
  1492 000018FC 3C00                <1> 	cmp al, 0
  1493 000018FE 7408                <1> 	je .done_count
  1494 00001900 3C2C                <1> 	cmp al, ','
  1495 00001902 75F7                <1> 	jne .count_loop
  1496 00001904 FEC1                <1> 	inc cl
  1497 00001906 EBF3                <1> 	jmp .count_loop
  1498                              <1> 
  1499                              <1> .done_count:
  1500 00001908 FEC1                <1> 	inc cl
  1501 0000190A 880E[631A]          <1> 	mov byte [.num_of_entries], cl
  1502                              <1> 
  1503 0000190E B39F                <1> 	mov bl, 0x9F		; White on light blue
  1504 00001910 B20F                <1> 	mov dl, 15			; Start X position
  1505 00001912 B602                <1> 	mov dh, 2			; Start Y position
  1506 00001914 BE3200              <1> 	mov si, 50			; Width
  1507 00001917 BF1700              <1> 	mov di, 23			; Finish Y position
  1508 0000191A E8A3F9              <1> 	call draw_block		; Draw option selector window
  1509                              <1> 
  1510 0000191D B210                <1> 	mov dl, 16			; Show first line of help text...
  1511 0000191F B603                <1> 	mov dh, 3
  1512 00001921 E825F9              <1> 	call move_cursor
  1513                              <1> 
  1514 00001924 5E                  <1> 	pop si				; Get back first string
  1515 00001925 E87902              <1> 	call print
  1516                              <1> 
  1517 00001928 FEC6                <1> 	inc dh				; ...and the second
  1518 0000192A E81CF9              <1> 	call move_cursor
  1519                              <1> 
  1520 0000192D 5E                  <1> 	pop si
  1521 0000192E E87002              <1> 	call print
  1522                              <1> 
  1523                              <1> 
  1524 00001931 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1525 00001932 8936[651A]          <1> 	mov word [.list_string], si
  1526                              <1> 
  1527                              <1> 
  1528                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1529                              <1> 	; entry and let the user move up and down using the cursor keys
  1530                              <1> 
  1531 00001936 C606[641A]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1532                              <1> 
  1533 0000193B B214                <1> 	mov dl, 20			; Set up starting position for selector
  1534 0000193D B607                <1> 	mov dh, 7
  1535                              <1> 
  1536 0000193F E807F9              <1> 	call move_cursor
  1537                              <1> 
  1538                              <1> .more_select:
  1539 00001942 60                  <1> 	pusha
  1540 00001943 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1541 00001945 B210                <1> 	mov dl, 16
  1542 00001947 B606                <1> 	mov dh, 6
  1543 00001949 BE3000              <1> 	mov si, 48
  1544 0000194C BF1600              <1> 	mov di, 22
  1545 0000194F E86EF9              <1> 	call draw_block
  1546 00001952 61                  <1> 	popa
  1547                              <1> 
  1548 00001953 E8E100              <1> 	call .draw_black_bar
  1549                              <1> 
  1550 00001956 8B36[651A]          <1> 	mov word si, [.list_string]
  1551 0000195A E89A00              <1> 	call .draw_list
  1552                              <1> 
  1553                              <1> .another_key:
  1554 0000195D B400                <1> 	mov ah, 0x00
  1555 0000195F CD16                <1> 	int 0x16
  1556                              <1> 
  1557 00001961 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1558 00001964 740F                <1> 	je .go_up
  1559 00001966 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1560 00001969 741B                <1> 	je .go_down
  1561 0000196B 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1562 0000196D 7468                <1> 	je .option_selected
  1563 0000196F 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1564 00001971 747E                <1> 	je .esc_pressed
  1565 00001973 EBCD                <1> 	jmp .more_select		; If not, wait for another key
  1566                              <1> 
  1567                              <1> 
  1568                              <1> .go_up:
  1569 00001975 80FE07              <1> 	cmp dh, 7			; Already at top?
  1570 00001978 7E32                <1> 	jle .hit_top
  1571                              <1> 
  1572 0000197A E8CF00              <1> 	call .draw_white_bar
  1573                              <1> 
  1574 0000197D B219                <1> 	mov dl, 25
  1575 0000197F E8C7F8              <1> 	call move_cursor
  1576                              <1> 
  1577 00001982 FECE                <1> 	dec dh				; Row to select (increasing down)
  1578 00001984 EBBC                <1> 	jmp .more_select
  1579                              <1> 
  1580                              <1> 
  1581                              <1> .go_down:				; Already at bottom of list?
  1582 00001986 80FE14              <1> 	cmp dh, 20
  1583 00001989 7430                <1> 	je .hit_bottom
  1584                              <1> 
  1585 0000198B B90000              <1> 	mov cx, 0
  1586 0000198E 88F1                <1> 	mov byte cl, dh
  1587                              <1> 
  1588 00001990 80E907              <1> 	sub cl, 7
  1589 00001993 FEC1                <1> 	inc cl
  1590 00001995 020E[641A]          <1> 	add byte cl, [.skip_num]
  1591                              <1> 
  1592 00001999 A0[631A]            <1> 	mov byte al, [.num_of_entries]
  1593 0000199C 38C1                <1> 	cmp cl, al
  1594 0000199E 74BD                <1> 	je .another_key
  1595                              <1> 
  1596 000019A0 E8A900              <1> 	call .draw_white_bar
  1597                              <1> 
  1598 000019A3 B219                <1> 	mov dl, 25
  1599 000019A5 E8A1F8              <1> 	call move_cursor
  1600                              <1> 
  1601 000019A8 FEC6                <1> 	inc dh
  1602 000019AA EB96                <1> 	jmp .more_select
  1603                              <1> 
  1604                              <1> 
  1605                              <1> .hit_top:
  1606 000019AC 8A0E[641A]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1607 000019B0 80F900              <1> 	cmp cl, 0
  1608 000019B3 74A8                <1> 	je .another_key			; If not, wait for another key
  1609                              <1> 
  1610 000019B5 FE0E[641A]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1611 000019B9 EB87                <1> 	jmp .more_select
  1612                              <1> 
  1613                              <1> 
  1614                              <1> .hit_bottom:				; See if there's more to scroll
  1615 000019BB B90000              <1> 	mov cx, 0
  1616 000019BE 88F1                <1> 	mov byte cl, dh
  1617                              <1> 
  1618 000019C0 80E907              <1> 	sub cl, 7
  1619 000019C3 FEC1                <1> 	inc cl
  1620 000019C5 020E[641A]          <1> 	add byte cl, [.skip_num]
  1621                              <1> 
  1622 000019C9 A0[631A]            <1> 	mov byte al, [.num_of_entries]
  1623 000019CC 38C1                <1> 	cmp cl, al
  1624 000019CE 748D                <1> 	je .another_key
  1625                              <1> 
  1626 000019D0 FE06[641A]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1627 000019D4 E96BFF              <1> 	jmp .more_select
  1628                              <1> 
  1629                              <1> 
  1630                              <1> 
  1631                              <1> .option_selected:
  1632 000019D7 E84EF8              <1> 	call show_cursor
  1633                              <1> 
  1634 000019DA 80EE07              <1> 	sub dh, 7
  1635                              <1> 
  1636 000019DD B80000              <1> 	mov ax, 0
  1637 000019E0 88F0                <1> 	mov al, dh
  1638                              <1> 
  1639 000019E2 FEC0                <1> 	inc al				; Options start from 1
  1640 000019E4 0206[641A]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1641                              <1> 
  1642 000019E8 A3[611A]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1643                              <1> 
  1644 000019EB 61                  <1> 	popa
  1645                              <1> 
  1646 000019EC A1[611A]            <1> 	mov word ax, [.tmp]
  1647 000019EF F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1648 000019F0 C3                  <1> 	ret
  1649                              <1> 
  1650                              <1> 
  1651                              <1> 
  1652                              <1> .esc_pressed:
  1653 000019F1 E834F8              <1> 	call show_cursor
  1654 000019F4 61                  <1> 	popa
  1655 000019F5 F9                  <1> 	stc				; Set carry for Esc
  1656 000019F6 C3                  <1> 	ret
  1657                              <1> 
  1658                              <1> 
  1659                              <1> 
  1660                              <1> .draw_list:
  1661 000019F7 60                  <1> 	pusha
  1662                              <1> 
  1663 000019F8 B212                <1> 	mov dl, 18			; Get into position for option list text
  1664 000019FA B607                <1> 	mov dh, 7
  1665 000019FC E84AF8              <1> 	call move_cursor
  1666                              <1> 
  1667                              <1> 
  1668 000019FF B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  1669 00001A02 8A0E[641A]          <1> 	mov byte cl, [.skip_num]
  1670                              <1> 
  1671                              <1> .skip_loop:
  1672 00001A06 83F900              <1> 	cmp cx, 0
  1673 00001A09 7408                <1> 	je .skip_loop_finished
  1674                              <1> .more_lodsb:
  1675 00001A0B AC                  <1> 	lodsb
  1676 00001A0C 3C2C                <1> 	cmp al, ','
  1677 00001A0E 75FB                <1> 	jne .more_lodsb
  1678 00001A10 49                  <1> 	dec cx
  1679 00001A11 EBF3                <1> 	jmp .skip_loop
  1680                              <1> 
  1681                              <1> 
  1682                              <1> .skip_loop_finished:
  1683 00001A13 BB0000              <1> 	mov bx, 0			; Counter for total number of options
  1684                              <1> 
  1685                              <1> 
  1686                              <1> .more:
  1687 00001A16 AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  1688                              <1> 
  1689 00001A17 3C00                <1> 	cmp al, 0			; End of string?
  1690 00001A19 7417                <1> 	je .done_list
  1691                              <1> 
  1692 00001A1B 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1693 00001A1D 7406                <1> 	je .newline
  1694                              <1> 
  1695 00001A1F B40E                <1> 	mov ah, 0Eh
  1696 00001A21 CD10                <1> 	int 10h
  1697 00001A23 EBF1                <1> 	jmp .more
  1698                              <1> 
  1699                              <1> .newline:
  1700 00001A25 B212                <1> 	mov dl, 18			; Go back to starting X position
  1701 00001A27 FEC6                <1> 	inc dh				; But jump down a line
  1702 00001A29 E81DF8              <1> 	call move_cursor
  1703                              <1> 
  1704 00001A2C 43                  <1> 	inc bx				; Update the number-of-options counter
  1705 00001A2D 83FB0E              <1> 	cmp bx, 14			; Limit to one screen of options
  1706 00001A30 7CE4                <1> 	jl .more
  1707                              <1> 
  1708                              <1> .done_list:
  1709 00001A32 61                  <1> 	popa
  1710 00001A33 E813F8              <1> 	call move_cursor
  1711                              <1> 
  1712 00001A36 C3                  <1> 	ret
  1713                              <1> 
  1714                              <1> 
  1715                              <1> 
  1716                              <1> .draw_black_bar:
  1717 00001A37 60                  <1> 	pusha
  1718                              <1> 
  1719 00001A38 B211                <1> 	mov dl, 17
  1720 00001A3A E80CF8              <1> 	call move_cursor
  1721                              <1> 
  1722 00001A3D B409                <1> 	mov ah, 09h			; Draw white bar at top
  1723 00001A3F B700                <1> 	mov bh, 0
  1724 00001A41 B92E00              <1> 	mov cx, 46
  1725 00001A44 B30F                <1> 	mov bl, 00001111b		; White text on black background
  1726 00001A46 B020                <1> 	mov al, ' '
  1727 00001A48 CD10                <1> 	int 10h
  1728                              <1> 
  1729 00001A4A 61                  <1> 	popa
  1730 00001A4B C3                  <1> 	ret
  1731                              <1> 
  1732                              <1> 
  1733                              <1> 
  1734                              <1> .draw_white_bar:
  1735 00001A4C 60                  <1> 	pusha
  1736                              <1> 
  1737 00001A4D B211                <1> 	mov dl, 17
  1738 00001A4F E8F7F7              <1> 	call move_cursor
  1739                              <1> 
  1740 00001A52 B409                <1> 	mov ah, 09h			; Draw white bar at top
  1741 00001A54 B700                <1> 	mov bh, 0
  1742 00001A56 B92E00              <1> 	mov cx, 46
  1743 00001A59 B3F0                <1> 	mov bl, 11110000b		; Black text on white background
  1744 00001A5B B020                <1> 	mov al, ' '
  1745 00001A5D CD10                <1> 	int 10h
  1746                              <1> 
  1747 00001A5F 61                  <1> 	popa
  1748 00001A60 C3                  <1> 	ret
  1749                              <1> 
  1750                              <1> 
  1751 00001A61 0000                <1> 	.tmp			dw 0
  1752 00001A63 00                  <1> 	.num_of_entries		db 0
  1753 00001A64 00                  <1> 	.skip_num		db 0
  1754 00001A65 0000                <1> 	.list_string		dw 0
   373                                      %include "./includes/misc.asm"
   374                              <1> ; get_api_version -- Return current version of KronkOS API
   375                              <1> ; OUT: AL = API version number
   376                              <1> 
   377                              <1> get_api_version:
   378 00001A67 B004                <1> 	mov al, KRONKOS_API
   379 00001A69 C3                  <1> 	ret
   380                              <1> 
   381                              <1> ; ------------------------------------------------------------------
   382                              <1> ; clear_regs -- Clear all the registers
   383                              <1> 
   384                              <1> clear_regs:
   385 00001A6A 31C0                <1> 	xor ax, ax
   386 00001A6C 31DB                <1> 	xor bx, bx
   387 00001A6E 31C9                <1> 	xor cx, cx
   388 00001A70 31D2                <1> 	xor dx, dx
   389 00001A72 31F6                <1> 	xor si, si
   390 00001A74 31FF                <1> 	xor di, di
   391                              <1> 	
   392 00001A76 C3                  <1> 	ret
   393                              <1> 
   394                              <1> ; ------------------------------------------------------------------
   395                              <1> ; fatal_error -- Display error message and halt execution
   396                              <1> ; IN: AX = error message string location
   397                              <1> 
   398                              <1> fatal_error:
   399 00001A77 89C3                <1> 	mov bx, ax			; Store string location for now
   400                              <1> 
   401 00001A79 B600                <1> 	mov dh, 0
   402 00001A7B B200                <1> 	mov dl, 0
   403 00001A7D E8C9F7              <1> 	call move_cursor
   404                              <1> 
   405 00001A80 60                  <1> 	pusha
   406 00001A81 B409                <1> 	mov ah, 0x09		; Draw red bar at top
   407 00001A83 B700                <1> 	mov bh, 0
   408 00001A85 B9F000              <1> 	mov cx, 240
   409 00001A88 B34F                <1> 	mov bl, 01001111b
   410 00001A8A B020                <1> 	mov al, ' '
   411 00001A8C CD10                <1> 	int 10h
   412 00001A8E 61                  <1> 	popa
   413                              <1> 
   414 00001A8F B600                <1> 	mov dh, 0
   415 00001A91 B200                <1> 	mov dl, 0
   416 00001A93 E8B3F7              <1> 	call move_cursor
   417                              <1> 
   418 00001A96 BE[A31A]            <1> 	mov si, .msg_inform		; Inform of fatal error
   419 00001A99 E80501              <1> 	call print
   420                              <1> 
   421 00001A9C 89DE                <1> 	mov si, bx			; Program-supplied error message
   422 00001A9E E80001              <1> 	call print
   423                              <1> 
   424 00001AA1 EBFE                <1> 	jmp $				; Halt execution
   425                              <1> 
   426                              <1> 	
   427 00001AA3 464154414C204F5045- <1> 	.msg_inform		db 'FATAL OPERATING SYSTEM ERROR!', 0x0d, 0x0a, 0
   427 00001AAC 524154494E47205359- <1>
   427 00001AB5 5354454D204552524F- <1>
   427 00001ABE 52210D0A00          <1>
   428                              <1> 
   429                              <1> ; ------------------------------------------------------------------
   430                              <1> ; bios_wait -- Wait
   431                              <1> ; IN: CX:DX time
   432                              <1> 
   433                              <1> bios_wait:
   434 00001AC3 B80086              <1> 	mov ax, 0x8600
   435 00001AC6 CD15                <1>     int 0x15
   436 00001AC8 C3                  <1>     ret
   374                                      %include "./includes/input.asm"
   375                              <1> get_input:
   376 00001AC9 60                  <1>     pusha
   377 00001ACA B200                <1>     mov dl, 0
   378 00001ACC BE[B601]            <1>     mov si, in_buffer
   379                              <1> 
   380                              <1>     ; Clear the input buffer for use
   381                              <1>     .clear_loop:
   382 00001ACF C60400              <1>         mov byte [si], 0
   383                              <1> 
   384 00001AD2 46                  <1>         inc si
   385 00001AD3 FEC2                <1>         inc dl
   386                              <1> 
   387 00001AD5 80FA1E              <1>         cmp dl, 30
   388 00001AD8 75F5                <1>         jne .clear_loop
   389                              <1> 
   390 00001ADA BE[B601]            <1>     mov si, in_buffer
   391 00001ADD 30DB                <1>     xor bl, bl ; Used for checking the length of the buffer
   392                              <1> 
   393                              <1> ; The actual loop
   394                              <1> .input_loop:
   395 00001ADF B400                <1>     mov ah, 0x00
   396 00001AE1 CD16                <1>     int 0x16
   397                              <1> 
   398                              <1>     ; Check if the user pressed enter
   399 00001AE3 3C0D                <1>     cmp al, 0x0d
   400 00001AE5 7442                <1>     je .input_done
   401                              <1> 
   402                              <1>     ; Check if the user pressed backspace
   403 00001AE7 3C08                <1>     cmp al, 0x08
   404 00001AE9 7524                <1>     jne .not_back
   405                              <1> 
   406                              <1>     ; ******************************
   407                              <1>     ; The user pressed backspace!
   408                              <1> 
   409                              <1>     ; Get current cursor position
   410 00001AEB B403                <1>     mov ah, 0x03
   411 00001AED B700                <1>     mov bh, 0
   412 00001AEF CD10                <1>     int 0x10
   413                              <1> 
   414 00001AF1 80FA03              <1>     cmp dl, 3 ; 3 = backspace limit
   415 00001AF4 74E9                <1>     je .input_loop
   416                              <1> 
   417 00001AF6 FECA                <1>     dec dl
   418 00001AF8 FECB                <1>     dec bl
   419                              <1> 
   420                              <1>     ; Move one back
   421 00001AFA B402                <1>     mov ah, 0x02
   422 00001AFC CD10                <1>     int 0x10
   423                              <1> 
   424 00001AFE B40E                <1>     mov ah, 0x0e
   425 00001B00 B000                <1>     mov al, 0
   426 00001B02 CD10                <1>     int 0x10
   427                              <1> 
   428 00001B04 B402                <1>     mov ah, 0x02
   429 00001B06 CD10                <1>     int 0x10
   430                              <1> 
   431                              <1>     ; Remove the last character from the input buffer
   432 00001B08 4E                  <1>     dec si
   433 00001B09 B000                <1>     mov al, 0
   434 00001B0B 8804                <1>     mov [si], al
   435                              <1> 
   436 00001B0D EBD0                <1>     jmp .input_loop
   437                              <1>     
   438                              <1>     ; ******************************
   439                              <1> 
   440                              <1>     ; Show the pressed character and save it to the input buffer
   441                              <1>     .not_back:
   442 00001B0F 80FB28              <1>         cmp bl, 40
   443 00001B12 74CB                <1>         je .input_loop
   444 00001B14 FEC3                <1>         inc bl
   445                              <1> 
   446 00001B16 8804                <1>         mov [si], al
   447 00001B18 46                  <1>         inc si
   448                              <1> 
   449 00001B19 B40E                <1>         mov ah, 0x0e
   450 00001B1B 3C61                <1>         cmp al, 'a'
   451 00001B1D 7206                <1>         jb .noatoz
   452 00001B1F 3C7A                <1>         cmp al, 'z'
   453 00001B21 7702                <1>         ja .noatoz
   454                              <1>         
   455 00001B23 24DF                <1>         and al, 0xdf
   456                              <1>         .noatoz:
   457 00001B25 CD10                <1>         int 0x10
   458                              <1> 
   459 00001B27 EBB6                <1>         jmp .input_loop
   460                              <1> 
   461                              <1>     ; Return the cursor to the start and return
   462                              <1>     .input_done:
   463 00001B29 B8[B601]            <1>         mov ax, in_buffer
   464 00001B2C E838F3              <1>         call string_lowercase
   465                              <1> 
   466 00001B2F B40E                <1>         mov ah, 0x0e
   467 00001B31 B00D                <1>         mov al, 0x0d
   468 00001B33 CD10                <1>         int 0x10
   469                              <1> 
   470 00001B35 61                  <1>         popa
   471 00001B36 C3                  <1>         ret
   375                                      %include "./includes/math.asm"
   376                              <1> ; ==================================================================
   377                              <1> ; KronkOS -- The Kronk Operating System kernel
   378                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   379                              <1> ;
   380                              <1> ; MATH ROUTINES
   381                              <1> ; ==================================================================
   382                              <1> 
   383                              <1> ; ------------------------------------------------------------------
   384                              <1> ; seed_random -- Seed the random number generator based on clock
   385                              <1> 
   386                              <1> seed_random:
   387 00001B37 53                  <1> 	push bx
   388 00001B38 50                  <1> 	push ax
   389                              <1> 
   390 00001B39 BB0000              <1> 	mov bx, 0
   391 00001B3C B002                <1> 	mov al, 0x02
   392 00001B3E E670                <1> 	out 0x70, al
   393 00001B40 E471                <1> 	in al, 0x71
   394                              <1> 
   395 00001B42 88C3                <1> 	mov bl, al
   396 00001B44 C1E308              <1> 	shl bx, 8
   397 00001B47 B000                <1> 	mov al, 0
   398 00001B49 E670                <1> 	out 0x70, al
   399 00001B4B E471                <1> 	in al, 0x71
   400                              <1> 
   401 00001B4D 891E[541B]          <1> 	mov word [random_seed], bx
   402                              <1> 
   403 00001B51 58                  <1> 	pop ax
   404 00001B52 5B                  <1> 	pop bx
   405 00001B53 C3                  <1> 	ret
   406                              <1> 
   407 00001B54 0000                <1> 	random_seed dw 0
   408                              <1> 
   409                              <1> ; ------------------------------------------------------------------
   410                              <1> ; get_random -- Return a random integer between low and high (inclusive)
   411                              <1> ; IN: AX = low integer, BX = high integer
   412                              <1> ; OUT: CX = random integer
   413                              <1> 
   414                              <1> get_random:
   415 00001B56 52                  <1> 	push dx
   416 00001B57 53                  <1> 	push bx
   417 00001B58 50                  <1> 	push ax
   418                              <1> 
   419 00001B59 29C3                <1> 	sub bx, ax
   420 00001B5B E80F00              <1> 	call .generate_random
   421 00001B5E 89DA                <1> 	mov dx, bx
   422 00001B60 83C201              <1> 	add dx, 1
   423 00001B63 F7E2                <1> 	mul dx
   424 00001B65 89D1                <1> 	mov cx, dx
   425                              <1> 
   426 00001B67 58                  <1> 	pop ax
   427 00001B68 5B                  <1> 	pop bx
   428 00001B69 5A                  <1> 	pop dx
   429 00001B6A 01C1                <1> 	add cx, ax
   430 00001B6C C3                  <1> 	ret
   431                              <1> 
   432                              <1> 	.generate_random:
   433 00001B6D 52                  <1> 		push dx
   434 00001B6E 53                  <1> 		push bx
   435                              <1> 
   436 00001B6F A1[541B]            <1> 		mov ax, [random_seed]
   437 00001B72 BA8373              <1> 		mov dx, 0x7383
   438 00001B75 F7E2                <1> 		mul dx
   439 00001B77 A3[541B]            <1> 		mov [random_seed], ax
   440                              <1> 
   441 00001B7A 5B                  <1> 		pop bx
   442 00001B7B 5A                  <1> 		pop dx
   443                              <1> 		
   444 00001B7C C3                  <1> 		ret
   445                              <1> 
   446                              <1> ; ------------------------------------------------------------------
   447                              <1> ; bcd_to_int -- Converts binary coded decimal number to an integer
   448                              <1> ; IN: AL = BCD number
   449                              <1> ; OUT: AX = integer value
   450                              <1> 
   451                              <1> bcd_to_int:
   452 00001B7D 60                  <1> 	pusha
   453                              <1> 
   454 00001B7E 88C3                <1> 	mov bl, al
   455                              <1> 
   456 00001B80 83E00F              <1> 	and ax, 0x0F
   457 00001B83 89C1                <1> 	mov cx, ax
   458                              <1> 
   459 00001B85 C0EB04              <1> 	shr bl, 4
   460 00001B88 B00A                <1> 	mov al, 10
   461 00001B8A F6E3                <1> 	mul bl
   462                              <1> 
   463 00001B8C 01C8                <1> 	add ax, cx
   464 00001B8E A3[961B]            <1> 	mov [.tmp], ax
   465                              <1> 
   466 00001B91 61                  <1> 	popa
   467 00001B92 A1[961B]            <1> 	mov ax, [.tmp]
   468 00001B95 C3                  <1> 	ret
   469                              <1> 
   470 00001B96 0000                <1> 	.tmp	dw 0
   471                              <1> 	
   472                              <1> ; ------------------------------------------------------------------
   473                              <1> ; long_int_negate -- Multiply value in DX:AX by -1
   474                              <1> ; IN: DX:AX = long integer
   475                              <1> ; OUT: DX:AX = -(initial DX:AX)
   476                              <1> 
   477                              <1> long_int_negate:
   478 00001B98 F7D8                <1> 	neg ax
   479 00001B9A 83D200              <1> 	adc dx, 0
   480 00001B9D F7DA                <1> 	neg dx
   481 00001B9F C3                  <1> 	ret
   482                              <1> 
   483                              <1> ; ------------------------------------------------------------------
   484                              <1> ; hex_to_int -- Convert a hexadecimal to decimal
   485                              <1> ; IN: AX = number to be converted, BX = base
   486                              <1> 
   487                              <1> hex_to_int:
   488 00001BA0 C3                  <1> 	ret
   489                              <1> 
   490                              <1> ; ==================================================================
   376                                      %include "./includes/print.asm"
   377                              <1> ; ------------------------------------------------------------------
   378                              <1> ; print -- Print a string to the screen
   379                              <1> ; IN: SI = The location of the string
   380                              <1> 
   381                              <1> print:
   382 00001BA1 60                  <1>     pusha
   383 00001BA2 B40E                <1>     mov ah, 0x0e
   384                              <1> 
   385                              <1> .repeat:
   386 00001BA4 AC                  <1>     lodsb
   387 00001BA5 84C0                <1>     test al, al
   388 00001BA7 7404                <1>     jz .done
   389                              <1> 
   390 00001BA9 CD10                <1>     int 0x10
   391 00001BAB EBF7                <1>     jmp short .repeat
   392                              <1> 
   393                              <1> .done:
   394 00001BAD 61                  <1>     popa
   395 00001BAE C3                  <1>     ret
   396                              <1> 
   397                              <1> ; ------------------------------------------------------------------
   398                              <1> ; welcome_print -- Print the welcome message
   399                              <1> ; IN: SI = The location of the string
   400                              <1> 
   401                              <1> welcome_print:
   402 00001BAF B409                <1>     mov ah, 0x09
   403 00001BB1 B90100              <1>     mov cx, 1
   404 00001BB4 31DB                <1>     xor bx, bx
   405 00001BB6 B330                <1>     mov bl, mb_color
   406                              <1> 
   407                              <1>     .repeat:
   408 00001BB8 AC                  <1>         lodsb
   409 00001BB9 3C00                <1>         cmp al, 0
   410 00001BBB 741C                <1>         je .done
   411                              <1> 
   412 00001BBD 3C0A                <1>         cmp al, 0x0a
   413 00001BBF 7410                <1>         je .other_char
   414 00001BC1 3C0D                <1>         cmp al, 0x0d
   415 00001BC3 740C                <1>         je .other_char
   416                              <1> 
   417 00001BC5 E88AF6              <1>         call get_cursor_pos
   418 00001BC8 FEC2                <1>         inc dl
   419 00001BCA E87CF6              <1>         call move_cursor
   420                              <1> 
   421 00001BCD CD10                <1>         int 0x10
   422 00001BCF EBE7                <1>         jmp short .repeat
   423                              <1> 
   424                              <1>     .other_char:
   425 00001BD1 B40E                <1>         mov ah, 0x0e
   426 00001BD3 CD10                <1>         int 0x10
   427                              <1> 
   428 00001BD5 B409                <1>         mov ah, 0x09
   429 00001BD7 EBDF                <1>         jmp .repeat
   430                              <1> 
   431                              <1>     .done:
   432 00001BD9 C3                  <1>         ret
   433                              <1> 
   434                              <1> ; ------------------------------------------------------------------
   435                              <1> ; print_atr -- Print a string with attribute to the screen
   436                              <1> ; IN: SI = The location of the string
   437                              <1> ;     BH = Page number
   438                              <1> ;     BL = Attribute
   439                              <1> 
   440                              <1> print_atr:
   441 00001BDA 60                  <1>     pusha
   442 00001BDB 8816[071C]          <1>     mov [.start_x], dl
   443                              <1> 
   444 00001BDF B90100              <1>     mov cx, 1
   445 00001BE2 B409                <1>     mov ah, 0x09
   446                              <1> 
   447                              <1> .repeat:
   448 00001BE4 AC                  <1>     lodsb
   449 00001BE5 84C0                <1>     test al, al
   450 00001BE7 741C                <1>     jz .done
   451                              <1> 
   452 00001BE9 3C0A                <1>     cmp al, 0x0a
   453 00001BEB 7410                <1>     je .special_char
   454                              <1> 
   455 00001BED 3C0D                <1>     cmp al, 0x0d
   456 00001BEF 740C                <1>     je .special_char
   457                              <1> 
   458 00001BF1 CD10                <1>     int 0x10
   459                              <1> 
   460 00001BF3 E85CF6              <1>     call get_cursor_pos
   461 00001BF6 FEC2                <1>     inc dl
   462 00001BF8 E84EF6              <1>     call move_cursor
   463                              <1> 
   464 00001BFB EBE7                <1>     jmp short .repeat
   465                              <1> 
   466                              <1> .special_char:
   467 00001BFD B40E                <1>     mov ah, 0x0e
   468 00001BFF CD10                <1>     int 0x10
   469 00001C01 B409                <1>     mov ah, 0x09
   470 00001C03 EBDF                <1>     jmp short .repeat
   471                              <1> 
   472                              <1> .done:
   473 00001C05 61                  <1>     popa
   474 00001C06 C3                  <1>     ret
   475                              <1> 
   476 00001C07 0000                <1>     .start_x:   dw 0
   477                              <1> 
   478                              <1> ; ------------------------------------------------------------------
   479                              <1> ; print_word_hex -- Print a word as hex
   480                              <1> ; IN: AX = Hex number
   481                              <1> ;     BH = Page number
   482                              <1> ;     BL = Attribute
   483                              <1> 
   484                              <1> print_word_hex:
   485 00001C09 60                  <1>     pusha
   486 00001C0A 86C4                <1>     xchg al, ah
   487 00001C0C E80700              <1>     call print_byte_hex
   488 00001C0F 86C4                <1>     xchg al, ah
   489 00001C11 E80200              <1>     call print_byte_hex
   490 00001C14 61                  <1>     popa
   491 00001C15 C3                  <1>     ret
   492                              <1> 
   493                              <1> ; ------------------------------------------------------------------
   494                              <1> ; print_byte_hex -- Print a byte as hex
   495                              <1> ; IN: AX = Hex number
   496                              <1> 
   497                              <1> print_byte_hex:
   498 00001C16 50                  <1>     push ax
   499 00001C17 51                  <1>     push cx
   500 00001C18 53                  <1>     push bx
   501                              <1> 
   502 00001C19 8D1E[371C]          <1>     lea bx, [.table]
   503                              <1> 
   504 00001C1D 88C4                <1>     mov ah, al
   505 00001C1F 240F                <1>     and al, 0x0f
   506 00001C21 B104                <1>     mov cl, 4
   507 00001C23 D2EC                <1>     shr ah, cl
   508 00001C25 D7                  <1>     xlat
   509 00001C26 86E0                <1>     xchg ah, al
   510 00001C28 D7                  <1>     xlat
   511                              <1> 
   512 00001C29 5B                  <1>     pop bx
   513 00001C2A 88E5                <1>     mov ch, ah
   514 00001C2C B40E                <1>     mov ah, 0x0e
   515 00001C2E CD10                <1>     int 0x10
   516 00001C30 88E8                <1>     mov al, ch
   517 00001C32 CD10                <1>     int 0x10
   518                              <1> 
   519 00001C34 59                  <1>     pop cx
   520 00001C35 58                  <1>     pop ax
   521 00001C36 C3                  <1>     ret
   522                              <1> 
   523 00001C37 303132333435363738- <1>     .table: db "0123456789ABCDEF", 0
   523 00001C40 3941424344454600    <1>
   377                                      %include "./includes/mouse.asm"
   378                              <1> HW_EQUIP_PS2     equ 4          ; PS2 mouse installed?
   379                              <1> MOUSE_PKT_BYTES  equ 3          ; Number of bytes in mouse packet
   380                              <1> MOUSE_RESOLUTION equ 3          ; Mouse resolution 8 counts/mm
   381                              <1> ARG_OFFSETS      equ 6          ; Offset of args from BP
   382                              <1> 
   383                              <1> mouse_initialize:
   384 00001C48 06                  <1>     push es
   385 00001C49 53                  <1>     push bx
   386                              <1> 
   387 00001C4A CD11                <1>     int 0x11
   388 00001C4C A90400              <1>     test ax, HW_EQUIP_PS2
   389 00001C4F 7421                <1>     jz .no_mouse
   390                              <1> 
   391 00001C51 B805C2              <1>     mov ax, 0xC205
   392 00001C54 B703                <1>     mov bh, MOUSE_PKT_BYTES
   393 00001C56 CD15                <1>     int 0x15
   394 00001C58 7218                <1>     jc .no_mouse
   395                              <1> 
   396 00001C5A B803C2              <1>     mov ax, 0xC203
   397 00001C5D B703                <1>     mov bh, MOUSE_RESOLUTION
   398 00001C5F CD15                <1>     int 0x15
   399 00001C61 720F                <1>     jc .no_mouse
   400                              <1> 
   401 00001C63 0E                  <1>     push cs
   402 00001C64 07                  <1>     pop es
   403                              <1> 
   404 00001C65 BB[DD1C]            <1>     mov bx, mouse_callback_dummy
   405 00001C68 B807C2              <1>     mov ax, 0xC207
   406 00001C6B CD15                <1>     int 0x15
   407 00001C6D 7203                <1>     jc .no_mouse
   408                              <1> 
   409 00001C6F F8                  <1>     clc
   410 00001C70 EB01                <1>     jmp .finished
   411                              <1>     
   412                              <1>     .no_mouse:
   413 00001C72 F9                  <1>         stc
   414                              <1>     
   415                              <1>     .finished:
   416 00001C73 5B                  <1>         pop bx
   417 00001C74 07                  <1>         pop es
   418 00001C75 C3                  <1>         ret
   419                              <1> 
   420                              <1> 
   421                              <1> mouse_enable:
   422 00001C76 06                  <1>     push es
   423 00001C77 53                  <1>     push bx
   424                              <1> 
   425 00001C78 E81400              <1>     call mouse_disable
   426                              <1> 
   427 00001C7B 0E                  <1>     push cs
   428 00001C7C 07                  <1>     pop es
   429 00001C7D BB[A21C]            <1>     mov bx, mouse_callback
   430 00001C80 B807C2              <1>     mov ax, 0xC207
   431 00001C83 CD15                <1>     int 0x15
   432                              <1> 
   433 00001C85 B800C2              <1>     mov ax, 0xC200
   434 00001C88 B701                <1>     mov bh, 1
   435 00001C8A CD15                <1>     int 0x15
   436                              <1> 
   437 00001C8C 5B                  <1>     pop bx
   438 00001C8D 07                  <1>     pop es
   439 00001C8E C3                  <1>     ret
   440                              <1> 
   441                              <1> 
   442                              <1> mouse_disable:
   443 00001C8F 06                  <1>     push es
   444 00001C90 53                  <1>     push bx
   445                              <1> 
   446 00001C91 B800C2              <1>     mov ax, 0xC200
   447 00001C94 31DB                <1>     xor bx, bx
   448 00001C96 CD15                <1>     int 0x15
   449                              <1> 
   450 00001C98 8EC3                <1>     mov es, bx
   451 00001C9A B807C2              <1>     mov ax, 0xC207
   452 00001C9D CD15                <1>     int 0x15
   453                              <1> 
   454 00001C9F 5B                  <1>     pop bx
   455 00001CA0 07                  <1>     pop es
   456 00001CA1 C3                  <1>     ret
   457                              <1> 
   458                              <1> 
   459                              <1> mouse_callback:
   460 00001CA2 55                  <1>     push bp
   461 00001CA3 89E5                <1>     mov bp, sp
   462                              <1> 
   463 00001CA5 1E                  <1>     push ds
   464 00001CA6 50                  <1>     push ax
   465 00001CA7 53                  <1>     push bx
   466 00001CA8 51                  <1>     push cx
   467 00001CA9 52                  <1>     push dx
   468                              <1> 
   469 00001CAA 0E                  <1>     push cs
   470 00001CAB 1F                  <1>     pop ds
   471                              <1> 
   472 00001CAC 8A460C              <1>     mov al, [bp+ARG_OFFSETS+6]
   473 00001CAF 88C3                <1>     mov bl, al
   474 00001CB1 B103                <1>     mov cl, 3
   475 00001CB3 D2E0                <1>     shl al, cl
   476                              <1> 
   477 00001CB5 18F6                <1>     sbb dh, dh
   478 00001CB7 98                  <1>     cbw
   479 00001CB8 8A5608              <1>     mov dl, [bp+ARG_OFFSETS+2]
   480 00001CBB 8A460A              <1>     mov al, [bp+ARG_OFFSETS+4]
   481                              <1> 
   482 00001CBE F7DA                <1>     neg dx
   483 00001CC0 8B0E[901D]          <1>     mov cx, [mouseY]
   484 00001CC4 01CA                <1>     add dx, cx
   485 00001CC6 8B0E[8E1D]          <1>     mov cx, [mouseX]
   486 00001CCA 01C8                <1>     add ax, cx
   487                              <1> 
   488 00001CCC 881E[921D]          <1>     mov [curStatus], bl
   489 00001CD0 A3[8E1D]            <1>     mov [mouseX], ax
   490 00001CD3 8916[901D]          <1>     mov [mouseY], dx
   491                              <1> 
   492 00001CD7 5A                  <1>     pop dx
   493 00001CD8 59                  <1>     pop cx
   494 00001CD9 5B                  <1>     pop bx
   495 00001CDA 58                  <1>     pop ax
   496 00001CDB 1F                  <1>     pop ds
   497 00001CDC 5D                  <1>     pop bp
   498                              <1> 
   499                              <1> mouse_callback_dummy:
   500 00001CDD CB                  <1>     retf
   501                              <1> 
   502                              <1> poll_mouse:
   503 00001CDE 50                  <1>     push ax
   504 00001CDF 53                  <1>     push bx
   505 00001CE0 52                  <1>     push dx
   506                              <1>     
   507 00001CE1 BB0200              <1>     mov bx, 0x0002
   508                              <1> 
   509 00001CE4 FA                  <1>     cli
   510 00001CE5 A1[8E1D]            <1>     mov ax, [mouseX]
   511 00001CE8 8B16[901D]          <1>     mov dx, [mouseY]
   512 00001CEC FB                  <1>     sti
   513                              <1> 
   514 00001CED 5A                  <1>     pop dx
   515 00001CEE 5B                  <1>     pop bx
   516 00001CEF 58                  <1>     pop ax
   517 00001CF0 C3                  <1>     ret
   518                              <1> 
   519                              <1> clamp_mouse:
   520 00001CF1 A1[8E1D]            <1>     mov ax, [mouseX]
   521                              <1> 
   522 00001CF4 83F84E              <1>     cmp ax, screenmaxW
   523 00001CF7 7D17                <1>     jge .r_edge
   524                              <1> 
   525 00001CF9 BA0100              <1>     mov dx, screenminW
   526 00001CFC 39D0                <1>     cmp ax, dx
   527 00001CFE 7E22                <1>     jle .l_edge
   528                              <1> 
   529 00001D00 BA0100              <1>     mov dx, screenminH
   530 00001D03 A1[901D]            <1>     mov ax, [mouseY]
   531 00001D06 39D0                <1>     cmp ax, dx
   532 00001D08 7E2A                <1>     jle .t_edge
   533                              <1> 
   534 00001D0A 83F817              <1>     cmp ax, screenmaxH
   535 00001D0D 7D37                <1>     jge .b_edge
   536                              <1> 
   537 00001D0F C3                  <1>     ret
   538                              <1> 
   539                              <1> .r_edge:
   540 00001D10 C706[8E1D]4E00      <1>     mov word [mouseX], screenmaxW
   541 00001D16 8A16[8E1D]          <1>     mov dl, [mouseX]
   542 00001D1A 8A36[901D]          <1>     mov dh, [mouseY]
   543 00001D1E E828F5              <1>     call move_cursor
   544 00001D21 C3                  <1>     ret
   545                              <1> 
   546                              <1> .l_edge:
   547 00001D22 C706[8E1D]0100      <1>     mov word [mouseX], screenminW
   548 00001D28 8A16[8E1D]          <1>     mov dl, [mouseX]
   549 00001D2C 8A36[901D]          <1>     mov dh, [mouseY]
   550 00001D30 E816F5              <1>     call move_cursor
   551 00001D33 C3                  <1>     ret
   552                              <1> 
   553                              <1> .t_edge:
   554 00001D34 C706[901D]0100      <1>     mov word [mouseY], screenminH
   555 00001D3A 8A16[8E1D]          <1>     mov dl, [mouseX]
   556 00001D3E 8A36[901D]          <1>     mov dh, [mouseY]
   557 00001D42 E804F5              <1>     call move_cursor
   558 00001D45 C3                  <1>     ret
   559                              <1> 
   560                              <1> .b_edge:
   561 00001D46 C706[901D]1700      <1>     mov word [mouseY], screenmaxH
   562 00001D4C 8A16[8E1D]          <1>     mov dl, [mouseX]
   563 00001D50 8A36[901D]          <1>     mov dh, [mouseY]
   564 00001D54 E8F2F4              <1>     call move_cursor
   565 00001D57 C3                  <1>     ret
   566                              <1> 
   567                              <1> no_mouse:
   568 00001D58 B8[3002]            <1>     mov ax, mouse_yes
   569 00001D5B 31DB                <1>     xor bx, bx
   570 00001D5D 31C9                <1>     xor cx, cx
   571 00001D5F BA0000              <1>     mov dx, 0
   572 00001D62 E876F5              <1>     call dialog_box
   573                              <1> 
   574 00001D65 31C0                <1>     xor ax, ax
   575 00001D67 CD13                <1>     int 0x13
   576                              <1> 
   577 00001D69 B80010              <1>     mov ax, 0x1000
   578 00001D6C 8CD0                <1>     mov ax, ss
   579 00001D6E BC00F0              <1>     mov sp, 0xf000
   580 00001D71 B80753              <1>     mov ax, 0x5307
   581 00001D74 BB0100              <1>     mov bx, 0x0001
   582 00001D77 B90300              <1>     mov cx, 0x0003
   583 00001D7A CD15                <1>     int 0x15
   584                              <1> 
   585                              <1> mouse_loop:
   586 00001D7C E85FFF              <1>     call poll_mouse
   587                              <1> 
   588 00001D7F 8A16[8E1D]          <1>     mov dl, [mouseX]
   589 00001D83 8A36[901D]          <1>     mov dh, [mouseY]
   590                              <1> 
   591 00001D87 E8BFF4              <1>     call move_cursor
   592 00001D8A E864FF              <1>     call clamp_mouse
   593                              <1> 
   594 00001D8D C3                  <1>     ret
   595                              <1> 
   596 00001D8E 0000                <1> mouseX:         dw 0
   597 00001D90 0000                <1> mouseY:         dw 0
   598 00001D92 00                  <1> curStatus:      db 0
   599 00001D93 0D4572726F72207365- <1> noMouseMsg:     db 0x0d, "Error setting up and initializing mouse", 0x0a, 0x0d, 0
   599 00001D9C 7474696E6720757020- <1>
   599 00001DA5 616E6420696E697469- <1>
   599 00001DAE 616C697A696E67206D- <1>
   599 00001DB7 6F7573650A0D00      <1>
   378                                      %include "./includes/disk.asm"
   379                              <1> ; ==================================================================
   380                              <1> ; The Kronk Operating System kernel
   381                              <1> ; Copyright (C) 2019 - 2020 Alexander Wiencken
   382                              <1> ;
   383                              <1> ; FAT12 FLOPPY DISK ROUTINES
   384                              <1> ; ==================================================================
   385                              <1> 
   386                              <1> ; ------------------------------------------------------------------
   387                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
   388                              <1> ; IN/OUT: AX = location to store zero-terminated filename string
   389                              <1> 
   390                              <1> os_get_file_list:
   391 00001DBE 60                  <1> 	pusha
   392                              <1> 
   393 00001DBF A3[601E]            <1> 	mov word [.file_list_tmp], ax
   394                              <1> 
   395 00001DC2 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   396                              <1> 
   397 00001DC8 E84007              <1> 	call disk_reset_floppy		; Just in case disk was changed
   398                              <1> 
   399 00001DCB B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   400 00001DCE E88307              <1> 	call disk_convert_l2hts
   401                              <1> 
   402 00001DD1 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   403 00001DD4 89F3                <1> 	mov bx, si
   404                              <1> 
   405 00001DD6 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   406 00001DD8 B00E                <1> 	mov al, 14			; And read 14 of them
   407                              <1> 
   408 00001DDA 60                  <1> 	pusha				; Prepare to enter loop
   409                              <1> 
   410                              <1> 
   411                              <1> .read_root_dir:
   412 00001DDB 61                  <1> 	popa
   413 00001DDC 60                  <1> 	pusha
   414                              <1> 
   415 00001DDD F9                  <1> 	stc
   416 00001DDE CD13                <1> 	int 13h				; Read sectors
   417 00001DE0 E82807              <1> 	call disk_reset_floppy		; Check we've read them OK
   418 00001DE3 7307                <1> 	jnc .show_dir_init		; No errors, continue
   419                              <1> 
   420 00001DE5 E82307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
   421 00001DE8 73F1                <1> 	jnc .read_root_dir
   422 00001DEA EB6E                <1> 	jmp .done			; Double error, exit 'dir' routine
   423                              <1> 
   424                              <1> .show_dir_init:
   425 00001DEC 61                  <1> 	popa
   426                              <1> 
   427 00001DED B80000              <1> 	mov ax, 0
   428 00001DF0 BE0060              <1> 	mov si, disk_buffer		; Data reader from start of filenames
   429                              <1> 
   430 00001DF3 8B3E[601E]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
   431                              <1> 
   432                              <1> 
   433                              <1> .start_entry:
   434 00001DF7 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   435 00001DFA 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   436 00001DFC 7457                <1> 	je .skip
   437                              <1> 
   438 00001DFE A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   439 00001E00 7553                <1> 	jnz .skip			; Yes, ignore it
   440                              <1> 
   441 00001E02 8A04                <1> 	mov al, [si]
   442 00001E04 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   443 00001E06 744D                <1> 	je .skip
   444                              <1> 
   445 00001E08 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
   446 00001E0A 744E                <1> 	je .done
   447                              <1> 
   448                              <1> 
   449 00001E0C B90100              <1> 	mov cx, 1			; Set char counter
   450 00001E0F 89F2                <1> 	mov dx, si			; Beginning of possible entry
   451                              <1> 
   452                              <1> .testdirentry:
   453 00001E11 46                  <1> 	inc si
   454 00001E12 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   455 00001E14 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   456 00001E16 7C3B                <1> 	jl .nxtdirentry
   457 00001E18 3C7E                <1> 	cmp al, '~'
   458 00001E1A 7737                <1> 	ja .nxtdirentry
   459                              <1> 
   460 00001E1C 41                  <1> 	inc cx
   461 00001E1D 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
   462 00001E20 7402                <1> 	je .gotfilename
   463 00001E22 EBED                <1> 	jmp .testdirentry
   464                              <1> 
   465                              <1> 
   466                              <1> .gotfilename:				; Got a filename that passes testing
   467 00001E24 89D6                <1> 	mov si, dx			; DX = where getting string
   468                              <1> 
   469 00001E26 B90000              <1> 	mov cx, 0
   470                              <1> .loopy:
   471 00001E29 8A04                <1> 	mov byte al, [si]
   472 00001E2B 3C20                <1> 	cmp al, ' '
   473 00001E2D 7411                <1> 	je .ignore_space
   474 00001E2F 8805                <1> 	mov byte [di], al
   475 00001E31 46                  <1> 	inc si
   476 00001E32 47                  <1> 	inc di
   477 00001E33 41                  <1> 	inc cx
   478 00001E34 83F908              <1> 	cmp cx, 8
   479 00001E37 7410                <1> 	je .add_dot
   480 00001E39 83F90B              <1> 	cmp cx, 11
   481 00001E3C 7411                <1> 	je .done_copy
   482 00001E3E EBE9                <1> 	jmp .loopy
   483                              <1> 
   484                              <1> .ignore_space:
   485 00001E40 46                  <1> 	inc si
   486 00001E41 41                  <1> 	inc cx
   487 00001E42 83F908              <1> 	cmp cx, 8
   488 00001E45 7402                <1> 	je .add_dot
   489 00001E47 EBE0                <1> 	jmp .loopy
   490                              <1> 
   491                              <1> .add_dot:
   492 00001E49 C6052E              <1> 	mov byte [di], '.'
   493 00001E4C 47                  <1> 	inc di
   494 00001E4D EBDA                <1> 	jmp .loopy
   495                              <1> 
   496                              <1> .done_copy:
   497 00001E4F C6052C              <1> 	mov byte [di], ','
   498 00001E52 47                  <1> 	inc di
   499                              <1> 
   500                              <1> .nxtdirentry:
   501 00001E53 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
   502                              <1> 
   503                              <1> .skip:
   504 00001E55 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
   505 00001E58 EB9D                <1> 	jmp .start_entry
   506                              <1> 
   507                              <1> 
   508                              <1> .done:
   509 00001E5A 4F                  <1> 	dec di
   510 00001E5B C60500              <1> 	mov byte [di], 0		; Zero-terminate string (gets rid of final comma)
   511                              <1> 
   512 00001E5E 61                  <1> 	popa
   513 00001E5F C3                  <1> 	ret
   514                              <1> 
   515 00001E60 0000                <1> 	.file_list_tmp		dw 0
   516                              <1> 
   517                              <1> ; ------------------------------------------------------------------
   518                              <1> ; os_load_file -- Load file into RAM
   519                              <1> ; IN: AX = location of filename, CX = location in RAM to load file
   520                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
   521                              <1> 
   522                              <1> os_load_file:
   523 00001E62 E8E5EF              <1> 	call string_uppercase
   524 00001E65 E87205              <1> 	call int_filename_convert
   525                              <1> 
   526 00001E68 A3[6A1F]            <1> 	mov [.filename_loc], ax		; Store filename location
   527 00001E6B 890E[6C1F]          <1> 	mov [.load_position], cx	; And where to load the file!
   528                              <1> 
   529 00001E6F 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   530                              <1> 
   531 00001E75 E89306              <1> 	call disk_reset_floppy		; In case floppy has been changed
   532 00001E78 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
   533                              <1> 
   534 00001E7A B8[7C1F]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
   535 00001E7D E9F7FB              <1> 	jmp fatal_error
   536                              <1> 
   537                              <1> 
   538                              <1> .floppy_ok:				; Ready to read first block of data
   539 00001E80 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   540 00001E83 E8CE06              <1> 	call disk_convert_l2hts
   541                              <1> 
   542 00001E86 BE0060              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   543 00001E89 89F3                <1> 	mov bx, si
   544                              <1> 
   545 00001E8B B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   546 00001E8D B00E                <1> 	mov al, 14			; 14 root directory sectors
   547                              <1> 
   548 00001E8F 60                  <1> 	pusha				; Prepare to enter loop
   549                              <1> 
   550                              <1> 
   551                              <1> .read_root_dir:
   552 00001E90 61                  <1> 	popa
   553 00001E91 60                  <1> 	pusha
   554                              <1> 
   555 00001E92 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
   556 00001E93 CD13                <1> 	int 13h				; Read sectors
   557 00001E95 7308                <1> 	jnc .search_root_dir		; No errors = continue
   558                              <1> 
   559 00001E97 E87106              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
   560 00001E9A 73F4                <1> 	jnc .read_root_dir
   561                              <1> 
   562 00001E9C 61                  <1> 	popa
   563 00001E9D EB38                <1> 	jmp .root_problem		; Double error = exit
   564                              <1> 
   565                              <1> .search_root_dir:
   566 00001E9F 61                  <1> 	popa
   567                              <1> 
   568 00001EA0 B9E000              <1> 	mov cx, word 224		; Search all entries in root dir
   569 00001EA3 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
   570                              <1> 
   571                              <1> .next_root_entry:
   572 00001EA6 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
   573 00001EA9 BF0060              <1> 	mov di, disk_buffer		; Point root dir at next entry
   574 00001EAC 01DF                <1> 	add di, bx
   575                              <1> 
   576 00001EAE 8A05                <1> 	mov al, [di]			; First character of name
   577                              <1> 
   578 00001EB0 3C00                <1> 	cmp al, 0			; Last file name already checked?
   579 00001EB2 7423                <1> 	je .root_problem
   580                              <1> 
   581 00001EB4 3CE5                <1> 	cmp al, 229			; Was this file deleted?
   582 00001EB6 74EE                <1> 	je .next_root_entry		; If yes, skip it
   583                              <1> 
   584 00001EB8 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
   585                              <1> 
   586 00001EBB 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
   587 00001EBD 74E7                <1> 	je .next_root_entry
   588                              <1> 
   589 00001EBF A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
   590 00001EC1 75E3                <1> 	jnz .next_root_entry
   591                              <1> 
   592 00001EC3 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
   593                              <1> 
   594 00001EC7 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
   595 00001EC9 E87EEF              <1> 	call string_uppercase
   596                              <1> 
   597 00001ECC 8B36[6A1F]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
   598                              <1> 
   599 00001ED0 E832F0              <1> 	call string_compare		; Current entry same as requested?
   600 00001ED3 7207                <1> 	jc .found_file_to_load
   601                              <1> 
   602 00001ED5 E2CF                <1> 	loop .next_root_entry
   603                              <1> 
   604                              <1> .root_problem:
   605 00001ED7 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
   606 00001EDA F9                  <1> 	stc				; return with size = 0 and carry set
   607 00001EDB C3                  <1> 	ret
   608                              <1> 
   609                              <1> 
   610                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
   611 00001EDC 8B451C              <1> 	mov ax, [di+28]			; Store file size to return to calling routine
   612 00001EDF A3[6E1F]            <1> 	mov word [.file_size], ax
   613                              <1> 
   614 00001EE2 83F800              <1> 	cmp ax, 0			; If the file size is zero, don't bother trying
   615 00001EE5 7478                <1> 	je .end				; to read more clusters
   616                              <1> 
   617 00001EE7 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
   618 00001EEA A3[661F]            <1> 	mov word [.cluster], ax
   619                              <1> 
   620 00001EED B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
   621 00001EF0 E86106              <1> 	call disk_convert_l2hts
   622                              <1> 
   623 00001EF3 BF0060              <1> 	mov di, disk_buffer		; ES:BX points to our buffer
   624 00001EF6 89FB                <1> 	mov bx, di
   625                              <1> 
   626 00001EF8 B402                <1> 	mov ah, 2			; int 13h params: read sectors
   627 00001EFA B009                <1> 	mov al, 9			; And read 9 of them
   628                              <1> 
   629 00001EFC 60                  <1> 	pusha
   630                              <1> 
   631                              <1> .read_fat:
   632 00001EFD 61                  <1> 	popa				; In case registers altered by int 13h
   633 00001EFE 60                  <1> 	pusha
   634                              <1> 
   635 00001EFF F9                  <1> 	stc
   636 00001F00 CD13                <1> 	int 13h
   637 00001F02 7308                <1> 	jnc .read_fat_ok
   638                              <1> 
   639 00001F04 E80406              <1> 	call disk_reset_floppy
   640 00001F07 73F4                <1> 	jnc .read_fat
   641                              <1> 
   642 00001F09 61                  <1> 	popa
   643 00001F0A EBCB                <1> 	jmp .root_problem
   644                              <1> 
   645                              <1> 
   646                              <1> .read_fat_ok:
   647 00001F0C 61                  <1> 	popa
   648                              <1> 
   649                              <1> 
   650                              <1> .load_file_sector:
   651 00001F0D A1[661F]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
   652 00001F10 83C01F              <1> 	add ax, 31
   653                              <1> 
   654 00001F13 E83E06              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
   655                              <1> 
   656 00001F16 8B1E[6C1F]          <1> 	mov bx, [.load_position]
   657                              <1> 
   658                              <1> 
   659 00001F1A B402                <1> 	mov ah, 02			; AH = read sectors, AL = just read 1
   660 00001F1C B001                <1> 	mov al, 01
   661                              <1> 
   662 00001F1E F9                  <1> 	stc
   663 00001F1F CD13                <1> 	int 13h
   664 00001F21 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
   665                              <1> 
   666 00001F23 E8E505              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
   667 00001F26 73E5                <1> 	jnc .load_file_sector
   668                              <1> 
   669 00001F28 B8[7C1F]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
   670 00001F2B E949FB              <1> 	jmp fatal_error
   671                              <1> 
   672                              <1> 
   673                              <1> .calculate_next_cluster:
   674 00001F2E A1[661F]            <1> 	mov ax, [.cluster]
   675 00001F31 BB0300              <1> 	mov bx, 3
   676 00001F34 F7E3                <1> 	mul bx
   677 00001F36 BB0200              <1> 	mov bx, 2
   678 00001F39 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
   679 00001F3B BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
   680 00001F3E 01C6                <1> 	add si, ax
   681 00001F40 3E8B04              <1> 	mov ax, word [ds:si]
   682                              <1> 
   683 00001F43 09D2                <1> 	or dx, dx			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
   684                              <1> 
   685 00001F45 7405                <1> 	jz .even			; If [CLUSTER] = even, drop last 4 bits of word
   686                              <1> 					; with next cluster; if odd, drop first 4 bits
   687                              <1> 
   688                              <1> .odd:
   689 00001F47 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
   690 00001F4A EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
   691                              <1> 
   692                              <1> .even:
   693 00001F4C 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
   694                              <1> 
   695                              <1> .calculate_cluster_cont:
   696 00001F4F A3[661F]            <1> 	mov word [.cluster], ax		; Store cluster
   697                              <1> 
   698 00001F52 3DF80F              <1> 	cmp ax, 0FF8h
   699 00001F55 7308                <1> 	jae .end
   700                              <1> 
   701 00001F57 8106[6C1F]0002      <1> 	add word [.load_position], 512
   702 00001F5D EBAE                <1> 	jmp .load_file_sector		; Onto next sector!
   703                              <1> 
   704                              <1> 
   705                              <1> .end:
   706 00001F5F 8B1E[6E1F]          <1> 	mov bx, [.file_size]		; Get file size to pass back in BX
   707 00001F63 F8                  <1> 	clc				; Carry clear = good load
   708 00001F64 C3                  <1> 	ret
   709                              <1> 
   710                              <1> 
   711 00001F65 00                  <1> 	.bootd		db 0 		; Boot device number
   712 00001F66 0000                <1> 	.cluster	dw 0 		; Cluster of the file we want to load
   713 00001F68 0000                <1> 	.pointer	dw 0 		; Pointer into disk_buffer, for loading 'file2load'
   714                              <1> 
   715 00001F6A 0000                <1> 	.filename_loc	dw 0		; Temporary store of filename location
   716 00001F6C 0000                <1> 	.load_position	dw 0		; Where we'll load the file
   717 00001F6E 0000                <1> 	.file_size	dw 0		; Size of the file
   718                              <1> 
   719 00001F70 00<rep Ch>          <1> 	.string_buff	times 12 db 0	; For size (integer) printing
   720                              <1> 
   721 00001F7C 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy failed to reset', 0
   721 00001F85 696C653A20466C6F70- <1>
   721 00001F8E 7079206661696C6564- <1>
   721 00001F97 20746F207265736574- <1>
   721 00001FA0 00                  <1>
   722                              <1> 
   723                              <1> 
   724                              <1> ; --------------------------------------------------------------------------
   725                              <1> ; os_write_file -- Save (max 64K) file to disk
   726                              <1> ; IN: AX = filename, BX = data location, CX = bytes to write
   727                              <1> ; OUT: Carry clear if OK, set if failure
   728                              <1> 
   729                              <1> os_write_file:
   730 00001FA1 60                  <1> 	pusha
   731                              <1> 
   732 00001FA2 89C6                <1> 	mov si, ax
   733 00001FA4 E854EE              <1> 	call string_length
   734 00001FA7 83F800              <1> 	cmp ax, 0
   735 00001FAA 0F849201            <1> 	je near .failure
   736 00001FAE 89F0                <1> 	mov ax, si
   737                              <1> 
   738 00001FB0 E897EE              <1> 	call string_uppercase
   739 00001FB3 E82404              <1> 	call int_filename_convert	; Make filename FAT12-style
   740 00001FB6 0F828601            <1> 	jc near .failure
   741                              <1> 
   742 00001FBA 890E[4321]          <1> 	mov word [.filesize], cx
   743 00001FBE 891E[4921]          <1> 	mov word [.location], bx
   744 00001FC2 A3[4D21]            <1> 	mov word [.filename], ax
   745                              <1> 
   746 00001FC5 E88702              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
   747 00001FC8 0F837401            <1> 	jnc near .failure
   748                              <1> 
   749                              <1> 
   750                              <1> 	; First, zero out the .free_clusters list from any previous execution
   751 00001FCC 60                  <1> 	pusha
   752                              <1> 
   753 00001FCD BF[4F21]            <1> 	mov di, .free_clusters
   754 00001FD0 B98000              <1> 	mov cx, 128
   755                              <1> .clean_free_loop:
   756 00001FD3 C7050000            <1> 	mov word [di], 0
   757 00001FD7 47                  <1> 	inc di
   758 00001FD8 47                  <1> 	inc di
   759 00001FD9 E2F8                <1> 	loop .clean_free_loop
   760                              <1> 
   761 00001FDB 61                  <1> 	popa
   762                              <1> 
   763                              <1> 
   764                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
   765                              <1> 
   766 00001FDC 89C8                <1> 	mov ax, cx
   767 00001FDE BA0000              <1> 	mov dx, 0
   768 00001FE1 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
   769 00001FE4 F7F3                <1> 	div bx
   770 00001FE6 83FA00              <1> 	cmp dx, 0
   771 00001FE9 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
   772 00001FEB EB03                <1> 	jmp .carry_on
   773                              <1> 
   774                              <1> .add_a_bit:
   775 00001FED 83C001              <1> 	add ax, 1
   776                              <1> .carry_on:
   777                              <1> 
   778 00001FF0 A3[4B21]            <1> 	mov word [.clusters_needed], ax
   779                              <1> 
   780 00001FF3 A1[4D21]            <1> 	mov word ax, [.filename]	; Get filename back
   781                              <1> 
   782 00001FF6 E87502              <1> 	call os_create_file		; Create empty root dir entry for this file
   783 00001FF9 0F824301            <1> 	jc near .failure		; If we can't write to the media, jump out
   784                              <1> 
   785 00001FFD 8B1E[4321]          <1> 	mov word bx, [.filesize]
   786 00002001 83FB00              <1> 	cmp bx, 0
   787 00002004 0F843501            <1> 	je near .finished
   788                              <1> 
   789 00002008 E86B04              <1> 	call disk_read_fat		; Get FAT copy into RAM
   790 0000200B BE0360              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
   791                              <1> 
   792 0000200E BB0200              <1> 	mov bx, 2			; Current cluster counter
   793 00002011 8B0E[4B21]          <1> 	mov word cx, [.clusters_needed]
   794 00002015 BA0000              <1> 	mov dx, 0			; Offset in .free_clusters list
   795                              <1> 
   796                              <1> .find_free_cluster:
   797 00002018 AD                  <1> 	lodsw				; Get a word
   798 00002019 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
   799 0000201C 740D                <1> 	jz .found_free_even		; Free entry?
   800                              <1> 
   801                              <1> .more_odd:
   802 0000201E 43                  <1> 	inc bx				; If not, bump our counter
   803 0000201F 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
   804                              <1> 
   805 00002020 AD                  <1> 	lodsw				; Get word
   806 00002021 C1E804              <1> 	shr ax, 4			; Shift for odd
   807 00002024 09C0                <1> 	or ax, ax			; Free entry?
   808 00002026 7416                <1> 	jz .found_free_odd
   809                              <1> 
   810                              <1> .more_even:
   811 00002028 43                  <1> 	inc bx				; If not, keep going
   812 00002029 EBED                <1> 	jmp .find_free_cluster
   813                              <1> 
   814                              <1> 
   815                              <1> .found_free_even:
   816 0000202B 56                  <1> 	push si
   817 0000202C BE[4F21]            <1> 	mov si, .free_clusters		; Store cluster
   818 0000202F 01D6                <1> 	add si, dx
   819 00002031 891C                <1> 	mov word [si], bx
   820 00002033 5E                  <1> 	pop si
   821                              <1> 
   822 00002034 49                  <1> 	dec cx				; Got all the clusters we need?
   823 00002035 83F900              <1> 	cmp cx, 0
   824 00002038 7417                <1> 	je .finished_list
   825                              <1> 
   826 0000203A 42                  <1> 	inc dx				; Next word in our list
   827 0000203B 42                  <1> 	inc dx
   828 0000203C EBE0                <1> 	jmp .more_odd
   829                              <1> 
   830                              <1> .found_free_odd:
   831 0000203E 56                  <1> 	push si
   832 0000203F BE[4F21]            <1> 	mov si, .free_clusters		; Store cluster
   833 00002042 01D6                <1> 	add si, dx
   834 00002044 891C                <1> 	mov word [si], bx
   835 00002046 5E                  <1> 	pop si
   836                              <1> 
   837 00002047 49                  <1> 	dec cx
   838 00002048 83F900              <1> 	cmp cx, 0
   839 0000204B 7404                <1> 	je .finished_list
   840                              <1> 
   841 0000204D 42                  <1> 	inc dx				; Next word in our list
   842 0000204E 42                  <1> 	inc dx
   843 0000204F EBD7                <1> 	jmp .more_even
   844                              <1> 
   845                              <1> 
   846                              <1> 
   847                              <1> .finished_list:
   848                              <1> 
   849                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
   850                              <1> 	; that correspond to free clusters on the disk; the next job is to
   851                              <1> 	; create a cluster chain in the FAT for our file
   852                              <1> 
   853 00002051 B90000              <1> 	mov cx, 0			; .free_clusters offset counter
   854 00002054 C706[4721]0100      <1> 	mov word [.count], 1		; General cluster counter
   855                              <1> 
   856                              <1> .chain_loop:
   857 0000205A A1[4721]            <1> 	mov word ax, [.count]		; Is this the last cluster?
   858 0000205D 3B06[4B21]          <1> 	cmp word ax, [.clusters_needed]
   859 00002061 7455                <1> 	je .last_cluster
   860                              <1> 
   861 00002063 BF[4F21]            <1> 	mov di, .free_clusters
   862                              <1> 
   863 00002066 01CF                <1> 	add di, cx
   864 00002068 8B1D                <1> 	mov word bx, [di]		; Get cluster
   865                              <1> 
   866 0000206A 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
   867 0000206C BA0000              <1> 	mov dx, 0
   868 0000206F BB0300              <1> 	mov bx, 3
   869 00002072 F7E3                <1> 	mul bx
   870 00002074 BB0200              <1> 	mov bx, 2
   871 00002077 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   872 00002079 BE0060              <1> 	mov si, disk_buffer
   873 0000207C 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   874 0000207E 3E8B04              <1> 	mov ax, word [ds:si]
   875                              <1> 
   876 00002081 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   877 00002083 741B                <1> 	jz .even
   878                              <1> 
   879                              <1> .odd:
   880 00002085 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
   881 00002088 BF[4F21]            <1> 	mov di, .free_clusters
   882 0000208B 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   883 0000208D 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
   884 00002090 C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
   885 00002093 01D8                <1> 	add ax, bx
   886                              <1> 
   887 00002095 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   888                              <1> 
   889 00002098 FF06[4721]          <1> 	inc word [.count]
   890 0000209C 41                  <1> 	inc cx				; Move on a word in .free_clusters
   891 0000209D 41                  <1> 	inc cx
   892                              <1> 
   893 0000209E EBBA                <1> 	jmp .chain_loop
   894                              <1> 
   895                              <1> .even:
   896 000020A0 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
   897 000020A3 BF[4F21]            <1> 	mov di, .free_clusters
   898 000020A6 01CF                <1> 	add di, cx			; Get offset in .free_clusters
   899 000020A8 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
   900                              <1> 
   901 000020AB 01D8                <1> 	add ax, bx
   902                              <1> 
   903 000020AD 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
   904                              <1> 
   905 000020B0 FF06[4721]          <1> 	inc word [.count]
   906 000020B4 41                  <1> 	inc cx				; Move on a word in .free_clusters
   907 000020B5 41                  <1> 	inc cx
   908                              <1> 
   909 000020B6 EBA2                <1> 	jmp .chain_loop
   910                              <1> 
   911                              <1> 
   912                              <1> 
   913                              <1> .last_cluster:
   914 000020B8 BF[4F21]            <1> 	mov di, .free_clusters
   915 000020BB 01CF                <1> 	add di, cx
   916 000020BD 8B1D                <1> 	mov word bx, [di]		; Get cluster
   917                              <1> 
   918 000020BF 89D8                <1> 	mov ax, bx
   919                              <1> 
   920 000020C1 BA0000              <1> 	mov dx, 0
   921 000020C4 BB0300              <1> 	mov bx, 3
   922 000020C7 F7E3                <1> 	mul bx
   923 000020C9 BB0200              <1> 	mov bx, 2
   924 000020CC F7F3                <1> 	div bx				; DX = [.cluster] mod 2
   925 000020CE BE0060              <1> 	mov si, disk_buffer
   926 000020D1 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
   927 000020D3 3E8B04              <1> 	mov ax, word [ds:si]
   928                              <1> 
   929 000020D6 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
   930 000020D8 7408                <1> 	jz .even_last
   931                              <1> 
   932                              <1> .odd_last:
   933 000020DA 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
   934 000020DD 83C080              <1> 	add ax, 0FF80h
   935 000020E0 EB06                <1> 	jmp .finito
   936                              <1> 
   937                              <1> .even_last:
   938 000020E2 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
   939 000020E5 05F80F              <1> 	add ax, 0FF8h
   940                              <1> 
   941                              <1> 
   942                              <1> .finito:
   943 000020E8 3E8904              <1> 	mov word [ds:si], ax
   944                              <1> 
   945 000020EB E8B403              <1> 	call disk_write_fat		; Save our FAT back to disk
   946                              <1> 
   947                              <1> 
   948                              <1> 	; Now it's time to save the sectors to disk!
   949                              <1> 
   950 000020EE B90000              <1> 	mov cx, 0
   951                              <1> 
   952                              <1> .save_loop:
   953 000020F1 BF[4F21]            <1> 	mov di, .free_clusters
   954 000020F4 01CF                <1> 	add di, cx
   955 000020F6 8B05                <1> 	mov word ax, [di]
   956                              <1> 
   957 000020F8 83F800              <1> 	cmp ax, 0
   958 000020FB 0F841D00            <1> 	je near .write_root_entry
   959                              <1> 
   960 000020FF 60                  <1> 	pusha
   961                              <1> 
   962 00002100 83C01F              <1> 	add ax, 31
   963                              <1> 
   964 00002103 E84E04              <1> 	call disk_convert_l2hts
   965                              <1> 
   966 00002106 8B1E[4921]          <1> 	mov word bx, [.location]
   967                              <1> 
   968 0000210A B403                <1> 	mov ah, 3
   969 0000210C B001                <1> 	mov al, 1
   970 0000210E F9                  <1> 	stc
   971 0000210F CD13                <1> 	int 13h
   972                              <1> 
   973 00002111 61                  <1> 	popa
   974                              <1> 
   975 00002112 8106[4921]0002      <1> 	add word [.location], 512
   976 00002118 41                  <1> 	inc cx
   977 00002119 41                  <1> 	inc cx
   978 0000211A EBD5                <1> 	jmp .save_loop
   979                              <1> 
   980                              <1> 
   981                              <1> .write_root_entry:
   982                              <1> 
   983                              <1> 	; Now it's time to head back to the root directory, find our
   984                              <1> 	; entry and update it with the cluster in use and file size
   985                              <1> 
   986 0000211C E8A203              <1> 	call disk_read_root_dir
   987                              <1> 
   988 0000211F A1[4D21]            <1> 	mov word ax, [.filename]
   989 00002122 E81903              <1> 	call disk_get_root_entry
   990                              <1> 
   991 00002125 A1[4F21]            <1> 	mov word ax, [.free_clusters]	; Get first free cluster
   992                              <1> 
   993 00002128 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
   994                              <1> 
   995 0000212B 8B0E[4321]          <1> 	mov word cx, [.filesize]
   996 0000212F 894D1C              <1> 	mov word [di+28], cx
   997                              <1> 
   998 00002132 C6451E00            <1> 	mov byte [di+30], 0		; File size
   999 00002136 C6451F00            <1> 	mov byte [di+31], 0
  1000                              <1> 
  1001 0000213A E8AF03              <1> 	call disk_write_root_dir
  1002                              <1> 
  1003                              <1> .finished:
  1004 0000213D 61                  <1> 	popa
  1005 0000213E F8                  <1> 	clc
  1006 0000213F C3                  <1> 	ret
  1007                              <1> 
  1008                              <1> .failure:
  1009 00002140 61                  <1> 	popa
  1010 00002141 F9                  <1> 	stc				; Couldn't write!
  1011 00002142 C3                  <1> 	ret
  1012                              <1> 
  1013                              <1> 
  1014 00002143 0000                <1> 	.filesize	dw 0
  1015 00002145 0000                <1> 	.cluster	dw 0
  1016 00002147 0000                <1> 	.count		dw 0
  1017 00002149 0000                <1> 	.location	dw 0
  1018                              <1> 
  1019 0000214B 0000                <1> 	.clusters_needed	dw 0
  1020                              <1> 
  1021 0000214D 0000                <1> 	.filename	dw 0
  1022                              <1> 
  1023 0000214F 0000<rep 80h>       <1> 	.free_clusters	times 128 dw 0
  1024                              <1> 
  1025                              <1> 
  1026                              <1> ; --------------------------------------------------------------------------
  1027                              <1> ; os_file_exists -- Check for presence of file on the floppy
  1028                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
  1029                              <1> 
  1030                              <1> os_file_exists:
  1031 0000224F E8F8EB              <1> 	call string_uppercase
  1032 00002252 E88501              <1> 	call int_filename_convert	; Make FAT12-style filename
  1033                              <1> 
  1034 00002255 50                  <1> 	push ax
  1035 00002256 E8A2EB              <1> 	call string_length
  1036 00002259 83F800              <1> 	cmp ax, 0
  1037 0000225C 740D                <1> 	je .failure
  1038 0000225E 58                  <1> 	pop ax
  1039                              <1> 
  1040 0000225F 50                  <1> 	push ax
  1041 00002260 E85E02              <1> 	call disk_read_root_dir
  1042                              <1> 
  1043 00002263 58                  <1> 	pop ax				; Restore filename
  1044 00002264 BF0060              <1> 	mov di, disk_buffer
  1045 00002267 E8D401              <1> 	call disk_get_root_entry	; Set or clear carry flag
  1046                              <1> 	
  1047 0000226A C3                  <1> 	ret
  1048                              <1> 
  1049                              <1> .failure:
  1050 0000226B 58                  <1> 	pop ax
  1051 0000226C F9                  <1> 	stc
  1052 0000226D C3                  <1> 	ret
  1053                              <1> 
  1054                              <1> 
  1055                              <1> ; --------------------------------------------------------------------------
  1056                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
  1057                              <1> ; IN: AX = location of filename
  1058                              <1> 
  1059                              <1> os_create_file:
  1060 0000226E F8                  <1> 	clc
  1061                              <1> 
  1062 0000226F E8D8EB              <1> 	call string_uppercase
  1063 00002272 E86501              <1> 	call int_filename_convert	; Make FAT12-style filename
  1064 00002275 60                  <1> 	pusha
  1065                              <1> 
  1066 00002276 50                  <1> 	push ax				; Save filename for now
  1067                              <1> 
  1068 00002277 E8D5FF              <1> 	call os_file_exists		; Does the file already exist?
  1069 0000227A 7315                <1> 	jnc .exists_error
  1070                              <1> 
  1071                              <1> 
  1072                              <1> 	; Root dir already read into disk_buffer by os_file_exists
  1073                              <1> 
  1074 0000227C BF0060              <1> 	mov di, disk_buffer		; So point DI at it!
  1075                              <1> 
  1076                              <1> 
  1077 0000227F B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
  1078                              <1> .next_entry:
  1079 00002282 8A05                <1> 	mov byte al, [di]
  1080 00002284 3C00                <1> 	cmp al, 0			; Is this a free entry?
  1081 00002286 740D                <1> 	je .found_free_entry
  1082 00002288 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
  1083 0000228A 7409                <1> 	je .found_free_entry
  1084 0000228C 83C720              <1> 	add di, 32			; If not, go onto next entry
  1085 0000228F E2F1                <1> 	loop .next_entry
  1086                              <1> 
  1087                              <1> .exists_error:				; We also get here if above loop finds nothing
  1088 00002291 58                  <1> 	pop ax				; Get filename back
  1089                              <1> 
  1090 00002292 61                  <1> 	popa
  1091 00002293 F9                  <1> 	stc				; Set carry for failure
  1092 00002294 C3                  <1> 	ret
  1093                              <1> 
  1094                              <1> 
  1095                              <1> .found_free_entry:
  1096 00002295 5E                  <1> 	pop si				; Get filename back
  1097 00002296 B90B00              <1> 	mov cx, 11
  1098 00002299 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
  1099                              <1> 
  1100                              <1> 
  1101 0000229B 83EF0B              <1> 	sub di, 11			; Back to start of root dir entry, for clarity
  1102                              <1> 
  1103                              <1> 
  1104 0000229E C6450B00            <1> 	mov byte [di+11], 0		; Attributes
  1105 000022A2 C6450C00            <1> 	mov byte [di+12], 0		; Reserved
  1106 000022A6 C6450D00            <1> 	mov byte [di+13], 0		; Reserved
  1107 000022AA C6450EC6            <1> 	mov byte [di+14], 0C6h		; Creation time
  1108 000022AE C6450F7E            <1> 	mov byte [di+15], 07Eh		; Creation time
  1109 000022B2 C6451000            <1> 	mov byte [di+16], 0		; Creation date
  1110 000022B6 C6451100            <1> 	mov byte [di+17], 0		; Creation date
  1111 000022BA C6451200            <1> 	mov byte [di+18], 0		; Last access date
  1112 000022BE C6451300            <1> 	mov byte [di+19], 0		; Last access date
  1113 000022C2 C6451400            <1> 	mov byte [di+20], 0		; Ignore in FAT12
  1114 000022C6 C6451500            <1> 	mov byte [di+21], 0		; Ignore in FAT12
  1115 000022CA C64516C6            <1> 	mov byte [di+22], 0C6h		; Last write time
  1116 000022CE C645177E            <1> 	mov byte [di+23], 07Eh		; Last write time
  1117 000022D2 C6451800            <1> 	mov byte [di+24], 0		; Last write date
  1118 000022D6 C6451900            <1> 	mov byte [di+25], 0		; Last write date
  1119 000022DA C6451A00            <1> 	mov byte [di+26], 0		; First logical cluster
  1120 000022DE C6451B00            <1> 	mov byte [di+27], 0		; First logical cluster
  1121 000022E2 C6451C00            <1> 	mov byte [di+28], 0		; File size
  1122 000022E6 C6451D00            <1> 	mov byte [di+29], 0		; File size
  1123 000022EA C6451E00            <1> 	mov byte [di+30], 0		; File size
  1124 000022EE C6451F00            <1> 	mov byte [di+31], 0		; File size
  1125                              <1> 
  1126 000022F2 E8F701              <1> 	call disk_write_root_dir
  1127 000022F5 7203                <1> 	jc .failure
  1128                              <1> 
  1129 000022F7 61                  <1> 	popa
  1130 000022F8 F8                  <1> 	clc				; Clear carry for success
  1131 000022F9 C3                  <1> 	ret
  1132                              <1> 
  1133                              <1> .failure:
  1134 000022FA 61                  <1> 	popa
  1135 000022FB F9                  <1> 	stc
  1136 000022FC C3                  <1> 	ret
  1137                              <1> 
  1138                              <1> 
  1139                              <1> ; --------------------------------------------------------------------------
  1140                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
  1141                              <1> ; IN: AX = location of filename to remove
  1142                              <1> 
  1143                              <1> os_remove_file:
  1144 000022FD 60                  <1> 	pusha
  1145 000022FE E849EB              <1> 	call string_uppercase
  1146 00002301 E8D600              <1> 	call int_filename_convert	; Make filename FAT12-style
  1147 00002304 50                  <1> 	push ax				; Save filename
  1148                              <1> 
  1149 00002305 F8                  <1> 	clc
  1150                              <1> 
  1151 00002306 E8B801              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1152                              <1> 
  1153 00002309 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
  1154                              <1> 
  1155 0000230C 58                  <1> 	pop ax				; Get chosen filename back
  1156                              <1> 
  1157 0000230D E82E01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1158 00002310 7269                <1> 	jc .failure			; If entry can't be found
  1159                              <1> 
  1160                              <1> 
  1161 00002312 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
  1162 00002316 A3[7E23]            <1> 	mov word [.cluster], ax		; And save it
  1163                              <1> 
  1164 00002319 C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
  1165                              <1> 
  1166 0000231C 47                  <1> 	inc di
  1167                              <1> 
  1168 0000231D B90000              <1> 	mov cx, 0			; Set rest of data in root dir entry to zeros
  1169                              <1> .clean_loop:
  1170 00002320 C60500              <1> 	mov byte [di], 0
  1171 00002323 47                  <1> 	inc di
  1172 00002324 41                  <1> 	inc cx
  1173 00002325 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
  1174 00002328 7CF6                <1> 	jl .clean_loop
  1175                              <1> 
  1176 0000232A E8BF01              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
  1177                              <1> 
  1178                              <1> 
  1179 0000232D E84601              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
  1180 00002330 BF0060              <1> 	mov di, disk_buffer		; And DI points to it
  1181                              <1> 
  1182                              <1> 
  1183                              <1> .more_clusters:
  1184 00002333 A1[7E23]            <1> 	mov word ax, [.cluster]		; Get cluster contents
  1185                              <1> 
  1186 00002336 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
  1187 00002339 743D                <1> 	je .nothing_to_do
  1188                              <1> 
  1189 0000233B BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
  1190 0000233E F7E3                <1> 	mul bx
  1191 00002340 BB0200              <1> 	mov bx, 2
  1192 00002343 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
  1193 00002345 BE0060              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1194 00002348 01C6                <1> 	add si, ax
  1195 0000234A 3E8B04              <1> 	mov ax, word [ds:si]
  1196                              <1> 
  1197 0000234D 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
  1198                              <1> 
  1199 0000234F 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
  1200                              <1> 					; with next cluster; if odd, drop first 4 bits
  1201                              <1> .odd:
  1202 00002351 50                  <1> 	push ax
  1203 00002352 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
  1204 00002355 3E8904              <1> 	mov word [ds:si], ax
  1205 00002358 58                  <1> 	pop ax
  1206                              <1> 
  1207 00002359 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
  1208 0000235C EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1209                              <1> 
  1210                              <1> .even:
  1211 0000235E 50                  <1> 	push ax
  1212 0000235F 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
  1213 00002362 3E8904              <1> 	mov word [ds:si], ax
  1214 00002365 58                  <1> 	pop ax
  1215                              <1> 
  1216 00002366 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
  1217                              <1> 
  1218                              <1> .calculate_cluster_cont:
  1219 00002369 A3[7E23]            <1> 	mov word [.cluster], ax		; Store cluster
  1220                              <1> 
  1221 0000236C 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
  1222 0000236F 7302                <1> 	jae .end
  1223                              <1> 
  1224 00002371 EBC0                <1> 	jmp .more_clusters		; If not, grab more
  1225                              <1> 
  1226                              <1> .end:
  1227 00002373 E82C01              <1> 	call disk_write_fat
  1228 00002376 7203                <1> 	jc .failure
  1229                              <1> 
  1230                              <1> .nothing_to_do:
  1231 00002378 61                  <1> 	popa
  1232 00002379 F8                  <1> 	clc
  1233 0000237A C3                  <1> 	ret
  1234                              <1> 
  1235                              <1> .failure:
  1236 0000237B 61                  <1> 	popa
  1237 0000237C F9                  <1> 	stc
  1238 0000237D C3                  <1> 	ret
  1239                              <1> 
  1240                              <1> 
  1241 0000237E 0000                <1> 	.cluster dw 0
  1242                              <1> 
  1243                              <1> 
  1244                              <1> ; --------------------------------------------------------------------------
  1245                              <1> ; os_rename_file -- Change the name of a file on the disk
  1246                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
  1247                              <1> ; OUT: carry set on error
  1248                              <1> 
  1249                              <1> os_rename_file:
  1250 00002380 53                  <1> 	push bx
  1251 00002381 50                  <1> 	push ax
  1252                              <1> 
  1253 00002382 F8                  <1> 	clc
  1254                              <1> 
  1255 00002383 E83B01              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1256                              <1> 
  1257 00002386 BF0060              <1> 	mov di, disk_buffer		; Point DI to root dir
  1258                              <1> 
  1259 00002389 58                  <1> 	pop ax				; Get chosen filename back
  1260                              <1> 
  1261 0000238A E8BDEA              <1> 	call string_uppercase
  1262 0000238D E84A00              <1> 	call int_filename_convert
  1263                              <1> 
  1264 00002390 E8AB00              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1265 00002393 7217                <1> 	jc .fail_read			; Quit out if file not found
  1266                              <1> 
  1267 00002395 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
  1268                              <1> 
  1269 00002396 89D8                <1> 	mov ax, bx
  1270                              <1> 
  1271 00002398 E8AFEA              <1> 	call string_uppercase
  1272 0000239B E83C00              <1> 	call int_filename_convert
  1273                              <1> 
  1274 0000239E 89C6                <1> 	mov si, ax
  1275                              <1> 
  1276 000023A0 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
  1277 000023A3 F3A4                <1> 	rep movsb
  1278                              <1> 
  1279 000023A5 E84401              <1> 	call disk_write_root_dir	; Save root dir to disk
  1280 000023A8 7205                <1> 	jc .fail_write
  1281                              <1> 
  1282 000023AA F8                  <1> 	clc
  1283 000023AB C3                  <1> 	ret
  1284                              <1> 
  1285                              <1> .fail_read:
  1286 000023AC 58                  <1> 	pop ax
  1287 000023AD F9                  <1> 	stc
  1288 000023AE C3                  <1> 	ret
  1289                              <1> 
  1290                              <1> .fail_write:
  1291 000023AF F9                  <1> 	stc
  1292 000023B0 C3                  <1> 	ret
  1293                              <1> 
  1294                              <1> 
  1295                              <1> ; --------------------------------------------------------------------------
  1296                              <1> ; os_get_file_size -- Get file size information for specified file
  1297                              <1> ; IN: AX = filename; OUT: BX = file size in bytes (up to 64K)
  1298                              <1> ; or carry set if file not found
  1299                              <1> 
  1300                              <1> os_get_file_size:
  1301 000023B1 60                  <1> 	pusha
  1302                              <1> 
  1303 000023B2 E895EA              <1> 	call string_uppercase
  1304 000023B5 E82200              <1> 	call int_filename_convert
  1305                              <1> 
  1306 000023B8 F8                  <1> 	clc
  1307                              <1> 
  1308 000023B9 50                  <1> 	push ax
  1309                              <1> 
  1310 000023BA E80401              <1> 	call disk_read_root_dir
  1311 000023BD 7216                <1> 	jc .failure
  1312                              <1> 
  1313 000023BF 58                  <1> 	pop ax
  1314                              <1> 
  1315 000023C0 BF0060              <1> 	mov di, disk_buffer
  1316                              <1> 
  1317 000023C3 E87800              <1> 	call disk_get_root_entry
  1318 000023C6 720D                <1> 	jc .failure
  1319                              <1> 
  1320 000023C8 8B5D1C              <1> 	mov word bx, [di+28]
  1321                              <1> 
  1322 000023CB 891E[D823]          <1> 	mov word [.tmp], bx
  1323                              <1> 
  1324 000023CF 61                  <1> 	popa
  1325                              <1> 
  1326 000023D0 8B1E[D823]          <1> 	mov word bx, [.tmp]
  1327                              <1> 
  1328 000023D4 C3                  <1> 	ret
  1329                              <1> 
  1330                              <1> .failure:
  1331 000023D5 61                  <1> 	popa
  1332 000023D6 F9                  <1> 	stc
  1333 000023D7 C3                  <1> 	ret
  1334                              <1> 
  1335                              <1> 
  1336 000023D8 0000                <1> 	.tmp	dw 0
  1337                              <1> 
  1338                              <1> 
  1339                              <1> ; ==================================================================
  1340                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  1341                              <1> 
  1342                              <1> ; ------------------------------------------------------------------
  1343                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  1344                              <1> ; IN: AX = filename string
  1345                              <1> ; OUT: AX = location of converted string (carry set if invalid)
  1346                              <1> 
  1347                              <1> int_filename_convert:
  1348 000023DA 60                  <1> 	pusha
  1349                              <1> 
  1350 000023DB 89C6                <1> 	mov si, ax
  1351                              <1> 
  1352 000023DD E81BEA              <1> 	call string_length
  1353 000023E0 83F80E              <1> 	cmp ax, 14			; Filename too long?
  1354 000023E3 7F49                <1> 	jg .failure			; Fail if so
  1355                              <1> 
  1356 000023E5 83F800              <1> 	cmp ax, 0
  1357 000023E8 7444                <1> 	je .failure			; Similarly, fail if zero-char string
  1358                              <1> 
  1359 000023EA 89C2                <1> 	mov dx, ax			; Store string length for now
  1360                              <1> 
  1361 000023EC BF[3124]            <1> 	mov di, .dest_string
  1362                              <1> 
  1363 000023EF B90000              <1> 	mov cx, 0
  1364                              <1> .copy_loop:
  1365 000023F2 AC                  <1> 	lodsb
  1366 000023F3 3C2E                <1> 	cmp al, '.'
  1367 000023F5 7408                <1> 	je .extension_found
  1368 000023F7 AA                  <1> 	stosb
  1369 000023F8 41                  <1> 	inc cx
  1370 000023F9 39D1                <1> 	cmp cx, dx
  1371 000023FB 7F31                <1> 	jg .failure			; No extension found = wrong
  1372 000023FD EBF3                <1> 	jmp .copy_loop
  1373                              <1> 
  1374                              <1> .extension_found:
  1375 000023FF 83F900              <1> 	cmp cx, 0
  1376 00002402 742A                <1> 	je .failure			; Fail if extension dot is first char
  1377                              <1> 
  1378 00002404 83F908              <1> 	cmp cx, 8
  1379 00002407 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  1380                              <1> 
  1381                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  1382                              <1> 	; with spaces, if necessary
  1383                              <1> 
  1384                              <1> .add_spaces:
  1385 00002409 C60520              <1> 	mov byte [di], ' '
  1386 0000240C 47                  <1> 	inc di
  1387 0000240D 41                  <1> 	inc cx
  1388 0000240E 83F908              <1> 	cmp cx, 8
  1389 00002411 7CF6                <1> 	jl .add_spaces
  1390                              <1> 
  1391                              <1> 	; Finally, copy over the extension
  1392                              <1> .do_extension:
  1393 00002413 AC                  <1> 	lodsb				; 3 characters
  1394 00002414 3C00                <1> 	cmp al, 0
  1395 00002416 7416                <1> 	je .failure
  1396 00002418 AA                  <1> 	stosb
  1397 00002419 AC                  <1> 	lodsb
  1398 0000241A 3C00                <1> 	cmp al, 0
  1399 0000241C 7410                <1> 	je .failure
  1400 0000241E AA                  <1> 	stosb
  1401 0000241F AC                  <1> 	lodsb
  1402 00002420 3C00                <1> 	cmp al, 0
  1403 00002422 740A                <1> 	je .failure
  1404 00002424 AA                  <1> 	stosb
  1405                              <1> 
  1406 00002425 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  1407                              <1> 
  1408 00002428 61                  <1> 	popa
  1409 00002429 B8[3124]            <1> 	mov ax, .dest_string
  1410 0000242C F8                  <1> 	clc				; Clear carry for success
  1411 0000242D C3                  <1> 	ret
  1412                              <1> 
  1413                              <1> 
  1414                              <1> .failure:
  1415 0000242E 61                  <1> 	popa
  1416 0000242F F9                  <1> 	stc				; Set carry for failure
  1417 00002430 C3                  <1> 	ret
  1418                              <1> 
  1419                              <1> 
  1420 00002431 00<rep Dh>          <1> 	.dest_string	times 13 db 0
  1421                              <1> 
  1422                              <1> 
  1423                              <1> ; --------------------------------------------------------------------------
  1424                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  1425                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  1426                              <1> ; or carry set if file not found
  1427                              <1> 
  1428                              <1> disk_get_root_entry:
  1429 0000243E 60                  <1> 	pusha
  1430                              <1> 
  1431 0000243F A3[7224]            <1> 	mov word [.filename], ax
  1432                              <1> 
  1433 00002442 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  1434 00002445 B80000              <1> 	mov ax, 0			; Searching at offset 0
  1435                              <1> 
  1436                              <1> .to_next_root_entry:
  1437 00002448 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  1438                              <1> 
  1439 0000244A 8B36[7224]          <1> 	mov word si, [.filename]	; Start searching for filename
  1440 0000244E B90B00              <1> 	mov cx, 11
  1441 00002451 F3A6                <1> 	rep cmpsb
  1442 00002453 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  1443                              <1> 
  1444 00002455 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  1445                              <1> 
  1446 00002458 BF0060              <1> 	mov di, disk_buffer		; Point to next root dir entry
  1447 0000245B 01C7                <1> 	add di, ax
  1448                              <1> 
  1449 0000245D 87D1                <1> 	xchg dx, cx			; Get the original CX back
  1450 0000245F E2E7                <1> 	loop .to_next_root_entry
  1451                              <1> 
  1452 00002461 61                  <1> 	popa
  1453                              <1> 
  1454 00002462 F9                  <1> 	stc				; Set carry if entry not found
  1455 00002463 C3                  <1> 	ret
  1456                              <1> 
  1457                              <1> 
  1458                              <1> .found_file:
  1459 00002464 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  1460                              <1> 
  1461 00002467 893E[7424]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  1462                              <1> 
  1463 0000246B 61                  <1> 	popa
  1464                              <1> 
  1465 0000246C 8B3E[7424]          <1> 	mov word di, [.tmp]
  1466                              <1> 
  1467 00002470 F8                  <1> 	clc
  1468 00002471 C3                  <1> 	ret
  1469                              <1> 
  1470                              <1> 
  1471 00002472 0000                <1> 	.filename	dw 0
  1472 00002474 0000                <1> 	.tmp		dw 0
  1473                              <1> 
  1474                              <1> 
  1475                              <1> ; --------------------------------------------------------------------------
  1476                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  1477                              <1> ; IN: Nothing; OUT: carry set if failure
  1478                              <1> 
  1479                              <1> disk_read_fat:
  1480 00002476 60                  <1> 	pusha
  1481                              <1> 
  1482 00002477 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1483 0000247A E8D700              <1> 	call disk_convert_l2hts
  1484                              <1> 
  1485 0000247D BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1486 00002480 BB0020              <1> 	mov bx, 2000h
  1487 00002483 8EC3                <1> 	mov es, bx
  1488 00002485 89F3                <1> 	mov bx, si
  1489                              <1> 
  1490 00002487 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1491 00002489 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  1492                              <1> 
  1493 0000248B 60                  <1> 	pusha				; Prepare to enter loop
  1494                              <1> 
  1495                              <1> 
  1496                              <1> .read_fat_loop:
  1497 0000248C 61                  <1> 	popa
  1498 0000248D 60                  <1> 	pusha
  1499                              <1> 
  1500 0000248E F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1501 0000248F CD13                <1> 	int 13h				; Read sectors
  1502                              <1> 
  1503 00002491 7308                <1> 	jnc .fat_done
  1504 00002493 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  1505 00002496 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  1506                              <1> 
  1507 00002498 61                  <1> 	popa
  1508 00002499 EB04                <1> 	jmp .read_failure		; Fatal double error
  1509                              <1> 
  1510                              <1> .fat_done:
  1511 0000249B 61                  <1> 	popa				; Restore registers from main loop
  1512                              <1> 
  1513 0000249C 61                  <1> 	popa				; And restore registers from start of system call
  1514 0000249D F8                  <1> 	clc
  1515 0000249E C3                  <1> 	ret
  1516                              <1> 
  1517                              <1> .read_failure:
  1518 0000249F 61                  <1> 	popa
  1519 000024A0 F9                  <1> 	stc				; Set carry flag (for failure)
  1520 000024A1 C3                  <1> 	ret
  1521                              <1> 
  1522                              <1> 
  1523                              <1> ; --------------------------------------------------------------------------
  1524                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  1525                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  1526                              <1> 
  1527                              <1> disk_write_fat:
  1528 000024A2 60                  <1> 	pusha
  1529                              <1> 
  1530 000024A3 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  1531 000024A6 E8AB00              <1> 	call disk_convert_l2hts
  1532                              <1> 
  1533 000024A9 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  1534 000024AC 8CDB                <1> 	mov bx, ds
  1535 000024AE 8EC3                <1> 	mov es, bx
  1536 000024B0 89F3                <1> 	mov bx, si
  1537                              <1> 
  1538 000024B2 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1539 000024B4 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  1540                              <1> 
  1541 000024B6 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1542 000024B7 CD13                <1> 	int 13h				; Write sectors
  1543                              <1> 
  1544 000024B9 7203                <1> 	jc .write_failure		; Fatal double error
  1545                              <1> 
  1546 000024BB 61                  <1> 	popa				; And restore from start of system call
  1547 000024BC F8                  <1> 	clc
  1548 000024BD C3                  <1> 	ret
  1549                              <1> 
  1550                              <1> .write_failure:
  1551 000024BE 61                  <1> 	popa
  1552 000024BF F9                  <1> 	stc				; Set carry flag (for failure)
  1553 000024C0 C3                  <1> 	ret
  1554                              <1> 
  1555                              <1> 
  1556                              <1> ; --------------------------------------------------------------------------
  1557                              <1> ; disk_read_root_dir -- Get the root directory contents
  1558                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  1559                              <1> 
  1560                              <1> disk_read_root_dir:
  1561 000024C1 60                  <1> 	pusha
  1562                              <1> 
  1563 000024C2 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1564 000024C5 E88C00              <1> 	call disk_convert_l2hts
  1565                              <1> 
  1566 000024C8 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1567 000024CB 8CDB                <1> 	mov bx, ds
  1568 000024CD 8EC3                <1> 	mov es, bx
  1569 000024CF 89F3                <1> 	mov bx, si
  1570                              <1> 
  1571 000024D1 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  1572 000024D3 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  1573                              <1> 
  1574 000024D5 60                  <1> 	pusha				; Prepare to enter loop
  1575                              <1> 
  1576                              <1> 
  1577                              <1> .read_root_dir_loop:
  1578 000024D6 61                  <1> 	popa
  1579 000024D7 60                  <1> 	pusha
  1580                              <1> 
  1581 000024D8 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1582 000024D9 CD13                <1> 	int 13h				; Read sectors
  1583                              <1> 
  1584 000024DB 7308                <1> 	jnc .root_dir_finished
  1585 000024DD E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  1586 000024E0 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  1587                              <1> 
  1588 000024E2 61                  <1> 	popa
  1589 000024E3 EB04                <1> 	jmp .read_failure		; Fatal double error
  1590                              <1> 
  1591                              <1> 
  1592                              <1> .root_dir_finished:
  1593 000024E5 61                  <1> 	popa				; Restore registers from main loop
  1594                              <1> 
  1595 000024E6 61                  <1> 	popa				; And restore from start of this system call
  1596 000024E7 F8                  <1> 	clc				; Clear carry (for success)
  1597 000024E8 C3                  <1> 	ret
  1598                              <1> 
  1599                              <1> .read_failure:
  1600 000024E9 61                  <1> 	popa
  1601 000024EA F9                  <1> 	stc				; Set carry flag (for failure)
  1602 000024EB C3                  <1> 	ret
  1603                              <1> 
  1604                              <1> 
  1605                              <1> ; --------------------------------------------------------------------------
  1606                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  1607                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  1608                              <1> 
  1609                              <1> disk_write_root_dir:
  1610 000024EC 60                  <1> 	pusha
  1611                              <1> 
  1612 000024ED B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1613 000024F0 E86100              <1> 	call disk_convert_l2hts
  1614                              <1> 
  1615 000024F3 BE0060              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  1616 000024F6 8CDB                <1> 	mov bx, ds
  1617 000024F8 8EC3                <1> 	mov es, bx
  1618 000024FA 89F3                <1> 	mov bx, si
  1619                              <1> 
  1620 000024FC B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  1621 000024FE B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  1622                              <1> 
  1623 00002500 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  1624 00002501 CD13                <1> 	int 13h				; Write sectors
  1625 00002503 7203                <1> 	jc .write_failure
  1626                              <1> 
  1627 00002505 61                  <1> 	popa				; And restore from start of this system call
  1628 00002506 F8                  <1> 	clc
  1629 00002507 C3                  <1> 	ret
  1630                              <1> 
  1631                              <1> .write_failure:
  1632 00002508 61                  <1> 	popa
  1633 00002509 F9                  <1> 	stc				; Set carry flag (for failure)
  1634 0000250A C3                  <1> 	ret
  1635                              <1> 
  1636                              <1> 
  1637                              <1> ; --------------------------------------------------------------------------
  1638                              <1> ; Reset floppy disk
  1639                              <1> 
  1640                              <1> disk_reset_floppy:
  1641 0000250B 50                  <1> 	push ax
  1642 0000250C 52                  <1> 	push dx
  1643 0000250D B80000              <1> 	mov ax, 0
  1644                              <1> ; ******************************************************************
  1645 00002510 8A16[8325]          <1> 	mov dl, [bootdev]
  1646                              <1> ; ******************************************************************
  1647 00002514 F9                  <1> 	stc
  1648 00002515 CD13                <1> 	int 13h
  1649 00002517 5A                  <1> 	pop dx
  1650 00002518 58                  <1> 	pop ax
  1651 00002519 C3                  <1> 	ret
  1652                              <1> 
  1653                              <1> 
  1654                              <1> ; --------------------------------------------------------------------------
  1655                              <1> ; chk_string_ext -- Check if a file has a 3 letter extension, if not add it
  1656                              <1> ; IN: SI = String
  1657                              <1> ;     AX = Truncate length
  1658                              <1> ; OUT SI = String with extension
  1659                              <1> 
  1660                              <1> chk_string_ext:
  1661 0000251A 50                  <1> 	push ax
  1662 0000251B 53                  <1> 	push bx
  1663                              <1> 
  1664 0000251C E86EE9              <1> 	call string_truncate
  1665                              <1> 
  1666 0000251F 50                  <1> 	push ax
  1667 00002520 56                  <1> 	push si
  1668 00002521 89F0                <1> 	mov ax, si
  1669 00002523 E8D5E8              <1> 	call string_length
  1670 00002526 01C6                <1> 	add si, ax
  1671                              <1> 
  1672 00002528 83EE04              <1> 	sub si, 4
  1673 0000252B 8A04                <1> 	mov al, [si]
  1674 0000252D 3C2E                <1> 	cmp al, '.'
  1675 0000252F 7504                <1> 	jne .ext_not_found
  1676                              <1> 
  1677 00002531 5E                  <1> 	pop si
  1678 00002532 58                  <1> 	pop ax
  1679 00002533 EB17                <1> 	jmp .ext_found
  1680                              <1> 
  1681                              <1> 	.ext_not_found:
  1682 00002535 5E                  <1> 		pop si
  1683 00002536 58                  <1> 		pop ax
  1684 00002537 83F808              <1> 		cmp ax, 8
  1685 0000253A 7C06                <1> 		jl .skip_trun
  1686                              <1> 
  1687 0000253C B80800              <1> 	mov ax, 8
  1688 0000253F E84BE9              <1> 	call string_truncate
  1689                              <1> 
  1690                              <1> 	.skip_trun:
  1691 00002542 89F0                <1> 		mov ax, si
  1692 00002544 BB[4F25]            <1> 		mov bx, .tmp_ext
  1693 00002547 E852E9              <1> 		call string_join
  1694 0000254A 89CE                <1> 		mov si, cx
  1695                              <1> 
  1696                              <1> 	.ext_found:
  1697 0000254C 58                  <1> 		pop ax
  1698 0000254D 5B                  <1> 		pop bx
  1699 0000254E C3                  <1> 		ret
  1700                              <1> 
  1701 0000254F 2E74787400          <1> 	.tmp_ext:	db ".txt", 0
  1702                              <1> 
  1703                              <1> 
  1704                              <1> ; --------------------------------------------------------------------------
  1705                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  1706                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  1707                              <1> 
  1708                              <1> disk_convert_l2hts:
  1709 00002554 53                  <1> 	push bx
  1710 00002555 50                  <1> 	push ax
  1711                              <1> 
  1712 00002556 89C3                <1> 	mov bx, ax			; Save logical sector
  1713                              <1> 
  1714 00002558 BA0000              <1> 	mov dx, 0			; First the sector
  1715 0000255B F736[8125]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1716 0000255F 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  1717 00002562 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  1718 00002564 89D8                <1> 	mov ax, bx
  1719                              <1> 
  1720 00002566 BA0000              <1> 	mov dx, 0			; Now calculate the head
  1721 00002569 F736[8125]          <1> 	div word [SecsPerTrack]		; Sectors per track
  1722 0000256D BA0000              <1> 	mov dx, 0
  1723 00002570 F736[7F25]          <1> 	div word [Sides]		; Floppy sides
  1724 00002574 88D6                <1> 	mov dh, dl			; Head/side
  1725 00002576 88C5                <1> 	mov ch, al			; Track
  1726                              <1> 
  1727 00002578 58                  <1> 	pop ax
  1728 00002579 5B                  <1> 	pop bx
  1729                              <1> 
  1730                              <1> ; ******************************************************************
  1731 0000257A 8A16[8325]          <1> 	mov dl, [bootdev]		; Set correct device
  1732                              <1> ; ******************************************************************
  1733                              <1> 
  1734 0000257E C3                  <1> 	ret
  1735                              <1> 
  1736                              <1> 
  1737 0000257F 0200                <1> 	Sides dw 2
  1738 00002581 1200                <1> 	SecsPerTrack dw 18
  1739                              <1> ; ******************************************************************
  1740 00002583 00                  <1> 	bootdev db 0			; Boot device number
  1741                              <1> ; ******************************************************************
  1742                              <1> ; ==================================================================
   379                                      %include "./includes/checkin.asm"
   380                              <1> check_com:      ; AX = command
   381 00002584 BE[B601]            <1>     mov si, in_buffer
   382 00002587 89C7                <1>     mov di, ax
   383                              <1> 
   384                              <1> .check_loop:
   385 00002589 AC                  <1>     lodsb
   386 0000258A 3A05                <1>     cmp al, [di]
   387 0000258C 7509                <1>     jne .not_equal
   388                              <1>     
   389 0000258E B000                <1>     mov al, 0
   390 00002590 3805                <1>     cmp [di], al
   391 00002592 7405                <1>     je .done
   392                              <1> 
   393 00002594 47                  <1>     inc di
   394 00002595 EBF2                <1>     jmp .check_loop
   395                              <1> 
   396                              <1> .not_equal:
   397 00002597 F9                  <1>     stc
   398 00002598 C3                  <1>     ret
   399                              <1> 
   400                              <1> .done:
   401 00002599 F8                  <1>     clc
   402 0000259A C3                  <1>     ret
   380                                  
   381                                  ; ==================================================================
   382                                  ; END OF KERNEL
   383                                  ; ==================================================================
